public class MetagunDesktop { public static void main ( String [ ] argv ) { <START_BUG> new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new Metagun ( ) , "Metagun" , 320 , 240 , false ) ; <END_BUG> } }
public class FilterAggregationBuilder extends AggregationBuilder < FilterAggregationBuilder > { private FilterBuilder filter ; public FilterAggregationBuilder ( String name ) { } public FilterAggregationBuilder filter ( FilterBuilder filter ) { } @ Override protected XContentBuilder internalXContent ( XContentBuilder builder , Params params ) throws IOException { if ( ( filter ) == null ) { <START_BUG> throw new org . elasticsearch . search . builder . SearchSourceBuilderException ( ( ( "filter<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>set<seq2seq4repair_space>on<seq2seq4repair_space>filter<seq2seq4repair_space>aggregation<seq2seq4repair_space>[" + ( getName ( ) ) ) + "]" ) ) ; <END_BUG> } filter . toXContent ( builder , params ) ; return builder ; } }
public class BouncyDesktop { public static void main ( String [ ] argv ) { <START_BUG> new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new Bouncy ( ) , "Bouncy" , 320 , 480 ) ; <END_BUG> } }
final class AndroidGraphics implements Renderer , Graphics { protected final GLSurfaceView view ; private AndroidInput input ; protected RenderListener listener ; protected int width ; protected int height ; protected AndroidApplication app ; protected GL10 gl10 ; protected GL11 gl11 ; protected GL20 gl20 ; private long lastFrameTime = System . nanoTime ( ) ; private float deltaTime = 0 ; private WindowedMean mean = new WindowedMean ( 5 ) ; private boolean dispose = false ; public AndroidGraphics ( AndroidApplication activity , boolean useGL2IfAvailable ) { } protected void setInput ( AndroidInput input ) { } private boolean checkGL20 ( Activity context ) { } @ Override public GL10 getGL10 ( ) { } @ Override public GL11 getGL11 ( ) { } @ Override public GL20 getGL20 ( ) { } @ Override public int getHeight ( ) { } @ Override public int getWidth ( ) { } @ Override public boolean isGL11Available ( ) { } @ Override public boolean isGL20Available ( ) { } @ Override public Font newFont ( String fontName , int size , FontStyle style , boolean managed ) { } @ Override public Font newFont ( FileHandle file , int size , FontStyle style , boolean managed ) { } @ Override public Pixmap newPixmap ( int width , int height , Format format ) { } @ Override public Pixmap newPixmap ( InputStream in ) { } @ Override public Pixmap newPixmap ( FileHandle file ) { } @ Override public Pixmap newPixmap ( Object nativePixmap ) { } @ Override public Texture newTexture ( int width , int height , Pixmap . Format format , TextureFilter minFilter , TextureFilter magFilter , TextureWrap uWrap , TextureWrap vWrap , boolean managed ) { } @ Override public Texture newTexture ( Pixmap pixmap , TextureFilter minFilter , TextureFilter magFilter , TextureWrap uWrap , TextureWrap vWrap , boolean managed ) { } @ Override public void setRenderListener ( RenderListener listener ) { synchronized ( this ) { if ( ( this . listener ) != null ) <START_BUG> listener . dispose ( app ) ; <END_BUG> this . listener = listener ; } } @ Override public void onDrawFrame ( javax . microedition . khronos . opengles . GL10 gl ) { } private void setupGL ( javax . microedition . khronos . opengles . GL10 gl ) { } @ Override public void onSurfaceChanged ( javax . microedition . khronos . opengles . GL10 gl , int width , int height ) { } @ Override public void onSurfaceCreated ( javax . microedition . khronos . opengles . GL10 gl , EGLConfig config ) { } @ Override public float getDeltaTime ( ) { } public void disposeRenderListener ( ) { } @ Override public GraphicsType getType ( ) { } }
public class FilterBrowseActivity extends RoboFragmentActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; <START_BUG> setTitle ( getString ( saved_filters_title ) ) ; <END_BUG> setContentView ( issue_filter_list ) ; } }
public class Vector3 implements Vector < Vector3 > , Serializable { private static final long serialVersionUID = 3840054589595372522L ; public float x ; public float y ; public float z ; public static final Vector3 tmp = new Vector3 ( ) ; public static final Vector3 tmp2 = new Vector3 ( ) ; public static final Vector3 tmp3 = new Vector3 ( ) ; public static final Vector3 X = new Vector3 ( 1 , 0 , 0 ) ; public static final Vector3 Y = new Vector3 ( 0 , 1 , 0 ) ; public static final Vector3 Z = new Vector3 ( 0 , 0 , 1 ) ; public static final Vector3 Zero = new Vector3 ( 0 , 0 , 0 ) ; private static final Matrix4 tmpMat = new Matrix4 ( ) ; public Vector3 ( ) { } public Vector3 ( float x , float y , float z ) { } public Vector3 ( final Vector3 vector ) { } public Vector3 ( final float [ ] values ) { } public Vector3 set ( float x , float y , float z ) { } public Vector3 set ( final Vector3 vector ) { } public Vector3 set ( final float [ ] values ) { } public Vector3 cpy ( ) { } public Vector3 tmp ( ) { } public Vector3 tmp2 ( ) { } Vector3 tmp3 ( ) { } public Vector3 add ( final Vector3 vector ) { } public Vector3 add ( float x , float y , float z ) { } public Vector3 add ( float values ) { } public Vector3 sub ( final Vector3 a_vec ) { } public Vector3 sub ( float x , float y , float z ) { } public Vector3 sub ( float value ) { } public Vector3 mul ( float value ) { } public Vector3 mul ( final Vector3 other ) { } public Vector3 mul ( float vx , float vy , float vz ) { } public Vector3 div ( float value ) { } public Vector3 div ( float vx , float vy , float vz ) { } public Vector3 div ( final Vector3 other ) { } public float len ( ) { } public float len2 ( ) { } public boolean idt ( final Vector3 vector ) { } public float dst ( final Vector3 vector ) { } public Vector3 nor ( ) { } public static float dot ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { } public float dot ( final Vector3 vector ) { } public Vector3 crs ( final Vector3 vector ) { } public Vector3 crs ( float x , float y , float z ) { } public Vector3 mul ( final Matrix4 matrix ) { } public Vector3 prj ( final Matrix4 matrix ) { } public Vector3 rot ( final Matrix4 matrix ) { } public Vector3 rotate ( float angle , float axisX , float axisY , float axisZ ) { } public Vector3 rotate ( final Vector3 axis , float angle ) { } public boolean isUnit ( ) { } public boolean isZero ( ) { } public Vector3 lerp ( final Vector3 target , float alpha ) { } public Vector3 slerp ( final Vector3 target , float alpha ) { } public String toString ( ) { } public float dot ( float x , float y , float z ) { } public float dst2 ( Vector3 point ) { } public Vector3 limit ( float limit ) { } public Vector3 clamp ( float min , float max ) { } public float dst2 ( float x , float y , float z ) { final float a = x - ( this . x ) ; final float b = y - ( this . y ) ; final float c = z - ( this . z ) ; <START_BUG> return ( ( a * a ) + ( b * b ) ) + ( c * b ) ; <END_BUG> } public float dst ( float x , float y , float z ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } public boolean epsilonEquals ( final Vector3 obj , float epsilon ) { } public boolean epsilonEquals ( float x , float y , float z , float epsilon ) { } public Vector3 scale ( float scalarX , float scalarY , float scalarZ ) { } }
public class IOSFiles implements Files { static final String appDir = System . getenv ( "HOME" ) ; static final String externalPath = ( IOSFiles . appDir ) + "/Documents" ; static final String localPath = ( IOSFiles . appDir ) + "/Library/local" ; static final String internalPath = NSBundle . getMainBundle ( ) . getBundlePath ( ) ; public IOSFiles ( ) { } @ Override public FileHandle getFileHandle ( String fileName , FileType type ) { } @ Override public FileHandle classpath ( String path ) { } @ Override public FileHandle internal ( String path ) { <START_BUG> return new IOSFileHandle ( path , FileType . Internal ) ; <END_BUG> } @ Override public FileHandle external ( String path ) { } @ Override public FileHandle absolute ( String path ) { } @ Override public FileHandle local ( String path ) { } @ Override public String getExternalStoragePath ( ) { } @ Override public boolean isExternalStorageAvailable ( ) { } @ Override public String getLocalStoragePath ( ) { } @ Override public boolean isLocalStorageAvailable ( ) { } }
public class Fixture { private final World world ; private final Body body ; protected final long addr ; protected Shape shape ; protected Fixture ( World world , Body body , long addr ) { } public Type getType ( ) { } private native int jniGetType ( long addr ) { } public Shape getShape ( ) { if ( ( shape ) == null ) { long shapeAddr = jniGetShape ( addr ) ; <START_BUG> int type = Shape . jniGetType ( addr ) ; <END_BUG> if ( type == 0 ) shape = new CircleShape ( shapeAddr ) ; else shape = new PolygonShape ( shapeAddr ) ; } return shape ; } private native long jniGetShape ( long addr ) { } public void setSensor ( boolean sensor ) { } private native void jniSetSensor ( long addr , boolean sensor ) { } public boolean isSensor ( ) { } private native boolean jniIsSensor ( long addr ) { } public void setFilterData ( Filter filter ) { } private native void jniSetFilterData ( long addr , short categoryBits , short maskBits , short groupIndex ) { } private final short [ ] tmp = new short [ 3 ] ; private final Filter filter = new Filter ( ) ; public Filter getFilterData ( ) { } private native void jniGetFilterData ( long addr , short [ ] filter ) { } public Body getBody ( ) { } public boolean testPoint ( Vector2 p ) { } private native boolean jniTestPoint ( long addr , float x , float y ) { } public void setDensity ( float density ) { } private native void jniSetDensity ( long addr , float density ) { } public float getDensity ( ) { } private native float jniGetDensity ( long addr ) { } public float getFriction ( ) { } private native float jniGetFriction ( long addr ) { } public void setFriction ( float friction ) { } private native void jniSetFriction ( long addr , float friction ) { } public float getRestitution ( ) { } private native float jniGetRestitution ( long addr ) { } public void setRestitution ( float restitution ) { } private native void jniSetRestitution ( long addr , float restitution ) { } }
public class TransportMultiGetAction extends TransportAction < MultiGetRequest , MultiGetResponse > { private final ClusterService clusterService ; private final TransportShardMultiGetAction shardAction ; @ Inject public TransportMultiGetAction ( Settings settings , ThreadPool threadPool , TransportService transportService , ClusterService clusterService , TransportShardMultiGetAction shardAction ) { } @ Override protected void doExecute ( final MultiGetRequest request , final ActionListener < MultiGetResponse > listener ) { } class TransportHandler extends BaseTransportRequestHandler < MultiGetRequest > { @ Override public MultiGetRequest newInstance ( ) { } @ Override public void messageReceived ( final MultiGetRequest request , final TransportChannel channel ) throws Exception { request . listenerThreaded ( false ) ; execute ( request , new ActionListener < MultiGetResponse > ( ) { @ Override public void onResponse ( MultiGetResponse response ) { try { channel . sendResponse ( response ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( e ) ; } catch ( Exception e1 ) { logger . warn ( ( ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>error<seq2seq4repair_space>response<seq2seq4repair_space>for<seq2seq4repair_space>action<seq2seq4repair_space>[" + ( MultiGetAction . NAME ) ) + "]<seq2seq4repair_space>and<seq2seq4repair_space>request<seq2seq4repair_space>[" ) + request ) + "]" ) , e1 ) ; } } } ) ; } @ Override public String executor ( ) { } } }
public final class BytesRefOrdValComparator extends FieldComparator < BytesRef > { final IndexFieldData . WithOrdinals < ? > indexFieldData ; final int [ ] ords ; final SortMode sortMode ; final BytesRef [ ] values ; final int [ ] readerGen ; int currentReaderGen = - 1 ; WithOrdinals termsIndex ; int bottomSlot = - 1 ; int bottomOrd ; boolean bottomSameReader ; BytesRef bottomValue ; final BytesRef tempBR = new BytesRef ( ) ; public BytesRefOrdValComparator ( IndexFieldData . WithOrdinals < ? > indexFieldData , int numHits , SortMode sortMode ) { } @ Override public int compare ( int slot1 , int slot2 ) { } @ Override public int compareBottom ( int doc ) { } @ Override public void copy ( int slot , int doc ) { } @ Override public int compareDocToValue ( int doc , BytesRef value ) { } abstract class PerSegmentComparator extends FieldComparator < BytesRef > { @ Override public FieldComparator < BytesRef > setNextReader ( AtomicReaderContext context ) throws IOException { } @ Override public int compare ( int slot1 , int slot2 ) { } @ Override public void setBottom ( final int bottom ) { } @ Override public BytesRef value ( int slot ) { } @ Override public int compareValues ( BytesRef val1 , BytesRef val2 ) { } @ Override public int compareDocToValue ( int doc , BytesRef value ) { } } private final class ByteOrdComparator extends BytesRefOrdValComparator . PerSegmentComparator { private final byte [ ] readerOrds ; private final WithOrdinals termsIndex ; private final int docBase ; public ByteOrdComparator ( byte [ ] readerOrds , BytesValues . WithOrdinals termsIndex , int docBase ) { } @ Override public int compareBottom ( int doc ) { } @ Override public void copy ( int slot , int doc ) { } } private final class ShortOrdComparator extends BytesRefOrdValComparator . PerSegmentComparator { private final short [ ] readerOrds ; private final WithOrdinals termsIndex ; private final int docBase ; public ShortOrdComparator ( short [ ] readerOrds , BytesValues . WithOrdinals termsIndex , int docBase ) { } @ Override public int compareBottom ( int doc ) { } @ Override public void copy ( int slot , int doc ) { } } private final class IntOrdComparator extends BytesRefOrdValComparator . PerSegmentComparator { private final int [ ] readerOrds ; private final WithOrdinals termsIndex ; private final int docBase ; public IntOrdComparator ( int [ ] readerOrds , BytesValues . WithOrdinals termsIndex , int docBase ) { } @ Override public int compareBottom ( int doc ) { } @ Override public void copy ( int slot , int doc ) { } } final class AnyOrdComparator extends BytesRefOrdValComparator . PerSegmentComparator { private final IndexFieldData fieldData ; private final Docs readerOrds ; private final WithOrdinals termsIndex ; private final int docBase ; public AnyOrdComparator ( IndexFieldData fieldData , BytesValues . WithOrdinals termsIndex , int docBase ) { } @ Override public int compareBottom ( int doc ) { } @ Override public void copy ( int slot , int doc ) { } } @ Override public FieldComparator < BytesRef > setNextReader ( AtomicReaderContext context ) throws IOException { } @ Override public void setBottom ( final int bottom ) { } @ Override public BytesRef value ( int slot ) { } protected static final int binarySearch ( BytesValues . WithOrdinals a , BytesRef key ) { <START_BUG> return BytesRefOrdValComparator . binarySearch ( a , key , 1 , ( ( a . ordinals ( ) . getNumOrds ( ) ) - 1 ) ) ; <END_BUG> } protected static final int binarySearch ( BytesValues . WithOrdinals a , BytesRef key , int low , int high ) { } class MultiAnyOrdComparator extends BytesRefOrdValComparator . PerSegmentComparator { private final WithOrdinals termsIndex ; private final Docs readerOrds ; private MultiAnyOrdComparator ( BytesValues . WithOrdinals termsIndex ) { } @ Override public int compareBottom ( int doc ) throws IOException { } @ Override public void copy ( int slot , int doc ) throws IOException { } @ Override public int compareDocToValue ( int doc , BytesRef value ) { } } static BytesRef getRelevantValue ( BytesValues . WithOrdinals readerValues , int docId , SortMode sortMode ) { } static int getRelevantOrd ( Ordinals . Docs readerOrds , int docId , SortMode sortMode ) { } }
public class AuthenticatorActivity extends RoboSherlockAccountAuthenticatorActivity { public static final String PARAM_AUTHTOKEN_TYPE = "authtokenType" ; private static final String PARAM_CONFIRMCREDENTIALS = "confirmCredentials" ; private static final String PARAM_USERNAME = "username" ; private static final String TAG = "GHAuthenticatorActivity" ; private static void configureSyncFor ( Account account ) { Log . d ( AuthenticatorActivity . TAG , "Trying<seq2seq4repair_space>to<seq2seq4repair_space>configure<seq2seq4repair_space>account<seq2seq4repair_space>for<seq2seq4repair_space>sync..." ) ; ContentResolver . setIsSyncable ( account , Constants . GITHUB_PROVIDER_AUTHORITY , 1 ) ; ContentResolver . setSyncAutomatically ( account , Constants . GITHUB_PROVIDER_AUTHORITY , true ) ; <START_BUG> ContentResolver . addPeriodicSync ( account , Constants . GITHUB_PROVIDER_AUTHORITY , new Bundle ( ) , ( ( long ) ( 15 * 60 ) ) ) ; <END_BUG> } private AccountManager accountManager ; @ InjectView ( id . et_login ) private EditText usernameEdit ; @ InjectView ( id . et_password ) private EditText passwordEdit ; @ InjectView ( id . b_login ) private Button okButton ; @ Inject private LeavingBlankTextFieldWarner leavingBlankTextFieldWarner ; private TextWatcher watcher = validationTextWatcher ( ) ; private RoboAsyncTask < User > authenticationTask ; private String authToken ; private String authTokenType ; private Boolean confirmCredentials = false ; private String password ; protected boolean requestNewAccount = false ; private String username ; @ Override public void onCreate ( Bundle icicle ) { } private void setNonBlankValidationFor ( EditText editText ) { } private TextWatcher validationTextWatcher ( ) { } @ Override protected void onResume ( ) { } private void updateUIWithValidation ( ) { } private boolean populated ( EditText editText ) { } @ Override protected Dialog onCreateDialog ( int id ) { } public void handleLogin ( View view ) { } protected void finishConfirmCredentials ( boolean result ) { } protected void finishLogin ( ) { } private void hideProgress ( ) { } private void showProgress ( ) { } public void onAuthenticationResult ( boolean result ) { } }
public class Pools { private static final ObjectMap < Class , ReflectionPool > typePools = new ObjectMap ( ) ; public static < T > Pool < T > get ( Class < T > type ) { } public static < T > T obtain ( Class < T > type ) { } public static void free ( Object object ) { } public static void freeAll ( Array objects ) { if ( objects == null ) throw new IllegalArgumentException ( "objects<seq2seq4repair_space>cannot<seq2seq4repair_space>be<seq2seq4repair_space>null." ) ; for ( int i = 0 , n = objects . size ; i < n ; i ++ ) { Object object = objects . get ( i ) ; <START_BUG> if ( objects == null ) <END_BUG> continue ; ReflectionPool pool = Pools . typePools . get ( object . getClass ( ) ) ; if ( pool == null ) return ; pool . free ( object ) ; } } private Pools ( ) { } }
final class LwjglGL11 extends LwjglGL10 implements GL11 { private IntBuffer tempInt ; private FloatBuffer tempFloat ; public LwjglGL11 ( ) { } private IntBuffer toBuffer ( int n , int [ ] src , int offset ) { } private IntBuffer toBuffer ( int [ ] src , int offset ) { } private FloatBuffer toBuffer ( float [ ] src , int offset ) { } public void glBindBuffer ( int target , int buffer ) { } public void glBufferData ( int target , int size , Buffer data , int usage ) { } public void glBufferSubData ( int target , int offset , int size , Buffer data ) { } public void glClipPlanef ( int plane , float [ ] equation , int offset ) { } public void glClipPlanef ( int plane , FloatBuffer equation ) { } public void glColor4ub ( byte red , byte green , byte blue , byte alpha ) { } public void glDeleteBuffers ( int n , int [ ] buffers , int offset ) { } public void glDeleteBuffers ( int n , IntBuffer buffers ) { } public void glGenBuffers ( int n , int [ ] buffers , int offset ) { for ( int i = offset ; i < ( offset + n ) ; i ++ ) <START_BUG> buffers [ offset ] = GL15 . glGenBuffers ( ) ; <END_BUG> } public void glGenBuffers ( int n , IntBuffer buffers ) { } public void glGetBooleanv ( int pname , boolean [ ] params , int offset ) { } public void glGetBooleanv ( int pname , IntBuffer params ) { } public void glGetBufferParameteriv ( int target , int pname , int [ ] params , int offset ) { } public void glGetBufferParameteriv ( int target , int pname , IntBuffer params ) { } public void glGetClipPlanef ( int pname , float [ ] eqn , int offset ) { } public void glGetClipPlanef ( int pname , FloatBuffer eqn ) { } public void glGetFixedv ( int pname , int [ ] params , int offset ) { } public void glGetFixedv ( int pname , IntBuffer params ) { } public void glGetFloatv ( int pname , float [ ] params , int offset ) { } public void glGetFloatv ( int pname , FloatBuffer params ) { } public void glGetLightfv ( int light , int pname , float [ ] params , int offset ) { } public void glGetLightfv ( int light , int pname , FloatBuffer params ) { } public void glGetLightxv ( int light , int pname , int [ ] params , int offset ) { } public void glGetLightxv ( int light , int pname , IntBuffer params ) { } public void glGetMaterialfv ( int face , int pname , float [ ] params , int offset ) { } public void glGetMaterialfv ( int face , int pname , FloatBuffer params ) { } public void glGetMaterialxv ( int face , int pname , int [ ] params , int offset ) { } public void glGetMaterialxv ( int face , int pname , IntBuffer params ) { } public void glGetPointerv ( int pname , Buffer [ ] params ) { } public void glGetTexEnviv ( int env , int pname , int [ ] params , int offset ) { } public void glGetTexEnviv ( int env , int pname , IntBuffer params ) { } public void glGetTexEnvxv ( int env , int pname , int [ ] params , int offset ) { } public void glGetTexEnvxv ( int env , int pname , IntBuffer params ) { } public void glGetTexParameterfv ( int target , int pname , float [ ] params , int offset ) { } public void glGetTexParameterfv ( int target , int pname , FloatBuffer params ) { } public void glGetTexParameteriv ( int target , int pname , int [ ] params , int offset ) { } public void glGetTexParameteriv ( int target , int pname , IntBuffer params ) { } public void glGetTexParameterxv ( int target , int pname , int [ ] params , int offset ) { } public void glGetTexParameterxv ( int target , int pname , IntBuffer params ) { } public boolean glIsBuffer ( int buffer ) { } public boolean glIsEnabled ( int cap ) { } public boolean glIsTexture ( int texture ) { } public void glPointParameterf ( int pname , float param ) { } public void glPointParameterfv ( int pname , float [ ] params , int offset ) { } public void glPointParameterfv ( int pname , FloatBuffer params ) { } public void glPointSizePointerOES ( int type , int stride , Buffer pointer ) { } public void glTexEnvi ( int target , int pname , int param ) { } public void glTexEnviv ( int target , int pname , int [ ] params , int offset ) { } public void glTexEnviv ( int target , int pname , IntBuffer params ) { } public void glTexParameterfv ( int target , int pname , float [ ] params , int offset ) { } public void glTexParameterfv ( int target , int pname , FloatBuffer params ) { } public void glTexParameteri ( int target , int pname , int param ) { } public void glTexParameteriv ( int target , int pname , int [ ] params , int offset ) { } public void glTexParameteriv ( int target , int pname , IntBuffer params ) { } public void glColorPointer ( int size , int type , int stride , int pointer ) { } public void glNormalPointer ( int type , int stride , int pointer ) { } public void glTexCoordPointer ( int size , int type , int stride , int pointer ) { }
private final ShardIndexingService indexingService ; private final ShardSearchService searchService ; private final ShardGetService getService ; private final ShardIndexWarmerService shardWarmerService ; private final ShardFilterCache shardFilterCache ; private final ShardIdCache shardIdCache ; private final ShardFieldData shardFieldData ; private final PercolatorQueriesRegistry percolatorQueriesRegistry ; private final ShardPercolateService shardPercolateService ; private final CodecService codecService ; private final ShardTermVectorService termVectorService ; private final Object mutex = new Object ( ) ; private final String checkIndexOnStartup ; private long checkIndexTook = 0 ; private volatile IndexShardState state ; private TimeValue refreshInterval ; private final TimeValue mergeInterval ; private volatile ScheduledFuture refreshScheduledFuture ; private volatile ScheduledFuture mergeScheduleFuture ; private volatile ShardRouting shardRouting ; private RecoveryStatus peerRecoveryStatus ; private InternalIndexShard . ApplyRefreshSettings applyRefreshSettings = new InternalIndexShard . ApplyRefreshSettings ( ) ; private final MeanMetric refreshMetric = new MeanMetric ( ) ; private final MeanMetric flushMetric = new MeanMetric ( ) ; @ Inject public InternalIndexShard ( ShardId shardId , @ IndexSettings Settings indexSettings , IndexSettingsService indexSettingsService , IndicesLifecycle indicesLifecycle , Store store , Engine engine , MergeSchedulerProvider mergeScheduler , Translog translog , ThreadPool threadPool , MapperService mapperService , IndexQueryParserService queryParserService , IndexCache indexCache , IndexAliasesService indexAliasesService , ShardIndexingService indexingService , ShardGetService getService , ShardSearchService searchService , ShardIndexWarmerService shardWarmerService , ShardFilterCache shardFilterCache , ShardIdCache shardIdCache , ShardFieldData shardFieldData , PercolatorQueriesRegistry percolatorQueriesRegistry , ShardPercolateService shardPercolateService , CodecService codecService , ShardTermVectorService termVectorService ) { } public MergeSchedulerProvider mergeScheduler ( ) { } public Store store ( ) { } public Engine engine ( ) { } public Translog translog ( ) { } public ShardIndexingService indexingService ( ) { } @ Override public ShardGetService getService ( ) { } @ Override public ShardTermVectorService termVectorService ( ) { } @ Override public ShardSearchService searchService ( ) { } @ Override public ShardIndexWarmerService warmerService ( ) { } @ Override public ShardFilterCache filterCache ( ) { } @ Override public ShardIdCache idCache ( ) { } @ Override public ShardFieldData fieldData ( ) { } @ Override public ShardRouting routingEntry ( ) { } public InternalIndexShard routingEntry ( ShardRouting newRouting ) { } public IndexShardState recovering ( String reason ) throws IndexShardClosedException , IndexShardRecoveringException , IndexShardRelocatedException , IndexShardStartedException { } public InternalIndexShard relocated ( String reason ) throws IndexShardNotStartedException { } public InternalIndexShard start ( String reason ) throws IndexShardClosedException , IndexShardRelocatedException , IndexShardStartedException { } @ Override public IndexShardState state ( ) { } @ Override public Create prepareCreate ( SourceToParse source ) throws ElasticSearchException { } @ Override public ParsedDocument create ( Engine . Create create ) throws ElasticSearchException { } @ Override public Index prepareIndex ( SourceToParse source ) throws ElasticSearchException { } @ Override public ParsedDocument index ( Engine . Index index ) throws ElasticSearchException { } @ Override public Delete prepareDelete ( String type , String id , long version ) throws ElasticSearchException { } @ Override public void delete ( Engine . Delete delete ) throws ElasticSearchException { } @ Override public DeleteByQuery prepareDeleteByQuery ( BytesReference querySource , @ Nullable String [ ] filteringAliases , String ... types ) throws ElasticSearchException { } @ Override public void deleteByQuery ( Engine . DeleteByQuery deleteByQuery ) throws ElasticSearchException { } @ Override public GetResult get ( Engine . Get get ) throws ElasticSearchException { } @ Override public void refresh ( Engine . Refresh refresh ) throws ElasticSearchException { } @ Override public RefreshStats refreshStats ( ) { } @ Override public FlushStats flushStats ( ) { } @ Override public DocsStats docStats ( ) { } @ Override public IndexingStats indexingStats ( String ... types ) { } @ Override public SearchStats searchStats ( String ... groups ) { } @ Override public GetStats getStats ( ) { } @ Override public StoreStats storeStats ( ) { } @ Override public MergeStats mergeStats ( ) { } @ Override public WarmerStats warmerStats ( ) { } @ Override public FilterCacheStats filterCacheStats ( ) { } @ Override public FieldDataStats fieldDataStats ( String ... fields ) { } @ Override public PercolatorQueriesRegistry percolateRegistry ( ) { } @ Override public ShardPercolateService shardPercolateService ( ) { } @ Override public IdCacheStats idCacheStats ( ) { } @ Override public CompletionStats completionStats ( String ... fields ) { } @ Override public void flush ( Engine . Flush flush ) throws ElasticSearchException { } @ Override public void optimize ( Engine . Optimize optimize ) throws ElasticSearchException { } @ Override public < T > T snapshot ( Engine . SnapshotHandler < T > snapshotHandler ) throws EngineException { } @ Override public void recover ( Engine . RecoveryHandler recoveryHandler ) throws EngineException { } @ Override public Searcher acquireSearcher ( ) { readAllowed ( ) ; <START_BUG> return engine . searcher ( ) ; <END_BUG> } public void close ( String reason ) { } public long checkIndexTook ( ) { } public void performRecoveryPrepareForTranslog ( ) throws ElasticSearchException { } public RecoveryStatus peerRecoveryStatus ( ) { } public void performRecoveryFinalization ( boolean withFlush , RecoveryStatus peerRecoveryStatus ) throws ElasticSearchException { } public void performRecoveryFinalization ( boolean withFlush ) throws ElasticSearchException { } public void performRecoveryOperation ( Translog . Operation operation ) throws ElasticSearchException { } public boolean ignoreRecoveryAttempt ( ) { } public void readAllowed ( ) throws IllegalIndexShardStateException { } private void writeAllowed ( ) throws IllegalIndexShardStateException { } private void verifyStartedOrRecovering ( ) throws IllegalIndexShardStateException { } private void verifyNotClosed ( ) throws IllegalIndexShardStateException { } private void verifyStarted ( ) throws IllegalIndexShardStateException { } private void startScheduledTasksIfNeeded ( ) { } private Query filterQueryIfNeeded ( Query query , String [ ] types ) { } public static final String INDEX_REFRESH_INTERVAL = "index.refresh_interval" ; private class ApplyRefreshSettings implements IndexSettingsService . Listener { @ Override public void onRefreshSettings ( Settings settings ) { } } class EngineRefresher implements Runnable { @ Override public void run ( ) { } } class EngineMerger implements Runnable { @ Override public void run ( ) { } } private void checkIndex ( boolean throwException ) throws IndexShardException { } }
public class AtomicQueue < T > { private final AtomicInteger writeIndex = new AtomicInteger ( ) ; private final AtomicInteger readIndex = new AtomicInteger ( ) ; private final AtomicReferenceArray < T > queue ; public AtomicQueue ( int capacity ) { } private int next ( int idx ) { <START_BUG> return ( idx + 1 ) & ( ( queue . length ( ) ) - 1 ) ; <END_BUG> } public boolean put ( T value ) { } public T poll ( ) { } }
@ Test public class SimpleAttachmentIntegrationTests { private final ESLogger logger = Loggers . getLogger ( getClass ( ) ) ; private Node node ; @ BeforeClass public void setupServer ( ) { <START_BUG> node = nodeBuilder ( ) . local ( true ) . node ( ) ; <END_BUG> } @ AfterClass public void closeServer ( ) { } @ BeforeMethod public void createIndex ( ) { } @ AfterMethod public void deleteIndex ( ) { } @ Test public void testSimpleAttachment ( ) throws Exception { } }
public class TribeTests extends ElasticsearchIntegrationTest { private static InternalTestCluster cluster2 ; private Node tribeNode ; private Client tribeClient ; @ BeforeClass public static void setupSecondCluster ( ) throws Exception { ElasticsearchIntegrationTest . beforeClass ( ) ; <START_BUG> TribeTests . cluster2 = new InternalTestCluster ( randomLong ( ) , 2 , 2 , Strings . randomBase64UUID ( getRandom ( ) ) , 0 , false , CHILD_JVM_ID ) ; <END_BUG> TribeTests . cluster2 . beforeTest ( getRandom ( ) , 0.1 ) ; TribeTests . cluster2 . ensureAtLeastNumDataNodes ( 2 ) ; } @ AfterClass public static void tearDownSecondCluster ( ) { } @ After public void tearDownTribeNode ( ) throws IOException { } private void setupTribeNode ( Settings settings ) { } @ Test public void testGlobalReadWriteBlocks ( ) throws Exception { } @ Test public void testIndexWriteBlocks ( ) throws Exception { } @ Test public void testOnConflictDrop ( ) throws Exception { } @ Test public void testOnConflictPrefer ( ) throws Exception { } private void testOnConflictPrefer ( String tribe ) throws Exception { } @ Test public void testTribeOnOneCluster ( ) throws Exception { } private void awaitIndicesInClusterState ( final String ... indices ) throws Exception { } private void awaitSameNodeCounts ( ) throws Exception { } private int countDataNodesForTribe ( String tribeName , DiscoveryNodes nodes ) { } }
public class DashboardIssueFragment extends PagedItemFragment < RepositoryIssue > { public static final String ARG_FILTER = "filter" ; @ Inject private IssueService service ; @ Inject private IssueStore store ; @ Inject private AvatarLoader avatarHelper ; private Map < String , String > filterData ; @ Override public void onCreate ( Bundle savedInstanceState ) { } @ SuppressWarnings ( "unchecked" ) @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { <START_BUG> startActivity ( ViewIssuesActivity . createIntent ( items , ( position - ( l . getHeaderViewsCount ( ) ) ) ) ) ; <END_BUG> } @ Override protected ResourcePager < RepositoryIssue > createPager ( ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected ItemListAdapter < RepositoryIssue , ? extends ItemView > createAdapter ( List < RepositoryIssue > items ) { } }
public class Loggers { private static final String commonPrefix = System . getProperty ( "es.logger.prefix" , "org.elasticsearch." ) ; public static final String SPACE = "<seq2seq4repair_space>" ; private static boolean consoleLoggingEnabled = true ; public static void disableConsoleLogging ( ) { } public static void enableConsoleLogging ( ) { } public static boolean consoleLoggingEnabled ( ) { } public static ESLogger getLogger ( Class clazz , Settings settings , ShardId shardId , String ... prefixes ) { } public static ESLogger getLogger ( Class clazz , Settings settings , Index index , String ... prefixes ) { } public static ESLogger getLogger ( Class clazz , Settings settings , RiverName riverName , String ... prefixes ) { } public static ESLogger getLogger ( Class clazz , Settings settings , String ... prefixes ) { } public static ESLogger getLogger ( String loggerName , Settings settings , String ... prefixes ) { } public static ESLogger getLogger ( ESLogger parentLogger , String s ) { } public static ESLogger getLogger ( String s ) { <START_BUG> return ESLoggerFactory . getLogger ( s ) ; <END_BUG> } public static ESLogger getLogger ( Class clazz ) { } public static ESLogger getLogger ( Class clazz , String ... prefixes ) { } public static ESLogger getLogger ( String name , String ... prefixes ) { } private static String buildClassLoggerName ( Class clazz ) { } private static String getLoggerName ( String name ) { } }
public class LoginActivity extends RoboSherlockAccountAuthenticatorActivity { public static final String PARAM_AUTHTOKEN_TYPE = "authtokenType" ; private static final String PARAM_CONFIRMCREDENTIALS = "confirmCredentials" ; private static final String PARAM_USERNAME = "username" ; private static final String TAG = "LoginActivity" ; private static final long SYNC_PERIOD = ( 8L * 60L ) * 60L ; private static void configureSyncFor ( Account account ) { } private static class AccountLoader extends AuthenticatedUserTask < List < User > > { @ Inject private AccountDataManager cache ; protected AccountLoader ( Context context ) { } @ Override protected List < User > run ( ) throws Exception { } } private AccountManager accountManager ; @ InjectView ( id . et_login ) private AutoCompleteTextView loginText ; @ InjectView ( id . et_password ) private EditText passwordText ; private RoboAsyncTask < User > authenticationTask ; private String authToken ; private String authTokenType ; private MenuItem loginItem ; private Boolean confirmCredentials = false ; private String password ; protected boolean requestNewAccount = false ; private String username ; @ Override public void onCreate ( Bundle savedInstanceState ) { } @ Override protected void onResume ( ) { } private boolean loginEnabled ( ) { <START_BUG> return ( ! ( TextUtils . isEmpty ( loginText . getText ( ) ) ) ) && ( ! ( TextUtils . isDigitsOnly ( passwordText . getText ( ) ) ) ) ; <END_BUG> } private void updateEnablement ( ) { } @ Override public void startActivity ( Intent intent ) { } public void handleLogin ( ) { } protected void finishConfirmCredentials ( boolean result ) { } protected void finishLogin ( ) { } public void onAuthenticationResult ( boolean result ) { } public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public boolean onCreateOptionsMenu ( Menu optionMenu ) { } private List < String > getEmailAddresses ( ) { } }
public class BufferUtils { static Array < ByteBuffer > unsafeBuffers = new Array < ByteBuffer > ( ) ; static int allocatedUnsafe = 0 ; public static void copy ( float [ ] src , Buffer dst , int numFloats , int offset ) { } public static void copy ( byte [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( short [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( char [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( int [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( long [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( float [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( double [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( Buffer src , Buffer dst , int numElements ) { } private static int positionInBytes ( Buffer dst ) { } private static int bytesToElements ( Buffer dst , int bytes ) { } private static int elementsToBytes ( Buffer dst , int elements ) { } public static FloatBuffer newFloatBuffer ( int numFloats ) { } public static DoubleBuffer newDoubleBuffer ( int numDoubles ) { } public static ByteBuffer newByteBuffer ( int numBytes ) { } public static ShortBuffer newShortBuffer ( int numShorts ) { } public static CharBuffer newCharBuffer ( int numChars ) { } public static IntBuffer newIntBuffer ( int numInts ) { } public static LongBuffer newLongBuffer ( int numLongs ) { } public static void disposeUnsafeByteBuffer ( ByteBuffer buffer ) { <START_BUG> int size = buffer . capacity ( ) ; <END_BUG> synchronized ( BufferUtils . unsafeBuffers ) { if ( ! ( BufferUtils . unsafeBuffers . removeValue ( buffer , true ) ) ) throw new IllegalArgumentException ( "buffer<seq2seq4repair_space>not<seq2seq4repair_space>allocated<seq2seq4repair_space>with<seq2seq4repair_space>newUnsafeByteBuffer<seq2seq4repair_space>or<seq2seq4repair_space>already<seq2seq4repair_space>disposed" ) ; } BufferUtils . allocatedUnsafe -= size ; BufferUtils . freeMemory ( buffer ) ; } public static ByteBuffer newUnsafeByteBuffer ( int numBytes ) { } public static int getAllocatedBytesUnsafe ( ) { } private static native void freeMemory ( ByteBuffer buffer ) { } private static native ByteBuffer newDisposableByteBuffer ( int numBytes ) { } public static native void clear ( ByteBuffer buffer , int numBytes ) { } private static native void copyJni ( float [ ] src , Buffer dst , int numFloats , int offset ) { } private static native void copyJni ( byte [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( char [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( short [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( int [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( long [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( float [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( double [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( Buffer src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } }
public class TransportFlushAction extends TransportBroadcastOperationAction < FlushRequest , FlushResponse , ShardFlushRequest , ShardFlushResponse > { private final IndicesService indicesService ; @ Inject public TransportFlushAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected FlushRequest newRequest ( ) { } @ Override protected FlushResponse newResponse ( FlushRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardFlushRequest newShardRequest ( ) { } @ Override protected ShardFlushRequest newShardRequest ( ShardRouting shard , FlushRequest request ) { } @ Override protected ShardFlushResponse newShardResponse ( ) { } @ Override protected ShardFlushResponse shardOperation ( ShardFlushRequest request ) throws ElasticSearchException { IndexShard indexShard = indicesService . indexServiceSafe ( request . index ( ) ) . shardSafe ( request . shardId ( ) ) ; <START_BUG> indexShard . flush ( new Engine . Flush ( ) . refresh ( request . refresh ( ) ) . type ( ( request . full ( ) ? Type . NEW_WRITER : Type . COMMIT_TRANSLOG ) ) . force ( request . force ( ) ) ) ; <END_BUG> return new ShardFlushResponse ( request . index ( ) , request . shardId ( ) ) ; } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , FlushRequest request , String [ ] concreteIndices ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , FlushRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , FlushRequest countRequest , String [ ] concreteIndices ) { } }
public class KeyframedModelViewer implements ApplicationListener { PerspectiveCamera cam ; KeyframedModel model ; Texture texture = null ; boolean hasNormals = false ; BoundingBox bounds = new BoundingBox ( ) ; ImmediateModeRenderer renderer ; float angle = 0 ; String fileName ; String textureFileName ; public KeyframedModelViewer ( String fileName , String textureFileName ) { } @ Override public void create ( ) { } private boolean hasNormals ( ) { } @ Override public void resume ( ) { } float [ ] lightColor = new float [ ] { 1 , 1 , 1 , 0 } ; float [ ] lightPosition = new float [ ] { 2 , 5 , 10 , 0 } ; @ Override public void render ( ) { } private void drawAxes ( ) { } @ Override public void resize ( int width , int height ) { } @ Override public void pause ( ) { } @ Override public void dispose ( ) { } public static void main ( String [ ] argv ) { if ( ( ( argv . length ) != 1 ) && ( ( argv . length ) != 2 ) ) { System . out . println ( "StillModelViewer<seq2seq4repair_space><filename><seq2seq4repair_space>?<texture-filename>" ) ; System . exit ( ( - 1 ) ) ; } <START_BUG> new JoglApplication ( new KeyframedModelViewer ( argv [ 0 ] , ( ( argv . length ) == 2 ? argv [ 1 ] : null ) ) , "KeframedModel<seq2seq4repair_space>Viewer" , 320 , 240 , false ) ; <END_BUG> } }
public class NettyHttpRequest extends AbstractRestRequest implements HttpRequest { private final HttpRequest request ; private final Map < String , String > params ; private final String rawPath ; private final BytesReference content ; public NettyHttpRequest ( org . jboss . netty . handler . codec . http . HttpRequest request ) { } @ Override public Method method ( ) { } @ Override public String uri ( ) { } @ Override public String rawPath ( ) { } @ Override public Map < String , String > params ( ) { } @ Override public boolean hasContent ( ) { } @ Override public boolean contentUnsafe ( ) { } @ Override public BytesReference content ( ) { } @ Override public String header ( String name ) { <START_BUG> return request . headers ( ) . get ( name ) ; <END_BUG> } @ Override public boolean hasParam ( String key ) { } @ Override public String param ( String key ) { } @ Override public String param ( String key , String defaultValue ) { } }
public class MD2Viewer implements ApplicationListener { KeyframedModel model ; PerspectiveCamera cam ; float angle = 0 ; @ Override public void create ( ) { <START_BUG> model = new MD2Loader ( ) . load ( files . internal ( "data/knight.md2" ) . read ( ) ) ; <END_BUG> Material material = new Material ( "knight" , new com . badlogic . gdx . graphics . g3d . materials . TextureAttribute ( new Texture ( "data/knight.jpg" ) , 0 , "a_tex0" ) ) ; model . setMaterial ( material ) ; cam = new PerspectiveCamera ( 67 , graphics . getWidth ( ) , graphics . getHeight ( ) ) ; cam . far = 300 ; cam . position . set ( 0 , 12 , 50 ) ; } @ Override public void resume ( ) { } @ Override public void render ( ) { } @ Override public void resize ( int width , int height ) { } @ Override public void pause ( ) { } @ Override public void dispose ( ) { } public static void main ( String [ ] argv ) { } }
public class CircularFloatBuffer { private final float [ ] buffer ; private int writePosition ; private int readPosition ; private int available ; public final int size ; public CircularFloatBuffer ( int size ) { } public void write ( float [ ] data , int offset , int count ) { } public void combine ( float [ ] data , int offset , int count ) { } public int read ( float [ ] data , int offset , int count ) { } public int skip ( int count ) { <START_BUG> int total = Math . min ( available , count ) ; <END_BUG> available -= total ; readPosition = ( ( readPosition ) + total ) % ( buffer . length ) ; return total ; } public void clear ( ) { } public void setWritePosition ( int writePosition ) { } public int getWritePosition ( ) { } public void setReadPosition ( int readPosition ) { } public int getReadPosition ( ) { } public int getAvailable ( ) { } private void dump ( ) { } private static void combine ( float [ ] src , int srcPos , float [ ] dest , int destPos , int length ) { } }
private final Array < Action > actions = new Array ( 0 ) ; private String name ; private Touchable touchable = Touchable . enabled ; private boolean visible = true ; private boolean debug ; float x ; float y ; float width ; float height ; float originX ; float originY ; float scaleX = 1 ; float scaleY = 1 ; float rotation ; final Color color = new Color ( 1 , 1 , 1 , 1 ) ; private Object userObject ; public void draw ( Batch batch , float parentAlpha ) { } public void act ( float delta ) { } public boolean fire ( Event event ) { } public boolean notify ( Event event , boolean capture ) { } public Actor hit ( float x , float y , boolean touchable ) { } public boolean remove ( ) { } public boolean addListener ( EventListener listener ) { } public boolean removeListener ( EventListener listener ) { } public Array < EventListener > getListeners ( ) { } public boolean addCaptureListener ( EventListener listener ) { } public boolean removeCaptureListener ( EventListener listener ) { } public Array < EventListener > getCaptureListeners ( ) { } public void addAction ( Action action ) { } public void removeAction ( Action action ) { } public Array < Action > getActions ( ) { } public void clearActions ( ) { } public void clearListeners ( ) { } public void clear ( ) { } public Stage getStage ( ) { } protected void setStage ( Stage stage ) { } public boolean isDescendantOf ( Actor actor ) { } public boolean isAscendantOf ( Actor actor ) { } public boolean hasParent ( ) { } public Group getParent ( ) { } protected void setParent ( Group parent ) { } public boolean isTouchable ( ) { } public Touchable getTouchable ( ) { } public void setTouchable ( Touchable touchable ) { } public boolean isVisible ( ) { } public void setVisible ( boolean visible ) { } public Object getUserObject ( ) { } public void setUserObject ( Object userObject ) { } public float getX ( ) { } public float getX ( int align ) { } public void setX ( float x ) { } public float getY ( ) { } public void setY ( float y ) { } public float getY ( int align ) { } public void setPosition ( float x , float y ) { } public void setPosition ( float x , float y , int align ) { } public void moveBy ( float x , float y ) { } public float getWidth ( ) { } public void setWidth ( float width ) { } public float getHeight ( ) { } public void setHeight ( float height ) { } public float getTop ( ) { } public float getRight ( ) { } protected void positionChanged ( ) { } protected void sizeChanged ( ) { } public void setSize ( float width , float height ) { } public void sizeBy ( float size ) { } public void sizeBy ( float width , float height ) { } public void setBounds ( float x , float y , float width , float height ) { } public float getOriginX ( ) { } public void setOriginX ( float originX ) { } public float getOriginY ( ) { } public void setOriginY ( float originY ) { } public void setOrigin ( float originX , float originY ) { } public void setOrigin ( int align ) { } public float getScaleX ( ) { } public void setScaleX ( float scaleX ) { } public float getScaleY ( ) { } public void setScaleY ( float scaleY ) { } public void setScale ( float scaleXY ) { } public void setScale ( float scaleX , float scaleY ) { } public void scaleBy ( float scale ) { } public void scaleBy ( float scaleX , float scaleY ) { } public float getRotation ( ) { } public void setRotation ( float degrees ) { } public void rotateBy ( float amountInDegrees ) { } public void setColor ( Color color ) { } public void setColor ( float r , float g , float b , float a ) { } public Color getColor ( ) { } public String getName ( ) { } public void setName ( String name ) { } public void toFront ( ) { } public void toBack ( ) { } public void setZIndex ( int index ) { } public int getZIndex ( ) { } public boolean clipBegin ( ) { } public boolean clipBegin ( float x , float y , float width , float height ) { } public void clipEnd ( ) { } public Vector2 screenToLocalCoordinates ( Vector2 screenCoords ) { } public Vector2 stageToLocalCoordinates ( Vector2 stageCoords ) { } public Vector2 localToStageCoordinates ( Vector2 localCoords ) { } public Vector2 localToParentCoordinates ( Vector2 localCoords ) { } public Vector2 localToAscendantCoordinates ( Actor ascendant , Vector2 localCoords ) { } public Vector2 parentToLocalCoordinates ( Vector2 parentCoords ) { } public void drawDebug ( ShapeRenderer shapes ) { } protected void drawDebugBounds ( ShapeRenderer shapes ) { if ( ! ( debug ) ) return ; shapes . set ( Line ) ; shapes . setColor ( stage . getDebugColor ( ) ) ; <START_BUG> shapes . rect ( x , y , originX , originY , width , height , scaleX , scaleY , rotation ) ; <END_BUG> } public void setDebug ( boolean enabled ) { } public boolean getDebug ( ) { } public Actor debug ( ) { } public String toString ( ) { } }
public class RestAnalyzeAction extends BaseRestHandler { @ Inject public RestAnalyzeAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { String text = request . param ( "text" ) ; if ( ( text == null ) && ( request . hasContent ( ) ) ) { text = request . content ( ) . toUtf8 ( ) ; } if ( text == null ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , new ElasticSearchIllegalArgumentException ( "text<seq2seq4repair_space>is<seq2seq4repair_space>missing" ) ) ) ; } catch ( IOException e1 ) { logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>response" , e1 ) ; } return ; } AnalyzeRequest analyzeRequest = new AnalyzeRequest ( request . param ( "index" ) , text ) ; analyzeRequest . listenerThreaded ( false ) ; analyzeRequest . preferLocal ( request . paramAsBoolean ( "prefer_local" , analyzeRequest . preferLocalShard ( ) ) ) ; analyzeRequest . analyzer ( request . param ( "analyzer" ) ) ; analyzeRequest . field ( request . param ( "field" ) ) ; analyzeRequest . tokenizer ( request . param ( "tokenizer" ) ) ; analyzeRequest . tokenFilters ( request . paramAsStringArray ( "token_filters" , request . paramAsStringArray ( "filters" , null ) ) ) ; client . admin ( ) . indices ( ) . analyze ( analyzeRequest , new org . elasticsearch . action . ActionListener < AnalyzeResponse > ( ) { @ Override public void onResponse ( AnalyzeResponse response ) { try { <START_BUG> XContentBuilder builder = restContentBuilder ( request , false ) ; <END_BUG> builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; } catch ( Throwable e ) { onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class PerformanceCounters { private static final float nano2seconds = 1.0F / 1.0E9F ; private long lastTick = 0L ; public final Array < PerformanceCounter > counters = new Array < PerformanceCounter > ( ) ; public PerformanceCounter add ( final String name , final int windowSize ) { } public PerformanceCounter add ( final String name ) { } public void tick ( ) { final long t = System . nanoTime ( ) ; if ( ( lastTick ) > 0L ) <START_BUG> tick ( ( ( t - ( lastTick ) ) * ( PerformanceCounters . nano2seconds ) ) ) ; <END_BUG> lastTick = t ; } public void tick ( final float deltaTime ) { } public StringBuilder toString ( final StringBuilder sb ) { } }
public class AllFieldMapper extends AbstractFieldMapper < Void > implements InternalMapper , RootMapper { public interface IncludeInAll extends Mapper { void includeInAll ( Boolean includeInAll ) { } void includeInAllIfNotSet ( Boolean includeInAll ) { } } public static final String NAME = "_all" ; public static final String CONTENT_TYPE = "_all" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = AllFieldMapper . NAME ; public static final String INDEX_NAME = AllFieldMapper . NAME ; public static final boolean ENABLED = true ; } public static class Builder extends AbstractFieldMapper . Builder < AllFieldMapper . Builder , AllFieldMapper > { private boolean enabled = AllFieldMapper . Defaults . ENABLED ; public Builder ( ) { } public AllFieldMapper . Builder enabled ( boolean enabled ) { } @ Override public AllFieldMapper . Builder store ( Field . Store store ) { } @ Override public AllFieldMapper . Builder termVector ( Field . TermVector termVector ) { } @ Override protected AllFieldMapper . Builder indexAnalyzer ( NamedAnalyzer indexAnalyzer ) { } @ Override protected AllFieldMapper . Builder searchAnalyzer ( NamedAnalyzer searchAnalyzer ) { } @ Override public AllFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private boolean enabled ; public AllFieldMapper ( ) { } protected AllFieldMapper ( String name , Field . Store store , Field . TermVector termVector , boolean omitNorms , boolean omitTermFreqAndPositions , NamedAnalyzer indexAnalyzer , NamedAnalyzer searchAnalyzer , boolean enabled ) { } public boolean enabled ( ) { } @ Override public Query queryStringTermQuery ( Term term ) { } @ Override public Query fieldQuery ( String value , QueryParseContext context ) { <START_BUG> return new org . elasticsearch . common . lucene . all . AllTermQuery ( termFactory . createTerm ( value ) ) ; <END_BUG> } @ Override public void preParse ( ParseContext context ) throws IOException { } @ Override public void postParse ( ParseContext context ) throws IOException { } @ Override public void parse ( ParseContext context ) throws IOException { } @ Override public void validate ( ParseContext context ) throws MapperParsingException { } @ Override public boolean includeInObject ( ) { } @ Override protected Fieldable parseCreateField ( ParseContext context ) throws IOException { } private Analyzer findAnalyzer ( ParseContext context ) { } @ Override public Void value ( Fieldable field ) { } @ Override public Void valueFromString ( String value ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public Object valueForSearch ( Fieldable field ) { } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public class QueueRecyclerTests extends AbstractRecyclerTests { @ Override protected Recycler < byte [ ] > newRecycler ( ) { <START_BUG> return new QueueRecycler < byte [ ] > ( RECYCLER_C ) ; <END_BUG> } }
public class ClickListener extends InputListener { public static float visualPressedDuration = 0.1F ; private float tapSquareSize = 14 ; private float touchDownX = - 1 ; private float touchDownY = - 1 ; private int pressedPointer = - 1 ; private int pressedButton = - 1 ; private int button ; private boolean pressed ; private boolean over ; private boolean cancelled ; private float visualPressedTime ; private long tapCountInterval = ( ( long ) ( 0.4F * 1000000000L ) ) ; private int tapCount ; private long lastTapTime ; public ClickListener ( ) { } public ClickListener ( int button ) { } public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { } public void touchDragged ( InputEvent event , float x , float y , int pointer ) { } public void touchUp ( InputEvent event , float x , float y , int pointer , int button ) { } public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { } public void exit ( InputEvent event , float x , float y , int pointer , Actor toActor ) { } public void cancel ( ) { } public void clicked ( InputEvent event , float x , float y ) { } public boolean isOver ( Actor actor , float x , float y ) { } public boolean inTapSquare ( float x , float y ) { } public boolean inTapSquare ( ) { } public void invalidateTapSquare ( ) { } public boolean isPressed ( ) { } public boolean isVisualPressed ( ) { if ( pressed ) return true ; if ( ( visualPressedTime ) <= 0 ) return false ; <START_BUG> if ( ( visualPressedTime ) > ( TimeUtils . nanoTime ( ) ) ) <END_BUG> return true ; visualPressedTime = 0 ; return false ; } public boolean isOver ( ) { } public void setTapSquareSize ( float halfTapSquareSize ) { } public float getTapSquareSize ( ) { } public void setTapCountInterval ( float tapCountInterval ) { } public int getTapCount ( ) { } public float getTouchDownX ( ) { } public float getTouchDownY ( ) { } public int getPressedButton ( ) { } public int getPressedPointer ( ) { } public int getButton ( ) { } public void setButton ( int button ) { } }
public class AllFieldMapper extends AbstractFieldMapper < Void > implements InternalMapper , RootMapper { public interface IncludeInAll extends Mapper { void includeInAll ( Boolean includeInAll ) { } void includeInAllIfNotSet ( Boolean includeInAll ) { } void unsetIncludeInAll ( ) { } } public static final String NAME = "_all" ; public static final String CONTENT_TYPE = "_all" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = AllFieldMapper . NAME ; public static final String INDEX_NAME = AllFieldMapper . NAME ; public static final boolean ENABLED = true ; public static final FieldType FIELD_TYPE = new FieldType ( ) ; } public static class Builder extends AbstractFieldMapper . Builder < AllFieldMapper . Builder , AllFieldMapper > { private boolean enabled = AllFieldMapper . Defaults . ENABLED ; boolean autoBoost = false ; public Builder ( ) { } public AllFieldMapper . Builder enabled ( boolean enabled ) { } @ Override public AllFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private boolean enabled ; private volatile boolean autoBoost ; public AllFieldMapper ( ) { } protected AllFieldMapper ( String name , FieldType fieldType , NamedAnalyzer indexAnalyzer , NamedAnalyzer searchAnalyzer , boolean enabled , boolean autoBoost , PostingsFormatProvider postingsProvider , DocValuesFormatProvider docValuesProvider , SimilarityProvider similarity , Loading normsLoading , @ Nullable Settings fieldDataSettings , Settings indexSettings ) { } public boolean enabled ( ) { } @ Override public FieldType defaultFieldType ( ) { } @ Override public FieldDataType defaultFieldDataType ( ) { } @ Override public Query queryStringTermQuery ( Term term ) { if ( ! ( autoBoost ) ) { return new org . apache . lucene . search . TermQuery ( term ) ; } <START_BUG> if ( ( fieldType . indexOptions ( ) ) == ( IndexOptions . DOCS_AND_FREQS_AND_POSITIONS ) ) { <END_BUG> return new org . elasticsearch . common . lucene . all . AllTermQuery ( term ) ; } return new org . apache . lucene . search . TermQuery ( term ) ; } @ Override public Query termQuery ( Object value , QueryParseContext context ) { } @ Override public void preParse ( ParseContext context ) throws IOException { } @ Override public void postParse ( ParseContext context ) throws IOException { } @ Override public void parse ( ParseContext context ) throws IOException { } @ Override public boolean includeInObject ( ) { } @ Override protected void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException { } private Analyzer findAnalyzer ( ParseContext context ) { } @ Override public Void value ( Object value ) { } @ Override public Object valueForSearch ( Object value ) { } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } private void innerToXContent ( XContentBuilder builder , boolean includeDefaults ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override public boolean hasDocValues ( ) { } }
public class AsyncExecutor implements Disposable { private final ExecutorService executor ; public AsyncExecutor ( int maxConcurrent ) { } public < T > AsyncResult < T > submit ( final AsyncTask < T > task ) { } @ Override public void dispose ( ) { executor . shutdown ( ) ; try { executor . awaitTermination ( Long . MAX_VALUE , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { <START_BUG> throw new GdxRuntimeException ( "Couldn't<seq2seq4repair_space>shutdown<seq2seq4repair_space>loading<seq2seq4repair_space>thread" , e ) ; <END_BUG> } } }
public class JvmMonitorService extends AbstractLifecycleComponent < JvmMonitorService > { private final ThreadPool threadPool ; private final DumpMonitorService dumpMonitorService ; private final boolean enabled ; private final TimeValue interval ; private final ImmutableMap < String , JvmMonitorService . GcThreshold > gcThresholds ; private volatile ScheduledFuture scheduledFuture ; static class GcThreshold { public final String name ; public final long warnThreshold ; public final long infoThreshold ; public final long debugThreshold ; GcThreshold ( String name , long warnThreshold , long infoThreshold , long debugThreshold ) { } @ Override public String toString ( ) { } } @ Inject public JvmMonitorService ( Settings settings , ThreadPool threadPool , DumpMonitorService dumpMonitorService ) { } @ Override protected void doStart ( ) throws ElasticsearchException { } @ Override protected void doStop ( ) throws ElasticsearchException { } @ Override protected void doClose ( ) throws ElasticsearchException { } private class JvmMonitor implements Runnable { private JvmStats lastJvmStats = JvmStats . jvmStats ( ) ; private long seq = 0 ; private final Set < DeadlockAnalyzer . Deadlock > lastSeenDeadlocks = new HashSet < DeadlockAnalyzer . Deadlock > ( ) ; public JvmMonitor ( ) { } @ Override public void run ( ) { try { monitorLongGc ( ) ; } catch ( Throwable t ) { <START_BUG> t . printStackTrace ( ) ; <END_BUG> } } private synchronized void monitorLongGc ( ) { } private String buildPools ( JvmStats prev , JvmStats current ) { } private void monitorDeadlock ( ) { } } }
public abstract class CompressedIndexInput < T extends CompressorContext > extends IndexInput { private IndexInput in ; protected final T context ; private int version ; private long totalUncompressedLength ; private BigLongArray offsets ; private boolean closed ; protected byte [ ] uncompressed ; protected int uncompressedLength ; private int position = 0 ; private int valid = 0 ; private int currentOffsetIdx ; private long currentUncompressedChunkPointer ; public CompressedIndexInput ( IndexInput in , T context ) throws IOException { } public int available ( ) throws IOException { } @ Override public byte readByte ( ) throws IOException { } public int read ( byte [ ] buffer , int offset , int length , boolean fullRead ) throws IOException { } @ Override public void readBytes ( byte [ ] b , int offset , int len ) throws IOException { } @ Override public long getFilePointer ( ) { } @ Override public void seek ( long pos ) throws IOException { } @ Override public long length ( ) { } @ Override public void close ( ) throws IOException { } protected abstract void doClose ( ) throws IOException { } protected boolean readyBuffer ( ) throws IOException { } protected abstract void readHeader ( IndexInput in ) throws IOException { } protected abstract int uncompress ( IndexInput in , byte [ ] out ) throws IOException { } @ Override <START_BUG> public Object clone ( ) { <END_BUG> CompressedIndexInput cloned = ( ( CompressedIndexInput ) ( super . clone ( ) ) ) ; cloned . uncompressed = new byte [ uncompressedLength ] ; System . arraycopy ( uncompressed , 0 , cloned . uncompressed , 0 , uncompressedLength ) ; cloned . in = ( ( IndexInput ) ( cloned . in . clone ( ) ) ) ; return cloned ; } }
public class ParticleEffectLoader extends SynchronousAssetLoader < ParticleEffect , ParticleEffectLoader . ParticleEffectParameter > { public ParticleEffectLoader ( FileHandleResolver resolver ) { } @ Override public ParticleEffect load ( AssetManager am , String fileName , FileHandle file , ParticleEffectLoader . ParticleEffectParameter param ) { } @ Override public Array < AssetDescriptor > getDependencies ( String fileName , FileHandle file , ParticleEffectLoader . ParticleEffectParameter param ) { Array < AssetDescriptor > deps = null ; if ( ( param != null ) && ( ( param . atlasFile ) != null ) ) { <START_BUG> deps = Array . of ( AssetDescriptor . class ) ; <END_BUG> deps . add ( new AssetDescriptor < TextureAtlas > ( param . atlasFile , TextureAtlas . class ) ) ; } return deps ; } public static class ParticleEffectParameter extends AssetLoaderParameters < ParticleEffect > { public String atlasFile ; public FileHandle imagesDir ; } }
public class ParticleEffectLoader extends SynchronousAssetLoader < ParticleEffect , ParticleEffectLoader . ParticleEffectParameter > { public ParticleEffectLoader ( FileHandleResolver resolver ) { } @ Override public ParticleEffect load ( AssetManager am , String fileName , FileHandle file , ParticleEffectLoader . ParticleEffectParameter param ) { } @ Override public Array < AssetDescriptor > getDependencies ( String fileName , FileHandle file , ParticleEffectLoader . ParticleEffectParameter param ) { Array < AssetDescriptor > deps = null ; if ( ( param != null ) && ( ( param . atlasFile ) != null ) ) { <START_BUG> deps = Array . of ( AssetDescriptor . class ) ; <END_BUG> deps . add ( new AssetDescriptor < TextureAtlas > ( param . atlasFile , TextureAtlas . class ) ) ; } return deps ; } public static class ParticleEffectParameter extends AssetLoaderParameters < ParticleEffect > { public String atlasFile ; public FileHandle imagesDir ; } }
public class ByteBufferIndexInput extends IndexInput { private static final ByteBuffer EMPTY_BUFFER = ByteBuffer . allocate ( 0 ) . asReadOnlyBuffer ( ) ; private final ByteBufferFile file ; private final long length ; private ByteBuffer currentBuffer ; private int currentBufferIndex ; private long bufferStart ; private final int BUFFER_SIZE ; private volatile boolean closed = false ; public ByteBufferIndexInput ( String name , ByteBufferFile file ) throws IOException { } @ Override public void close ( ) { } @ Override public long length ( ) { } @ Override public short readShort ( ) throws IOException { } @ Override public int readInt ( ) throws IOException { } @ Override public long readLong ( ) throws IOException { } @ Override public byte readByte ( ) throws IOException { } @ Override public void readBytes ( byte [ ] b , int offset , int len ) throws IOException { } @ Override public long getFilePointer ( ) { } @ Override public void seek ( long pos ) throws IOException { } private void switchCurrentBuffer ( boolean enforceEOF ) throws IOException { } @ Override <START_BUG> public Object clone ( ) { <END_BUG> ByteBufferIndexInput cloned = ( ( ByteBufferIndexInput ) ( super . clone ( ) ) ) ; cloned . file . incRef ( ) ; if ( ( currentBuffer ) != ( ByteBufferIndexInput . EMPTY_BUFFER ) ) { cloned . currentBuffer = currentBuffer . asReadOnlyBuffer ( ) ; cloned . currentBuffer . position ( currentBuffer . position ( ) ) ; } return cloned ; } }
class RecoveryFileChunkRequest implements Streamable { private ShardId shardId ; private String name ; private long position ; private long length ; private String checksum ; private BytesReference content ; RecoveryFileChunkRequest ( ) { } RecoveryFileChunkRequest ( ShardId shardId , String name , long position , long length , String checksum , BytesArray content ) { } public ShardId shardId ( ) { } public String name ( ) { } public long position ( ) { } @ Nullable public String checksum ( ) { } public long length ( ) { } public BytesReference content ( ) { } public RecoveryFileChunkRequest readFileChunk ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { shardId . writeTo ( out ) ; out . writeUTF ( name ) ; out . writeVLong ( position ) ; out . writeVLong ( length ) ; if ( ( checksum ) == null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeUTF ( checksum ) ; } <START_BUG> out . writeBytesReference ( content , true ) ; <END_BUG> } @ Override public String toString ( ) { } }
public class TransportFlushAction extends TransportBroadcastOperationAction < FlushRequest , FlushResponse , ShardFlushRequest , ShardFlushResponse > { private final IndicesService indicesService ; @ Inject public TransportFlushAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected FlushRequest newRequest ( ) { } @ Override protected boolean ignoreNonActiveExceptions ( ) { } @ Override protected FlushResponse newResponse ( FlushRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardFlushRequest newShardRequest ( ) { } @ Override protected ShardFlushRequest newShardRequest ( ShardRouting shard , FlushRequest request ) { } @ Override protected ShardFlushResponse newShardResponse ( ) { } @ Override protected ShardFlushResponse shardOperation ( ShardFlushRequest request ) throws ElasticSearchException { IndexShard indexShard = indicesService . indexServiceSafe ( request . index ( ) ) . shardSafe ( request . shardId ( ) ) ; <START_BUG> indexShard . flush ( new Engine . Flush ( ) . refresh ( request . refresh ( ) ) . full ( request . full ( ) ) . force ( request . force ( ) ) ) ; <END_BUG> return new ShardFlushResponse ( request . index ( ) , request . shardId ( ) ) ; } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , FlushRequest request , String [ ] concreteIndices ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , FlushRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , FlushRequest countRequest , String [ ] concreteIndices ) { } }
public class SpriteBatch implements Batch { private Mesh mesh ; private Mesh [ ] buffers ; private int currBufferIdx = 0 ; private final float [ ] vertices ; private int idx = 0 ; private Texture lastTexture = null ; private float invTexWidth = 0 ; private float invTexHeight = 0 ; private boolean drawing = false ; private final Matrix4 transformMatrix = new Matrix4 ( ) ; private final Matrix4 projectionMatrix = new Matrix4 ( ) ; private final Matrix4 combinedMatrix = new Matrix4 ( ) ; private boolean blendingDisabled = false ; private int blendSrcFunc = GL11 . GL_SRC_ALPHA ; private int blendDstFunc = GL11 . GL_ONE_MINUS_SRC_ALPHA ; private final ShaderProgram shader ; private ShaderProgram customShader = null ; private boolean ownsShader ; float color = WHITE . toFloatBits ( ) ; private Color tempColor = new Color ( 1 , 1 , 1 , 1 ) ; public int renderCalls = 0 ; public int totalRenderCalls = 0 ; public int maxSpritesInBatch = 0 ; public SpriteBatch ( ) { } public SpriteBatch ( int size ) { } public SpriteBatch ( int size , ShaderProgram defaultShader ) { } public SpriteBatch ( int size , int buffers ) { } public SpriteBatch ( int size , int buffers , ShaderProgram defaultShader ) { } public static ShaderProgram createDefaultShader ( ) { } @ Override public void begin ( ) { } @ Override public void end ( ) { } @ Override public void setColor ( Color tint ) { } @ Override public void setColor ( float r , float g , float b , float a ) { } @ Override public void setColor ( float color ) { } @ Override public Color getColor ( ) { int intBits = NumberUtils . floatToIntColor ( color ) ; <START_BUG> Color color = tempColor ; <END_BUG> color . r = ( intBits & 255 ) / 255.0F ; color . g = ( ( intBits > > > 8 ) & 255 ) / 255.0F ; color . b = ( ( intBits > > > 16 ) & 255 ) / 255.0F ; color . a = ( ( intBits > > > 24 ) & 255 ) / 255.0F ; return color ; } @ Override public void draw ( Texture texture , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { } @ Override public void draw ( Texture texture , float x , float y , float width , float height , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { } @ Override public void draw ( Texture texture , float x , float y , int srcX , int srcY , int srcWidth , int srcHeight ) { } @ Override public void draw ( Texture texture , float x , float y , float width , float height , float u , float v , float u2 , float v2 ) { } @ Override public void draw ( Texture texture , float x , float y ) { } @ Override public void draw ( Texture texture , float x , float y , float width , float height ) { } @ Override public void draw ( Texture texture , float [ ] spriteVertices , int offset , int count ) { } @ Override public void draw ( TextureRegion region , float x , float y ) { } @ Override public void draw ( TextureRegion region , float x , float y , float width , float height ) { } @ Override public void draw ( TextureRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation ) { } @ Override public void draw ( TextureRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation , boolean clockwise ) { } @ Override public void flush ( ) { } @ Override public void disableBlending ( ) { } @ Override public void enableBlending ( ) { } @ Override public void setBlendFunction ( int srcFunc , int dstFunc ) { } @ Override public int getBlendSrcFunc ( ) { } @ Override public int getBlendDstFunc ( ) { } @ Override public void dispose ( ) { } @ Override public Matrix4 getProjectionMatrix ( ) { } @ Override public Matrix4 getTransformMatrix ( ) { } @ Override public void setProjectionMatrix ( Matrix4 projection ) { } @ Override public void setTransformMatrix ( Matrix4 transform ) { } private void setupMatrices ( ) { } private void switchTexture ( Texture texture ) { } @ Override public void setShader ( ShaderProgram shader ) { } @ Override public boolean isBlendingEnabled ( ) { } }
public class TransportNodesInfoAction extends TransportNodesOperationAction < NodesInfoRequest , NodesInfoResponse , TransportNodesInfoAction . NodeInfoRequest , NodeInfo > { private final MonitorService monitorService ; private volatile ImmutableMap < String , String > nodeAttributes = ImmutableMap . of ( ) ; @ Inject public TransportNodesInfoAction ( Settings settings , ClusterName clusterName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , MonitorService monitorService ) { } public synchronized void putNodeAttribute ( String key , String value ) { } public synchronized void removeNodeAttribute ( String key ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportNodeAction ( ) { } @ Override protected NodesInfoResponse newResponse ( NodesInfoRequest nodesInfoRequest , AtomicReferenceArray responses ) { } @ Override protected NodesInfoRequest newRequest ( ) { } @ Override protected TransportNodesInfoAction . NodeInfoRequest newNodeRequest ( ) { } @ Override protected TransportNodesInfoAction . NodeInfoRequest newNodeRequest ( String nodeId , NodesInfoRequest request ) { } @ Override protected NodeInfo newNodeResponse ( ) { } @ Override protected NodeInfo nodeOperation ( TransportNodesInfoAction . NodeInfoRequest nodeInfoRequest ) throws ElasticSearchException { <START_BUG> return new NodeInfo ( clusterService . state ( ) . nodes ( ) . localNode ( ) , nodeAttributes , settings , monitorService . osService ( ) . info ( ) , monitorService . processService ( ) . info ( ) , monitorService . jvmService ( ) . info ( ) , monitorService . networkService ( ) . info ( ) , threadPool . info ( ) ) ; <END_BUG> } @ Override protected boolean accumulateExceptions ( ) { } protected static class NodeInfoRequest extends NodeOperationRequest { private NodeInfoRequest ( ) { } private NodeInfoRequest ( String nodeId ) { } } }
public class PrismaticJointDef extends JointDef { public PrismaticJointDef ( ) { } public void initialize ( Body bodyA , Body bodyB , Vector2 anchor , Vector2 axis ) { this . bodyA = bodyA ; this . bodyB = bodyB ; localAnchorA . set ( bodyA . getLocalPoint ( anchor ) ) ; localAnchorB . set ( bodyB . getLocalPoint ( anchor ) ) ; <START_BUG> localAxis1 . set ( bodyA . getLocalVector ( anchor ) ) ; <END_BUG> referenceAngle = ( bodyB . getAngle ( ) ) - ( bodyA . getAngle ( ) ) ; } public final Vector2 localAnchorA = new Vector2 ( ) ; public final Vector2 localAnchorB = new Vector2 ( ) ; public final Vector2 localAxis1 = new Vector2 ( 1 , 0 ) ; public float referenceAngle = 0 ; public boolean enableLimit = false ; public float lowerTranslation = 0 ; public float upperTranslation = 0 ; public boolean enableMotor = false ; public float maxMotorForce = 0 ; public float motorSpeed = 0 ; }
public class StringFieldsFunctionDataComparator extends FieldComparator < String > { public static ExtendedFieldComparatorSource comparatorSource ( SearchScript script ) { } private static class InnerSource extends FieldDataType . ExtendedFieldComparatorSource { private final SearchScript script ; private InnerSource ( SearchScript script ) { } @ Override public FieldComparator newComparator ( String fieldname , int numHits , int sortPos , boolean reversed ) throws IOException { } @ Override public Type reducedType ( ) { } } private final SearchScript script ; private String [ ] values ; private String bottom ; public StringFieldsFunctionDataComparator ( int numHits , SearchScript script ) { } @ Override public FieldComparator < String > setNextReader ( AtomicReaderContext context ) throws IOException { <START_BUG> script . setNextReader ( context . reader ( ) ) ; <END_BUG> return this ; } @ Override public void setScorer ( Scorer scorer ) { } @ Override public int compare ( int slot1 , int slot2 ) { } @ Override public int compareBottom ( int doc ) { } @ Override public int compareDocToValue ( int doc , String val2 ) throws IOException { } @ Override public void copy ( int slot , int doc ) { } @ Override public void setBottom ( final int bottom ) { } @ Override public String value ( int slot ) { } }
public final class ExceptionsHelper { private static final ESLogger logger = Loggers . getLogger ( ExceptionsHelper . class ) ; public static Throwable unwrapCause ( Throwable t ) { int counter = 0 ; Throwable result = t ; while ( result instanceof ElasticSearchWrapperException ) { if ( ( result . getCause ( ) ) == null ) { return result ; } if ( ( result . getCause ( ) ) == result ) { return result ; } if ( ( counter ++ ) > 10 ) { ExceptionsHelper . logger . warn ( "Exception<seq2seq4repair_space>cause<seq2seq4repair_space>unwrapping<seq2seq4repair_space>ran<seq2seq4repair_space>for<seq2seq4repair_space>10<seq2seq4repair_space>levels..." , t ) ; return result ; } <START_BUG> result = t . getCause ( ) ; <END_BUG> } return result ; } public static String detailedMessage ( Throwable t ) { } public static String detailedMessage ( Throwable t , boolean newLines , int initialCounter ) { } }
public class GistFragment extends ListLoadingFragment < Comment > { private String id ; private LoaderCallbacks < List < Comment > > loadListener ; @ Inject private GistService service ; @ Inject private GistStore store ; private Gist gist ; private List < View > fileHeaders = new ArrayList < View > ( ) ; @ Inject private AvatarHelper avatarHelper ; public void onListItemClick ( ListView l , View v , int position , long id ) { } public GistFragment setLoadListener ( LoaderCallbacks < List < Comment > > loadListener ) { } public GistFragment setId ( String id ) { } @ Override public Loader < List < Comment > > onCreateLoader ( int i , Bundle bundle ) { return new com . github . mobile . android . AsyncLoader < List < Comment > > ( getActivity ( ) ) { @ Override public List < Comment > loadInBackground ( ) { try { Gist gist = store . addGist ( service . getGist ( id ) ) ; List < Comment > comments ; if ( ( gist . getComments ( ) ) > 0 ) comments = service . getComments ( id ) ; else comments = Collections . emptyList ( ) ; <START_BUG> return new FullGist ( gist , comments ) ; <END_BUG> } catch ( IOException e ) { return new FullGist ( ) ; } } } ; } @ Override protected ViewHoldingListAdapter < Comment > adapterFor ( List < Comment > items ) { } public void onLoadFinished ( Loader < List < Comment > > loader , List < Comment > items ) { } public void onLoaderReset ( Loader < List < Comment > > listLoader ) { } }
public final float [ ] tmp = new float [ 16 ] ; public final float [ ] val = new float [ 16 ] ; public Matrix4 ( ) { } public Matrix4 ( Matrix4 matrix ) { } public Matrix4 ( float [ ] values ) { } public Matrix4 ( Quaternion quaternion ) { } public Matrix4 ( Vector3 position , Quaternion rotation , Vector3 scale ) { } public Matrix4 set ( Matrix4 matrix ) { } public Matrix4 set ( float [ ] values ) { } public Matrix4 set ( Quaternion quaternion ) { } public Matrix4 set ( float x , float y , float z , float w ) { } public Matrix4 set ( Vector3 position , Quaternion orientation ) { } public Matrix4 set ( float translationX , float translationY , float translationZ , float quaternionX , float quaternionY , float quaternionZ , float quaternionW ) { } public Matrix4 set ( Vector3 xAxis , Vector3 yAxis , Vector3 zAxis , Vector3 pos ) { } public Matrix4 set ( Vector3 position , Quaternion orientation , Vector3 scale ) { } public Matrix4 cpy ( ) { } public Matrix4 trn ( Vector3 vector ) { } public Matrix4 trn ( float x , float y , float z ) { } public float [ ] getValues ( ) { } public Matrix4 mul ( Matrix4 matrix ) { } public Matrix4 mulLeft ( Matrix4 matrix ) { } public Matrix4 tra ( ) { } public Matrix4 idt ( ) { } public Matrix4 inv ( ) { } public float det ( ) { } public float det3x3 ( ) { } public Matrix4 setToProjection ( float near , float far , float fov , float aspectRatio ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height , float near , float far ) { } public Matrix4 setToOrtho ( float left , float right , float bottom , float top , float near , float far ) { } public Matrix4 setTranslation ( Vector3 vector ) { } public Matrix4 setTranslation ( float x , float y , float z ) { } public Matrix4 setToTranslation ( Vector3 vector ) { } public Matrix4 setToTranslation ( float x , float y , float z ) { } public Matrix4 setToTranslationAndScaling ( Vector3 translation , Vector3 scaling ) { } public Matrix4 setToTranslationAndScaling ( float translationX , float translationY , float translationZ , float scalingX , float scalingY , float scalingZ ) { } static Quaternion quat = new Quaternion ( ) ; public Matrix4 setToRotation ( Vector3 axis , float degrees ) { } public Matrix4 setToRotationRad ( Vector3 axis , float radians ) { } public Matrix4 setToRotationRad ( float axisX , float axisY , float axisZ , float radians ) { } public Matrix4 setToRotation ( float axisX , float axisY , float axisZ , float angle ) { } public Matrix4 setToRotation ( final Vector3 v1 , final Vector3 v2 ) { } public Matrix4 setToRotation ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } public Matrix4 setFromEulerAngles ( float yaw , float pitch , float roll ) { } public Matrix4 setToScaling ( Vector3 vector ) { } public Matrix4 setToScaling ( float x , float y , float z ) { } static final Vector3 l_vez = new Vector3 ( ) ; static final Vector3 l_vex = new Vector3 ( ) ; static final Vector3 l_vey = new Vector3 ( ) ; public Matrix4 setToLookAt ( Vector3 direction , Vector3 up ) { } static final Vector3 tmpVec = new Vector3 ( ) ; static final Matrix4 tmpMat = new Matrix4 ( ) ; public Matrix4 setToLookAt ( Vector3 position , Vector3 target , Vector3 up ) { Matrix4 . tmpVec . set ( target ) . sub ( position ) ; setToLookAt ( Matrix4 . tmpVec , up ) ; <START_BUG> this . mul ( Matrix4 . tmpMat . setToTranslation ( ( - ( position . x ) ) , ( - ( position . y ) ) , ( - ( position . z ) ) ) ) ; <END_BUG> return this ; } static final Vector3 right = new Vector3 ( ) ; static final Vector3 tmpForward = new Vector3 ( ) ; static final Vector3 tmpUp = new Vector3 ( ) ; public Matrix4 setToWorld ( Vector3 position , Vector3 forward , Vector3 up ) { } public String toString ( ) { } public Matrix4 lerp ( Matrix4 matrix , float alpha ) { } public Matrix4 set ( Matrix3 mat ) { } public Matrix4 scl ( Vector3 scale ) { } public Matrix4 scl ( float x , float y , float z ) { } public Matrix4 scl ( float scale ) { } public Vector3 getTranslation ( Vector3 position ) { } public Quaternion getRotation ( Quaternion rotation , boolean normalizeAxes ) { } public Quaternion getRotation ( Quaternion rotation ) { } public float getScaleXSquared ( ) { } public float getScaleYSquared ( ) { } public float getScaleZSquared ( ) { } public float getScaleX ( ) { } public float getScaleY ( ) { } public float getScaleZ ( ) { } public Vector3 getScale ( Vector3 scale ) { } public Matrix4 toNormalMatrix ( ) { } static void matrix4_mul ( float [ ] mata , float [ ] matb ) { } static float matrix4_det ( float [ ] val ) { } static boolean matrix4_inv ( float [ ] val ) { } static void matrix4_mulVec ( float [ ] mat , float [ ] vec , int offset ) { }
public class StillModel implements Model { public final StillSubMesh [ ] subMeshes ; public StillModel ( StillSubMesh [ ] subMeshes ) { } @ Override public void render ( ) { } @ Override public void render ( ShaderProgram program ) { } @ Override public Model getSubModel ( String ... subMeshNames ) { } @ Override <START_BUG> public SubMesh getSubMesh ( String name ) { <END_BUG> for ( StillSubMesh subMesh : subMeshes ) { if ( subMesh . name . equals ( name ) ) return subMesh ; } return null ; } @ Override public SubMesh [ ] getSubMeshes ( ) { } @ Override public void setMaterials ( Material ... materials ) { } @ Override public void setMaterial ( Material material ) { } private static final BoundingBox tmpBox = new BoundingBox ( ) ; @ Override public void getBoundingBox ( BoundingBox bbox ) { } }
public class TransportClientHeadersTests extends AbstractClientHeadersTests { private static final LocalTransportAddress address = new LocalTransportAddress ( "test" ) ; @ Override protected Client buildClient ( Settings headersSettings , GenericAction [ ] testedActions ) { } public static class InternalTransportService extends TransportService { @ Inject public InternalTransportService ( Settings settings , Transport transport , ThreadPool threadPool ) { } @ Override @ SuppressWarnings ( "unchecked" ) public < T extends TransportResponse > void sendRequest ( DiscoveryNode node , String action , TransportRequest request , TransportRequestOptions options , TransportResponseHandler < T > handler ) { if ( NAME . equals ( action ) ) { ( ( TransportResponseHandler < NodesInfoResponse > ) ( handler ) ) . handleResponse ( new NodesInfoResponse ( ClusterName . DEFAULT , new NodeInfo [ 0 ] ) ) ; return ; } <START_BUG> handler . handleException ( new TransportException ( "" , new InternalException ( action , request . getHeaders ( ) ) ) ) ; <END_BUG> } @ Override public boolean nodeConnected ( DiscoveryNode node ) { } @ Override public void connectToNode ( DiscoveryNode node ) throws ConnectTransportException { } } }
public class TransferThreadPoolExecutor extends AbstractExecutorService { private final TransferQueue < Runnable > workQueue = new org . elasticsearch . common . util . concurrent . jsr166y . LinkedTransferQueue < Runnable > ( ) ; private final AtomicInteger queueSize = new AtomicInteger ( ) ; private final ReentrantLock mainLock = new ReentrantLock ( ) ; private final Condition termination = mainLock . newCondition ( ) ; private final HashSet < TransferThreadPoolExecutor . Worker > workers = new HashSet < TransferThreadPoolExecutor . Worker > ( ) ; private final ThreadFactory threadFactory ; volatile int runState ; static final int RUNNING = 0 ; static final int SHUTDOWN = 1 ; static final int STOP = 2 ; static final int TERMINATED = 3 ; private final boolean blocking ; private final int blockingCapacity ; private final long blockingTime ; private final int corePoolSize ; private final int maximumPoolSize ; private final long keepAliveTime ; private final AtomicInteger poolSize = new AtomicInteger ( ) ; public static TransferThreadPoolExecutor newScalingExecutor ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory ) { } public static TransferThreadPoolExecutor newBlockingExecutor ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , long blockingTime , TimeUnit blockingUnit , int blockingCapacity , ThreadFactory threadFactory ) { } private TransferThreadPoolExecutor ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , boolean blocking , long blockingTime , TimeUnit blockingUnit , int blockingCapacity , ThreadFactory threadFactory ) { } @ Override public void execute ( Runnable command ) { } private void executeNonBlocking ( Runnable command ) { } private void executeBlocking ( Runnable command ) { } private void transferOrAddBlocking ( Runnable command , int currentCapacity ) { } @ Override public void shutdown ( ) { } @ Override public List < Runnable > shutdownNow ( ) { } @ Override public boolean isShutdown ( ) { } @ Override public boolean isTerminated ( ) { } @ Override public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { } public int getPoolSize ( ) { } public int getActiveCount ( ) { } public int getCorePoolSize ( ) { } public int getMaximumPoolSize ( ) { } public int getQueueSize ( ) { } private final class Worker implements Runnable { private final ReentrantLock runLock = new ReentrantLock ( ) ; Thread thread ; Worker ( ) { } boolean isActive ( ) { } void interruptIfIdle ( ) { } void interruptNow ( ) { } private void runTask ( Runnable task ) { } public void run ( ) { } } Runnable getTask ( ) { } private boolean workerCanExit ( ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; boolean canExit ; try { <START_BUG> canExit = ( ( runState ) >= ( TransferThreadPoolExecutor . STOP ) ) || ( ( queueSize . get ( ) ) == 0 ) ; <END_BUG> } finally { mainLock . unlock ( ) ; } return canExit ; } void interruptIdleWorkers ( ) { } void workerDone ( TransferThreadPoolExecutor . Worker w ) { } private void tryTerminate ( ) { } private Thread addWorker ( ) { } private Thread addThread ( ) { } private List < Runnable > drainQueue ( ) { } }
@ ThreadSafe public class InternalIndexShard extends AbstractIndexShardComponent implements IndexShard { private final ThreadPool threadPool ; private final MapperService mapperService ; private final IndexQueryParserService queryParserService ; private final IndexCache indexCache ; private final Store store ; private final Engine engine ; private final Translog translog ; private final Object mutex = new Object ( ) ; private volatile IndexShardState state ; private ScheduledFuture refreshScheduledFuture ; private volatile ShardRouting shardRouting ; @ Inject public InternalIndexShard ( ShardId shardId , @ IndexSettings Settings indexSettings , Store store , Engine engine , Translog translog , ThreadPool threadPool , MapperService mapperService , IndexQueryParserService queryParserService , IndexCache indexCache ) { } public Store store ( ) { } public Engine engine ( ) { } public Translog translog ( ) { } @ Override public ShardRouting routingEntry ( ) { } public InternalIndexShard routingEntry ( ShardRouting shardRouting ) { } public IndexShardState recovering ( ) throws IndexShardClosedException , IndexShardRecoveringException , IndexShardRelocatedException , IndexShardStartedException { } public InternalIndexShard restoreRecoveryState ( IndexShardState stateToRestore ) { } public InternalIndexShard relocated ( ) throws IndexShardNotStartedException { } public InternalIndexShard start ( ) throws IndexShardClosedException , IndexShardRelocatedException , IndexShardStartedException { } @ Override public IndexShardState state ( ) { } @ Override public SizeValue estimateFlushableMemorySize ( ) throws ElasticSearchException { } @ Override public ParsedDocument create ( String type , String id , byte [ ] source ) throws ElasticSearchException { } private ParsedDocument innerCreate ( String type , String id , byte [ ] source ) { } @ Override public ParsedDocument index ( String type , String id , byte [ ] source ) throws ElasticSearchException { } private ParsedDocument innerIndex ( String type , String id , byte [ ] source ) { } @ Override public void delete ( String type , String id ) { } @ Override public void delete ( Term uid ) { } private void innerDelete ( Term uid ) { } @ Override public void deleteByQuery ( byte [ ] querySource , @ Nullable String queryParserName , String ... types ) throws ElasticSearchException { } private void innerDeleteByQuery ( byte [ ] querySource , String queryParserName , String ... types ) { } @ Override public byte [ ] get ( String type , String id ) throws ElasticSearchException { } @ Override public long count ( float minScore , byte [ ] querySource , @ Nullable String queryParserName , String ... types ) throws ElasticSearchException { } @ Override public long count ( float minScore , byte [ ] querySource , int querySourceOffset , int querySourceLength , @ Nullable String queryParserName , String ... types ) throws ElasticSearchException { } @ Override public void refresh ( Engine . Refresh refresh ) throws ElasticSearchException { } @ Override public void flush ( Engine . Flush flush ) throws ElasticSearchException { writeAllowed ( ) ; if ( logger . isTraceEnabled ( ) ) { <START_BUG> logger . trace ( "Flush" ) ; <END_BUG> } engine . flush ( flush ) ; } @ Override public void optimize ( Engine . Optimize optimize ) throws ElasticSearchException { } @ Override public < T > T snapshot ( Engine . SnapshotHandler < T > snapshotHandler ) throws EngineException { } @ Override public void recover ( Engine . RecoveryHandler recoveryHandler ) throws EngineException { } @ Override public Searcher searcher ( ) { } @ Override public void close ( ) { } public void performRecovery ( Iterable < Translog . Operation > operations ) throws ElasticSearchException { } public void performRecovery ( Translog . Snapshot snapshot , boolean phase3 ) throws ElasticSearchException { } private void applyTranslogOperations ( Iterable < Translog . Operation > snapshot ) { } public boolean ignoreRecoveryAttempt ( ) { } public void readAllowed ( ) throws IllegalIndexShardStateException { } public void writeAllowed ( ) throws IllegalIndexShardStateException { } private void scheduleRefresherIfNeeded ( ) { } private Query filterByTypesIfNeeded ( Query query , String [ ] types ) { } private class EngineRefresher implements Runnable { @ Override public void run ( ) { } } }
public class AvgAggregator extends MetricsAggregator . SingleValue { private final NumericValuesSource valuesSource ; private DoubleValues values ; private LongArray counts ; private DoubleArray sums ; public AvgAggregator ( String name , long estimatedBucketsCount , NumericValuesSource valuesSource , AggregationContext context , Aggregator parent ) { } @ Override public boolean shouldCollect ( ) { } @ Override public void setNextReader ( AtomicReaderContext reader ) { } @ Override public void collect ( int doc , long owningBucketOrdinal ) throws IOException { } @ Override public double metric ( long owningBucketOrd ) { <START_BUG> return ( sums . get ( owningBucketOrd ) ) / ( counts . get ( owningBucketOrd ) ) ; <END_BUG> } @ Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) { } @ Override public InternalAggregation buildEmptyAggregation ( ) { } public static class Factory extends ValueSourceAggregatorFactory . LeafOnly < NumericValuesSource > { public Factory ( String name , String type , ValuesSourceConfig < NumericValuesSource > valuesSourceConfig ) { } @ Override protected Aggregator createUnmapped ( AggregationContext aggregationContext , Aggregator parent ) { } @ Override protected Aggregator create ( NumericValuesSource valuesSource , long expectedBucketsCount , AggregationContext aggregationContext , Aggregator parent ) { } } @ Override public void doRelease ( ) { } }
public class Material implements Iterable < Material . Attribute > , Comparator < Material . Attribute > { public static abstract class Attribute { protected static long register ( final String type ) { } public final long type ; protected Attribute ( final long type ) { } public abstract Material . Attribute copy ( ) { } protected abstract boolean equals ( Material . Attribute other ) { } @ Override public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( obj == ( this ) ) return true ; if ( ! ( obj instanceof Material . Attribute ) ) return false ; final Material . Attribute other = ( ( Material . Attribute ) ( obj ) ) ; <START_BUG> if ( ( other . type ) != ( other . type ) ) <END_BUG> return false ; return equals ( other ) ; } @ Override public String toString ( ) { } } private static final Array < String > types = new Array < String > ( ) ; private static int counter = 0 ; protected static final long getAttributeType ( final String alias ) { } protected static final String getAttributeAlias ( final long type ) { } protected static final long register ( final String alias ) { } public String id ; protected long mask ; protected final Array < Material . Attribute > attributes = new Array < Material . Attribute > ( ) ; protected boolean sorted = true ; public Material ( ) { } public Material ( final String id ) { } public Material ( final Material . Attribute ... attributes ) { } public Material ( final String id , final Material . Attribute ... attributes ) { } public Material ( final Array < Material . Attribute > attributes ) { } public Material ( final String id , final Array < Material . Attribute > attributes ) { } public Material ( final Material copyFrom ) { } public Material ( final String id , final Material copyFrom ) { } private final void enable ( final long mask ) { } private final void disable ( final long mask ) { } public final long getMask ( ) { } public final boolean has ( final long type ) { } protected int indexOf ( final long type ) { } public final void set ( final Material . Attribute attribute ) { } public final void set ( final Material . Attribute ... attributes ) { } public final void set ( final Iterable < Material . Attribute > attributes ) { } public final void remove ( final long mask ) { } public final Material . Attribute get ( final long type ) { } public final Array < Material . Attribute > get ( final Array < Material . Attribute > out , final long type ) { } public final void clear ( ) { } public int size ( ) { } public final Material copy ( ) { } @ Override public final int compare ( final Material . Attribute arg0 , final Material . Attribute arg1 ) { } public final void sort ( ) { } public final boolean same ( final Material other , boolean compareValues ) { } public final boolean same ( final Material other ) { } public final boolean equals ( final Material other ) { } @ Override public final boolean equals ( final Object obj ) { return obj instanceof Material ? equals ( ( ( Material ) ( obj ) ) ) : false ; } @ Override public final Iterator < Material . Attribute > iterator ( ) { } }
public abstract class BaseG3dHudTest extends BaseG3dTest { public static final int PREF_HUDWIDTH = 640 ; public static final int PREF_HUDHEIGHT = 480 ; public static final float rotationSpeed = 0.02F * 360.0F ; public static final float moveSpeed = 0.25F ; protected Stage hud ; protected float hudWidth ; protected float hudHeight ; protected Skin skin ; protected Label fpsLabel ; protected BaseG3dHudTest . CollapsableWindow modelsWindow ; protected CheckBox gridCheckBox ; protected CheckBox rotateCheckBox ; protected CheckBox moveCheckBox ; protected final StringBuilder stringBuilder = new StringBuilder ( ) ; protected final Matrix4 transform = new Matrix4 ( ) ; protected float moveRadius = 2.0F ; protected String [ ] models = new String [ ] { "car.obj" , "cube.obj" , "scene.obj" , "scene2.obj" , "wheel.obj" , "g3d/invaders.g3dj" , "g3d/head.g3db" , "g3d/house.g3dj" , "g3d/knight.g3dj" , "g3d/knight.g3db" , "g3d/ship.obj" , "g3d/shapes/cube_1.0x1.0.g3dj" , "g3d/shapes/cube_1.5x1.5.g3dj" , "g3d/shapes/sphere.g3dj" , "g3d/shapes/teapot.g3dj" , "g3d/shapes/torus.g3dj" } ; @ Override public void create ( ) { } protected void createHUD ( ) { } protected BaseG3dHudTest . CollapsableWindow addListWindow ( String title , List list , float x , float y ) { } protected abstract void onModelClicked ( final String name ) { } protected void getStatus ( final StringBuilder stringBuilder ) { } protected float rotation ; protected float movement ; @ Override public void render ( ) { } @ Override public void resize ( int width , int height ) { super . resize ( width , height ) ; <START_BUG> hud . getViewport ( ) . update ( width , height ) ; <END_BUG> hudWidth = hud . getWidth ( ) ; hudHeight = hud . getHeight ( ) ; } @ Override public void dispose ( ) { } public static class CollapsableWindow extends Window { private boolean collapsed ; private float collapseHeight = 20.0F ; private float expandHeight ; public CollapsableWindow ( String title , Skin skin ) { } public void expand ( ) { } public void collapse ( ) { } public void toggleCollapsed ( ) { } public boolean isCollapsed ( ) { } } }
public interface Application { public enum ApplicationType { Android , Desktop , Applet , WebGL , iOS ; } public static final int LOG_NONE = 0 ; public static final int LOG_DEBUG = 3 ; public static final int LOG_INFO = 2 ; public static final int LOG_ERROR = 1 ; public ApplicationListener getApplicationListener ( ) { } public Graphics getGraphics ( ) { } public Audio getAudio ( ) { } public Input getInput ( ) { } public Files getFiles ( ) { } public Net getNet ( ) { } public void log ( String tag , String message ) { } <START_BUG> public void log ( String tag , String message , Exception exception ) ; <END_BUG> public void error ( String tag , String message ) { } public void error ( String tag , String message , Throwable exception ) { } public void debug ( String tag , String message ) { } public void debug ( String tag , String message , Throwable exception ) { } public void setLogLevel ( int logLevel ) { } public int getLogLevel ( ) { } public Application . ApplicationType getType ( ) { } public int getVersion ( ) { } public long getJavaHeap ( ) { } public long getNativeHeap ( ) { } public Preferences getPreferences ( String name ) { } public Clipboard getClipboard ( ) { } public void postRunnable ( Runnable runnable ) { } public void exit ( ) { } public void addLifecycleListener ( LifecycleListener listener ) { } public void removeLifecycleListener ( LifecycleListener listener ) { } }
public class Body { protected final long addr ; private final float [ ] tmp = new float [ 4 ] ; private final World world ; private ArrayList < Fixture > fixtures = new ArrayList < Fixture > ( 2 ) ; protected ArrayList < JointEdge > joints = new ArrayList < JointEdge > ( 2 ) ; private Object userData ; protected Body ( World world , long addr ) { } public Fixture createFixture ( FixtureDef def ) { } private native long jniCreateFixture ( long addr , long shapeAddr , float friction , float restitution , float density , boolean isSensor , short filterCategoryBits , short filterMaskBits , short filterGroupIndex ) { } public Fixture createFixture ( Shape shape , float density ) { } private native long jniCreateFixture ( long addr , long shapeAddr , float density ) { } public void destroyFixture ( Fixture fixture ) { jniDestroyFixture ( addr , fixture . addr ) ; <START_BUG> this . world . fixtures . remove ( fixture ) ; <END_BUG> this . fixtures . remove ( fixture ) ; } private native void jniDestroyFixture ( long addr , long fixtureAddr ) { } public void setTransform ( Vector2 position , float angle ) { } private native void jniSetTransform ( long addr , float positionX , float positionY , float angle ) { } private final Transform transform = new Transform ( ) ; public Transform getTransform ( ) { } private native void jniGetTransform ( long addr , float [ ] vals ) { } private final Vector2 position = new Vector2 ( ) ; public Vector2 getPosition ( ) { } private native void jniGetPosition ( long addr , float [ ] position ) { } public float getAngle ( ) { } private native float jniGetAngle ( long addr ) { } private final Vector2 worldCenter = new Vector2 ( ) ; public Vector2 getWorldCenter ( ) { } private native void jniGetWorldCenter ( long addr , float [ ] worldCenter ) { } private final Vector2 localCenter = new Vector2 ( ) ; public Vector2 getLocalCenter ( ) { } private native void jniGetLocalCenter ( long addr , float [ ] localCenter ) { } public void setLinearVelocity ( Vector2 v ) { } private native void jniSetLinearVelocity ( long addr , float x , float y ) { } private final Vector2 linearVelocity = new Vector2 ( ) ; public Vector2 getLinearVelocity ( ) { } private native void jniGetLinearVelocity ( long addr , float [ ] tmpLinearVelocity ) { } public void setAngularVelocity ( float omega ) { } private native void jniSetAngularVelocity ( long addr , float omega ) { } public float getAngularVelocity ( ) { } private native float jniGetAngularVelocity ( long addr ) { } public void applyForce ( Vector2 force , Vector2 point ) { } private native void jniApplyForce ( long addr , float forceX , float forceY , float pointX , float pointY ) { } public void applyTorque ( float torque ) { } private native void jniApplyTorque ( long addr , float torque ) { } public void applyLinearImpulse ( Vector2 impulse , Vector2 point ) { } private native void jniApplyLinearImpulse ( long addr , float impulseX , float impulseY , float pointX , float pointY ) { } public void applyAngularImpulse ( float impulse ) { } private native void jniApplyAngularImpulse ( long addr , float impulse ) { } public float getMass ( ) { } private native float jniGetMass ( long addr ) { } public float getInertia ( ) { } private native float jniGetInertia ( long addr ) { } private final MassData massData = new MassData ( ) ; public MassData getMassData ( ) { } private native void jniGetMassData ( long addr , float [ ] massData ) { } public void setMassData ( MassData data ) { } private native void jniSetMassData ( long addr , float mass , float centerX , float centerY , float I ) { } public void resetMassData ( ) { } private native void jniResetMassData ( long addr ) { } private final Vector2 localPoint = new Vector2 ( ) ; public Vector2 getWorldPoint ( Vector2 localPoint ) { } private native void jniGetWorldPoint ( long addr , float localPointX , float localPointY , float [ ] worldPoint ) { } private final Vector2 worldVector = new Vector2 ( ) ; public Vector2 getWorldVector ( Vector2 localVector ) { } private native void jniGetWorldVector ( long addr , float localVectorX , float localVectorY , float [ ] worldVector ) { } public final Vector2 localPoint2 = new Vector2 ( ) ; public Vector2 getLocalPoint ( Vector2 worldPoint ) { } private native void jniGetLocalPoint ( long addr , float worldPointX , float worldPointY , float [ ] localPoint ) { } public final Vector2 localVector = new Vector2 ( ) ; public Vector2 getLocalVector ( Vector2 worldVector ) { } private native void jniGetLocalVector ( long addr , float worldVectorX , float worldVectorY , float [ ] worldVector ) { } public final Vector2 linVelWorld = new Vector2 ( ) ; public Vector2 getLinearVelocityFromWorldPoint ( Vector2 worldPoint ) { } private native void jniGetLinearVelocityFromWorldPoint ( long addr , float worldPointX , float worldPointY , float [ ] linVelWorld ) { } public final Vector2 linVelLoc = new Vector2 ( ) ; public Vector2 getLinearVelocityFromLocalPoint ( Vector2 localPoint ) { } private native void jniGetLinearVelocityFromLocalPoint ( long addr , float localPointX , float localPointY , float [ ] linVelLoc ) { } public float getLinearDamping ( ) { } private native float jniGetLinearDamping ( long add ) { } public void setLinearDamping ( float linearDamping ) { } private native void jniSetLinearDamping ( long addr , float linearDamping ) { } public float getAngularDamping ( ) { } private native float jniGetAngularDamping ( long addr ) { }
public class TextField extends Widget { private static final char BACKSPACE = 8 ; private static final char ENTER_DESKTOP = '\r' ; private static final char ENTER_ANDROID = '\n' ; private static final char TAB = '\t' ; private static final char DELETE = 127 ; private static final char BULLET = 149 ; TextField . TextFieldStyle style ; String text ; String messageText ; private CharSequence displayText ; int cursor ; private Clipboard clipboard ; TextField . TextFieldListener listener ; TextField . TextFieldFilter filter ; TextField . OnscreenKeyboard keyboard = new TextField . DefaultOnscreenKeyboard ( ) ; boolean focusTraversal = true ; private boolean passwordMode ; private StringBuilder passwordBuffer ; private final Rectangle fieldBounds = new Rectangle ( ) ; private final TextBounds textBounds = new TextBounds ( ) ; private final Rectangle scissor = new Rectangle ( ) ; float renderOffset ; float textOffset ; private int visibleTextStart ; private int visibleTextEnd ; private final FloatArray glyphAdvances = new FloatArray ( ) ; final FloatArray glyphPositions = new FloatArray ( ) ; boolean cursorOn = true ; private float blinkTime = 0.32F ; long lastBlink ; boolean hasSelection ; int selectionStart ; private float selectionX ; private float selectionWidth ; private char passwordCharacter = TextField . BULLET ; InputListener inputListener ; TextField . KeyRepeatTask keyRepeatTask = new TextField . KeyRepeatTask ( ) ; float keyRepeatInitialTime = 0.4F ; float keyRepeatTime = 0.1F ; boolean rightAligned ; public TextField ( String text , Skin skin ) { } public TextField ( String text , Skin skin , String styleName ) { } public TextField ( String text , TextField . TextFieldStyle style ) { } private void initialize ( ) { addListener ( ( inputListener = new ClickListener ( ) { public void clicked ( InputEvent event , float x , float y ) { if ( ( getTapCount ( ) ) > 1 ) setSelection ( 0 , text . length ( ) ) ; } public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { if ( ! ( super . touchDown ( event , x , y , pointer , button ) ) ) return false ; if ( ( pointer == 0 ) && ( button != 0 ) ) return false ; Stage stage = getStage ( ) ; keyboard . show ( true ) ; clearSelection ( ) ; setCursorPosition ( x ) ; selectionStart = cursor ; if ( stage != null ) stage . setKeyboardFocus ( TextField . this ) ; return true ; } public void touchDragged ( InputEvent event , float x , float y , int pointer ) { super . touchDragged ( event , x , y , pointer ) ; lastBlink = 0 ; cursorOn = false ; setCursorPosition ( x ) ; hasSelection = true ; } private void setCursorPosition ( float x ) { lastBlink = 0 ; cursorOn = false ; <START_BUG> x -= renderOffset ; <END_BUG> for ( int i = 0 ; i < ( glyphPositions . size ) ; i ++ ) { if ( ( glyphPositions . items [ i ] ) > x ) { cursor = Math . max ( 0 , ( i - 1 ) ) ; return ; } } cursor = Math . max ( 0 , ( ( glyphPositions . size ) - 1 ) ) ; } public boolean keyDown ( InputEvent event , int keycode ) { final BitmapFont font = style . font ; lastBlink = 0 ; cursorOn = false ; Stage stage = getStage ( ) ; if ( ( stage != null ) && ( ( stage . getKeyboardFocus ( ) ) == ( TextField . this ) ) ) { boolean repeat = false ; boolean ctrl = ( input . isKeyPressed ( CONTROL_LEFT ) ) || ( input . isKeyPressed ( CONTROL_RIGHT ) ) ; if ( ctrl ) { if ( keycode == ( Keys . V ) ) { paste ( ) ; return true ; } if ( ( keycode == ( Keys . C ) ) || ( keycode == ( Keys . INSERT ) ) ) { copy ( ) ; return true ; } if ( ( keycode == ( Keys . X ) ) || ( keycode == ( Keys . DEL ) ) ) { cut ( ) ; return true ; } } if ( ( input . isKeyPressed ( SHIFT_LEFT ) ) || ( input . isKeyPressed ( SHIFT_RIGHT ) ) ) { if ( keycode == ( Keys . INSERT ) ) paste ( ) ; if ( keycode == ( Keys . FORWARD_DEL ) ) { if ( hasSelection ) { copy ( ) ; delete ( ) ; } } if ( keycode == ( Keys . LEFT ) ) { if ( ! ( hasSelection ) ) { selectionStart = cursor ; hasSelection = true ; } while ( ( ( -- ( cursor ) ) > 0 ) && ctrl ) { char c = text . charAt ( cursor ) ; if ( ( c >= 'A' ) && ( c <= 'Z' ) ) continue ; if ( ( c >= 'a' ) && ( c <= 'z' ) ) continue ; if ( ( c >= '0' ) && ( c <= '9' ) ) continue ; break ; } repeat = true ; } if ( keycode == ( Keys . RIGHT ) ) { if ( ! ( hasSelection ) ) { selectionStart = cursor ; hasSelection = true ; } int length = text . length ( ) ; while ( ( ( ++ ( cursor ) ) < length ) && ctrl ) { char c = text . charAt ( ( ( cursor ) - 1 ) ) ;
public class BooleanArray { public boolean [ ] items ; public int size ; public boolean ordered ; public BooleanArray ( ) { } public BooleanArray ( int capacity ) { } public BooleanArray ( boolean ordered , int capacity ) { } public BooleanArray ( BooleanArray array ) { } public BooleanArray ( boolean [ ] array ) { } public BooleanArray ( boolean ordered , boolean [ ] array , int startIndex , int count ) { } public void add ( boolean value ) { } public void addAll ( BooleanArray array ) { } public void addAll ( BooleanArray array , int offset , int length ) { } public void addAll ( boolean [ ] array ) { } public void addAll ( boolean [ ] array , int offset , int length ) { boolean [ ] items = this . items ; <START_BUG> int sizeNeeded = ( size ) + length ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public boolean get ( int index ) { } public void set ( int index , boolean value ) { } public void insert ( int index , boolean value ) { } public void swap ( int first , int second ) { } public boolean removeIndex ( int index ) { } public boolean removeAll ( BooleanArray array ) { } public boolean pop ( ) { } public boolean peek ( ) { } public boolean first ( ) { } public void clear ( ) { } public void shrink ( ) { } public boolean [ ] ensureCapacity ( int additionalCapacity ) { } protected boolean [ ] resize ( int newSize ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public boolean random ( ) { } public boolean [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class RestNodesInfoAction extends BaseRestHandler { private final SettingsFilter settingsFilter ; @ Inject public RestNodesInfoAction ( Settings settings , Client client , RestController controller , SettingsFilter settingsFilter ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } void executeNodeRequest ( final RestRequest request , final RestChannel channel , NodesInfoRequest nodesInfoRequest ) { nodesInfoRequest . listenerThreaded ( false ) ; client . admin ( ) . cluster ( ) . nodesInfo ( nodesInfoRequest , new org . elasticsearch . action . ActionListener < NodesInfoResponse > ( ) { @ Override public void onResponse ( NodesInfoResponse response ) { try { response . settingsFilter ( settingsFilter ) ; XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; builder . field ( "ok" , true ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } class RestSettingsHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestOsHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestProcessHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestJvmHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestThreadPoolHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestNetworkHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestTransportHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestHttpHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } }
@ ThreadSafe public class MemoryTranslog extends AbstractIndexShardComponent implements Translog { private final Object mutex = new Object ( ) ; private final AtomicLong estimatedMemorySize = new AtomicLong ( ) ; private volatile long id ; private volatile Queue < Operation > operations ; private final AtomicInteger operationCounter = new AtomicInteger ( ) ; @ Inject public MemoryTranslog ( ShardId shardId , @ IndexSettings Settings indexSettings ) { } @ Override public long currentId ( ) { } @ Override public int size ( ) { } @ Override public ByteSizeValue estimateMemorySize ( ) { } @ Override public void newTranslog ( long id ) { } @ Override public void add ( Operation operation ) throws TranslogException { } @ Override public Snapshot snapshot ( ) { } @ Override public Snapshot snapshot ( Snapshot snapshot ) { synchronized ( mutex ) { MemorySnapshot memorySnapshot = ( ( MemorySnapshot ) ( snapshot ) ) ; if ( ( currentId ( ) ) != ( snapshot . translogId ( ) ) ) { return snapshot ( ) ; } MemorySnapshot newSnapshot = new MemorySnapshot ( currentId ( ) , operations , operationCounter . get ( ) ) ; <START_BUG> newSnapshot . seekForward ( memorySnapshot . length ( ) ) ; <END_BUG> return newSnapshot ; } } @ Override public void close ( ) { } }
public class FunctionScoreQuery extends Query { Query subQuery ; final ScoreFunction function ; float maxBoost = Float . MAX_VALUE ; CombineFunction combineFunction ; public FunctionScoreQuery ( Query subQuery , ScoreFunction function ) { } public void setCombineFunction ( CombineFunction combineFunction ) { } public void setMaxBoost ( float maxBoost ) { } public float getMaxBoost ( ) { } public Query getSubQuery ( ) { } public ScoreFunction getFunction ( ) { } @ Override public Query rewrite ( IndexReader reader ) throws IOException { } @ Override public void extractTerms ( Set < Term > terms ) { } @ Override public Weight createWeight ( IndexSearcher searcher ) throws IOException { } class CustomBoostFactorWeight extends Weight { final Weight subQueryWeight ; public CustomBoostFactorWeight ( Weight subQueryWeight ) throws IOException { } public Query getQuery ( ) { } @ Override public float getValueForNormalization ( ) throws IOException { } @ Override public void normalize ( float norm , float topLevelBoost ) { } @ Override public Scorer scorer ( AtomicReaderContext context , Bits acceptDocs ) throws IOException { } @ Override public Explanation explain ( AtomicReaderContext context , int doc ) throws IOException { Explanation subQueryExpl = subQueryWeight . explain ( context , doc ) ; if ( ! ( subQueryExpl . isMatch ( ) ) ) { return subQueryExpl ; } function . setNextReader ( context ) ; <START_BUG> Explanation functionExplanation = function . explainScore ( doc , subQueryExpl ) ; <END_BUG> return combineFunction . explain ( getBoost ( ) , subQueryExpl , functionExplanation , maxBoost ) ; } } static class CustomBoostFactorScorer extends Scorer { private final float subQueryBoost ; private final Scorer scorer ; private final ScoreFunction function ; private final float maxBoost ; private final CombineFunction scoreCombiner ; private CustomBoostFactorScorer ( FunctionScoreQuery . CustomBoostFactorWeight w , Scorer scorer , ScoreFunction function , float maxBoost , CombineFunction scoreCombiner ) throws IOException { } @ Override public int docID ( ) { } @ Override public int advance ( int target ) throws IOException { } @ Override public int nextDoc ( ) throws IOException { } @ Override public float score ( ) throws IOException { } @ Override public int freq ( ) throws IOException { } @ Override public long cost ( ) { } } public String toString ( String field ) { } public boolean equals ( Object o ) { } public int hashCode ( ) { } }
public class DesktopStarter { private static final int WINDOW_WIDTH = 800 ; private static final int WINDOW_HEIGHT = 480 ; public static void main ( String [ ] args ) { <START_BUG> new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new VeryAngryRobotsGame ( ) , "Very<seq2seq4repair_space>Angry<seq2seq4repair_space>Robots" , DesktopStarter . WINDOW_WIDTH , DesktopStarter . WINDOW_HEIGHT ) ; <END_BUG> } }
public class VertexBufferObject implements VertexData { static final IntBuffer tmpHandle = BufferUtils . newIntBuffer ( 1 ) ; final VertexAttributes attributes ; final FloatBuffer buffer ; int bufferHandle ; final boolean isStatic ; final int usage ; boolean isDirty = false ; boolean isBound = false ; public VertexBufferObject ( boolean isStatic , int numVertices , VertexAttribute ... attributes ) { } public VertexBufferObject ( boolean isStatic , int numVertices , VertexAttributes attributes ) { } private int createBufferObject ( ) { } @ Override public VertexAttributes getAttributes ( ) { } @ Override public int getNumVertices ( ) { } @ Override public int getNumMaxVertices ( ) { } @ Override public FloatBuffer getBuffer ( ) { } private void bufferChanged ( ) { } @ Override public void setVertices ( float [ ] vertices , int offset , int count ) { } @ Override public void updateVertices ( int targetOffset , float [ ] vertices , int sourceOffset , int count ) { isDirty = true ; final int pos = buffer . position ( ) ; buffer . position ( targetOffset ) ; <START_BUG> BufferUtils . copy ( vertices , sourceOffset , buffer , count ) ; <END_BUG> buffer . position ( pos ) ; bufferChanged ( ) ; } @ Override public void bind ( ) { } @ Override public void bind ( ShaderProgram shader ) { } @ Override public void bind ( ShaderProgram shader , int [ ] locations ) { } @ Override public void unbind ( ) { } @ Override public void unbind ( final ShaderProgram shader ) { } @ Override public void unbind ( final ShaderProgram shader , final int [ ] locations ) { } public void invalidate ( ) { } @ Override public void dispose ( ) { } }
public class ParentChildIndexFieldData extends AbstractIndexFieldData < ParentChildAtomicFieldData > implements DocumentTypeListener { private final NavigableSet < BytesRef > parentTypes ; private final CircuitBreakerService breakerService ; private final Object lock = new Object ( ) ; public ParentChildIndexFieldData ( Index index , @ IndexSettings Settings indexSettings , FieldMapper . Names fieldNames , FieldDataType fieldDataType , IndexFieldDataCache cache , MapperService mapperService , CircuitBreakerService breakerService ) { } @ Override public boolean valuesOrdered ( ) { } @ Override public XFieldComparatorSource comparatorSource ( @ Nullable Object missingValue , SortMode sortMode ) { } @ Override public ParentChildAtomicFieldData loadDirect ( AtomicReaderContext context ) throws Exception { } @ Override public void beforeCreate ( DocumentMapper mapper ) { } @ Override public void afterRemove ( DocumentMapper mapper ) { } class TypeBuilder { final PagedBytes bytes ; final MonotonicAppendingLongBuffer termOrdToBytesOffset ; final OrdinalsBuilder builder ; TypeBuilder ( float acceptableTransientOverheadRatio , AtomicReader reader ) throws IOException { } } public static class Builder implements IndexFieldData . Builder { @ Override public IndexFieldData < ? > build ( Index index , @ IndexSettings Settings indexSettings , FieldMapper < ? > mapper , IndexFieldDataCache cache , CircuitBreakerService breakerService , MapperService mapperService , GlobalOrdinalsBuilder globalOrdinalBuilder ) { } } public class ParentChildEstimator implements PerValueEstimator { private final MemoryCircuitBreaker breaker ; private final TermsEnum filteredEnum ; public ParentChildEstimator ( MemoryCircuitBreaker breaker , TermsEnum filteredEnum ) { } @ Override public long bytesPerValue ( BytesRef term ) { } @ Override public TermsEnum beforeLoad ( Terms terms ) throws IOException { <START_BUG> return new RamAccountingTermsEnum ( filteredEnum , breaker , this ) ; <END_BUG> } @ Override public void afterLoad ( TermsEnum termsEnum , long actualUsed ) { } } }
public final class WindowedMean { float [ ] values ; int added_values = 0 ; int last_value ; float mean = 0 ; boolean dirty = true ; public WindowedMean ( int window_size ) { } public boolean hasEnoughData ( ) { } public void clear ( ) { } public void addValue ( float value ) { } public float getMean ( ) { } public float getOldest ( ) { } public float getLatest ( ) { } public float standardDeviation ( ) { if ( ! ( hasEnoughData ( ) ) ) return 0 ; float mean = getMean ( ) ; float sum = 0 ; for ( int i = 0 ; i < ( values . length ) ; i ++ ) { sum += ( ( values [ i ] ) - mean ) * ( ( values [ i ] ) - mean ) ; } <START_BUG> return FastMath . sqrt ( ( sum / ( values . length ) ) ) ; <END_BUG> } }
public class BulkAction extends Action < BulkRequest , BulkResponse , BulkRequestBuilder > { public static final BulkAction INSTANCE = new BulkAction ( ) ; public static final String NAME = "bulk" ; private BulkAction ( ) { } @ Override public BulkResponse newResponse ( ) { } @ Override public BulkRequestBuilder newRequestBuilder ( Client client ) { } @ Override public TransportRequestOptions transportOptions ( Settings settings ) { <START_BUG> return TransportRequestOptions . options ( ) . withType ( Type . fromString ( settings . get ( "action.bulk.transport.type" , LOW . toString ( ) ) ) ) . withCompress ( settings . getAsBoolean ( "action.bulk.compress" , true ) ) ; <END_BUG> } }
public class PercolateRequestBuilder extends BroadcastOperationRequestBuilder < PercolateRequest , PercolateResponse , PercolateRequestBuilder > { private PercolateSourceBuilder sourceBuilder ; public PercolateRequestBuilder ( Client client ) { } public PercolateRequestBuilder setDocumentType ( String type ) { } public PercolateRequestBuilder setRouting ( String routing ) { } public PercolateRequestBuilder setRouting ( String ... routings ) { } public PercolateRequestBuilder setPreference ( String preference ) { } public PercolateRequestBuilder setGetRequest ( GetRequest getRequest ) { } public PercolateRequestBuilder setOnlyCount ( boolean onlyCount ) { } public PercolateRequestBuilder setSize ( int size ) { } public PercolateRequestBuilder setSort ( boolean sort ) { } public PercolateRequestBuilder setScore ( boolean score ) { <START_BUG> sourceBuilder ( ) . setScore ( score ) ; <END_BUG> return this ; } public PercolateRequestBuilder setPercolateDoc ( PercolateSourceBuilder . DocBuilder docBuilder ) { } public PercolateRequestBuilder setPercolateQuery ( QueryBuilder queryBuilder ) { } public PercolateRequestBuilder setPercolateFilter ( FilterBuilder filterBuilder ) { } public PercolateRequestBuilder setHighlightBuilder ( HighlightBuilder highlightBuilder ) { } public PercolateRequestBuilder addFacet ( FacetBuilder facetBuilder ) { } public PercolateRequestBuilder addAggregation ( AggregationBuilder aggregationBuilder ) { } public PercolateRequestBuilder setSource ( PercolateSourceBuilder source ) { } public PercolateRequestBuilder setSource ( Map < String , Object > source ) { } public PercolateRequestBuilder setSource ( Map < String , Object > source , XContentType contentType ) { } public PercolateRequestBuilder setSource ( String source ) { } public PercolateRequestBuilder setSource ( XContentBuilder sourceBuilder ) { } public PercolateRequestBuilder setSource ( BytesReference source ) { } public PercolateRequestBuilder setSource ( BytesReference source , boolean unsafe ) { } public PercolateRequestBuilder setSource ( byte [ ] source ) { } public PercolateRequestBuilder setSource ( byte [ ] source , int offset , int length ) { } public PercolateRequestBuilder setSource ( byte [ ] source , int offset , int length , boolean unsafe ) { } private PercolateSourceBuilder sourceBuilder ( ) { } @ Override public PercolateRequest request ( ) { } @ Override protected void doExecute ( ActionListener < PercolateResponse > listener ) { } }
public static final int M20 = 2 ; public static final int M21 = 6 ; public static final int M22 = 10 ; public static final int M23 = 14 ; public static final int M30 = 3 ; public static final int M31 = 7 ; public static final int M32 = 11 ; public static final int M33 = 15 ; public final float [ ] tmp = new float [ 16 ] ; public final float [ ] val = new float [ 16 ] ; public Matrix4 ( ) { } public Matrix4 ( Matrix4 matrix ) { } public Matrix4 ( float [ ] values ) { } public Matrix4 ( Quaternion quaternion ) { } public Matrix4 set ( Matrix4 matrix ) { } public Matrix4 set ( float [ ] values ) { } public Matrix4 set ( Quaternion quaternion ) { } public Matrix4 set ( float x , float y , float z , float w ) { } public Matrix4 set ( Vector3 xAxis , Vector3 yAxis , Vector3 zAxis , Vector3 pos ) { } public Matrix4 cpy ( ) { } public Matrix4 trn ( Vector3 vector ) { } public Matrix4 trn ( float x , float y , float z ) { } public float [ ] getValues ( ) { } public Matrix4 mul ( Matrix4 matrix ) { } public Matrix4 tra ( ) { } public Matrix4 idt ( ) { } public Matrix4 inv ( ) { } public float det ( ) { } public Matrix4 setToProjection ( float near , float far , float fov , float aspectRatio ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height , float near , float far ) { } public Matrix4 setToOrtho ( float left , float right , float bottom , float top , float near , float far ) { } public Matrix4 setTranslation ( Vector3 vector ) { } public Matrix4 setToTranslation ( Vector3 vector ) { } public Matrix4 setToTranslation ( float x , float y , float z ) { } public Matrix4 setToTranslationAndScaling ( Vector3 translation , Vector3 scaling ) { } public Matrix4 setToTranslationAndScaling ( float translationX , float translationY , float translationZ , float scalingX , float scalingY , float scalingZ ) { } static Quaternion quat = new Quaternion ( ) ; public Matrix4 setToRotation ( Vector3 axis , float angle ) { } public Matrix4 setToRotation ( float axisX , float axisY , float axisZ , float angle ) { } public Matrix4 setToRotation ( final Vector3 v1 , final Vector3 v2 ) { } public Matrix4 setToRotation ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } public Matrix4 setFromEulerAngles ( float yaw , float pitch , float roll ) { } public Matrix4 setToScaling ( Vector3 vector ) { } public Matrix4 setToScaling ( float x , float y , float z ) { } static final Vector3 l_vez = new Vector3 ( ) ; static final Vector3 l_vex = new Vector3 ( ) ; static final Vector3 l_vey = new Vector3 ( ) ; public Matrix4 setToLookAt ( Vector3 direction , Vector3 up ) { } static final Vector3 tmpVec = new Vector3 ( ) ; static final Matrix4 tmpMat = new Matrix4 ( ) ; public Matrix4 setToLookAt ( Vector3 position , Vector3 target , Vector3 up ) { Matrix4 . tmpVec . set ( target ) . sub ( position ) ; setToLookAt ( Matrix4 . tmpVec , up ) ; <START_BUG> this . mul ( Matrix4 . tmpMat . setToTranslation ( position . tmp ( ) . scl ( ( - 1 ) ) ) ) ; <END_BUG> return this ; } static final Vector3 right = new Vector3 ( ) ; static final Vector3 tmpForward = new Vector3 ( ) ; static final Vector3 tmpUp = new Vector3 ( ) ; public Matrix4 setToWorld ( Vector3 position , Vector3 forward , Vector3 up ) { } public String toString ( ) { } public void lerp ( Matrix4 matrix , float alpha ) { } public Matrix4 set ( Matrix3 mat ) { } public Matrix4 scl ( Vector3 scale ) { } public Matrix4 scl ( float x , float y , float z ) { } public Matrix4 scl ( float scale ) { } public void getTranslation ( Vector3 position ) { } public void getRotation ( Quaternion rotation ) { } public Matrix4 toNormalMatrix ( ) { } static void matrix4_mul ( float [ ] mata , float [ ] matb ) { } static float matrix4_det ( float [ ] val ) { } static boolean matrix4_inv ( float [ ] val ) { } static void matrix4_mulVec ( float [ ] mat , float [ ] vec , int offset ) { } static void matrix4_proj ( float [ ] mat , float [ ] vec , int offset ) { } static void matrix4_rot ( float [ ] mat , float [ ] vec , int offset ) { } public static void mul ( float [ ] mata , float [ ] matb ) { } public static void mulVec ( float [ ] mat , float [ ] vec ) { } public static void mulVec ( float [ ] mat , float [ ] vecs , int offset , int numVecs , int stride ) { } public static void prj ( float [ ] mat , float [ ] vec ) { } public static void prj ( float [ ] mat , float [ ] vecs , int offset , int numVecs , int stride ) { }
public class BumperElement extends FieldElement { Body pegBody ; Collection pegBodySet ; float radius ; float cx ; float cy ; float kick ; public void finishCreate ( Map params , World world ) { } @ Override public Collection getBodies ( ) { } @ Override public boolean shouldCallTick ( ) { } Vector2 impulseForBall ( Body ball ) { } @ Override public void handleCollision ( Body ball , Body bodyHit , Field field ) { Vector2 impulse = this . impulseForBall ( ball ) ; if ( impulse != null ) { <START_BUG> ball . applyLinearImpulse ( impulse , ball . getWorldCenter ( ) ) ; <END_BUG> flashForFrames ( 3 ) ; } } @ Override public void draw ( IFieldRenderer renderer ) { } }
public class NodeMappingCreatedAction extends AbstractComponent { private final ThreadPool threadPool ; private final TransportService transportService ; private final ClusterService clusterService ; private final List < NodeMappingCreatedAction . Listener > listeners = new CopyOnWriteArrayList < NodeMappingCreatedAction . Listener > ( ) ; @ Inject public NodeMappingCreatedAction ( Settings settings , ThreadPool threadPool , TransportService transportService , ClusterService clusterService ) { } public void add ( final NodeMappingCreatedAction . Listener listener , TimeValue timeout ) { listeners . add ( listener ) ; threadPool . schedule ( new Runnable ( ) { @ Override public void run ( ) { boolean removed = listeners . remove ( listener ) ; if ( removed ) { listener . onTimeout ( ) ; } } <START_BUG> } , timeout ) ; <END_BUG> } public void remove ( NodeMappingCreatedAction . Listener listener ) { } public void nodeMappingCreated ( final NodeMappingCreatedAction . NodeMappingCreatedResponse response ) throws ElasticSearchException { } private void innerNodeIndexCreated ( NodeMappingCreatedAction . NodeMappingCreatedResponse response ) { } public static interface Listener { void onNodeMappingCreated ( NodeMappingCreatedAction . NodeMappingCreatedResponse response ) { } void onTimeout ( ) { } } private class NodeMappingCreatedTransportHandler extends BaseTransportRequestHandler < NodeMappingCreatedAction . NodeMappingCreatedResponse > { static final String ACTION = "cluster/nodeMappingCreated" ; @ Override public NodeMappingCreatedAction . NodeMappingCreatedResponse newInstance ( ) { } @ Override public void messageReceived ( NodeMappingCreatedAction . NodeMappingCreatedResponse response , TransportChannel channel ) throws Exception { } } public static class NodeMappingCreatedResponse implements Streamable { private String index ; private String type ; private String nodeId ; private NodeMappingCreatedResponse ( ) { } public NodeMappingCreatedResponse ( String index , String type , String nodeId ) { } public String index ( ) { } public String type ( ) { } public String nodeId ( ) { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } } }
public class ElasticsearchAssertions { public static void assertAcked ( AcknowledgedRequestBuilder < ? , ? , ? , ? > builder ) { } public static void assertNoTimeout ( ClusterHealthRequestBuilder requestBuilder ) { } public static void assertNoTimeout ( ClusterHealthResponse response ) { <START_BUG> assertThat ( ( ( "ClusterHealthResponse<seq2seq4repair_space>has<seq2seq4repair_space>timed<seq2seq4repair_space>out<seq2seq4repair_space>-<seq2seq4repair_space>returned:<seq2seq4repair_space>[" + response ) + "]" ) , response . isTimedOut ( ) , is ( false ) ) ; <END_BUG> } public static void assertAcked ( AcknowledgedResponse response ) { } public static void assertAcked ( DeleteIndexRequestBuilder builder ) { } public static void assertAcked ( DeleteIndexResponse response ) { } public static String formatShardStatus ( BroadcastOperationResponse response ) { } public static String formatShardStatus ( SearchResponse response ) { } public static void assertHitCount ( SearchResponse searchResponse , long expectedHitCount ) { } public static void assertSearchHits ( SearchResponse searchResponse , String ... ids ) { } public static void assertOrderedSearchHits ( SearchResponse searchResponse , String ... ids ) { } public static void assertHitCount ( CountResponse countResponse , long expectedHitCount ) { } public static void assertMatchCount ( PercolateResponse percolateResponse , long expectedHitCount ) { } public static void assertExists ( GetResponse response ) { } public static void assertFirstHit ( SearchResponse searchResponse , Matcher < SearchHit > matcher ) { } public static void assertSecondHit ( SearchResponse searchResponse , Matcher < SearchHit > matcher ) { } public static void assertThirdHit ( SearchResponse searchResponse , Matcher < SearchHit > matcher ) { } public static void assertSearchHit ( SearchResponse searchResponse , int number , Matcher < SearchHit > matcher ) { } public static void assertNoFailures ( SearchResponse searchResponse ) { } public static void assertFailures ( SearchResponse searchResponse ) { } public static void assertNoFailures ( BulkResponse response ) { } public static void assertFailures ( SearchRequestBuilder searchRequestBuilder , RestStatus restStatus , Matcher < String > reasonMatcher ) { } public static void assertNoFailures ( BroadcastOperationResponse response ) { } public static void assertAllSuccessful ( BroadcastOperationResponse response ) { } public static void assertAllSuccessful ( SearchResponse response ) { } public static void assertSearchHit ( SearchHit searchHit , Matcher < SearchHit > matcher ) { } public static void assertHighlight ( SearchResponse resp , int hit , String field , int fragment , Matcher < String > matcher ) { } public static void assertHighlight ( SearchResponse resp , int hit , String field , int fragment , int totalFragments , Matcher < String > matcher ) { } public static void assertHighlight ( SearchHit hit , String field , int fragment , Matcher < String > matcher ) { } public static void assertHighlight ( SearchHit hit , String field , int fragment , int totalFragments , Matcher < String > matcher ) { } private static void assertHighlight ( SearchResponse resp , int hit , String field , int fragment , Matcher < Integer > fragmentsMatcher , Matcher < String > matcher ) { } private static void assertHighlight ( SearchHit hit , String field , int fragment , Matcher < Integer > fragmentsMatcher , Matcher < String > matcher ) { } public static void assertNotHighlighted ( SearchResponse resp , int hit , String field ) { } public static void assertSuggestionSize ( Suggest searchSuggest , int entry , int size , String key ) { } public static void assertSuggestion ( Suggest searchSuggest , int entry , int ord , String key , String text ) { } public static void assertSuggestion ( Suggest searchSuggest , int entry , String key , String ... text ) { } public static void assertSuggestion ( Suggest searchSuggest , int entry , String key , int size , String ... text ) { } public static void assertIndexTemplateMissing ( GetIndexTemplatesResponse templatesResponse , String name ) { } public static void assertIndexTemplateExists ( GetIndexTemplatesResponse templatesResponse , String name ) { } public static Matcher < SearchHit > hasId ( final String id ) { } public static Matcher < SearchHit > hasType ( final String type ) { } public static Matcher < SearchHit > hasIndex ( final String index ) { } public static Matcher < SearchHit > hasScore ( final float score ) { } public static < T extends Query > T assertBooleanSubQuery ( Query query , Class < T > subqueryType , int i ) { } public static < E extends Throwable > void assertThrows ( ActionRequestBuilder < ? , ? , ? , ? > builder , Class < E > exceptionClass ) { } public static < E extends Throwable > void assertThrows ( ActionRequestBuilder < ? , ? , ? , ? > builder , Class < E > exceptionClass , String extraInfo ) { } public static < E extends Throwable > void assertThrows ( ActionFuture future , Class < E > exceptionClass ) { } public static < E extends Throwable > void assertThrows ( ActionFuture future , Class < E > exceptionClass , String extraInfo ) { } public static < E extends Throwable > void assertThrows ( ActionRequestBuilder < ? , ? , ? , ? > builder , RestStatus status ) { } public static < E extends Throwable > void assertThrows ( ActionRequestBuilder < ? , ? , ? , ? > builder , RestStatus status , String extraInfo ) { } public static < E extends Throwable > void assertThrows ( ActionFuture future , RestStatus status ) { } public static void assertThrows ( ActionFuture future , RestStatus status , String extraInfo ) { } private static BytesReference serialize ( Version version , Streamable streamable ) throws IOException { } public static void assertVersionSerializable ( Streamable streamable ) { } public static void assertVersionSerializable ( Version version , Streamable streamable ) { } private static Streamable tryCreateNewInstance ( Streamable streamable ) throws IllegalAccessException , InstantiationException , NoSuchMethodException , InvocationTargetException { } public static SearchResponse assertSearchResponse ( SearchRequestBuilder request ) { } public static SearchResponse assertSearchResponse ( SearchResponse response ) { }
public class GistFileFragment extends RoboSherlockFragment implements OnSharedPreferenceChangeListener { @ InjectView ( id . wv_code ) private WebView webView ; @ InjectExtra ( Intents . EXTRA_GIST_ID ) private String gistId ; private GistFile file ; private Gist gist ; @ Inject private GistStore store ; private SourceEditor editor ; private SharedPreferences codePrefs ; private MenuItem wrapItem ; @ Override public void onCreate ( Bundle savedInstanceState ) { } @ Override public void onDestroy ( ) { } public void onDestroyView ( ) { } @ Override public void onCreateOptionsMenu ( Menu optionsMenu , MenuInflater inflater ) { } private void updateWrapItem ( ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } private void loadSource ( ) { } private void showSource ( ) { <START_BUG> editor . setSource ( file . getFilename ( ) , file . getContent ( ) ) ; <END_BUG> } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { } @ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String key ) { } }
public final class Intersector { public static float getLowestPositiveRoot ( float a , float b , float c ) { } private static final Vector3 v0 = new Vector3 ( ) ; private static final Vector3 v1 = new Vector3 ( ) ; private static final Vector3 v2 = new Vector3 ( ) ; public static boolean isPointInTriangle ( Vector3 point , Vector3 t1 , Vector3 t2 , Vector3 t3 ) { } public static boolean intersectSegmentPlane ( Vector3 start , Vector3 end , Plane plane , Vector3 intersection ) { } public static Vector2 triangleCentroid ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , Vector2 centroid ) { centroid . x = ( ( x1 + x2 ) + x3 ) / 3 ; <START_BUG> centroid . y = ( ( x1 + x2 ) + x3 ) / 3 ; <END_BUG> return centroid ; } public static Vector2 quadrilateralCentroid ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 , Vector2 centroid ) { } public static int pointLineSide ( Vector2 linePoint1 , Vector2 linePoint2 , Vector2 point ) { } public static int pointLineSide ( float linePoint1X , float linePoint1Y , float linePoint2X , float linePoint2Y , float pointX , float pointY ) { } public static boolean isPointInPolygon ( List < Vector2 > polygon , Vector2 point ) { } public static float distanceLinePoint ( Vector2 start , Vector2 end , Vector2 point ) { } public static float distanceLinePoint ( float startX , float startY , float endX , float endY , float pointX , float pointY ) { } public static float distanceSegmentPoint ( float startX , float startY , float endX , float endY , float pointX , float pointY ) { } public static float distanceSegmentPoint ( Vector2 start , Vector2 end , Vector2 point ) { } public static Vector2 nearestSegmentPoint ( Vector2 start , Vector2 end , Vector2 point , Vector2 nearest ) { } public static Vector2 nearestSegmentPoint ( float startX , float startY , float endX , float endY , float pointX , float pointY , Vector2 nearest ) { } public static boolean intersectSegmentCircle ( Vector2 start , Vector2 end , Vector2 center , float squareRadius ) { } public static float intersectSegmentCircleDisplace ( Vector2 start , Vector2 end , Vector2 point , float radius , Vector2 displacement ) { } public static boolean intersectRayPlane ( Ray ray , Plane plane , Vector3 intersection ) { } public static float intersectLinePlane ( float x , float y , float z , float x2 , float y2 , float z2 , Plane plane , Vector3 intersection ) { } private static final Plane p = new Plane ( new Vector3 ( ) , 0 ) ; private static final Vector3 i = new Vector3 ( ) ; public static boolean intersectRayTriangle ( Ray ray , Vector3 t1 , Vector3 t2 , Vector3 t3 , Vector3 intersection ) { } private static final Vector3 dir = new Vector3 ( ) ; private static final Vector3 start = new Vector3 ( ) ; public static boolean intersectRaySphere ( Ray ray , Vector3 center , float radius , Vector3 intersection ) { } public static boolean intersectRayBounds ( Ray ray , BoundingBox box , Vector3 intersection ) { } public static boolean intersectRayBoundsFast ( Ray ray , BoundingBox box ) { } static Vector3 best = new Vector3 ( ) ; static Vector3 tmp = new Vector3 ( ) ; static Vector3 tmp1 = new Vector3 ( ) ; static Vector3 tmp2 = new Vector3 ( ) ; static Vector3 tmp3 = new Vector3 ( ) ; static Vector2 v2tmp = new Vector2 ( ) ; public static boolean intersectRayTriangles ( Ray ray , float [ ] triangles , Vector3 intersection ) { } public static boolean intersectRayTriangles ( Ray ray , float [ ] vertices , short [ ] indices , int vertexSize , Vector3 intersection ) { } public static boolean intersectRayTriangles ( Ray ray , List < Vector3 > triangles , Vector3 intersection ) { } public static boolean intersectLines ( Vector2 p1 , Vector2 p2 , Vector2 p3 , Vector2 p4 , Vector2 intersection ) { } public static boolean intersectLines ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 , Vector2 intersection ) { } public static boolean intersectLinePolygon ( Vector2 p1 , Vector2 p2 , Polygon polygon ) { } public static boolean intersectSegmentPolygon ( Vector2 p1 , Vector2 p2 , Polygon polygon ) { } public static boolean intersectSegments ( Vector2 p1 , Vector2 p2 , Vector2 p3 , Vector2 p4 , Vector2 intersection ) { } static float det ( float a , float b , float c , float d ) { } static double detd ( double a , double b , double c , double d ) { } public static boolean overlaps ( Circle c1 , Circle c2 ) { } public static boolean overlaps ( Rectangle r1 , Rectangle r2 ) { } public static boolean overlaps ( Circle c , Rectangle r ) { } public static boolean overlapConvexPolygons ( Polygon p1 , Polygon p2 ) { } public static boolean overlapConvexPolygons ( Polygon p1 , Polygon p2 , Intersector . MinimumTranslationVector mtv ) { } public static boolean overlapConvexPolygons ( float [ ] verts1 , float [ ] verts2 , Intersector . MinimumTranslationVector mtv ) { } public static void splitTriangle ( float [ ] triangle , Plane plane , Intersector . SplitTriangle split ) { } static Vector3 intersection = new Vector3 ( ) ;
public class UAX29URLEmailTokenizerFactory extends AbstractTokenizerFactory { private final int maxTokenLength ; @ Inject public UAX29URLEmailTokenizerFactory ( Index index , @ IndexSettings Settings indexSettings , @ Assisted String name , @ Assisted Settings settings ) { } @ Override public Tokenizer create ( Reader reader ) { <START_BUG> UAX29URLEmailTokenizer tokenizer = new UAX29URLEmailTokenizer ( reader ) ; <END_BUG> tokenizer . setMaxTokenLength ( maxTokenLength ) ; return tokenizer ; } }
public class WidgetGroup extends Group implements Layout { private boolean needsLayout = true ; private boolean fillParent ; private boolean layoutEnabled = true ; public float getMinWidth ( ) { } public float getMinHeight ( ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMaxWidth ( ) { } public float getMaxHeight ( ) { } public void setLayoutEnabled ( boolean enabled ) { } private void setLayoutEnabled ( Group parent , boolean enabled ) { } public void validate ( ) { } public boolean needsLayout ( ) { } public void invalidate ( ) { } public void invalidateHierarchy ( ) { } protected void childrenChanged ( ) { } public void pack ( ) { } public void setFillParent ( boolean fillParent ) { } public void layout ( ) { } public void draw ( SpriteBatch batch , float parentAlpha ) { validate ( ) ; <START_BUG> super . draw ( batch , parentAlpha ) ; <END_BUG> } }
public class Button extends Table implements Disableable { private Button . ButtonStyle style ; boolean isChecked ; boolean isDisabled ; ButtonGroup buttonGroup ; private ClickListener clickListener ; public Button ( Skin skin ) { } public Button ( Skin skin , String styleName ) { } public Button ( Actor child , Skin skin , String styleName ) { } public Button ( Actor child , Button . ButtonStyle style ) { } public Button ( Button . ButtonStyle style ) { } public Button ( ) { } private void initialize ( ) { } public Button ( Drawable up ) { } public Button ( Drawable up , Drawable down ) { } public Button ( Drawable up , Drawable down , Drawable checked ) { } public Button ( Actor child , Skin skin ) { } public void setChecked ( boolean isChecked ) { } public void toggle ( ) { } public boolean isChecked ( ) { } public boolean isPressed ( ) { <START_BUG> return clickListener . isPressed ( ) ; <END_BUG> } public boolean isOver ( ) { } public ClickListener getClickListener ( ) { } public boolean isDisabled ( ) { } public void setDisabled ( boolean isDisabled ) { } public void setStyle ( Button . ButtonStyle style ) { } public Button . ButtonStyle getStyle ( ) { } public void draw ( Batch batch , float parentAlpha ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMinWidth ( ) { } public float getMinHeight ( ) { } public static class ButtonStyle { public Drawable up ; public Drawable down ; public Drawable over ; public Drawable checked ; public Drawable checkedOver ; public Drawable disabled ; public float pressedOffsetX ; public float pressedOffsetY ; public float unpressedOffsetX ; public float unpressedOffsetY ; public ButtonStyle ( ) { } public ButtonStyle ( Drawable up , Drawable down , Drawable checked ) { } public ButtonStyle ( Button . ButtonStyle style ) { } } }
public class TransportAliasesExistAction extends TransportMasterNodeOperationAction < GetAliasesRequest , AliasesExistResponse > { @ Inject public TransportAliasesExistAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } @ Override protected String transportAction ( ) { } @ Override protected String executor ( ) { } @ Override protected GetAliasesRequest newRequest ( ) { } @ Override protected AliasesExistResponse newResponse ( ) { } @ Override protected void masterOperation ( GetAliasesRequest request , ClusterState state , ActionListener < AliasesExistResponse > listener ) throws ElasticSearchException { <START_BUG> String [ ] concreteIndices = state . metaData ( ) . concreteIndices ( request . indices ( ) , request . ignoreIndices ( ) , true ) ; <END_BUG> request . indices ( concreteIndices ) ; boolean result = state . metaData ( ) . hasAliases ( request . aliases ( ) , request . indices ( ) ) ; listener . onResponse ( new AliasesExistResponse ( result ) ) ; } }
public class Label extends Widget { final Label . LabelStyle style ; String label ; final TextBounds bounds = new TextBounds ( ) ; final Vector2 textPos = new Vector2 ( ) ; public Label ( String name , String label , Label . LabelStyle style ) { } @ Override public void layout ( ) { } @ Override protected void draw ( SpriteBatch batch , float parentAlpha ) { final BitmapFont font = style . font ; final Color fontColor = style . fontColor ; if ( invalidated ) layout ( ) ; <START_BUG> font . setColor ( fontColor ) ; <END_BUG> font . drawMultiLine ( batch , label , ( ( x ) + ( textPos . x ) ) , ( ( y ) + ( height ) ) ) ; } @ Override protected boolean touchDown ( float x , float y , int pointer ) { } @ Override protected boolean touchUp ( float x , float y , int pointer ) { } @ Override protected boolean touchDragged ( float x , float y , int pointer ) { } @ Override public Actor hit ( float x , float y ) { } public static class LabelStyle { public BitmapFont font ; public Color fontColor ; public LabelStyle ( BitmapFont font , Color fontColor ) { } } public void setText ( String text ) { } }
public class XContentRestResponse extends AbstractRestResponse { private static final byte [ ] END_JSONP ; private static ThreadLocal < ThreadLocals . CleanableValue < UnicodeUtil . UTF8Result > > prefixCache = new ThreadLocal < ThreadLocals . CleanableValue < UnicodeUtil . UTF8Result > > ( ) { @ Override protected ThreadLocals . CleanableValue < UnicodeUtil . UTF8Result > initialValue ( ) { } } ; private final UTF8Result prefixUtf8Result ; private final Status status ; private final XContentBuilder builder ; public XContentRestResponse ( RestRequest request , Status status ) { } public XContentRestResponse ( RestRequest request , Status status , XContentBuilder builder ) throws IOException { } @ Override public String contentType ( ) { <START_BUG> return "application/json;<seq2seq4repair_space>charset=UTF-8" ; <END_BUG> } @ Override public boolean contentThreadSafe ( ) { } @ Override public byte [ ] content ( ) throws IOException { } @ Override public int contentLength ( ) throws IOException { } @ Override public Status status ( ) { } @ Override public byte [ ] prefixContent ( ) { } @ Override public int prefixContentLength ( ) { } @ Override public byte [ ] suffixContent ( ) { } @ Override public int suffixContentLength ( ) { } private static UTF8Result startJsonp ( RestRequest request ) { } }
class GdxFont implements Font { private static final HAlignment [ ] gdxAlignment = HAlignment . values ( ) ; final GdxRenderer renderer ; final BitmapFont bitmapFont ; private final GdxFont . FontState [ ] fontStates ; private final float yOffset ; public GdxFont ( GdxRenderer renderer , BitmapFont bitmapFont , Map < String , String > params , Collection < FontParameter > condParams ) { } public int drawText ( AnimationState as , int x , int y , CharSequence str ) { } public int drawText ( AnimationState as , int x , int y , CharSequence str , int start , int end ) { } public int drawMultiLineText ( AnimationState as , int x , int y , CharSequence str , int width , de . matthiasmann . twl . HAlignment align ) { } public FontCache cacheText ( FontCache cache , CharSequence str ) { } public FontCache cacheText ( FontCache cache , CharSequence str , int start , int end ) { } public FontCache cacheMultiLineText ( FontCache cache , CharSequence str , int width , de . matthiasmann . twl . HAlignment align ) { } public void destroy ( ) { } public int getBaseLine ( ) { } public int getLineHeight ( ) { } public int getSpaceWidth ( ) { } public int getEM ( ) { } public int getEX ( ) { } public int computeMultiLineTextWidth ( CharSequence str ) { } public int computeTextWidth ( CharSequence str ) { } public int computeTextWidth ( CharSequence str , int start , int end ) { } public int computeVisibleGlpyhs ( CharSequence str , int start , int end , int width ) { <START_BUG> return bitmapFont . computeVisibleGlpyhs ( str , start , end , width ) ; <END_BUG> } GdxFont . FontState evalFontState ( AnimationState animationState ) { } private static class FontState { final StateExpression condition ; final Color color ; final int offsetX ; final int offsetY ; public FontState ( StateExpression condition , Map < String , String > params ) { } } private class GdxFontCache extends BitmapFontCache implements FontCache { public GdxFontCache ( ) { } public void draw ( AnimationState as , int x , int y ) { } public int getWidth ( ) { } public int getHeight ( ) { } public void destroy ( ) { } } }
public class SizeFieldMapper extends IntegerFieldMapper implements RootMapper { public static final String NAME = "_size" ; public static final String CONTENT_TYPE = "_size" ; public static class Defaults extends IntegerFieldMapper . Defaults { public static final String NAME = SizeFieldMapper . CONTENT_TYPE ; public static final boolean ENABLED = false ; } public static class Builder extends Mapper . Builder < SizeFieldMapper . Builder , IntegerFieldMapper > { protected boolean enabled = SizeFieldMapper . Defaults . ENABLED ; protected Store store = STORE ; public Builder ( ) { } public SizeFieldMapper . Builder enabled ( boolean enabled ) { } public SizeFieldMapper . Builder store ( Field . Store store ) { } @ Override public SizeFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private final boolean enabled ; public SizeFieldMapper ( ) { } public SizeFieldMapper ( boolean enabled , Field . Store store ) { } @ Override protected String contentType ( ) { } public boolean enabled ( ) { } @ Override public void validate ( ParseContext context ) throws MapperParsingException { } @ Override public void preParse ( ParseContext context ) throws IOException { } @ Override public void postParse ( ParseContext context ) throws IOException { } @ Override public void parse ( ParseContext context ) throws IOException { } @ Override public boolean includeInObject ( ) { } @ Override protected Fieldable parseCreateField ( ParseContext context ) throws IOException { if ( ! ( enabled ) ) { return null ; } <START_BUG> return new CustomIntegerNumericField ( this , context . sourceLength ( ) ) ; <END_BUG> } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
@ ThreadSafe @ Immutable public class ImmutableSettings implements Settings { private Map < String , String > settings ; private Settings globalSettings ; private transient ClassLoader classLoader ; private ImmutableSettings ( Map < String , String > settings , Settings globalSettings , ClassLoader classLoader ) { } @ Override public Settings getGlobalSettings ( ) { } @ Override public ClassLoader getClassLoader ( ) { } @ Override public Map < String , String > getAsMap ( ) { } @ Override public Settings getComponentSettings ( Class component ) { } @ Override public Settings getComponentSettings ( String prefix , Class component ) { } @ Override public String get ( String setting ) { } @ Override public String get ( String setting , String defaultValue ) { } @ Override public Float getAsFloat ( String setting , Float defaultValue ) { } @ Override public Double getAsDouble ( String setting , Double defaultValue ) { } @ Override public Integer getAsInt ( String setting , Integer defaultValue ) { } @ Override public Long getAsLong ( String setting , Long defaultValue ) { } @ Override public Boolean getAsBoolean ( String setting , Boolean defaultValue ) { String sValue = get ( setting ) ; if ( sValue == null ) { return defaultValue ; } try { <START_BUG> return Boolean . valueOf ( sValue ) ; <END_BUG> } catch ( NumberFormatException e ) { throw new SettingsException ( ( ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>parse<seq2seq4repair_space>boolean<seq2seq4repair_space>setting<seq2seq4repair_space>[" + setting ) + "]<seq2seq4repair_space>with<seq2seq4repair_space>value<seq2seq4repair_space>[" ) + sValue ) + "]" ) , e ) ; } } @ Override public TimeValue getAsTime ( String setting , TimeValue defaultValue ) { } @ Override public SizeValue getAsSize ( String setting , SizeValue defaultValue ) throws SettingsException { } @ SuppressWarnings ( { "unchecked" } ) @ Override public < T > Class < ? extends T > getAsClass ( String setting , Class < ? extends T > defaultClazz ) throws NoClassSettingsException { } @ Override public < T > Class < ? extends T > getAsClass ( String setting , Class < ? extends T > defaultClazz , String prefixPackage , String suffixClassName ) throws NoClassSettingsException { } @ Override public String [ ] getAsArray ( String settingPrefix ) throws SettingsException { } @ Override public Map < String , Settings > getGroups ( String settingPrefix ) throws SettingsException { } private static ClassLoader buildClassLoader ( ) { } public static Settings readSettingsFromStream ( DataInput in ) throws IOException { } public static Settings readSettingsFromStream ( DataInput in , Settings globalSettings ) throws IOException { } public static void writeSettingsToStream ( Settings settings , DataOutput out ) throws IOException { } public static ImmutableSettings . Builder settingsBuilder ( ) { } public static class Builder implements Settings . Builder { public static final Settings EMPTY_SETTINGS = new ImmutableSettings . Builder ( ) . build ( ) ; private final Map < String , String > map = new LinkedHashMap < String , String > ( ) ; private ClassLoader classLoader ; private Settings globalSettings ; private Builder ( ) { } public String get ( String key ) { } public ImmutableSettings . Builder put ( String key , String value ) { } public ImmutableSettings . Builder putClass ( String key , Class clazz ) { } public ImmutableSettings . Builder putBoolean ( String setting , boolean value ) { } public ImmutableSettings . Builder putInt ( String setting , int value ) { } public ImmutableSettings . Builder putLong ( String setting , long value ) { } public ImmutableSettings . Builder putFloat ( String setting , float value ) { } public ImmutableSettings . Builder putDouble ( String setting , double value ) { } public ImmutableSettings . Builder putTime ( String setting , long value , TimeUnit timeUnit ) { } public ImmutableSettings . Builder putSize ( String setting , long value , SizeUnit sizeUnit ) { } public ImmutableSettings . Builder putGroup ( String settingPrefix , String groupName , String [ ] settings , String [ ] values ) throws SettingsException { } public ImmutableSettings . Builder putAll ( Settings settings ) { } public ImmutableSettings . Builder putAll ( Map < String , String > settings ) { } public ImmutableSettings . Builder putAll ( Properties properties ) { } public ImmutableSettings . Builder loadFromSource ( String source ) { } public ImmutableSettings . Builder loadFromUrl ( URL url ) throws SettingsException { } public ImmutableSettings . Builder loadFromStream ( String resourceName , InputStream is ) throws SettingsException { } public ImmutableSettings . Builder loadFromClasspath ( String resourceName ) throws SettingsException { } public ImmutableSettings . Builder classLoader ( ClassLoader classLoader ) { } public ImmutableSettings . Builder globalSettings ( Settings globalSettings ) { } public ImmutableSettings . Builder putProperties ( String prefix , Properties properties ) { } public ImmutableSettings . Builder replacePropertyPlaceholders ( ) { } public Settings build ( ) { } } }
public class FieldsTermsStringFacetExecutor extends FacetExecutor { private final ComparatorType comparatorType ; private final int size ; private final int shardSize ; private final IndexFieldData [ ] indexFieldDatas ; private final SearchScript script ; private final HashedAggregator aggregator ; long missing ; long total ; public FieldsTermsStringFacetExecutor ( FieldMapper [ ] fieldMappers , int size , int shardSize , InternalStringTermsFacet . ComparatorType comparatorType , boolean allTerms , SearchContext context , ImmutableSet < BytesRef > excluded , Pattern pattern , SearchScript script ) { } @ Override public FieldsTermsStringFacetExecutor . Collector collector ( ) { } @ Override public InternalFacet buildFacet ( String facetName ) { } class Collector extends FacetExecutor . Collector { private final HashedAggregator aggregator ; private BytesValues [ ] values ; public Collector ( HashedAggregator aggregator ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { for ( int i = 0 ; i < ( indexFieldDatas . length ) ; i ++ ) { <START_BUG> values [ i ] = indexFieldDatas [ i ] . load ( context ) . getBytesValues ( true ) ; <END_BUG> } if ( ( script ) != null ) { script . setNextReader ( context ) ; } } @ Override public void collect ( int doc ) throws IOException { } @ Override public void postCollection ( ) { } } }
public class AsyncExecutor implements Disposable { private final ExecutorService executor ; public AsyncExecutor ( int maxConcurrent ) { } public < T > AsyncResult < T > submit ( final AsyncTask < T > task ) { } @ Override public void dispose ( ) { executor . shutdown ( ) ; try { executor . awaitTermination ( Long . MAX_VALUE , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { <START_BUG> new GdxRuntimeException ( "Couldn't<seq2seq4repair_space>shutdown<seq2seq4repair_space>loading<seq2seq4repair_space>thread" ) ; <END_BUG> } } }
public class IntFloatMap { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; private static final int EMPTY = 0 ; public int size ; int [ ] keyTable ; float [ ] valueTable ; int capacity ; int stashSize ; float zeroValue ; boolean hasZeroValue ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private IntFloatMap . Entries entries1 ; private IntFloatMap . Entries entries2 ; private IntFloatMap . Values values1 ; private IntFloatMap . Values values2 ; private IntFloatMap . Keys keys1 ; private IntFloatMap . Keys keys2 ; public IntFloatMap ( ) { } public IntFloatMap ( int initialCapacity ) { } public IntFloatMap ( int initialCapacity , float loadFactor ) { } public void put ( int key , float value ) { } public void putAll ( IntFloatMap map ) { } private void putResize ( int key , float value ) { } private void push ( int insertKey , float insertValue , int index1 , int key1 , int index2 , int key2 , int index3 , int key3 ) { } private void putStash ( int key , float value ) { } public float get ( int key , float defaultValue ) { } private float getStash ( int key , float defaultValue ) { } public float getAndIncrement ( int key , float defaultValue , float increment ) { } private float getAndIncrementStash ( int key , float defaultValue , float increment ) { } public float remove ( int key , float defaultValue ) { } float removeStash ( int key , float defaultValue ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean containsValue ( float value ) { } public boolean containsValue ( float value , float epsilon ) { <START_BUG> if ( ( hasZeroValue ) && ( ( Math . abs ( ( ( zeroValue ) - value ) ) ) <= epsilon ) ) <END_BUG> return true ; float [ ] valueTable = this . valueTable ; for ( int i = ( capacity ) + ( stashSize ) ; ( i -- ) > 0 ; ) if ( ( Math . abs ( ( ( valueTable [ i ] ) - value ) ) ) <= epsilon ) return true ; return false ; } public boolean containsKey ( int key ) { } private boolean containsKeyStash ( int key ) { } public int findKey ( float value , int notFound ) { } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public IntFloatMap . Entries entries ( ) { } public IntFloatMap . Values values ( ) { } public IntFloatMap . Keys keys ( ) { } public static class Entry < K > { public int key ; public float value ; public String toString ( ) { } } private static class MapIterator < K > { static final int INDEX_ILLEGAL = - 2 ; static final int INDEX_ZERO = - 1 ; public boolean hasNext ; final IntFloatMap map ; int nextIndex ; int currentIndex ; boolean valid = true ; public MapIterator ( IntFloatMap map ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { } } public static class Entries extends IntFloatMap . MapIterator implements Iterable < IntFloatMap . Entry > , Iterator < IntFloatMap . Entry > { private IntFloatMap . Entry entry = new IntFloatMap . Entry ( ) ; public Entries ( IntFloatMap map ) { } public IntFloatMap . Entry next ( ) { } public boolean hasNext ( ) { } public Iterator < IntFloatMap . Entry > iterator ( ) { } } public static class Values extends IntFloatMap . MapIterator < Object > { public Values ( IntFloatMap map ) { } public boolean hasNext ( ) { } public float next ( ) { } public FloatArray toArray ( ) { } } public static class Keys extends IntFloatMap . MapIterator { public Keys ( IntFloatMap map ) { } public boolean hasNext ( ) { } public int next ( ) { } public IntArray toArray ( ) { } } }
public class ParentChildAtomicFieldData extends AbstractAtomicParentChildFieldData { private final ImmutableOpenMap < String , AtomicOrdinalsFieldData > typeToIds ; private final long memorySizeInBytes ; public ParentChildAtomicFieldData ( ImmutableOpenMap < String , AtomicOrdinalsFieldData > typeToIds ) { } @ Override public long ramBytesUsed ( ) { } @ Override public Set < String > types ( ) { } @ Override public SortedDocValues getOrdinalsValues ( String type ) { AtomicOrdinalsFieldData atomicFieldData = typeToIds . get ( type ) ; if ( atomicFieldData != null ) { <START_BUG> return MIN . select ( atomicFieldData . getOrdinalsValues ( ) , ( - 1 ) ) ; <END_BUG> } else { return DocValues . emptySorted ( ) ; } } public AtomicOrdinalsFieldData getAtomicFieldData ( String type ) { } @ Override public void close ( ) { } }
public class TwoInstanceUnbalancedShardsEmbeddedSearchTests extends AbstractNodesTests { private IndicesService indicesService ; private ClusterService clusterService ; private Map < String , SearchService > nodeToSearchService ; private SearchPhaseController searchPhaseController ; @ BeforeClass public void createNodeAndInitWithData ( ) throws Exception { } @ AfterClass public void closeNodes ( ) { } @ Test public void testDfsQueryFetch ( ) throws Exception { } @ Test public void testDfsQueryFetchWithSort ( ) throws Exception { } @ Test public void testQueryFetchInOneGo ( ) { } @ Test public void testSimpleFacets ( ) { } @ Test public void testSimpleFacetsTwice ( ) { } private static InternalSearchRequest searchRequest ( ShardRouting shardRouting , SearchSourceBuilder builder ) { <START_BUG> return new InternalSearchRequest ( shardRouting ) . source ( builder . buildAsBytes ( ) ) ; <END_BUG> } private void index ( Client client , String id , String nameValue , int age ) { } private String source ( String id , String nameValue , int age ) { } public static class UnevenOperationRoutingModule extends AbstractModule { @ Override protected void configure ( ) { } } public static class UnevenOperationRoutingStrategy extends PlainOperationRouting { @ Inject public UnevenOperationRoutingStrategy ( Index index , @ IndexSettings Settings indexSettings ) { } @ Override protected int hash ( String type , String id ) { } } }
public class ViewPager extends android . support . v4 . view . ViewPager { public ViewPager ( final Context context ) { } public ViewPager ( final Context context , final AttributeSet attrs ) { } public boolean setItem ( final int item ) { } public boolean setItem ( final int item , final OnPageChangeListener listener ) { final boolean changed = setItem ( item ) ; <START_BUG> if ( changed ) <END_BUG> listener . onPageSelected ( item ) ; return changed ; } public void scheduleSetItem ( final int item , final OnPageChangeListener listener ) { } public void scheduleSetItem ( final int item ) { } @ Override protected boolean canScroll ( final View v , final boolean checkV , final int dx , final int x , final int y ) { } }
public class ContactProcessedListenerByValue { private long swigCPtr ; protected boolean swigCMemOwn ; protected ContactProcessedListenerByValue ( long cPtr , boolean cMemoryOwn ) { } public static long getCPtr ( ContactProcessedListenerByValue obj ) { } protected void finalize ( ) { } public synchronized void delete ( ) { } protected void swigDirectorDisconnect ( ) { } public void swigReleaseOwnership ( ) { } public void swigTakeOwnership ( ) { } public void onContactProcessed ( btManifoldPoint cp , int userValue0 , boolean match0 , int userValue1 , boolean match1 ) { <START_BUG> gdxBulletJNI . ContactProcessedListenerByValue_onContactProcessed ( swigCPtr , this , btManifoldPoint . getCPtr ( cp ) , cp , userValue0 , match0 , userValue1 , match1 ) ; <END_BUG> } public ContactProcessedListenerByValue ( ) { } }
public class SourceFieldVisitor extends BaseFieldVisitor { private BytesRef source ; @ Override public Status needsField ( FieldInfo fieldInfo ) throws IOException { } @ Override public void binaryField ( FieldInfo fieldInfo , byte [ ] value ) throws IOException { } @ Override public Document createDocument ( ) { Document document = new Document ( ) ; <START_BUG> document . add ( new org . apache . lucene . document . StoredField ( "_source" , source ) ) ; <END_BUG> return document ; } public BytesRef source ( ) { } @ Override public String toString ( ) { } }
public class Lucene { public static final Version VERSION = Version . LUCENE_44 ; public static final Version ANALYZER_VERSION = Lucene . VERSION ; public static final Version QUERYPARSER_VERSION = Lucene . VERSION ; public static final NamedAnalyzer STANDARD_ANALYZER = new NamedAnalyzer ( "_standard" , AnalyzerScope . GLOBAL , new org . apache . lucene . analysis . standard . StandardAnalyzer ( Lucene . ANALYZER_VERSION ) ) ; public static final NamedAnalyzer KEYWORD_ANALYZER = new NamedAnalyzer ( "_keyword" , AnalyzerScope . GLOBAL , new KeywordAnalyzer ( ) ) ; public static final int NO_DOC = - 1 ; public static ScoreDoc [ ] EMPTY_SCORE_DOCS = new ScoreDoc [ 0 ] ; @ SuppressWarnings ( "deprecation" ) public static Version parseVersion ( @ Nullable String version , Version defaultVersion , ESLogger logger ) { } public static SegmentInfos readSegmentInfos ( Directory directory ) throws IOException { } public static long count ( IndexSearcher searcher , Query query ) throws IOException { } public static boolean safeClose ( IndexWriter writer ) { if ( writer == null ) { return true ; } try { writer . close ( ) ; return true ; <START_BUG> } catch ( IOException e ) { <END_BUG> return false ; } } public static TopDocs readTopDocs ( StreamInput in ) throws IOException { } public static void writeTopDocs ( StreamOutput out , TopDocs topDocs , int from ) throws IOException { } public static Type readSortType ( StreamInput in ) throws IOException { } public static void writeSortType ( StreamOutput out , SortField . Type sortType ) throws IOException { } public static Explanation readExplanation ( StreamInput in ) throws IOException { } public static void writeExplanation ( StreamOutput out , Explanation explanation ) throws IOException { } public static class ExistsCollector extends Collector { private boolean exists ; public void reset ( ) { } public boolean exists ( ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { } @ Override public boolean acceptsDocsOutOfOrder ( ) { } } private Lucene ( ) { } public static final boolean indexExists ( final Directory directory ) throws IOException { } }
public class ActionTest extends GdxTest implements OnActionCompleted { @ Override public boolean needsGL20 ( ) { } Stage stage ; @ Override public void create ( ) { } @ Override public void render ( ) { gl . glClear ( GL_COLOR_BUFFER_BIT ) ; stage . act ( graphics . getDeltaTime ( ) ) ; <START_BUG> stage . render ( ) ; <END_BUG> } @ Override public void completed ( Action action ) { } }
public class ScriptTermsStringFieldFacetExecutor extends FacetExecutor { private final ComparatorType comparatorType ; private final int size ; private final SearchScript script ; private final Matcher matcher ; private final ImmutableSet < BytesRef > excluded ; private final int numberOfShards ; final TObjectIntHashMap < BytesRef > facets ; long missing ; long total ; public ScriptTermsStringFieldFacetExecutor ( int size , InternalStringTermsFacet . ComparatorType comparatorType , SearchContext context , ImmutableSet < BytesRef > excluded , Pattern pattern , String scriptLang , String script , Map < String , Object > params ) { } @ Override public ScriptTermsStringFieldFacetExecutor . Collector collector ( ) { } @ Override public InternalFacet buildFacet ( String facetName ) { } class Collector extends FacetExecutor . Collector { private final Matcher matcher ; private final ImmutableSet < BytesRef > excluded ; private final SearchScript script ; private final TObjectIntHashMap < BytesRef > facets ; long missing ; long total ; Collector ( Matcher matcher , ImmutableSet < BytesRef > excluded , SearchScript script , TObjectIntHashMap < BytesRef > facets ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void postCollection ( ) { ScriptTermsStringFieldFacetExecutor . this . missing = missing ; <START_BUG> ScriptTermsStringFieldFacetExecutor . this . total = missing ; <END_BUG> } private boolean match ( String value ) { } } }
public class GetFieldMappingsResponse extends ActionResponse implements ToXContent { private ImmutableMap < String , ImmutableMap < String , ImmutableMap < String , GetFieldMappingsResponse . FieldMappingMetaData > > > mappings = ImmutableMap . of ( ) ; GetFieldMappingsResponse ( ImmutableMap < String , ImmutableMap < String , ImmutableMap < String , GetFieldMappingsResponse . FieldMappingMetaData > > > mappings ) { } GetFieldMappingsResponse ( ) { } public ImmutableMap < String , ImmutableMap < String , ImmutableMap < String , GetFieldMappingsResponse . FieldMappingMetaData > > > mappings ( ) { } public GetFieldMappingsResponse . FieldMappingMetaData fieldMappings ( String index , String type , String field ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } public static class FieldMappingMetaData implements ToXContent { public static final GetFieldMappingsResponse . FieldMappingMetaData NULL = new GetFieldMappingsResponse . FieldMappingMetaData ( "" , BytesArray . EMPTY ) ; private String fullName ; private BytesReference source ; public FieldMappingMetaData ( String fullName , BytesReference source ) { } public String fullName ( ) { } public Map < String , Object > sourceAsMap ( ) { <START_BUG> return XContentHelper . convertToMap ( source . array ( ) , source . arrayOffset ( ) , source . length ( ) , true ) . v2 ( ) ; <END_BUG> } public boolean isNull ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public class TransportValidateAction extends TransportBroadcastOperationAction < ValidateRequest , ValidateResponse , ShardValidateRequest , ShardValidateResponse > { private final IndicesService indicesService ; @ Inject public TransportValidateAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected ValidateRequest newRequest ( ) { } @ Override protected ShardValidateRequest newShardRequest ( ) { } @ Override protected ShardValidateRequest newShardRequest ( ShardRouting shard , ValidateRequest request ) { } @ Override protected ShardValidateResponse newShardResponse ( ) { } @ Override protected GroupShardsIterator shards ( ValidateRequest request , String [ ] concreteIndices , ClusterState clusterState ) { Map < String , Set < String > > routingMap = clusterState . metaData ( ) . resolveSearchRouting ( "0" , request . indices ( ) ) ; <START_BUG> return clusterService . operationRouting ( ) . searchShards ( clusterState , request . indices ( ) , concreteIndices , null , routingMap , null ) ; <END_BUG> } @ Override protected void checkBlock ( ValidateRequest request , String [ ] concreteIndices , ClusterState state ) { } @ Override protected ValidateResponse newResponse ( ValidateRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardValidateResponse shardOperation ( ShardValidateRequest request ) throws ElasticSearchException { } }
public class SingleInstanceEmbeddedSearchTests extends AbstractNodesTests { private SearchService searchService ; private SearchPhaseController searchPhaseController ; @ BeforeClass public void createNodeAndInitWithData ( ) throws Exception { } @ AfterClass public void closeNode ( ) { } @ Test public void testDirectDfs ( ) throws Exception { } @ Test public void testDirectQuery ( ) throws Exception { } @ Test public void testDirectFetch ( ) throws Exception { } @ Test public void testQueryThenFetch ( ) throws Exception { } @ Test public void testQueryAndFetch ( ) throws Exception { } @ Test public void testDfsQueryThenFetch ( ) throws Exception { } @ Test public void testSimpleQueryFacetsNoExecutionType ( ) throws Exception { } @ Test public void testSimpleQueryFacetsQueryExecutionCollect ( ) throws Exception { } @ Test public void testSimpleQueryFacetsQueryExecutionIdset ( ) throws Exception { } @ Test public void testQueryFetchKeepAliveTimeout ( ) throws Exception { } private InternalSearchRequest searchRequest ( SearchSourceBuilder builder ) { <START_BUG> return new InternalSearchRequest ( "test" , 0 , builder . buildAsBytes ( ) ) ; <END_BUG> } private void index ( Client client , String id , String nameValue , int age ) { } private String source ( String id , String nameValue , int age ) { } }
public class RestSnapshotsStatusAction extends BaseRestHandler { @ Inject public RestSnapshotsStatusAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { String repository = request . param ( "repository" ) ; String [ ] snapshots = request . paramAsStringArray ( "snapshot" , EMPTY_ARRAY ) ; if ( ( ( snapshots . length ) == 1 ) && ( "_all" . equalsIgnoreCase ( snapshots [ 0 ] ) ) ) { snapshots = Strings . EMPTY_ARRAY ; } SnapshotsStatusRequest snapshotsStatusResponse = snapshotsStatusRequest ( repository ) . snapshots ( snapshots ) ; snapshotsStatusResponse . masterNodeTimeout ( request . paramAsTime ( "master_timeout" , snapshotsStatusResponse . masterNodeTimeout ( ) ) ) ; client . admin ( ) . cluster ( ) . snapshotsStatus ( snapshotsStatusResponse , new AbstractRestResponseActionListener < SnapshotsStatusResponse > ( request , channel , logger ) { @ Override public void onResponse ( SnapshotsStatusResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; <START_BUG> channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <END_BUG> } catch ( IOException e ) { onFailure ( e ) ; } } } ) ; } }
public class IOSApplication extends UIApplicationDelegate implements Application { UIApplication uiApp ; UIWindow uiWindow ; ApplicationListener listener ; IOSApplicationConfiguration config ; IOSGraphics graphics ; IOSAudio audio ; IOSFiles files ; IOSInput input ; IOSNet net ; int logLevel = Application . LOG_DEBUG ; boolean firstResume ; public IOSApplication ( ApplicationListener listener , IOSApplicationConfiguration config ) { } @ Override public boolean FinishedLaunching ( UIApplication uiApp , NSDictionary options ) { } RectangleF getBounds ( UIViewController viewController ) { } @ Override public void OnActivated ( UIApplication uiApp ) { } @ Override public void OnResignActivation ( UIApplication uiApp ) { } @ Override public void WillTerminate ( UIApplication uiApp ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Input getInput ( ) { } @ Override public Files getFiles ( ) { } @ Override public Net getNet ( ) { } @ Override public void log ( String tag , String message ) { } @ Override public void log ( String tag , String message , Exception exception ) { } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } @ Override public Preferences getPreferences ( String name ) { <START_BUG> return null ; <END_BUG> } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void exit ( ) { } @ Override public Clipboard getClipboard ( ) { } }
public class ManagedTest implements RenderListener { MeshRenderer mesh ; Texture texture ; @ Override public void surfaceCreated ( Application app ) { } @ Override public void render ( Application app ) { GL10 gl = app . getGraphics ( ) . getGL10 ( ) ; gl . glViewport ( 0 , 0 , app . getGraphics ( ) . getWidth ( ) , app . getGraphics ( ) . getHeight ( ) ) ; gl . glClearColor ( 0.7F , 0.7F , 0.7F , 1 ) ; gl . glClear ( GL_COLOR_BUFFER_BIT ) ; gl . glEnable ( GL_TEXTURE_2D ) ; texture . bind ( ) ; <START_BUG> mesh . render ( GL_TRIANGLE_FAN , 0 , 4 ) ; <END_BUG> } @ Override public void dispose ( Application app ) { } @ Override public void surfaceChanged ( Application app , int width , int height ) { } public static void main ( String [ ] argv ) { } }
public class btCollisionDispatcher extends btDispatcher { private long swigCPtr ; protected btCollisionDispatcher ( final String className , long cPtr , boolean cMemoryOwn ) { } public btCollisionDispatcher ( long cPtr , boolean cMemoryOwn ) { } @ Override protected void reset ( long cPtr , boolean cMemoryOwn ) { } public static long getCPtr ( btCollisionDispatcher obj ) { } @ Override protected void finalize ( ) throws Throwable { } @ Override protected synchronized void delete ( ) { } public int getDispatcherFlags ( ) { } public void setDispatcherFlags ( int flags ) { } public void registerCollisionCreateFunc ( int proxyType0 , int proxyType1 , btCollisionAlgorithmCreateFunc createFunc ) { } public btPersistentManifold getManifoldByIndexInternal ( int index ) { } public btCollisionDispatcher ( btCollisionConfiguration collisionConfiguration ) { } public btCollisionAlgorithm findAlgorithm ( btCollisionObjectWrapper body0Wrap , btCollisionObjectWrapper body1Wrap , btPersistentManifold sharedManifold ) { } public btCollisionAlgorithm findAlgorithm ( btCollisionObjectWrapper body0Wrap , btCollisionObjectWrapper body1Wrap ) { } public void setNearCallback ( SWIGTYPE_p_f_r_btBroadphasePair_r_btCollisionDispatcher_r_q_const__btDispatcherInfo__void nearCallback ) { } public SWIGTYPE_p_f_r_btBroadphasePair_r_btCollisionDispatcher_r_q_const__btDispatcherInfo__void getNearCallback ( ) { } public static void defaultNearCallback ( btBroadphasePair collisionPair , btCollisionDispatcher dispatcher , btDispatcherInfo dispatchInfo ) { <START_BUG> CollisionJNI . btCollisionDispatcher_defaultNearCallback ( btBroadphasePair . getCPtr ( collisionPair ) , collisionPair , btCollisionDispatcher . getCPtr ( dispatcher ) , dispatcher , btDispatcherInfo . getCPtr ( dispatchInfo ) , dispatchInfo ) ; <END_BUG> } public btCollisionConfiguration getCollisionConfiguration ( ) { } public void setCollisionConfiguration ( btCollisionConfiguration config ) { } public btPoolAllocator getInternalManifoldPool ( ) { } public static final class DispatcherFlags { public static final int CD_STATIC_STATIC_REPORTED = 1 ; public static final int CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD = 2 ; public static final int CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION = 4 ; } }
public abstract class ClickListener extends PressedListener { public void touchUp ( ActorEvent event , float x , float y , int pointer , int button ) { <START_BUG> if ( ( pointer == 0 ) && ( isOver ( event . getContextActor ( ) , x , y ) ) ) <END_BUG> clicked ( event , x , y ) ; super . touchUp ( event , x , y , pointer , button ) ; } public abstract void clicked ( ActorEvent event , float x , float y ) { } }
public abstract class TransportShardSingleOperationAction < Request extends SingleShardOperationRequest , Response extends ActionResponse > extends TransportAction < Request , Response > { protected final ClusterService clusterService ; protected final TransportService transportService ; final String transportShardAction ; final String executor ; protected TransportShardSingleOperationAction ( Settings settings , String actionName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , ActionFilters actionFilters ) { } @ Override protected void doExecute ( Request request , ActionListener < Response > listener ) { } protected abstract String executor ( ) { } protected abstract Response shardOperation ( Request request , int shardId ) throws ElasticsearchException { } protected abstract Request newRequest ( ) { } protected abstract Response newResponse ( ) { } protected abstract ClusterBlockException checkGlobalBlock ( ClusterState state , Request request ) { } protected abstract ClusterBlockException checkRequestBlock ( ClusterState state , Request request ) { } protected void resolveRequest ( ClusterState state , Request request ) { <START_BUG> request . index ( state . metaData ( ) . concreteSingleIndex ( request . index ( ) ) ) ; <END_BUG> } protected abstract ShardIterator shards ( ClusterState state , Request request ) throws ElasticsearchException { } class AsyncSingleAction { private final ActionListener < Response > listener ; private final ShardIterator shardIt ; private final Request request ; private final DiscoveryNodes nodes ; private volatile Throwable lastFailure ; private AsyncSingleAction ( Request request , ActionListener < Response > listener ) { } public void start ( ) { } private void onFailure ( ShardRouting shardRouting , Throwable e ) { } private void perform ( @ Nullable final Throwable currentFailure ) { } } private class TransportHandler extends BaseTransportRequestHandler < Request > { @ Override public Request newInstance ( ) { } @ Override public String executor ( ) { } @ Override public void messageReceived ( Request request , final TransportChannel channel ) throws Exception { } } private class ShardTransportHandler extends BaseTransportRequestHandler < TransportShardSingleOperationAction < Request , Response > . ShardSingleOperationRequest > { @ Override public TransportShardSingleOperationAction < Request , Response > . ShardSingleOperationRequest newInstance ( ) { } @ Override public String executor ( ) { } @ Override public void messageReceived ( final TransportShardSingleOperationAction < Request , Response > . ShardSingleOperationRequest request , final TransportChannel channel ) throws Exception { } } class ShardSingleOperationRequest extends TransportRequest { private Request request ; private int shardId ; ShardSingleOperationRequest ( ) { } public ShardSingleOperationRequest ( Request request , int shardId ) { } public Request request ( ) { } public int shardId ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class LongArray { public long [ ] items ; public int size ; public boolean ordered ; public LongArray ( ) { } public LongArray ( int capacity ) { } public LongArray ( boolean ordered , int capacity ) { } public LongArray ( LongArray array ) { } public LongArray ( long [ ] array ) { } public LongArray ( boolean ordered , long [ ] array , int startIndex , int count ) { } public void add ( long value ) { } public void addAll ( LongArray array ) { } public void addAll ( LongArray array , int offset , int length ) { } public void addAll ( long [ ] array ) { } public void addAll ( long [ ] array , int offset , int length ) { long [ ] items = this . items ; <START_BUG> int sizeNeeded = ( size ) + length ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public long get ( int index ) { } public void set ( int index , long value ) { } public void insert ( int index , long value ) { } public void swap ( int first , int second ) { } public boolean contains ( long value ) { } public int indexOf ( long value ) { } public int lastIndexOf ( char value ) { } public boolean removeValue ( long value ) { } public long removeIndex ( int index ) { } public boolean removeAll ( LongArray array ) { } public long pop ( ) { } public long peek ( ) { } public long first ( ) { } public void clear ( ) { } public void shrink ( ) { } public long [ ] ensureCapacity ( int additionalCapacity ) { } protected long [ ] resize ( int newSize ) { } public void sort ( ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public long random ( ) { } public long [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class IndexNameFacetCollector extends AbstractFacetCollector { private final String indexName ; private final ComparatorType comparatorType ; private final int size ; private int count = 0 ; public IndexNameFacetCollector ( String facetName , String indexName , TermsFacet . ComparatorType comparatorType , int size ) { } @ Override protected void doSetNextReader ( IndexReader reader , int docBase ) throws IOException { } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override public Facet facet ( ) { <START_BUG> return new InternalStringTermsFacet ( facetName , comparatorType , size , Sets . newHashSet ( new InternalStringTermsFacet . StringEntry ( indexName , count ) ) , 0 ) ; <END_BUG> } }
public class Analysis { public static Version parseAnalysisVersion ( @ IndexSettings Settings indexSettings , Settings settings , ESLogger logger ) { String sVersion = settings . get ( "version" ) ; if ( sVersion != null ) { return Lucene . parseVersion ( sVersion , ANALYZER_VERSION , logger ) ; } sVersion = indexSettings . get ( "index.analysis.version" ) ; if ( sVersion != null ) { return Lucene . parseVersion ( sVersion , ANALYZER_VERSION , logger ) ; } <START_BUG> return indexSettings . getAsVersion ( SETTING_VERSION_CREATED , CURRENT ) . luceneVersion ; <END_BUG> } public static boolean isNoStopwords ( Settings settings ) { } public static CharArraySet parseStemExclusion ( Settings settings , CharArraySet defaultStemExclusion , Version version ) { } public static final ImmutableMap < String , Set < ? > > namedStopWords = MapBuilder . < String , Set < ? > > newMapBuilder ( ) . put ( "_arabic_" , ArabicAnalyzer . getDefaultStopSet ( ) ) . put ( "_armenian_" , ArmenianAnalyzer . getDefaultStopSet ( ) ) . put ( "_basque_" , BasqueAnalyzer . getDefaultStopSet ( ) ) . put ( "_brazilian_" , BrazilianAnalyzer . getDefaultStopSet ( ) ) . put ( "_bulgarian_" , BulgarianAnalyzer . getDefaultStopSet ( ) ) . put ( "_catalan_" , CatalanAnalyzer . getDefaultStopSet ( ) ) . put ( "_czech_" , CzechAnalyzer . getDefaultStopSet ( ) ) . put ( "_danish_" , DanishAnalyzer . getDefaultStopSet ( ) ) . put ( "_dutch_" , DutchAnalyzer . getDefaultStopSet ( ) ) . put ( "_english_" , EnglishAnalyzer . getDefaultStopSet ( ) ) . put ( "_finnish_" , FinnishAnalyzer . getDefaultStopSet ( ) ) . put ( "_french_" , FrenchAnalyzer . getDefaultStopSet ( ) ) . put ( "_galician_" , GalicianAnalyzer . getDefaultStopSet ( ) ) . put ( "_german_" , GermanAnalyzer . getDefaultStopSet ( ) ) . put ( "_greek_" , GreekAnalyzer . getDefaultStopSet ( ) ) . put ( "_hindi_" , HindiAnalyzer . getDefaultStopSet ( ) ) . put ( "_hungarian_" , HungarianAnalyzer . getDefaultStopSet ( ) ) . put ( "_indonesian_" , IndonesianAnalyzer . getDefaultStopSet ( ) ) . put ( "_irish_" , IrishAnalyzer . getDefaultStopSet ( ) ) . put ( "_italian_" , ItalianAnalyzer . getDefaultStopSet ( ) ) . put ( "_latvian_" , LatvianAnalyzer . getDefaultStopSet ( ) ) . put ( "_norwegian_" , NorwegianAnalyzer . getDefaultStopSet ( ) ) . put ( "_persian_" , PersianAnalyzer . getDefaultStopSet ( ) ) . put ( "_portuguese_" , PortugueseAnalyzer . getDefaultStopSet ( ) ) . put ( "_romanian_" , RomanianAnalyzer . getDefaultStopSet ( ) ) . put ( "_russian_" , RussianAnalyzer . getDefaultStopSet ( ) ) . put ( "_sorani_" , SoraniAnalyzer . getDefaultStopSet ( ) ) . put ( "_spanish_" , SpanishAnalyzer . getDefaultStopSet ( ) ) . put ( "_swedish_" , SwedishAnalyzer . getDefaultStopSet ( ) ) . put ( "_thai_" , ThaiAnalyzer . getDefaultStopSet ( ) ) . put ( "_turkish_" , TurkishAnalyzer . getDefaultStopSet ( ) ) . immutableMap ( ) ; public static CharArraySet parseWords ( Environment env , Settings settings , String name , CharArraySet defaultWords , ImmutableMap < String , Set < ? > > namedWords , Version version , boolean ignoreCase ) { } public static CharArraySet parseCommonWords ( Environment env , Settings settings , CharArraySet defaultCommonWords , Version version , boolean ignoreCase ) { } public static CharArraySet parseArticles ( Environment env , Settings settings , Version version ) { } public static CharArraySet parseStopWords ( Environment env , Settings settings , CharArraySet defaultStopWords , Version version ) { } public static CharArraySet parseStopWords ( Environment env , Settings settings , CharArraySet defaultStopWords , Version version , boolean ignoreCase ) { } private static CharArraySet resolveNamedWords ( Collection < String > words , ImmutableMap < String , Set < ? > > namedWords , Version version , boolean ignoreCase ) { } public static CharArraySet getWordSet ( Environment env , Settings settings , String settingsPrefix , Version version ) { } public static List < String > getWordList ( Environment env , Settings settings , String settingPrefix ) { } public static List < String > loadWordList ( Reader reader , String comment ) throws IOException { } public static Reader getReaderFromFile ( Environment env , Settings settings , String settingPrefix ) { } public static boolean isCharacterTokenStream ( TokenStream tokenStream ) { } public static boolean generatesCharacterTokenStream ( Analyzer analyzer , String fieldName ) throws IOException { } }
public class NettyHttpRequest extends AbstractRestRequest implements HttpRequest { private final HttpRequest request ; private final Map < String , String > params ; private final String rawPath ; private final BytesReference content ; public NettyHttpRequest ( org . jboss . netty . handler . codec . http . HttpRequest request ) { } @ Override public Method method ( ) { } @ Override public String uri ( ) { } @ Override public String rawPath ( ) { } @ Override public Map < String , String > params ( ) { } @ Override public boolean hasContent ( ) { } @ Override public boolean contentUnsafe ( ) { } @ Override public BytesReference content ( ) { } @ Override public String header ( String name ) { <START_BUG> return request . getHeader ( name ) ; <END_BUG> } @ Override public boolean hasParam ( String key ) { } @ Override public String param ( String key ) { } @ Override public String param ( String key , String defaultValue ) { } }
public class FloatFieldMapper extends NumberFieldMapper < Float > { public static final String CONTENT_TYPE = "float" ; public static class Defaults extends NumberFieldMapper . Defaults { public static final FieldType FLOAT_FIELD_TYPE = new FieldType ( NumberFieldMapper . Defaults . NUMBER_FIELD_TYPE ) ; public static final Float NULL_VALUE = null ; } public static class Builder extends NumberFieldMapper . Builder < FloatFieldMapper . Builder , FloatFieldMapper > { protected Float nullValue = FloatFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public FloatFieldMapper . Builder nullValue ( float nullValue ) { } @ Override public FloatFieldMapper build ( BuilderContext context ) { <START_BUG> fieldType . setOmitNorms ( ( ( fieldType . omitNorms ( ) ) || ( ( boost ) != 1.0F ) ) ) ; <END_BUG> FloatFieldMapper fieldMapper = new FloatFieldMapper ( buildNames ( context ) , precisionStep , fuzzyFactor , boost , fieldType , nullValue , ignoreMalformed ( context ) ) ; fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private Float nullValue ; private String nullValueAsString ; protected FloatFieldMapper ( Names names , int precisionStep , String fuzzyFactor , float boost , FieldType fieldType , Float nullValue , Explicit < Boolean > ignoreMalformed ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Float value ( Field field ) { } @ Override public Float valueFromString ( String value ) { } @ Override public String indexedValue ( String value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query fuzzyQuery ( String value , double minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query fieldQuery ( String value , @ Nullable QueryParseContext context ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter fieldFilter ( String value , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( FieldDataCache fieldDataCache , String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected boolean customBoost ( ) { } @ Override protected Field innerParseCreateField ( ParseContext context ) throws IOException { } @ Override public FieldDataType fieldDataType ( ) { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } public static class CustomFloatNumericField extends CustomNumericField { private final float number ; private final NumberFieldMapper mapper ; public CustomFloatNumericField ( NumberFieldMapper mapper , float number , FieldType fieldType ) { } @ Override public TokenStream tokenStream ( Analyzer analyzer ) throws IOException { } @ Override public String numericAsString ( ) { } } }
public class Circle implements Serializable { public float x ; public float y ; public float radius ; public Circle ( ) { } public Circle ( float x , float y , float radius ) { } public Circle ( Vector2 position , float radius ) { } public void set ( float x , float y , float radius ) { } public boolean contains ( float x , float y ) { } public boolean contains ( Vector2 point ) { } public boolean overlaps ( Circle c ) { float dx = ( x ) - ( c . x ) ; float dy = ( y ) - ( c . y ) ; float distance = ( dx * dx ) + ( dy * dy ) ; float radiusSum = ( radius ) + ( c . radius ) ; <START_BUG> return distance <= ( radiusSum * radiusSum ) ; <END_BUG> } public String toString ( ) { } }
public class ClusterStateResponse implements ActionResponse { private ClusterName clusterName ; private ClusterState clusterState ; ClusterStateResponse ( ) { } ClusterStateResponse ( ClusterName clusterName , ClusterState clusterState ) { } public ClusterState state ( ) { } public ClusterState getState ( ) { } public ClusterName clusterName ( ) { } public ClusterName getClusterName ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { clusterName = ClusterName . readClusterName ( in ) ; <START_BUG> clusterState = Builder . readFrom ( in , null , null ) ; <END_BUG> } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public class VertexBufferObject implements VertexData { static final IntBuffer tmpHandle = BufferUtils . newIntBuffer ( 1 ) ; final VertexAttributes attributes ; final FloatBuffer buffer ; int bufferHandle ; final boolean isStatic ; final int usage ; boolean isDirty = false ; boolean isBound = false ; public VertexBufferObject ( boolean isStatic , int numVertices , VertexAttribute ... attributes ) { } public VertexBufferObject ( boolean isStatic , int numVertices , VertexAttributes attributes ) { } private int createBufferObject ( ) { } @ Override public VertexAttributes getAttributes ( ) { } @ Override public int getNumVertices ( ) { <START_BUG> return ( ( buffer . limit ( ) ) * 4 ) / ( attributes . vertexSize ) ; <END_BUG> } public int getNumMaxVertices ( ) { } @ Override public FloatBuffer getBuffer ( ) { } @ Override public void setVertices ( float [ ] vertices , int offset , int count ) { } @ Override public void bind ( ) { } public void bind ( ShaderProgram shader ) { } @ Override public void unbind ( ) { } public void unbind ( ShaderProgram shader ) { } public void invalidate ( ) { } @ Override public void dispose ( ) { } }
public class GistsActivity extends RoboFragmentActivity implements OnItemClickListener { private static final int REQUEST_CREATE = 1 ; private static final int REQUEST_VIEW = ( GistsActivity . REQUEST_CREATE ) + 1 ; @ Inject private Context context ; @ Inject private ContextScopedProvider < GistService > serviceProvider ; private GistsFragment gists ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } private void randomGist ( ) { } private void openGist ( ) { } @ Override public boolean onCreateOptionsMenu ( Menu options ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } public void onItemClick ( AdapterView < ? > list , View view , int position , long id ) { Gist gist = ( ( Gist ) ( list . getItemAtPosition ( position ) ) ) ; <START_BUG> startActivityForResult ( ViewGistActivity . createIntent ( gist . getId ( ) ) , GistsActivity . REQUEST_VIEW ) ; <END_BUG> } }
public class FilterAggregationBuilder extends AggregationBuilder < FilterAggregationBuilder > { private FilterBuilder filter ; public FilterAggregationBuilder ( String name ) { } public FilterAggregationBuilder filter ( FilterBuilder filter ) { } @ Override protected XContentBuilder internalXContent ( XContentBuilder builder , Params params ) throws IOException { if ( ( filter ) == null ) { <START_BUG> throw new org . elasticsearch . search . builder . SearchSourceBuilderException ( ( ( "filter<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>set<seq2seq4repair_space>on<seq2seq4repair_space>filter<seq2seq4repair_space>aggregation<seq2seq4repair_space>[" + ( name ) ) + "]" ) ) ; <END_BUG> } filter . toXContent ( builder , params ) ; return builder ; } }
public abstract class AbstractSimpleTranslogTests { protected final ShardId shardId = new ShardId ( new Index ( "index" ) , 1 ) ; protected Translog translog ; @ BeforeMethod public void setUp ( ) { } @ AfterMethod public void tearDown ( ) { <START_BUG> translog . close ( ) ; <END_BUG> } protected abstract Translog create ( ) { } @ Test public void testSimpleOperations ( ) { } @ Test public void testSnapshot ( ) { } @ Test public void testSnapshotWithNewTranslog ( ) { } @ Test public void testSnapshotWithSeekForward ( ) { } private Term newUid ( String id ) { } }
public class IpFieldMapper extends NumberFieldMapper < Long > { public static final String CONTENT_TYPE = "ip" ; public static String longToIp ( long longIp ) { } private static final Pattern pattern = Pattern . compile ( "\\." ) ; public static long ipToLong ( String ip ) throws ElasticSearchIllegalArgumentException { } public static class Defaults extends NumberFieldMapper . Defaults { public static final String NULL_VALUE = null ; public static final FieldType IP_FIELD_TYPE = new FieldType ( NumberFieldMapper . Defaults . NUMBER_FIELD_TYPE ) ; } public static class Builder extends NumberFieldMapper . Builder < IpFieldMapper . Builder , IpFieldMapper > { protected String nullValue = IpFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public IpFieldMapper . Builder nullValue ( String nullValue ) { } @ Override public IpFieldMapper build ( BuilderContext context ) { <START_BUG> fieldType . setOmitNorms ( ( ( fieldType . omitNorms ( ) ) || ( ( boost ) != 1.0F ) ) ) ; <END_BUG> IpFieldMapper fieldMapper = new IpFieldMapper ( buildNames ( context ) , precisionStep , boost , fieldType , nullValue , ignoreMalformed ( context ) ) ; fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private String nullValue ; protected IpFieldMapper ( Names names , int precisionStep , float boost , FieldType fieldType , String nullValue , Explicit < Boolean > ignoreMalformed ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Long value ( Field field ) { } @ Override public Long valueFromString ( String value ) { } @ Override public Object valueForSearch ( Field field ) { } @ Override public String valueAsString ( Field field ) { } @ Override public String indexedValue ( String value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query fuzzyQuery ( String value , double minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( FieldDataCache fieldDataCache , String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected Field innerParseCreateField ( ParseContext context ) throws IOException { } @ Override public FieldDataType fieldDataType ( ) { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } public static class NumericIpAnalyzer extends NumericAnalyzer < IpFieldMapper . NumericIpTokenizer > { private final int precisionStep ; public NumericIpAnalyzer ( ) { } public NumericIpAnalyzer ( int precisionStep ) { } @ Override protected IpFieldMapper . NumericIpTokenizer createNumericTokenizer ( Reader reader , char [ ] buffer ) throws IOException { } } public static class NumericIpTokenizer extends NumericTokenizer { public NumericIpTokenizer ( Reader reader , int precisionStep ) throws IOException { } public NumericIpTokenizer ( Reader reader , int precisionStep , char [ ] buffer ) throws IOException { } @ Override protected void setValue ( NumericTokenStream tokenStream , String value ) { } } }
public class IOSMusic implements Music { private final OALAudioTrack track ; OnCompletionListener onCompletionListener ; public IOSMusic ( OALAudioTrack track ) { } @ Override public void play ( ) { } @ Override public void pause ( ) { } @ Override public void stop ( ) { } @ Override public boolean isPlaying ( ) { } @ Override public void setLooping ( boolean isLooping ) { } @ Override public boolean isLooping ( ) { } @ Override public void setVolume ( float volume ) { } public void setPosition ( float position ) { } @ Override public float getPosition ( ) { <START_BUG> return ( ( float ) ( ( track . getCurrentTime ( ) ) * 1000.0 ) ) ; <END_BUG> } @ Override public void dispose ( ) { } @ Override public float getVolume ( ) { } @ Override public void setPan ( float pan , float volume ) { } @ Override public void setOnCompletionListener ( OnCompletionListener listener ) { } }
public abstract class Viewport { private Camera camera ; private float worldWidth ; private float worldHeight ; private int screenX ; private int screenY ; private int screenWidth ; private int screenHeight ; private final Vector3 tmp = new Vector3 ( ) ; public void apply ( ) { } public void apply ( boolean centerCamera ) { } public final void update ( int screenWidth , int screenHeight ) { } public void update ( int screenWidth , int screenHeight , boolean centerCamera ) { } public Vector2 unproject ( Vector2 screenCoords ) { } public Vector2 project ( Vector2 worldCoords ) { } public Vector3 unproject ( Vector3 screenCoords ) { } public Vector3 project ( Vector3 worldCoords ) { } public Ray getPickRay ( float screenX , float screenY ) { <START_BUG> return camera . getPickRay ( screenX , screenY , screenX , screenY , screenWidth , screenHeight ) ; <END_BUG> } public void calculateScissors ( Matrix4 batchTransform , Rectangle area , Rectangle scissor ) { } public Vector2 toScreenCoordinates ( Vector2 worldCoords , Matrix4 transformMatrix ) { } public Camera getCamera ( ) { } public void setCamera ( Camera camera ) { } public float getWorldWidth ( ) { } public void setWorldWidth ( float worldWidth ) { } public float getWorldHeight ( ) { } public void setWorldHeight ( float worldHeight ) { } public void setWorldSize ( float worldWidth , float worldHeight ) { } public int getScreenX ( ) { } public void setScreenX ( int screenX ) { } public int getScreenY ( ) { } public void setScreenY ( int screenY ) { } public int getScreenWidth ( ) { } public void setScreenWidth ( int screenWidth ) { } public int getScreenHeight ( ) { } public void setScreenHeight ( int screenHeight ) { } public void setScreenPosition ( int screenX , int screenY ) { } public void setScreenSize ( int screenWidth , int screenHeight ) { } public void setScreenBounds ( int screenX , int screenY , int screenWidth , int screenHeight ) { } public int getLeftGutterWidth ( ) { } public int getRightGutterX ( ) { } public int getRightGutterWidth ( ) { } public int getBottomGutterHeight ( ) { } public int getTopGutterY ( ) { } public int getTopGutterHeight ( ) { } }
public class ParticleEffectLoader extends SynchronousAssetLoader < ParticleEffect , ParticleEffectLoader . ParticleEffectParameter > { public ParticleEffectLoader ( FileHandleResolver resolver ) { } @ Override public ParticleEffect load ( AssetManager am , String fileName , FileHandle file , ParticleEffectLoader . ParticleEffectParameter param ) { } @ Override public Array < AssetDescriptor > getDependencies ( String fileName , FileHandle file , ParticleEffectLoader . ParticleEffectParameter param ) { Array < AssetDescriptor > deps = null ; if ( ( param != null ) && ( ( param . atlasFile ) != null ) ) { <START_BUG> deps = new Array < AssetDescriptor > ( ) ; <END_BUG> deps . add ( new AssetDescriptor < TextureAtlas > ( param . atlasFile , TextureAtlas . class ) ) ; } return deps ; } public static class ParticleEffectParameter extends AssetLoaderParameters < ParticleEffect > { public String atlasFile ; public FileHandle imagesDir ; } }
public class ScriptHistogramFacetCollector extends AbstractFacetCollector { private final SearchScript keyScript ; private final SearchScript valueScript ; private final long interval ; private final ComparatorType comparatorType ; private final TLongLongHashMap counts = new TLongLongHashMap ( ) ; private final TLongDoubleHashMap totals = new TLongDoubleHashMap ( ) ; public ScriptHistogramFacetCollector ( String facetName , String scriptLang , String keyScript , String valueScript , Map < String , Object > params , long interval , HistogramFacet . ComparatorType comparatorType , SearchContext context ) { } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override protected void doSetNextReader ( IndexReader reader , int docBase ) throws IOException { } @ Override public Facet facet ( ) { <START_BUG> return new InternalCountAndTotalHistogramFacet ( facetName , "_na" , "_na" , ( - 1 ) , comparatorType , counts , totals ) ; <END_BUG> } public static long bucket ( double value , long interval ) { } }
public class IndicesAliasesRequestBuilder extends MasterNodeOperationRequestBuilder < IndicesAliasesRequest , IndicesAliasesResponse , IndicesAliasesRequestBuilder > { public IndicesAliasesRequestBuilder ( IndicesAdminClient indicesClient ) { } public IndicesAliasesRequestBuilder addAlias ( String index , String alias ) { } public IndicesAliasesRequestBuilder addAlias ( String index , String alias , String filter ) { } public IndicesAliasesRequestBuilder addAlias ( String index , String alias , Map < String , Object > filter ) { } public IndicesAliasesRequestBuilder addAlias ( String index , String alias , FilterBuilder filterBuilder ) { } public IndicesAliasesRequestBuilder addAliasAction ( AliasAction aliasAction ) { } public IndicesAliasesRequestBuilder removeAlias ( String index , String alias ) { } public IndicesAliasesRequestBuilder setTimeout ( TimeValue timeout ) { <START_BUG> request . timeout ( timeout ) ; <END_BUG> return this ; } @ Override protected void doExecute ( ActionListener < IndicesAliasesResponse > listener ) { } }
public class TransportSearchDfsQueryThenFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchDfsQueryThenFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportSearchCache transportSearchCache , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < DfsSearchResult > { private final Collection < DfsSearchResult > dfsResults = searchCache . obtainDfsResults ( ) ; private final Map < SearchShardTarget , QuerySearchResultProvider > queryResults = searchCache . obtainQueryResults ( ) ; private final Map < SearchShardTarget , FetchSearchResult > fetchResults = searchCache . obtainFetchResults ( ) ; private volatile Map < SearchShardTarget , ExtTIntArrayList > docIdsToLoad ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , InternalSearchRequest request , SearchServiceListener < DfsSearchResult > listener ) { } @ Override protected void processFirstPhaseResult ( ShardRouting shard , DfsSearchResult result ) { } @ Override protected void moveToSecondPhase ( ) { } private void executeQuery ( final DfsSearchResult dfsResult , final AtomicInteger counter , final QuerySearchRequest querySearchRequest , DiscoveryNode node ) { } private void executeFetchPhase ( ) { } private void innerExecuteFetchPhase ( ) { } private void executeFetch ( final SearchShardTarget shardTarget , final AtomicInteger counter , final FetchSearchRequest fetchSearchRequest , DiscoveryNode node ) { } private void finishHim ( ) { } private void innerFinishHim ( ) { final InternalSearchResponse internalResponse = searchPhaseController . merge ( sortedShardList , queryResults , fetchResults ) ; String scrollId = null ; if ( ( request . scroll ( ) ) != null ) { scrollId = TransportSearchHelper . buildScrollId ( request . searchType ( ) , dfsResults ) ; } <START_BUG> invokeListener ( new SearchResponse ( internalResponse , scrollId , expectedSuccessfulOps , successulOps . get ( ) , buildShardFailures ( ) ) ) ; <END_BUG> } } }
public class TransportDeleteWarmerAction extends TransportMasterNodeOperationAction < DeleteWarmerRequest , DeleteWarmerResponse > { @ Inject public TransportDeleteWarmerAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected DeleteWarmerRequest newRequest ( ) { } @ Override protected DeleteWarmerResponse newResponse ( ) { } @ Override protected void doExecute ( DeleteWarmerRequest request , ActionListener < DeleteWarmerResponse > listener ) { <START_BUG> request . indices ( clusterService . state ( ) . metaData ( ) . concreteIndices ( request . indices ( ) ) ) ; <END_BUG> super . doExecute ( request , listener ) ; } @ Override protected ClusterBlockException checkBlock ( DeleteWarmerRequest request , ClusterState state ) { } @ Override protected void masterOperation ( final DeleteWarmerRequest request , final ClusterState state , final ActionListener < DeleteWarmerResponse > listener ) throws ElasticSearchException { } }
public class FileTextureData implements TextureData { public static boolean copyToPOT ; final FileHandle file ; int width = 0 ; int height = 0 ; Format format ; Pixmap pixmap ; boolean useMipMaps ; boolean isPrepared = false ; public FileTextureData ( FileHandle file , Pixmap preloadedPixmap , Format format , boolean useMipMaps ) { } @ Override public boolean isPrepared ( ) { } @ Override public void prepare ( ) { } private Pixmap ensurePot ( Pixmap pixmap ) { } @ Override public Pixmap consumePixmap ( ) { } @ Override public boolean disposePixmap ( ) { } @ Override public int getWidth ( ) { } @ Override public int getHeight ( ) { } @ Override public Format getFormat ( ) { } @ Override public boolean useMipMaps ( ) { } @ Override public boolean isManaged ( ) { } public FileHandle getFileHandle ( ) { } @ Override public TextureDataType getType ( ) { } @ Override <START_BUG> public void consumeCompressedData ( int target ) { <END_BUG> throw new GdxRuntimeException ( "This<seq2seq4repair_space>TextureData<seq2seq4repair_space>implementation<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>upload<seq2seq4repair_space>data<seq2seq4repair_space>itself" ) ; } }
public class TextAreaTest extends GdxTest { private Stage stage ; private Skin skin ; @ Override public void create ( ) { } @ Override public void render ( ) { } @ Override public void resize ( int width , int height ) { <START_BUG> stage . getViewport ( ) . update ( width , height ) ; <END_BUG> } @ Override public void dispose ( ) { } }
public interface Mapper extends ToXContent { public static final Mapper [ ] EMPTY_ARRAY = new Mapper [ 0 ] ; public static class BuilderContext { private final Settings indexSettings ; private final ContentPath contentPath ; public BuilderContext ( Settings indexSettings , ContentPath contentPath ) { } public ContentPath path ( ) { } @ Nullable public Settings indexSettings ( ) { } @ Nullable public Version indexCreatedVersion ( ) { if ( ( indexSettings ) == null ) { return null ; } <START_BUG> return indexSettings . getAsVersion ( SETTING_VERSION_CREATED , null ) ; <END_BUG> } } public static abstract class Builder < T extends Mapper . Builder , Y extends Mapper > { public String name ; protected T builder ; protected Builder ( String name ) { } public String name ( ) { } public abstract Y build ( Mapper . BuilderContext context ) { } } public interface TypeParser { public static class ParserContext { private final PostingsFormatService postingsFormatService ; private final DocValuesFormatService docValuesFormatService ; private final AnalysisService analysisService ; private final SimilarityLookupService similarityLookupService ; private final ImmutableMap < String , Mapper . TypeParser > typeParsers ; private final Version indexVersionCreated ; public ParserContext ( PostingsFormatService postingsFormatService , DocValuesFormatService docValuesFormatService , AnalysisService analysisService , SimilarityLookupService similarityLookupService , ImmutableMap < String , Mapper . TypeParser > typeParsers , Version indexVersionCreated ) { } public AnalysisService analysisService ( ) { } public PostingsFormatService postingFormatService ( ) { } public DocValuesFormatService docValuesFormatService ( ) { } public SimilarityLookupService similarityLookupService ( ) { } public Mapper . TypeParser typeParser ( String type ) { } public Version indexVersionCreated ( ) { } } Mapper . Builder < ? , ? > parse ( String name , Map < String , Object > node , Mapper . TypeParser . ParserContext parserContext ) throws MapperParsingException { } } String name ( ) { } void parse ( ParseContext context ) throws IOException { } void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } void traverse ( FieldMapperListener fieldMapperListener ) { } void traverse ( ObjectMapperListener objectMapperListener ) { } void close ( ) { } }
public abstract class UserNewsFragment extends NewsFragment implements OrganizationSelectionListener { protected User org ; @ Override public void onAttach ( Activity activity ) { } @ Override protected void viewRepository ( Repository repository ) { } @ Override public void onOrganizationSelected ( User organization ) { int previousOrgId = ( ( org ) != null ) ? org . getId ( ) : - 1 ; org = organization ; <START_BUG> if ( ( ( getView ( ) ) != null ) && ( previousOrgId != ( org . getId ( ) ) ) ) <END_BUG> refreshWithProgress ( ) ; } }
public final class PerspectiveCamera { protected Matrix4 tmp = new Matrix4 ( ) ; protected Matrix4 proj = new Matrix4 ( ) ; protected Matrix4 model = new Matrix4 ( ) ; protected Matrix4 comb = new Matrix4 ( ) ; private final Vector3 direction = new Vector3 ( 0 , 0 , ( - 1 ) ) ; private final Vector3 up = new Vector3 ( 0 , 1 , 0 ) ; private final Vector3 right = new Vector3 ( 1 , 0 , 0 ) ; private final Vector3 position = new Vector3 ( ) ; private final Frustum frustum = new Frustum ( ) ; private float near = 1 ; private float far = 1000 ; private float fov = 90 ; private float viewportWidth = 640 ; private float viewportHeight = 480 ; public float getNear ( ) { } public void setNear ( float near ) { } public float getFar ( ) { } public void setFar ( float far ) { } public float getFov ( ) { } public void setFov ( float fov ) { } public float getViewportWidth ( ) { } public void setViewport ( float viewportWidth , float viewportHeight ) { } public Matrix4 getProjectionMatrix ( ) { } public Matrix4 getModelviewMatrix ( ) { } public Matrix4 getCombinedMatrix ( ) { } public Frustum getFrustum ( ) { } Vector3 tmp2 = new Vector3 ( ) ; public void update ( ) { } public void setMatrices ( ) { setViewport ( graphics . getWidth ( ) , graphics . getHeight ( ) ) ; update ( ) ; <START_BUG> GL10 gl = graphics . getGL10 ( ) ; <END_BUG> gl . glMatrixMode ( GL_PROJECTION ) ; gl . glLoadMatrixf ( getCombinedMatrix ( ) . val , 0 ) ; gl . glMatrixMode ( GL_MODELVIEW ) ; gl . glLoadIdentity ( ) ; } public Vector3 getDirection ( ) { } public Vector3 getRight ( ) { } public Vector3 getUp ( ) { } public Vector3 getPosition ( ) { } public Ray getPickRay ( int screenX , int screenY ) { } public void project ( Vector3 pos ) { } }
public class LwjglAWTCanvas implements Application { final LwjglGraphics graphics ; final OpenALAudio audio ; final LwjglFiles files ; final LwjglAWTInput input ; final LwjglNet net ; final ApplicationListener listener ; final AWTGLCanvas canvas ; final List < Runnable > runnables = new ArrayList ( ) ; final List < Runnable > executedRunnables = new ArrayList ( ) ; final Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; boolean running = true ; int lastWidth ; int lastHeight ; int logLevel = LOG_INFO ; private Cursor cursor ; public LwjglAWTCanvas ( ApplicationListener listener , boolean useGL2 ) { } public LwjglAWTCanvas ( ApplicationListener listener , boolean useGL2 , LwjglAWTCanvas sharedContextCanvas ) { } protected void setDisplayMode ( int width , int height ) { } protected void setTitle ( String title ) { } @ Override public ApplicationListener getApplicationListener ( ) { } public Canvas getCanvas ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Files getFiles ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Input getInput ( ) { } @ Override public Net getNet ( ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { } void setGlobals ( ) { } void create ( ) { } void render ( ) { } protected void start ( ) { } protected void resize ( int width , int height ) { } protected void stopped ( ) { } public void stop ( ) { } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } Map < String , Preferences > preferences = new HashMap < String , Preferences > ( ) ; @ Override public Preferences getPreferences ( String name ) { } @ Override public Clipboard getClipboard ( ) { } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } public void log ( String tag , String message ) { } @ Override <START_BUG> public void log ( String tag , String message , Throwable exception ) { <END_BUG> if ( ( logLevel ) >= ( LOG_INFO ) ) { System . out . println ( ( ( tag + ":<seq2seq4repair_space>" ) + message ) ) ; exception . printStackTrace ( System . out ) ; } } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public int getLogLevel ( ) { } @ Override public void exit ( ) { } public void makeCurrent ( ) { } public boolean isCurrent ( ) { } public void setCursor ( Cursor cursor ) { } @ Override public void addLifecycleListener ( LifecycleListener listener ) { } @ Override public void removeLifecycleListener ( LifecycleListener listener ) { } }
public class InternalIndexService extends AbstractIndexComponent implements IndexService { private final Injector injector ; private final Settings indexSettings ; private final NodeEnvironment nodeEnv ; private final ThreadPool threadPool ; private final PluginsService pluginsService ; private final InternalIndicesLifecycle indicesLifecycle ; private final PercolatorService percolatorService ; private final AnalysisService analysisService ; private final MapperService mapperService ; private final IndexQueryParserService queryParserService ; private final SimilarityService similarityService ; private final IndexAliasesService aliasesService ; private final IndexCache indexCache ; private final IndexFieldDataService indexFieldData ; private final IndexEngine indexEngine ; private final IndexGateway indexGateway ; private final IndexStore indexStore ; private final IndexSettingsService settingsService ; private volatile ImmutableMap < Integer , Injector > shardsInjectors = ImmutableMap . of ( ) ; private volatile ImmutableMap < Integer , IndexShard > shards = ImmutableMap . of ( ) ; private volatile boolean closed = false ; @ Inject public InternalIndexService ( Injector injector , Index index , @ IndexSettings Settings indexSettings , NodeEnvironment nodeEnv , ThreadPool threadPool , PercolatorService percolatorService , AnalysisService analysisService , MapperService mapperService , IndexQueryParserService queryParserService , SimilarityService similarityService , IndexAliasesService aliasesService , IndexCache indexCache , IndexEngine indexEngine , IndexGateway indexGateway , IndexStore indexStore , IndexSettingsService settingsService , IndexFieldDataService indexFieldData ) { } @ Override public int numberOfShards ( ) { } @ Override public UnmodifiableIterator < IndexShard > iterator ( ) { } @ Override public boolean hasShard ( int shardId ) { } @ Override public IndexShard shard ( int shardId ) { } @ Override public IndexShard shardSafe ( int shardId ) throws IndexShardMissingException { } @ Override public ImmutableSet < Integer > shardIds ( ) { <START_BUG> return ImmutableSet . copyOf ( shards . keySet ( ) ) ; <END_BUG> } @ Override public Injector injector ( ) { } @ Override public IndexGateway gateway ( ) { } @ Override public IndexSettingsService settingsService ( ) { } @ Override public IndexStore store ( ) { } @ Override public IndexCache cache ( ) { } @ Override public IndexFieldDataService fieldData ( ) { } @ Override public PercolatorService percolateService ( ) { } @ Override public AnalysisService analysisService ( ) { } @ Override public MapperService mapperService ( ) { } @ Override public IndexQueryParserService queryParserService ( ) { } @ Override public SimilarityService similarityService ( ) { } @ Override public IndexAliasesService aliasesService ( ) { } @ Override public IndexEngine engine ( ) { } public void close ( final String reason , @ Nullable Executor executor ) { } @ Override public Injector shardInjector ( int shardId ) throws ElasticSearchException { } @ Override public Injector shardInjectorSafe ( int shardId ) throws IndexShardMissingException { } @ Override public synchronized IndexShard createShard ( int sShardId ) throws ElasticSearchException { } @ Override public synchronized void removeShard ( int shardId , String reason ) throws ElasticSearchException { } }
public class MatchAllFilterParser implements FilterParser { public static final String NAME = "match_all" ; @ Inject public MatchAllFilterParser ( ) { } @ Override public String [ ] names ( ) { } @ Override public Filter parse ( QueryParseContext parseContext ) throws IOException , QueryParsingException { XContentParser parser = parseContext . parser ( ) ; XContentParser . Token token ; <START_BUG> while ( ( token = parser . nextToken ( ) ) != ( Token . END_OBJECT ) ) { <END_BUG> } return Queries . MATCH_ALL_FILTER ; } }
public class UidFieldMapper extends AbstractFieldMapper < Uid > implements org . elasticsearch . index . mapper . UidFieldMapper { public static final String CONTENT_TYPE = "_uid" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = org . elasticsearch . index . mapper . UidFieldMapper . NAME ; public static final Index INDEX = Index . NOT_ANALYZED ; public static final boolean OMIT_NORMS = true ; public static final boolean OMIT_TERM_FREQ_AND_POSITIONS = false ; } public static class Builder extends XContentMapper . Builder < UidFieldMapper . Builder , UidFieldMapper > { protected String indexName ; public Builder ( ) { } @ Override public UidFieldMapper build ( BuilderContext context ) { } } private ThreadLocal < UidField > fieldCache = new ThreadLocal < UidField > ( ) { @ Override protected UidField initialValue ( ) { } } ; protected UidFieldMapper ( ) { } protected UidFieldMapper ( String name ) { } protected UidFieldMapper ( String name , String indexName ) { } @ Override protected Fieldable parseCreateField ( ParseContext context ) throws IOException { } @ Override public Uid value ( Fieldable field ) { } @ Override public Uid valueFromString ( String value ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } @ Override public Term term ( String type , String id ) { } @ Override public Term term ( String uid ) { <START_BUG> return new Term ( names . indexName ( ) , uid ) ; <END_BUG> } @ Override public void close ( ) { } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( XContentMapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public interface ToXContent { public static interface Params { String param ( String key ) { } String param ( String key , String defaultValue ) { } boolean paramAsBoolean ( String key , boolean defaultValue ) { } Boolean paramAsBoolean ( String key , Boolean defaultValue ) { } } public static final ToXContent . Params EMPTY_PARAMS = new ToXContent . Params ( ) { @ Override public String param ( String key ) { } @ Override public String param ( String key , String defaultValue ) { } @ Override public boolean paramAsBoolean ( String key , boolean defaultValue ) { } @ Override public Boolean paramAsBoolean ( String key , Boolean defaultValue ) { } } ; public static class MapParams implements ToXContent . Params { private final Map < String , String > params ; public MapParams ( Map < String , String > params ) { } @ Override public String param ( String key ) { } @ Override public String param ( String key , String defaultValue ) { } @ Override public boolean paramAsBoolean ( String key , boolean defaultValue ) { } @ Override public Boolean paramAsBoolean ( String key , Boolean defaultValue ) { } } <START_BUG> void toXContent ( XContentBuilder builder , ToXContent . Params params ) throws IOException ; <END_BUG> }
public class RepositoryNewsFragment extends NewsFragment { @ InjectExtra ( Intents . EXTRA_REPOSITORY ) private Repository repo ; @ Override protected ResourcePager < Event > createPager ( ) { } @ Override protected void viewRepository ( Repository repository ) { <START_BUG> if ( ( repo . getId ( ) ) != ( repository . getId ( ) ) ) <END_BUG> super . viewRepository ( repository ) ; } }
public class BoostScoreFunction extends ScoreFunction { private final float boost ; public BoostScoreFunction ( float boost ) { } public float getBoost ( ) { } @ Override public void setNextReader ( AtomicReaderContext context ) { } @ Override public double score ( int docId , float subQueryScore ) { } @ Override <START_BUG> public Explanation explainScore ( int docId , Explanation subQueryExpl ) { <END_BUG> Explanation exp = new Explanation ( boost , "static<seq2seq4repair_space>boost<seq2seq4repair_space>factor" ) ; exp . addDetail ( new Explanation ( boost , "boostFactor" ) ) ; return exp ; } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } }
public class RefUtils { private static final String PREFIX_REFS = "refs/" ; private static final String PREFIX_TAG = "refs/tags/" ; private static final String PREFIX_HEADS = "refs/heads/" ; public static boolean isBranch ( final Reference ref ) { } public static boolean isTag ( final Reference ref ) { } public static String getPath ( final Reference ref ) { if ( ref == null ) return null ; String name = ref . getRef ( ) ; if ( ( ! ( TextUtils . isEmpty ( name ) ) ) && ( name . startsWith ( RefUtils . PREFIX_REFS ) ) ) return name . substring ( RefUtils . PREFIX_REFS . length ( ) ) ; else <START_BUG> return null ; <END_BUG> } public static String getName ( final Reference ref ) { } public static boolean isValid ( final Reference ref ) { } }
public final class ClassReflection { public static Class forName ( String name ) throws ReflectionException { } public static String getSimpleName ( Class c ) { } public static boolean isInstance ( Class c , Object obj ) { <START_BUG> return ClassReflection . isAssignableFrom ( c , obj . getClass ( ) ) ; <END_BUG> } public static boolean isAssignableFrom ( Class c1 , Class c2 ) { } public static boolean isMemberClass ( Class c ) { } public static boolean isStaticClass ( Class c ) { } public static < T > T newInstance ( Class < T > c ) throws ReflectionException { } public static Constructor [ ] getConstructors ( Class c ) { } public static Constructor getConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Constructor getDeclaredConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getMethods ( Class c ) { } public static Method getMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getDeclaredMethods ( Class c ) { } public static Method getDeclaredMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Field [ ] getFields ( Class c ) { } public static Field getField ( Class c , String name ) throws ReflectionException { } public static Field [ ] getDeclaredFields ( Class c ) { } public static Field getDeclaredField ( Class c , String name ) throws ReflectionException { } }
public class IndicesClusterStateService extends AbstractLifecycleComponent < IndicesClusterStateService > implements ClusterStateListener { private final IndicesService indicesService ; private final ClusterService clusterService ; private final ThreadPool threadPool ; private final RecoverySource recoverySource ; private final RecoveryTarget recoveryTarget ; private final ShardStateAction shardStateAction ; private final NodeIndexCreatedAction nodeIndexCreatedAction ; private final NodeIndexDeletedAction nodeIndexDeletedAction ; private final NodeMappingCreatedAction nodeMappingCreatedAction ; private final ConcurrentMap < Tuple < String , String > , Boolean > seenMappings = ConcurrentCollections . newConcurrentMap ( ) ; private final Object mutex = new Object ( ) ; @ Inject public IndicesClusterStateService ( Settings settings , IndicesService indicesService , ClusterService clusterService , ThreadPool threadPool , RecoveryTarget recoveryTarget , RecoverySource recoverySource , ShardStateAction shardStateAction , NodeIndexCreatedAction nodeIndexCreatedAction , NodeIndexDeletedAction nodeIndexDeletedAction , NodeMappingCreatedAction nodeMappingCreatedAction ) { } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } @ Override public void clusterChanged ( final ClusterChangedEvent event ) { } private void applyCleanedIndices ( final ClusterChangedEvent event ) { } private void applyDeletedIndices ( final ClusterChangedEvent event ) { } private void applyDeletedShards ( final ClusterChangedEvent event ) { } private void applyNewIndices ( final ClusterChangedEvent event ) { } private void applyMappings ( ClusterChangedEvent event ) { } private void processMapping ( ClusterChangedEvent event , String index , MapperService mapperService , String mappingType , CompressedString mappingSource ) { } private void applyNewOrUpdatedShards ( final ClusterChangedEvent event ) throws ElasticSearchException { } private void applyInitializingShard ( final RoutingTable routingTable , final DiscoveryNodes nodes , final ShardRouting shardRouting ) throws ElasticSearchException { } private class PeerRecoveryListener implements RecoveryTarget . RecoveryListener { private final StartRecoveryRequest request ; private final ShardRouting shardRouting ; private final IndexService indexService ; private PeerRecoveryListener ( StartRecoveryRequest request , ShardRouting shardRouting , IndexService indexService ) { } @ Override public void onRecoveryDone ( ) { } @ Override public void onRetryRecovery ( TimeValue retryAfter ) { threadPool . schedule ( new Runnable ( ) { @ Override public void run ( ) { recoveryTarget . startRecovery ( request , true , IndicesClusterStateService . PeerRecoveryListener . this ) ; } <START_BUG> } , retryAfter ) ; <END_BUG> } @ Override public void onIgnoreRecovery ( boolean removeShard , String reason ) { } @ Override public void onRecoveryFailure ( RecoveryFailedException e , boolean sendShardFailure ) { } } private void handleRecoveryFailure ( IndexService indexService , ShardRouting shardRouting , boolean sendShardFailure , Throwable failure ) { } }
public class ContainerTest extends GdxTest { Skin skin ; Stage stage ; @ Override public void create ( ) { } Table label ( String text ) { } @ Override public void render ( ) { } @ Override public void resize ( int width , int height ) { <START_BUG> stage . getViewport ( ) . update ( width , height ) ; <END_BUG> } @ Override public void dispose ( ) { } }
public class BooleanArray { public boolean [ ] items ; public int size ; public boolean ordered ; public BooleanArray ( ) { } public BooleanArray ( int capacity ) { } public BooleanArray ( boolean ordered , int capacity ) { } public BooleanArray ( BooleanArray array ) { } public BooleanArray ( boolean [ ] array ) { } public BooleanArray ( boolean ordered , boolean [ ] array , int startIndex , int count ) { } public void add ( boolean value ) { } public void addAll ( BooleanArray array ) { } public void addAll ( BooleanArray array , int offset , int length ) { } public void addAll ( boolean [ ] array ) { } public void addAll ( boolean [ ] array , int offset , int length ) { boolean [ ] items = this . items ; <START_BUG> int sizeNeeded = ( ( size ) + length ) - offset ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public boolean get ( int index ) { } public void set ( int index , boolean value ) { } public void insert ( int index , boolean value ) { } public void swap ( int first , int second ) { } public boolean removeIndex ( int index ) { } public boolean removeAll ( BooleanArray array ) { } public boolean pop ( ) { } public boolean peek ( ) { } public boolean first ( ) { } public void clear ( ) { } public void shrink ( ) { } public boolean [ ] ensureCapacity ( int additionalCapacity ) { } protected boolean [ ] resize ( int newSize ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public boolean random ( ) { } public boolean [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class Label extends Widget { private static final Color tempColor = new Color ( ) ; private Label . LabelStyle style ; private final TextBounds bounds = new TextBounds ( ) ; private final StringBuilder text = new StringBuilder ( ) ; private StringBuilder tempText ; private BitmapFontCache cache ; private int labelAlign = Align . left ; private HAlignment lineAlign = HAlignment . LEFT ; private boolean wrap ; private float lastPrefHeight ; private boolean sizeInvalid = true ; private float fontScaleX = 1 ; private float fontScaleY = 1 ; private boolean ellipse ; public Label ( CharSequence text , Skin skin ) { } public Label ( CharSequence text , Skin skin , String styleName ) { } public Label ( CharSequence text , Skin skin , String fontName , Color color ) { } public Label ( CharSequence text , Skin skin , String fontName , String colorName ) { } public Label ( CharSequence text , Label . LabelStyle style ) { } public void setStyle ( Label . LabelStyle style ) { } public Label . LabelStyle getStyle ( ) { } public void setText ( CharSequence newText ) { } public boolean textEquals ( CharSequence other ) { } <START_BUG> public StringBuilder getText ( ) { <END_BUG> return text ; } public void invalidate ( ) { } private void scaleAndComputeSize ( ) { } private void computeSize ( ) { } public void layout ( ) { } public void draw ( Batch batch , float parentAlpha ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public TextBounds getTextBounds ( ) { } public void setWrap ( boolean wrap ) { } public void setAlignment ( int alignment ) { } public void setAlignment ( int labelAlign , int lineAlign ) { } public void setFontScale ( float fontScale ) { } public void setFontScale ( float fontScaleX , float fontScaleY ) { } public float getFontScaleX ( ) { } public void setFontScaleX ( float fontScaleX ) { } public float getFontScaleY ( ) { } public void setFontScaleY ( float fontScaleY ) { } public void setEllipse ( boolean ellipse ) { } protected BitmapFontCache getBitmapFontCache ( ) { } public static class LabelStyle { public BitmapFont font ; public Color fontColor ; public Drawable background ; public LabelStyle ( ) { } public LabelStyle ( BitmapFont font , Color fontColor ) { } public LabelStyle ( Label . LabelStyle style ) { } } }
public class ReproduceInfoPrinter extends RunListener { protected final ESLogger logger = Loggers . getLogger ( ElasticsearchTestCase . class ) ; @ Override public void testStarted ( Description description ) throws Exception { } @ Override public void testFinished ( Description description ) throws Exception { } @ Override public void testFailure ( Failure failure ) throws Exception { } protected ReproduceErrorMessageBuilder reproduceErrorMessageBuilder ( StringBuilder b ) { } protected TraceFormatting traces ( ) { } protected static class MavenMessageBuilder extends ReproduceErrorMessageBuilder { public MavenMessageBuilder ( StringBuilder b ) { } @ Override public ReproduceErrorMessageBuilder appendAllOpts ( Description description ) { } @ Override public ReproduceErrorMessageBuilder appendOpt ( String sysPropName , String value ) { } public ReproduceErrorMessageBuilder appendESProperties ( ) { <START_BUG> appendProperties ( "es.logger.level" , "es.node.mode" , "es.node.local" , TESTS_ENABLE_MOCK_MODULES , "tests.assertion.disabled" , "tests.security.manager" , "tests.nighly" ) ; <END_BUG> if ( ( ( System . getProperty ( "tests.jvm.argline" ) ) != null ) && ( ! ( System . getProperty ( "tests.jvm.argline" ) . isEmpty ( ) ) ) ) { appendOpt ( "tests.jvm.argline" , ( ( "\"" + ( System . getProperty ( "tests.jvm.argline" ) ) ) + "\"" ) ) ; } return this ; } protected ReproduceErrorMessageBuilder appendProperties ( String ... properties ) { } } }
public class GeoDistanceParser implements Aggregator . Parser { private static final ParseField ORIGIN_FIELD = new ParseField ( "origin" , "center" , "point" , "por" ) ; @ Override public String type ( ) { } private static String key ( String key , double from , double to ) { } @ Override public AggregatorFactory parse ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { } private static class GeoDistanceFactory extends ValuesSourceAggregatorFactory < ValuesSource . GeoPoint > { private final GeoPoint origin ; private final DistanceUnit unit ; private final GeoDistance distanceType ; private final Factory rangeFactory ; private final List < RangeAggregator . Range > ranges ; private final boolean keyed ; public GeoDistanceFactory ( String name , ValuesSourceConfig < ValuesSource . GeoPoint > valueSourceConfig , InternalRange . Factory rangeFactory , GeoPoint origin , DistanceUnit unit , GeoDistance distanceType , List < RangeAggregator . Range > ranges , boolean keyed ) { } @ Override protected Aggregator createUnmapped ( AggregationContext aggregationContext , Aggregator parent ) { } @ Override protected Aggregator create ( final ValuesSource . GeoPoint valuesSource , long expectedBucketsCount , AggregationContext aggregationContext , Aggregator parent ) { } private static class DistanceSource extends ValuesSource . Numeric implements ReaderContextAware { private final GeoPoint source ; private final GeoDistance distanceType ; private final DistanceUnit unit ; private final GeoPoint origin ; private final MetaData metaData ; private SortedNumericDoubleValues distanceValues ; public DistanceSource ( ValuesSource . GeoPoint source , GeoDistance distanceType , GeoPoint origin , DistanceUnit unit ) { } @ Override public void setNextReader ( AtomicReaderContext reader ) { final MultiGeoPointValues geoValues = source . geoPointValues ( ) ; final FixedSourceDistance distance = distanceType . fixedSourceDistance ( origin . getLat ( ) , origin . getLon ( ) , unit ) ; <START_BUG> distanceValues = GeoDistance . distanceValues ( distance , geoValues ) ; <END_BUG> } @ Override public MetaData metaData ( ) { } @ Override public boolean isFloatingPoint ( ) { } @ Override public SortedNumericDocValues longValues ( ) { } @ Override public SortedNumericDoubleValues doubleValues ( ) { } @ Override public SortedBinaryDocValues bytesValues ( ) { } } } }
public class OrganizationRepositories implements PersistableResource < Repository > { public interface Factory { OrganizationRepositories under ( User org ) { } } private final User org ; private final RepositoryService repos ; private final WatcherService watcher ; private final Provider < GitHubAccount > accountProvider ; @ Inject public OrganizationRepositories ( @ Assisted User orgs , RepositoryService repos , WatcherService watcher , Provider < GitHubAccount > accountProvider ) { } @ Override public Cursor getCursor ( SQLiteDatabase readableDatabase ) { } @ Override public Repository loadFrom ( Cursor cursor ) { } @ Override public void store ( SQLiteDatabase db , List < Repository > repos ) { } @ Override public List < Repository > request ( ) throws IOException { } private boolean isAuthenticatedUser ( ) { } @ Override public String toString ( ) { <START_BUG> return ( ( ( getClass ( ) . getSimpleName ( ) ) + "[" ) + ( org . getLogin ( ) ) ) + "]" ; <END_BUG> } }
public class EditIssueActivityTest extends ActivityTest < EditIssueActivity > { public EditIssueActivityTest ( ) { } @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; Repository repo = new Repository ( ) ; repo . setName ( "repo" ) ; repo . setOwner ( new User ( ) . setLogin ( "owner" ) ) ; <START_BUG> setActivityIntent ( EditIssueActivity . createIntent ( repo , "an<seq2seq4repair_space>issue" ) ) ; <END_BUG> } public void testSaveMenuEnabled ( ) throws Throwable { } }
public class StringBuilder implements Appendable , CharSequence { static final int INITIAL_CAPACITY = 16 ; public char [ ] chars ; public int length ; final char [ ] getValue ( ) { } public StringBuilder ( ) { } public StringBuilder ( int capacity ) { } public StringBuilder ( CharSequence seq ) { } public StringBuilder ( StringBuilder builder ) { } public StringBuilder ( String string ) { } private void enlargeBuffer ( int min ) { } final void appendNull ( ) { } final void append0 ( char [ ] value ) { int newSize = ( length ) + ( value . length ) ; if ( newSize > ( chars . length ) ) { enlargeBuffer ( newSize ) ; } <START_BUG> System . arraycopy ( value , 0 , chars , length , value . length ) ; <END_BUG> length = newSize ; } final void append0 ( char [ ] value , int offset , int length ) { } final void append0 ( char ch ) { } final void append0 ( String string ) { } final void append0 ( CharSequence s , int start , int end ) { } public int capacity ( ) { } public char charAt ( int index ) { } final void delete0 ( int start , int end ) { } final void deleteCharAt0 ( int location ) { } public void ensureCapacity ( int min ) { } public void getChars ( int start , int end , char [ ] dest , int destStart ) { } final void insert0 ( int index , char [ ] value ) { } final void insert0 ( int index , char [ ] value , int start , int length ) { } final void insert0 ( int index , char ch ) { } final void insert0 ( int index , String string ) { } final void insert0 ( int index , CharSequence s , int start , int end ) { } public int length ( ) { } private void move ( int size , int index ) { } final void replace0 ( int start , int end , String string ) { } final void reverse0 ( ) { } public void setCharAt ( int index , char ch ) { } public void setLength ( int newLength ) { } public String substring ( int start ) { } public String substring ( int start , int end ) { } @ Override public String toString ( ) { } public CharSequence subSequence ( int start , int end ) { } public int indexOf ( String string ) { } public int indexOf ( String subString , int start ) { } public int lastIndexOf ( String string ) { } public int lastIndexOf ( String subString , int start ) { } public void trimToSize ( ) { } public int codePointAt ( int index ) { } public int codePointBefore ( int index ) { } public int codePointCount ( int beginIndex , int endIndex ) { } public int offsetByCodePoints ( int index , int codePointOffset ) { } public StringBuilder append ( boolean b ) { } public StringBuilder append ( char c ) { } public StringBuilder append ( int i ) { } public StringBuilder append ( long lng ) { } public StringBuilder append ( float f ) { } public StringBuilder append ( double d ) { } public StringBuilder append ( Object obj ) { } public StringBuilder append ( String str ) { } public StringBuilder append ( char [ ] ch ) { } public StringBuilder append ( char [ ] str , int offset , int len ) { } public StringBuilder append ( CharSequence csq ) { } public StringBuilder append ( StringBuilder builder ) { } public StringBuilder append ( CharSequence csq , int start , int end ) { } public StringBuilder append ( StringBuilder builder , int start , int end ) { } public StringBuilder appendCodePoint ( int codePoint ) { } public StringBuilder delete ( int start , int end ) { } public StringBuilder deleteCharAt ( int index ) { } public StringBuilder insert ( int offset , boolean b ) { } public StringBuilder insert ( int offset , char c ) { } public StringBuilder insert ( int offset , int i ) { } public StringBuilder insert ( int offset , long l ) { } public StringBuilder insert ( int offset , float f ) { } public StringBuilder insert ( int offset , double d ) { } public StringBuilder insert ( int offset , Object obj ) { } public StringBuilder insert ( int offset , String str ) { } public StringBuilder insert ( int offset , char [ ] ch ) { } public StringBuilder insert ( int offset , char [ ] str , int strOffset , int strLen ) { } public StringBuilder insert ( int offset , CharSequence s ) { } public StringBuilder insert ( int offset , CharSequence s , int start , int end ) { } public StringBuilder replace ( int start , int end , String str ) { } public StringBuilder reverse ( ) { } public int hashCode ( ) { } public boolean equals ( Object obj ) { } }
public class InternalTickTest extends BaseBulletTest { static class TestInternalTickCallback extends InternalTickCallback { public TestInternalTickCallback ( btDynamicsWorld dynamicsWorld ) { } @ Override public void onInternalTick ( btDynamicsWorld dynamicsWorld , float timeStep ) { } } final int BOXCOUNT_X = 5 ; final int BOXCOUNT_Y = 5 ; final int BOXCOUNT_Z = 1 ; final float BOXOFFSET_X = - 2.5F ; final float BOXOFFSET_Y = 0.5F ; final float BOXOFFSET_Z = 0.0F ; InternalTickTest . TestInternalTickCallback internalTickCallback ; @ Override public void create ( ) { } @ Override public void dispose ( ) { super . dispose ( ) ; if ( ( internalTickCallback ) != null ) <START_BUG> internalTickCallback . delete ( ) ; <END_BUG> internalTickCallback = null ; } float toggleTime = 0.0F ; boolean toggleAttach = false ; @ Override public void render ( ) { } @ Override public boolean tap ( float x , float y , int count , int button ) { } }
public class Quaternion implements Serializable { private static final long serialVersionUID = - 7661875440774897168L ; private static final float NORMALIZATION_TOLERANCE = 1.0E-5F ; private static Quaternion tmp1 = new Quaternion ( 0 , 0 , 0 , 0 ) ; private static Quaternion tmp2 = new Quaternion ( 0 , 0 , 0 , 0 ) ; public float x ; public float y ; public float z ; public float w ; public Quaternion ( float x , float y , float z , float w ) { } Quaternion ( ) { } public Quaternion ( Quaternion quaternion ) { } public Quaternion ( Vector3 axis , float angle ) { } public Quaternion set ( float x , float y , float z , float w ) { } public Quaternion set ( Quaternion quaternion ) { } public Quaternion set ( Vector3 axis , float angle ) { } public Quaternion cpy ( ) { } public float len ( ) { } public String toString ( ) { } public Quaternion setEulerAngles ( float yaw , float pitch , float roll ) { } public float len2 ( ) { } public Quaternion nor ( ) { } public Quaternion conjugate ( ) { } public void transform ( Vector3 v ) { } public Quaternion mul ( Quaternion q ) { } public Quaternion mulLeft ( Quaternion q ) { } public void toMatrix ( float [ ] matrix ) { } public static Quaternion idt ( ) { } public Quaternion setFromAxis ( Vector3 axis , float angle ) { <START_BUG> return setFromAxis ( axis . z , axis . y , axis . z , angle ) ; <END_BUG> } public Quaternion setFromAxis ( float x , float y , float z , float angle ) { } public Quaternion setFromMatrix ( Matrix4 matrix ) { } public Quaternion setFromAxes ( float xx , float xy , float xz , float yx , float yy , float yz , float zx , float zy , float zz ) { } public Quaternion slerp ( Quaternion end , float alpha ) { } public boolean equals ( final Object o ) { } public float dot ( Quaternion other ) { } public Quaternion mul ( float scalar ) { } }
public interface Client { void close ( ) { } AdminClient admin ( ) { } < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder > > ActionFuture < Response > execute ( final Action < Request , Response , RequestBuilder > action , final Request request ) { } < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder > > void execute ( final Action < Request , Response , RequestBuilder > action , final Request request , ActionListener < Response > listener ) { } < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder > > RequestBuilder prepareExecute ( final Action < Request , Response , RequestBuilder > action ) { } ActionFuture < IndexResponse > index ( IndexRequest request ) { } void index ( IndexRequest request , ActionListener < IndexResponse > listener ) { } IndexRequestBuilder prepareIndex ( ) { } ActionFuture < UpdateResponse > update ( UpdateRequest request ) { } void update ( UpdateRequest request , ActionListener < UpdateResponse > listener ) { } UpdateRequestBuilder prepareUpdate ( ) { } UpdateRequestBuilder prepareUpdate ( String index , String type , String id ) { } IndexRequestBuilder prepareIndex ( String index , String type ) { } IndexRequestBuilder prepareIndex ( String index , String type , @ Nullable String id ) { } ActionFuture < DeleteResponse > delete ( DeleteRequest request ) { } void delete ( DeleteRequest request , ActionListener < DeleteResponse > listener ) { } DeleteRequestBuilder prepareDelete ( ) { } DeleteRequestBuilder prepareDelete ( String index , String type , String id ) { } ActionFuture < BulkResponse > bulk ( BulkRequest request ) { } void bulk ( BulkRequest request , ActionListener < BulkResponse > listener ) { } BulkRequestBuilder prepareBulk ( ) { } ActionFuture < DeleteByQueryResponse > deleteByQuery ( DeleteByQueryRequest request ) { } void deleteByQuery ( DeleteByQueryRequest request , ActionListener < DeleteByQueryResponse > listener ) { } DeleteByQueryRequestBuilder prepareDeleteByQuery ( String ... indices ) { } ActionFuture < GetResponse > get ( GetRequest request ) { } void get ( GetRequest request , ActionListener < GetResponse > listener ) { } GetRequestBuilder prepareGet ( ) { } GetRequestBuilder prepareGet ( String index , @ Nullable String type , String id ) { } ActionFuture < MultiGetResponse > multiGet ( MultiGetRequest request ) { } void multiGet ( MultiGetRequest request , ActionListener < MultiGetResponse > listener ) { } MultiGetRequestBuilder prepareMultiGet ( ) { } ActionFuture < CountResponse > count ( CountRequest request ) { } void count ( CountRequest request , ActionListener < CountResponse > listener ) { } CountRequestBuilder prepareCount ( String ... indices ) { } ActionFuture < SuggestResponse > suggest ( SuggestRequest request ) { } void suggest ( SuggestRequest request , ActionListener < SuggestResponse > listener ) { } SuggestRequestBuilder prepareSuggest ( String ... indices ) { } ActionFuture < SearchResponse > search ( SearchRequest request ) { } void search ( SearchRequest request , ActionListener < SearchResponse > listener ) { } SearchRequestBuilder prepareSearch ( String ... indices ) { } ActionFuture < SearchResponse > searchScroll ( SearchScrollRequest request ) { } void searchScroll ( SearchScrollRequest request , ActionListener < SearchResponse > listener ) { } SearchScrollRequestBuilder prepareSearchScroll ( String scrollId ) { } ActionFuture < MultiSearchResponse > multiSearch ( MultiSearchRequest request ) { } void multiSearch ( MultiSearchRequest request , ActionListener < MultiSearchResponse > listener ) { } MultiSearchRequestBuilder prepareMultiSearch ( ) { } ActionFuture < SearchResponse > moreLikeThis ( MoreLikeThisRequest request ) { } void moreLikeThis ( MoreLikeThisRequest request , ActionListener < SearchResponse > listener ) { } MoreLikeThisRequestBuilder prepareMoreLikeThis ( String index , String type , String id ) { } ActionFuture < TermVectorResponse > termVector ( TermVectorRequest request ) { } void termVector ( TermVectorRequest request , ActionListener < TermVectorResponse > listener ) { } TermVectorRequestBuilder prepareTermVector ( String index , String type , String id ) { } ActionFuture < MultiTermVectorsResponse > multiTermVectors ( MultiTermVectorsRequest request ) { } void multiTermVectors ( MultiTermVectorsRequest request , ActionListener < MultiTermVectorsResponse > listener ) { } MultiTermVectorsRequestBuilder prepareMultiTermVectors ( ) { } ActionFuture < PercolateResponse > percolate ( PercolateRequest request ) { } void percolate ( PercolateRequest request , ActionListener < PercolateResponse > listener ) { } PercolateRequestBuilder preparePercolate ( ) { } ActionFuture < MultiPercolateResponse > multiPercolate ( MultiPercolateRequest request ) { } void multiPercolate ( MultiPercolateRequest request , ActionListener < MultiPercolateResponse > listener ) { } MultiPercolateRequestBuilder prepareMultiPercolate ( ) { } ExplainRequestBuilder prepareExplain ( String index , String type , String id ) { } ActionFuture < ExplainResponse > explain ( ExplainRequest request ) { } void explain ( ExplainRequest request , ActionListener < ExplainResponse > listener ) { } ClearScrollRequestBuilder prepareClearScroll ( ) { } ActionFuture < ClearScrollResponse > clearScroll ( ClearScrollRequest request ) { } void clearScroll ( ClearScrollRequest request , ActionListener < ClearScrollResponse > listener ) { } void bench ( BenchmarkRequest request , ActionListener < BenchmarkResponse > listener ) { } ActionFuture < BenchmarkResponse > bench ( BenchmarkRequest request ) { } BenchmarkRequestBuilder prepareBench ( String ... indices ) { } void abortBench ( AbortBenchmarkRequest request , ActionListener < AbortBenchmarkResponse > listener ) { } <START_BUG> AbortBenchmarkRequestBuilder prepareAbortBench ( String benchmarkId ) ; <END_BUG> void benchStatus ( BenchmarkStatusRequest request , ActionListener < BenchmarkStatusResponse > listener ) { } BenchmarkStatusRequestBuilder prepareBenchStatus ( ) { } }
public class UITest extends GdxTest implements InputProcessor { Texture uiTexture ; Texture badlogic ; Stage ui ; @ Override public void create ( ) { } @ Override public void render ( ) { GL10 gl = graphics . getGL10 ( ) ; gl . glClear ( GL_COLOR_BUFFER_BIT ) ; <START_BUG> ui . act ( graphics . getDeltaTime ( ) ) ; <END_BUG> ui . draw ( ) ; } @ Override public boolean keyDown ( int keycode ) { } @ Override public boolean keyUp ( int keycode ) { } @ Override public boolean keyTyped ( char character ) { } @ Override public boolean touchDown ( int x , int y , int pointer , int button ) { } Vector2 point = new Vector2 ( ) ; @ Override public boolean touchUp ( int x , int y , int pointer , int button ) { } @ Override public boolean touchDragged ( int x , int y , int pointer ) { } @ Override public boolean needsGL20 ( ) { } @ Override public boolean touchMoved ( int x , int y ) { } @ Override public boolean scrolled ( int amount ) { } }
@ Immutable public class MetaData implements Iterable < IndexMetaData > { public static MetaData EMPTY_META_DATA = MetaData . newMetaDataBuilder ( ) . build ( ) ; private final ImmutableMap < String , IndexMetaData > indices ; private final int maxNumberOfShardsPerNode ; private transient final int totalNumberOfShards ; private final String [ ] allIndices ; private final ImmutableSet < String > aliases ; private final ImmutableMap < String , String [ ] > aliasAndIndexToIndexMap ; private final ImmutableMap < String , ImmutableSet < String > > aliasAndIndexToIndexMap2 ; private MetaData ( ImmutableMap < String , IndexMetaData > indices , int maxNumberOfShardsPerNode ) { } public ImmutableSet < String > aliases ( ) { } public ImmutableSet < String > getAliases ( ) { } public String [ ] concreteAllIndices ( ) { } public String [ ] getConcreteAllIndices ( ) { } public String [ ] concreteIndices ( String [ ] indices ) throws IndexMissingException { } public String concreteIndex ( String index ) throws ElasticSearchIllegalArgumentException , IndexMissingException { } public boolean hasIndex ( String index ) { } public boolean hasConcreteIndex ( String index ) { <START_BUG> return ( aliasAndIndexToIndexMap2 . get ( index ) ) != null ; <END_BUG> } public IndexMetaData index ( String index ) { } public ImmutableMap < String , IndexMetaData > indices ( ) { } public ImmutableMap < String , IndexMetaData > getIndices ( ) { } public int maxNumberOfShardsPerNode ( ) { } public int getMaxNumberOfShardsPerNode ( ) { } public int totalNumberOfShards ( ) { } public int getTotalNumberOfShards ( ) { } @ Override public UnmodifiableIterator < IndexMetaData > iterator ( ) { } public static MetaData . Builder newMetaDataBuilder ( ) { } public static class Builder { private int maxNumberOfShardsPerNode = 100 ; private MapBuilder < String , IndexMetaData > indices = newMapBuilder ( ) ; public MetaData . Builder put ( IndexMetaData . Builder indexMetaDataBuilder ) { } public MetaData . Builder put ( IndexMetaData indexMetaData ) { } public IndexMetaData get ( String index ) { } public MetaData . Builder remove ( String index ) { } public MetaData . Builder metaData ( MetaData metaData ) { } public MetaData . Builder maxNumberOfShardsPerNode ( int maxNumberOfShardsPerNode ) { } public MetaData build ( ) { } public static String toXContent ( MetaData metaData ) throws IOException { } public static void toXContent ( MetaData metaData , XContentBuilder builder , ToXContent . Params params ) throws IOException { } public static MetaData fromXContent ( XContentParser parser , @ Nullable Settings globalSettings ) throws IOException { } public static MetaData readFrom ( StreamInput in , @ Nullable Settings globalSettings ) throws IOException { } public static void writeTo ( MetaData metaData , StreamOutput out ) throws IOException { } } }
public class Matchers { private Matchers ( ) { } public static Matcher < Object > any ( ) { } private static final Matcher < Object > ANY = new Matchers . Any ( ) ; private static class Any extends AbstractMatcher < Object > implements Serializable { public boolean matches ( Object o ) { } @ Override public String toString ( ) { } public Object readResolve ( ) { } private static final long serialVersionUID = 0 ; } public static < T > Matcher < T > not ( final Matcher < ? super T > p ) { <START_BUG> return new Matchers . Not < T > ( p ) ; <END_BUG> } private static class Not < T > extends AbstractMatcher < T > implements Serializable { final Matcher < ? super T > delegate ; private Not ( Matcher < ? super T > delegate ) { } public boolean matches ( T t ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } private static final long serialVersionUID = 0 ; } private static void checkForRuntimeRetention ( Class < ? extends Annotation > annotationType ) { } public static Matcher < AnnotatedElement > annotatedWith ( final Class < ? extends Annotation > annotationType ) { } private static class AnnotatedWithType extends AbstractMatcher < AnnotatedElement > implements Serializable { private final Class < ? extends Annotation > annotationType ; public AnnotatedWithType ( Class < ? extends Annotation > annotationType ) { } public boolean matches ( AnnotatedElement element ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } private static final long serialVersionUID = 0 ; } public static Matcher < AnnotatedElement > annotatedWith ( final Annotation annotation ) { } private static class AnnotatedWith extends AbstractMatcher < AnnotatedElement > implements Serializable { private final Annotation annotation ; public AnnotatedWith ( Annotation annotation ) { } public boolean matches ( AnnotatedElement element ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } private static final long serialVersionUID = 0 ; } public static Matcher < Class > subclassesOf ( final Class < ? > superclass ) { } private static class SubclassesOf extends AbstractMatcher < Class > implements Serializable { private final Class < ? > superclass ; public SubclassesOf ( Class < ? > superclass ) { } public boolean matches ( Class subclass ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } private static final long serialVersionUID = 0 ; } public static Matcher < Object > only ( Object value ) { } private static class Only extends AbstractMatcher < Object > implements Serializable { private final Object value ; public Only ( Object value ) { } public boolean matches ( Object other ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } private static final long serialVersionUID = 0 ; } public static Matcher < Object > identicalTo ( final Object value ) { } private static class IdenticalTo extends AbstractMatcher < Object > implements Serializable { private final Object value ; public IdenticalTo ( Object value ) { } public boolean matches ( Object other ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } private static final long serialVersionUID = 0 ; } public static Matcher < Class > inPackage ( final Package targetPackage ) { } private static class InPackage extends AbstractMatcher < Class > implements Serializable { private transient final Package targetPackage ; private final String packageName ; public InPackage ( Package targetPackage ) { } public boolean matches ( Class c ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } public Object readResolve ( ) { } private static final long serialVersionUID = 0 ; } public static Matcher < Class > inSubpackage ( final String targetPackageName ) { } private static class InSubpackage extends AbstractMatcher < Class > implements Serializable { private final String targetPackageName ; public InSubpackage ( String targetPackageName ) { } public boolean matches ( Class c ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } private static final long serialVersionUID = 0 ; } public static Matcher < Method > returns ( final Matcher < ? super Class < ? > > returnType ) { } private static class Returns extends AbstractMatcher < Method > implements Serializable { private final Matcher < ? super Class < ? > > returnType ; public Returns ( Matcher < ? super Class < ? > > returnType ) { } public boolean matches ( Method m ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } private static final long serialVersionUID = 0 ; } }
public class OpenALAudioDevice implements AudioDevice { private static final int bufferSize = 512 ; private static final int bufferCount = 9 ; private static final int bytesPerSample = 2 ; private static final ByteBuffer tempBuffer = BufferUtils . createByteBuffer ( OpenALAudioDevice . bufferSize ) ; private final OpenALAudio audio ; private final int channels ; private IntBuffer buffers ; private int sourceID = - 1 ; private int format ; private int sampleRate ; private boolean isPlaying ; private float volume = 1 ; private float renderedSeconds ; private float secondsPerBuffer ; private byte [ ] bytes ; public OpenALAudioDevice ( OpenALAudio audio , int sampleRate , boolean isMono ) { } public void writeSamples ( short [ ] samples , int offset , int numSamples ) { } public void writeSamples ( float [ ] samples , int offset , int numSamples ) { } public void writeSamples ( byte [ ] data , int offset , int length ) { } private int fillBuffer ( byte [ ] data , int offset , int length ) { } public void stop ( ) { } public boolean isPlaying ( ) { } public void setVolume ( float volume ) { } public float getPosition ( ) { } public void setPosition ( float position ) { } public int getChannels ( ) { } public int getRate ( ) { } public void dispose ( ) { } public boolean isMono ( ) { <START_BUG> return false ; <END_BUG> } public int getLatency ( ) { } }
public class AudioTools { public static native void convertToFloat ( ShortBuffer source , FloatBuffer target , int numSamples ) { } public static native void convertToShort ( FloatBuffer source , ShortBuffer target , int numSamples ) { } public static native void convertToMonoShort ( ShortBuffer source , ShortBuffer target , int numSamples ) { } public static native void convertToMonoFloat ( FloatBuffer source , FloatBuffer target , int numSamples ) { } public static native float spectralFlux ( FloatBuffer spectrumA , FloatBuffer spectrumB , int numSamples ) { } public static FloatBuffer allocateFloatBuffer ( int numSamples , int numChannels ) { } public static ShortBuffer allocateShortBuffer ( int numSamples , int numChannels ) { } public static void toShort ( byte [ ] src , int offsetSrc , short [ ] dst , int offsetDst , int numBytes ) { } public static void toFloat ( byte [ ] src , int offsetSrc , float [ ] dst , int offsetDst , int numBytes ) { } public static void toFloat ( short [ ] src , int offsetSrc , float [ ] dst , int offsetDst , int numBytes ) { float scale = 1.0F / ( Short . MAX_VALUE ) ; for ( int i = offsetSrc , ii = offsetDst ; i < numBytes ; i ++ , ii ++ ) <START_BUG> dst [ ii ] = ( src [ i ] ) * scale ; <END_BUG> } public static short [ ] generate ( int samplingRate , int frequency , int numSamples ) { } public static short [ ] generate ( int samplingRate , int frequency , float length ) { } public static float [ ] generateFloat ( int samplingRate , int frequency , int numSamples ) { } public static float [ ] generateFloat ( int samplingRate , int frequency , float length ) { } }
public class BaseAnimationController { public static final class Transform implements Poolable { public final Vector3 translation = new Vector3 ( ) ; public final Quaternion rotation = new Quaternion ( ) ; public final Vector3 scale = new Vector3 ( 1 , 1 , 1 ) ; public Transform ( ) { } public BaseAnimationController . Transform idt ( ) { } public BaseAnimationController . Transform set ( final Vector3 t , final Quaternion r , final Vector3 s ) { } public BaseAnimationController . Transform set ( final BaseAnimationController . Transform other ) { } public BaseAnimationController . Transform lerp ( final BaseAnimationController . Transform target , final float alpha ) { } public BaseAnimationController . Transform lerp ( final Vector3 targetT , final Quaternion targetR , final Vector3 targetS , final float alpha ) { } public Matrix4 toMatrix4 ( final Matrix4 out ) { out . idt ( ) ; out . translate ( translation ) ; out . rotate ( rotation ) ; <START_BUG> out . scl ( scale ) ; <END_BUG> return out ; } @ Override public void reset ( ) { } } private final Pool < BaseAnimationController . Transform > transformPool = new Pool < BaseAnimationController . Transform > ( ) { @ Override protected BaseAnimationController . Transform newObject ( ) { } } ; private static final ObjectMap < Node , BaseAnimationController . Transform > transforms = new ObjectMap < Node , BaseAnimationController . Transform > ( ) ; private boolean applying = false ; public final ModelInstance target ; public BaseAnimationController ( final ModelInstance target ) { } protected void begin ( ) { } protected void apply ( final Animation animation , final float time , final float weight ) { } protected void end ( ) { } protected void applyAnimation ( final Animation animation , final float time ) { } protected void applyAnimations ( final Animation anim1 , final float time1 , final Animation anim2 , final float time2 , final float weight ) { } private static final BaseAnimationController . Transform tmpT = new BaseAnimationController . Transform ( ) ; protected static void applyAnimation ( final ObjectMap < Node , BaseAnimationController . Transform > out , final Pool < BaseAnimationController . Transform > pool , final float alpha , final Animation animation , final float time ) { } }
public class QueryFacetCollectorParser implements FacetCollectorParser { public static final String NAME = "query" ; @ Override public String [ ] names ( ) { } @ Override public FacetCollector parse ( String facetName , XContentParser parser , SearchContext context ) { XContentIndexQueryParser indexQueryParser = ( ( XContentIndexQueryParser ) ( context . queryParser ( ) ) ) ; <START_BUG> Query facetQuery = indexQueryParser . parse ( parser ) ; <END_BUG> return new QueryFacetCollector ( facetName , facetQuery , context . filterCache ( ) ) ; } }
public class Assets { public static Texture background ; public static TextureRegion backgroundRegion ; public static Texture items ; public static TextureRegion mainMenu ; public static TextureRegion pauseMenu ; public static TextureRegion ready ; public static TextureRegion gameOver ; public static TextureRegion highScoresRegion ; public static TextureRegion logo ; public static TextureRegion soundOn ; public static TextureRegion soundOff ; public static TextureRegion arrow ; public static TextureRegion pause ; public static TextureRegion spring ; public static TextureRegion castle ; public static Animation coinAnim ; public static Animation bobJump ; public static Animation bobFall ; public static TextureRegion bobHit ; public static Animation squirrelFly ; public static TextureRegion platform ; public static Animation brakingPlatform ; public static BitmapFont font ; public static Music music ; public static Sound jumpSound ; public static Sound highJumpSound ; public static Sound hitSound ; public static Sound coinSound ; public static Sound clickSound ; public static Texture loadTexture ( String file ) { <START_BUG> return graphics . newTexture ( files . internal ( file ) , Nearest , Nearest , ClampToEdge , ClampToEdge ) ; <END_BUG> } public static void load ( ) { } public static void playSound ( Sound sound ) { } }
public class ShardSearchFailure implements ShardOperationFailedException { public static final ShardSearchFailure [ ] EMPTY_ARRAY = new ShardSearchFailure [ 0 ] ; private SearchShardTarget shardTarget ; private String reason ; private ShardSearchFailure ( ) { } public ShardSearchFailure ( Throwable t ) { } public ShardSearchFailure ( String reason , SearchShardTarget shardTarget ) { } @ Nullable public SearchShardTarget shard ( ) { } @ Override public String index ( ) { } @ Override public int shardId ( ) { } public String reason ( ) { } @ Override public String toString ( ) { <START_BUG> return ( ( ( "Search<seq2seq4repair_space>Failure<seq2seq4repair_space>Shard<seq2seq4repair_space>" + ( shardTarget ) ) + ",<seq2seq4repair_space>reason<seq2seq4repair_space>[" ) + ( reason ) ) + "]" ; <END_BUG> } public static ShardSearchFailure readShardSearchFailure ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public abstract class DoubleArrayAtomicFieldData extends AbstractAtomicNumericFieldData { public static DoubleArrayAtomicFieldData empty ( ) { } protected long size = - 1 ; public DoubleArrayAtomicFieldData ( ) { } @ Override public void close ( ) { } static class Empty extends DoubleArrayAtomicFieldData { Empty ( ) { } @ Override public LongValues getLongValues ( ) { } @ Override public DoubleValues getDoubleValues ( ) { } @ Override public boolean isMultiValued ( ) { } @ Override public long getNumberUniqueValues ( ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override <START_BUG> public BytesValues getBytesValues ( boolean needsHashes ) { <END_BUG> return BytesValues . EMPTY ; } @ Override public ScriptDocValues getScriptValues ( ) { } } public static class WithOrdinals extends DoubleArrayAtomicFieldData { private final DoubleArray values ; private final Ordinals ordinals ; public WithOrdinals ( DoubleArray values , Ordinals ordinals ) { } @ Override public boolean isMultiValued ( ) { } @ Override public long getNumberUniqueValues ( ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override public DoubleArrayAtomicFieldData . WithOrdinals . LongValues getLongValues ( ) { } @ Override public DoubleArrayAtomicFieldData . WithOrdinals . DoubleValues getDoubleValues ( ) { } static class LongValues extends org . elasticsearch . index . fielddata . LongValues . WithOrdinals { private final DoubleArray values ; LongValues ( DoubleArray values , Ordinals . Docs ordinals ) { } @ Override public final long getValueByOrd ( long ord ) { } } static class DoubleValues extends org . elasticsearch . index . fielddata . DoubleValues . WithOrdinals { private final DoubleArray values ; DoubleValues ( DoubleArray values , Ordinals . Docs ordinals ) { } @ Override public double getValueByOrd ( long ord ) { } } } public static class SingleFixedSet extends DoubleArrayAtomicFieldData { private final DoubleArray values ; private final FixedBitSet set ; private final long numOrds ; public SingleFixedSet ( DoubleArray values , FixedBitSet set , long numOrds ) { } @ Override public boolean isMultiValued ( ) { } @ Override public long getNumberUniqueValues ( ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override public DoubleArrayAtomicFieldData . SingleFixedSet . LongValues getLongValues ( ) { } @ Override public DoubleArrayAtomicFieldData . SingleFixedSet . DoubleValues getDoubleValues ( ) { } static class LongValues extends org . elasticsearch . index . fielddata . LongValues { private final DoubleArray values ; private final FixedBitSet set ; LongValues ( DoubleArray values , FixedBitSet set ) { } @ Override public int setDocument ( int docId ) { } @ Override public long nextValue ( ) { } } static class DoubleValues extends org . elasticsearch . index . fielddata . DoubleValues { private final DoubleArray values ; private final FixedBitSet set ; DoubleValues ( DoubleArray values , FixedBitSet set ) { } @ Override public int setDocument ( int docId ) { } @ Override public double nextValue ( ) { } } } public static class Single extends DoubleArrayAtomicFieldData { private final DoubleArray values ; private final long numOrds ; public Single ( DoubleArray values , long numOrds ) { } @ Override public boolean isMultiValued ( ) { } @ Override public long getNumberUniqueValues ( ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override public DoubleArrayAtomicFieldData . Single . LongValues getLongValues ( ) { } @ Override public DoubleArrayAtomicFieldData . Single . DoubleValues getDoubleValues ( ) { } static final class LongValues extends DenseLongValues { private final DoubleArray values ; LongValues ( DoubleArray values ) { } @ Override public long nextValue ( ) { } } static final class DoubleValues extends DenseDoubleValues { private final DoubleArray values ; DoubleValues ( DoubleArray values ) { } @ Override public double nextValue ( ) { } } } }
public class ScriptTermsStringFieldFacetCollector extends AbstractFacetCollector { private final ComparatorType comparatorType ; private final int size ; private final int numberOfShards ; private final SearchScript script ; private final Matcher matcher ; private final ImmutableSet < BytesRef > excluded ; private final TObjectIntHashMap < BytesRef > facets ; private int missing ; private int total ; public ScriptTermsStringFieldFacetCollector ( String facetName , int size , InternalStringTermsFacet . ComparatorType comparatorType , SearchContext context , ImmutableSet < BytesRef > excluded , Pattern pattern , String scriptLang , String script , Map < String , Object > params ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { } @ Override protected void doCollect ( int doc ) throws IOException { } private boolean match ( String value ) { <START_BUG> if ( ( ( excluded ) != null ) && ( excluded . contains ( value ) ) ) { <END_BUG> return false ; } if ( ( ( matcher ) != null ) && ( ! ( matcher . reset ( value ) . matches ( ) ) ) ) { return false ; } return true ; } @ Override public Facet facet ( ) { } }
public class TopHitsAggregator extends BucketsAggregator implements ScorerAware { private final FetchPhase fetchPhase ; private final TopHitsContext topHitsContext ; private final LongObjectPagedHashMap < TopDocsCollector > topDocsCollectors ; private Scorer currentScorer ; private AtomicReaderContext currentContext ; public TopHitsAggregator ( FetchPhase fetchPhase , TopHitsContext topHitsContext , String name , long estimatedBucketsCount , AggregationContext context , Aggregator parent ) { } @ Override public boolean shouldCollect ( ) { } @ Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) { } @ Override public InternalAggregation buildEmptyAggregation ( ) { <START_BUG> return new InternalTopHits ( name , topHitsContext . size ( ) , topHitsContext . sort ( ) , Lucene . EMPTY_TOP_DOCS , InternalSearchHits . empty ( ) ) ; <END_BUG> } @ Override public void collect ( int docId , long bucketOrdinal ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) { } @ Override public void setScorer ( Scorer scorer ) { } @ Override protected void doClose ( ) { } public static class Factory extends AggregatorFactory { private final FetchPhase fetchPhase ; private final TopHitsContext topHitsContext ; public Factory ( String name , FetchPhase fetchPhase , TopHitsContext topHitsContext ) { } @ Override public Aggregator create ( AggregationContext aggregationContext , Aggregator parent , long expectedBucketsCount ) { } @ Override public AggregatorFactory subFactories ( AggregatorFactories subFactories ) { } } }
public class PerformanceCounters { private static final float nano2seconds = 1.0F / 1.0E9F ; private long lastTick = 0L ; public final Array < PerformanceCounter > counters = new Array < PerformanceCounter > ( ) ; public PerformanceCounter add ( final String name , final int windowSize ) { } public PerformanceCounter add ( final String name ) { } public void tick ( ) { final long t = System . nanoTime ( ) ; if ( ( lastTick ) > 0L ) <START_BUG> tick ( ( ( ( lastTick ) - t ) * ( PerformanceCounters . nano2seconds ) ) ) ; <END_BUG> lastTick = t ; } public void tick ( final float deltaTime ) { } public StringBuilder toString ( final StringBuilder sb ) { } }
public class TermsStringOrdinalsFacetExecutor extends FacetExecutor { private final WithOrdinals indexFieldData ; final CacheRecycler cacheRecycler ; final BigArrays bigArrays ; private final ComparatorType comparatorType ; private final int size ; private final int shardSize ; private final int minCount ; private final ImmutableSet < BytesRef > excluded ; private final Matcher matcher ; final int ordinalsCacheAbove ; final List < TermsStringOrdinalsFacetExecutor . ReaderAggregator > aggregators ; long missing ; long total ; public TermsStringOrdinalsFacetExecutor ( IndexFieldData . WithOrdinals indexFieldData , int size , int shardSize , TermsFacet . ComparatorType comparatorType , boolean allTerms , SearchContext context , ImmutableSet < BytesRef > excluded , Pattern pattern , int ordinalsCacheAbove ) { } @ Override public TermsStringOrdinalsFacetExecutor . Collector collector ( ) { } @ Override public InternalFacet buildFacet ( String facetName ) { } class Collector extends FacetExecutor . Collector { private long missing ; private long total ; private BytesValues . WithOrdinals values ; private TermsStringOrdinalsFacetExecutor . ReaderAggregator current ; private Docs ordinals ; @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { if ( ( current ) != null ) { missing += current . missing ; total += current . total ; if ( ( current . values . ordinals ( ) . getMaxOrd ( ) ) > ( Ordinals . MIN_ORDINAL ) ) { aggregators . add ( current ) ; } else { Releasables . close ( current ) ; } } <START_BUG> values = indexFieldData . load ( context ) . getBytesValues ( false ) ; <END_BUG> current = new TermsStringOrdinalsFacetExecutor . ReaderAggregator ( values , ordinalsCacheAbove , cacheRecycler ) ; ordinals = values . ordinals ( ) ; } @ Override public void collect ( int doc ) throws IOException { } @ Override public void postCollection ( ) { } } public final class ReaderAggregator implements Releasable { private final long maxOrd ; final BytesValues . WithOrdinals values ; final IntArray counts ; int missing = 0 ; long position = ( Ordinals . MIN_ORDINAL ) - 1 ; BytesRef current ; int total ; public ReaderAggregator ( BytesValues . WithOrdinals values , int ordinalsCacheLimit , CacheRecycler cacheRecycler ) { } final void onOrdinal ( int docId , long ordinal ) { } final void incrementMissing ( int numMissing ) { } public boolean nextPosition ( ) { } public BytesRef copyCurrent ( ) { } @ Override public void close ( ) { } } public static class AggregatorPriorityQueue extends PriorityQueue < TermsStringOrdinalsFacetExecutor . ReaderAggregator > { public AggregatorPriorityQueue ( int size ) { } @ Override protected boolean lessThan ( TermsStringOrdinalsFacetExecutor . ReaderAggregator a , TermsStringOrdinalsFacetExecutor . ReaderAggregator b ) { } } }
public class BulkProcessor { public static interface Listener { void beforeBulk ( long executionId , BulkRequest request ) { } void afterBulk ( long executionId , BulkRequest request , BulkResponse response ) { } void afterBulk ( long executionId , BulkRequest request , Throwable failure ) { } } public static class Builder { private final Client client ; private final BulkProcessor . Listener listener ; private String name ; private int concurrentRequests = 1 ; private int bulkActions = 1000 ; private ByteSizeValue bulkSize = new ByteSizeValue ( 5 , ByteSizeUnit . MB ) ; private TimeValue flushInterval = null ; public Builder ( Client client , BulkProcessor . Listener listener ) { } public BulkProcessor . Builder setName ( String name ) { } public BulkProcessor . Builder setConcurrentRequests ( int concurrentRequests ) { } public BulkProcessor . Builder setBulkActions ( int bulkActions ) { } public BulkProcessor . Builder setBulkSize ( ByteSizeValue bulkSize ) { } public BulkProcessor . Builder setFlushInterval ( TimeValue flushInterval ) { } public BulkProcessor build ( ) { } } public static BulkProcessor . Builder builder ( Client client , BulkProcessor . Listener listener ) { } private final Client client ; private final BulkProcessor . Listener listener ; private final String name ; private final int concurrentRequests ; private final int bulkActions ; private final int bulkSize ; private final TimeValue flushInterval ; private final Semaphore semaphore ; private final ScheduledThreadPoolExecutor scheduler ; private final ScheduledFuture scheduledFuture ; private final AtomicLong executionIdGen = new AtomicLong ( ) ; private BulkRequest bulkRequest ; private volatile boolean closed = false ; BulkProcessor ( Client client , BulkProcessor . Listener listener , @ Nullable String name , int concurrentRequests , int bulkActions , ByteSizeValue bulkSize , @ Nullable TimeValue flushInterval ) { } public synchronized void close ( ) { } public BulkProcessor add ( IndexRequest request ) { } public BulkProcessor add ( DeleteRequest request ) { } public BulkProcessor add ( ActionRequest request ) { } public BulkProcessor add ( ActionRequest request , @ Nullable Object payload ) { } private synchronized void internalAdd ( ActionRequest request , @ Nullable Object payload ) { } public BulkProcessor add ( BytesReference data , boolean contentUnsafe , @ Nullable String defaultIndex , @ Nullable String defaultType ) throws Exception { } public synchronized BulkProcessor add ( BytesReference data , boolean contentUnsafe , @ Nullable String defaultIndex , @ Nullable String defaultType , @ Nullable Object payload ) throws Exception { <START_BUG> bulkRequest . add ( data , contentUnsafe , defaultIndex , defaultType , payload ) ; <END_BUG> executeIfNeeded ( ) ; return this ; } private void executeIfNeeded ( ) { } private void execute ( ) { } private boolean isOverTheLimit ( ) { } class Flush implements Runnable { @ Override public void run ( ) { } } }
public class MultiValueShortFieldData extends ShortFieldData { private static final int VALUE_CACHE_SIZE = 10 ; private ThreadLocal < ThreadLocals . CleanableValue < double [ ] [ ] > > doublesValuesCache = new ThreadLocal < ThreadLocals . CleanableValue < double [ ] [ ] > > ( ) { @ Override protected ThreadLocals . CleanableValue < double [ ] [ ] > initialValue ( ) { } } ; private ThreadLocal < ThreadLocals . CleanableValue < short [ ] [ ] > > valuesCache = new ThreadLocal < ThreadLocals . CleanableValue < short [ ] [ ] > > ( ) { @ Override protected ThreadLocals . CleanableValue < short [ ] [ ] > initialValue ( ) { } } ; private final int [ ] [ ] ordinals ; public MultiValueShortFieldData ( String fieldName , int [ ] [ ] ordinals , short [ ] values ) { } @ Override protected long computeSizeInBytes ( ) { } @ Override public boolean multiValued ( ) { } @ Override public boolean hasValue ( int docId ) { } @ Override public void forEachValueInDoc ( int docId , StringValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , DoubleValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , LongValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , MissingDoubleValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , MissingLongValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , ValueInDocProc proc ) { } @ Override public void forEachOrdinalInDoc ( int docId , OrdinalInDocProc proc ) { boolean found = false ; for ( int [ ] ordinal : ordinals ) { int loc = ordinal [ docId ] ; if ( loc != 0 ) { found = true ; <START_BUG> proc . onOrdinal ( docId , ordinal [ docId ] ) ; <END_BUG> } } if ( ! found ) { proc . onOrdinal ( docId , 0 ) ; } } @ Override public double [ ] doubleValues ( int docId ) { } @ Override public short value ( int docId ) { } @ Override public short [ ] values ( int docId ) { } }
public class GeoPointBinaryDVIndexFieldData extends DocValuesIndexFieldData implements IndexGeoPointFieldData < AtomicGeoPointFieldData < ScriptDocValues > > { public GeoPointBinaryDVIndexFieldData ( Index index , Names fieldNames , FieldDataType fieldDataType ) { } @ Override public boolean valuesOrdered ( ) { } @ Override public final XFieldComparatorSource comparatorSource ( @ Nullable Object missingValue , SortMode sortMode ) { } @ Override public AtomicGeoPointFieldData < ScriptDocValues > load ( AtomicReaderContext context ) { try { <START_BUG> return new GeoPointBinaryDVAtomicFieldData ( context . reader ( ) , context . reader ( ) . getBinaryDocValues ( fieldNames . indexName ( ) ) ) ; <END_BUG> } catch ( IOException e ) { throw new ElasticsearchIllegalStateException ( "Cannot<seq2seq4repair_space>load<seq2seq4repair_space>doc<seq2seq4repair_space>values" , e ) ; } } @ Override public AtomicGeoPointFieldData < ScriptDocValues > loadDirect ( AtomicReaderContext context ) throws Exception { } public static class Builder implements IndexFieldData . Builder { @ Override public IndexFieldData < ? > build ( Index index , Settings indexSettings , FieldMapper < ? > mapper , IndexFieldDataCache cache , CircuitBreakerService breakerService , MapperService mapperService , GlobalOrdinalsBuilder globalOrdinalBuilder ) { } } }
public class TransportCountAction extends TransportBroadcastOperationAction < CountRequest , CountResponse , ShardCountRequest , ShardCountResponse > { private final IndicesService indicesService ; private final ScriptService scriptService ; @ Inject public TransportCountAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService , ScriptService scriptService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected CountRequest newRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ShardRouting shard , CountRequest request ) { } @ Override protected ShardCountResponse newShardResponse ( ) { } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , CountRequest request , String [ ] concreteIndices ) { Map < String , Set < String > > routingMap = clusterState . metaData ( ) . resolveSearchRouting ( request . routing ( ) , request . indices ( ) ) ; <START_BUG> return clusterService . operationRouting ( ) . searchShards ( clusterState , request . indices ( ) , concreteIndices , request . queryHint ( ) , routingMap , null ) ; <END_BUG> } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , CountRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , CountRequest countRequest , String [ ] concreteIndices ) { } @ Override protected CountResponse newResponse ( CountRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardCountResponse shardOperation ( ShardCountRequest request ) throws ElasticSearchException { } }
@ ClusterScope ( numNodes = 0 , scope = Scope . TEST ) public class QuorumLocalGatewayTests extends ElasticsearchIntegrationTest { @ Test @ Slow public void testChangeInitialShardsRecovery ( ) throws Exception { logger . info ( "--><seq2seq4repair_space>starting<seq2seq4repair_space>3<seq2seq4repair_space>nodes" ) ; final String [ ] nodes = new String [ 3 ] ; nodes [ 0 ] = cluster ( ) . startNode ( settingsBuilder ( ) . put ( "gateway.type" , "local" ) . put ( "index.number_of_shards" , 2 ) . put ( "index.number_of_replicas" , 2 ) . build ( ) ) ; nodes [ 1 ] = cluster ( ) . startNode ( settingsBuilder ( ) . put ( "gateway.type" , "local" ) . put ( "index.number_of_shards" , 2 ) . put ( "index.number_of_replicas" , 2 ) . build ( ) ) ; nodes [ 2 ] = cluster ( ) . startNode ( settingsBuilder ( ) . put ( "gateway.type" , "local" ) . put ( "index.number_of_shards" , 2 ) . put ( "index.number_of_replicas" , 2 ) . build ( ) ) ; logger . info ( "--><seq2seq4repair_space>indexing..." ) ; client ( ) . prepareIndex ( "test" , "type1" , "1" ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( "field" , "value1" ) . endObject ( ) ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . get ( ) ; client ( ) . prepareIndex ( "test" , "type1" , "2" ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( "field" , "value2" ) . endObject ( ) ) . get ( ) ; assertNoFailures ( client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . get ( ) ) ; logger . info ( "--><seq2seq4repair_space>running<seq2seq4repair_space>cluster_health<seq2seq4repair_space>(wait<seq2seq4repair_space>for<seq2seq4repair_space>the<seq2seq4repair_space>shards<seq2seq4repair_space>to<seq2seq4repair_space>startup)" ) ; ClusterHealthResponse clusterHealth = client ( ) . admin ( ) . cluster ( ) . health ( clusterHealthRequest ( ) . waitForGreenStatus ( ) . waitForActiveShards ( 6 ) ) . actionGet ( ) ; logger . info ( ( "--><seq2seq4repair_space>done<seq2seq4repair_space>cluster_health,<seq2seq4repair_space>status<seq2seq4repair_space>" + ( clusterHealth . getStatus ( ) ) ) ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( clusterHealth . getStatus ( ) , equalTo ( GREEN ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { assertHitCount ( client ( ) . prepareCount ( ) . setQuery ( matchAllQuery ( ) ) . get ( ) , 2L ) ; } final String nodeToRemove = nodes [ between ( 0 , 2 ) ] ; logger . info ( "--><seq2seq4repair_space>restarting<seq2seq4repair_space>1<seq2seq4repair_space>nodes<seq2seq4repair_space>--<seq2seq4repair_space>kill<seq2seq4repair_space>2" ) ; cluster ( ) . fullRestart ( new RestartCallback ( ) { @ Override public Settings onNodeStopped ( String nodeName ) throws Exception { return settingsBuilder ( ) . put ( "gateway.type" , "local" ) . build ( ) ; } @ Override public boolean doRestart ( String nodeName ) { return nodeToRemove . equals ( nodeName ) ; } } ) ; if ( randomBoolean ( ) ) { Thread . sleep ( between ( 1 , 400 ) ) ; } clusterHealth = client ( ) . admin ( ) . cluster ( ) . health ( clusterHealthRequest ( ) . waitForNodes ( "1" ) ) . actionGet ( ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( clusterHealth . getStatus ( ) , equalTo ( RED ) ) ; assertThat ( awaitBusy ( new Predicate < Object > ( ) { @ Override public boolean apply ( Object input ) { ClusterStateResponse clusterStateResponse = cluster ( ) . smartClient ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setMasterNodeTimeout ( "500ms" ) . get ( ) ; <START_BUG> return ( clusterStateResponse . getState ( ) ) != null ; <END_BUG> } } ) , equalTo ( true ) ) ; final ClusterStateResponse clusterStateResponse = cluster ( ) . smartClient ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setMasterNodeTimeout ( "500ms" ) . get ( ) ; assertThat ( clusterStateResponse . getState ( ) , notNullValue ( ) ) ; assertThat ( clusterStateResponse . getState ( ) . routingTable ( ) . index ( "test" ) , notNullValue ( ) ) ; assertThat ( clusterStateResponse . getState ( ) . routingTable ( ) . index ( "test" ) . allPrimaryShardsActive ( ) , is ( false ) ) ; logger . info ( "--><seq2seq4repair_space>change<seq2seq4repair_space>the<seq2seq4repair_space>recovery.initial_shards<seq2seq4repair_space>setting,<seq2seq4repair_space>and<seq2seq4repair_space>make<seq2seq4repair_space>sure<seq2seq4repair_space>its<seq2seq4repair_space>recovered" ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( "test" ) . setSettings ( settingsBuilder ( ) . put ( "recovery.initial_shards" , 1 ) ) . get ( ) ; logger . info ( "--><seq2seq4repair_space>running<seq2seq4repair_space>cluster_health<seq2seq4repair_space>(wait<seq2seq4repair_space>for<seq2seq4repair_space>the<seq2seq4repair_space>shards<seq2seq4repair_space>to<seq2seq4repair_space>startup),<seq2seq4repair_space>2<seq2seq4repair_space>shards<seq2seq4repair_space>since<seq2seq4repair_space>we<seq2seq4repair_space>only<seq2seq4repair_space>have<seq2seq4repair_space>1<seq2seq4repair_space>node" ) ; clusterHealth = client ( ) . admin ( ) . cluster ( ) . health ( clusterHealthRequest ( ) . waitForYellowStatus ( ) . waitForActiveShards ( 2 ) ) . actionGet ( ) ; logger . info ( ( "--><seq2seq4repair_space>done<seq2seq4repair_space>cluster_health,<seq2seq4repair_space>status<seq2seq4repair_space>" + ( clusterHealth . getStatus ( ) ) ) ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( clusterHealth . getStatus ( ) , equalTo ( YELLOW ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { assertHitCount ( client ( ) . prepareCount ( ) . setQuery ( matchAllQuery ( ) ) . get ( ) , 2L ) ; } } @ Test @ Slow public void testQuorumRecovery ( ) throws Exception { } }
public class TransportBroadcastPingAction extends TransportBroadcastOperationAction < BroadcastPingRequest , BroadcastPingResponse , BroadcastShardPingRequest , BroadcastShardPingResponse > { @ Inject public TransportBroadcastPingAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected BroadcastPingRequest newRequest ( ) { } @ Override protected GroupShardsIterator shards ( BroadcastPingRequest request , ClusterState clusterState ) { <START_BUG> return clusterService . operationRouting ( ) . searchShards ( clusterState , request . indices ( ) , request . queryHint ( ) ) ; <END_BUG> } @ Override protected BroadcastPingResponse newResponse ( BroadcastPingRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected BroadcastShardPingRequest newShardRequest ( ) { } @ Override protected BroadcastShardPingRequest newShardRequest ( ShardRouting shard , BroadcastPingRequest request ) { } @ Override protected BroadcastShardPingResponse newShardResponse ( ) { } @ Override protected BroadcastShardPingResponse shardOperation ( BroadcastShardPingRequest broadcastShardPingRequest ) throws ElasticSearchException { } }
public class IndicesQueryParser implements QueryParser { public static final String NAME = "indices" ; @ Nullable private final ClusterService clusterService ; @ Inject public IndicesQueryParser ( @ Nullable ClusterService clusterService ) { } @ Override public String [ ] names ( ) { } @ Override public Query parse ( QueryParseContext parseContext ) throws IOException , QueryParsingException { } protected boolean matchesIndices ( String currentIndex , String ... indices ) { <START_BUG> final String [ ] concreteIndices = clusterService . state ( ) . metaData ( ) . concreteIndices ( indices , org . elasticsearch . action . support . IndicesOptions . lenientExpandOpen ( ) ) ; <END_BUG> for ( String index : concreteIndices ) { if ( Regex . simpleMatch ( index , currentIndex ) ) { return true ; } } return false ; } }
public class BitmapFontCache { private final BitmapFont font ; private float [ ] [ ] vertexData ; private int [ ] idx ; private int [ ] tmpGlyphCount ; private float x ; private float y ; private float color = WHITE . toFloatBits ( ) ; private final Color tempColor = new Color ( 1 , 1 , 1 , 1 ) ; private final TextBounds textBounds = new TextBounds ( ) ; private boolean integer = true ; private int glyphCount = 0 ; private IntArray [ ] glyphIndices ; public BitmapFontCache ( BitmapFont font ) { } public BitmapFontCache ( BitmapFont font , boolean integer ) { } public void setPosition ( float x , float y ) { } public void translate ( float xAmount , float yAmount ) { } public void setColors ( float color ) { } public void setColors ( Color tint ) { } public void setColors ( float r , float g , float b , float a ) { } public void setColors ( Color tint , int start , int end ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public void setColor ( float color ) { } public Color getColor ( ) { } public void draw ( Batch spriteBatch ) { TextureRegion [ ] regions = font . getRegions ( ) ; for ( int j = 0 , n = vertexData . length ; j < n ; j ++ ) { <START_BUG> if ( ( idx [ j ] ) >= 0 ) { <END_BUG> float [ ] vertices = vertexData [ j ] ; spriteBatch . draw ( regions [ j ] . getTexture ( ) , vertices , 0 , idx [ j ] ) ; } } } public void draw ( Batch spriteBatch , int start , int end ) { } public void draw ( Batch spriteBatch , float alphaModulation ) { } public void clear ( ) { } private void requireSequence ( CharSequence seq , int start , int end ) { } private void require ( int page , int glyphCount ) { } private float addToCache ( CharSequence str , float x , float y , int start , int end ) { } private void addGlyph ( Glyph glyph , float x , float y , float width , float height ) { } public TextBounds setText ( CharSequence str , float x , float y ) { } public TextBounds setText ( CharSequence str , float x , float y , int start , int end ) { } public TextBounds addText ( CharSequence str , float x , float y ) { } public TextBounds addText ( CharSequence str , float x , float y , int start , int end ) { } public TextBounds setMultiLineText ( CharSequence str , float x , float y ) { } public TextBounds setMultiLineText ( CharSequence str , float x , float y , float alignmentWidth , HAlignment alignment ) { } public TextBounds addMultiLineText ( CharSequence str , float x , float y ) { } public TextBounds addMultiLineText ( CharSequence str , float x , float y , float alignmentWidth , HAlignment alignment ) { } public TextBounds setWrappedText ( CharSequence str , float x , float y , float wrapWidth ) { } public TextBounds setWrappedText ( CharSequence str , float x , float y , float wrapWidth , HAlignment alignment ) { } public TextBounds addWrappedText ( CharSequence str , float x , float y , float wrapWidth ) { } public TextBounds addWrappedText ( CharSequence str , float x , float y , float wrapWidth , HAlignment alignment ) { } public TextBounds getBounds ( ) { } public float getX ( ) { } public float getY ( ) { } public BitmapFont getFont ( ) { } public void setUseIntegerPositions ( boolean use ) { } public boolean usesIntegerPositions ( ) { } public float [ ] getVertices ( ) { } public float [ ] getVertices ( int page ) { } }
public class FsChannelSnapshot implements Translog . Snapshot { private final ShardId shardId ; private final long id ; private final int totalOperations ; private final int snapshotOperations ; private final RafReference raf ; private final FileChannel channel ; private final long length ; private Operation lastOperationRead = null ; private int position = 0 ; private ByteBuffer cacheBuffer ; public FsChannelSnapshot ( ShardId shardId , long id , RafReference raf , long length , int totalOperations , int snapshotOperations ) throws FileNotFoundException { } @ Override public long translogId ( ) { } @ Override public long position ( ) { } @ Override public long length ( ) { } @ Override public int totalOperations ( ) { } @ Override public int snapshotOperations ( ) { } @ Override public InputStream stream ( ) throws IOException { } @ Override public long lengthInBytes ( ) { } @ Override public boolean hasNext ( ) { } @ Override public Operation next ( ) { } @ Override public void seekForward ( long length ) { } @ Override public boolean release ( ) throws ElasticSearchException { <START_BUG> raf . decreaseRefCount ( ) ; <END_BUG> return true ; } }
public abstract class MetricsAggregationBuilder < B extends MetricsAggregationBuilder < B > > extends AbstractAggregationBuilder { public MetricsAggregationBuilder ( String name , String type ) { } @ Override public final XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { <START_BUG> builder . startObject ( name ) . startObject ( type ) ; <END_BUG> internalXContent ( builder , params ) ; return builder . endObject ( ) . endObject ( ) ; } protected abstract void internalXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class AnalyzeResponse implements Iterable < AnalyzeResponse . AnalyzeToken > , ActionResponse , ToXContent { public static class AnalyzeToken implements Streamable { private String term ; private int startOffset ; private int endOffset ; private int position ; private String type ; AnalyzeToken ( ) { } public AnalyzeToken ( String term , int position , int startOffset , int endOffset , String type ) { } public String term ( ) { } public String getTerm ( ) { } public int startOffset ( ) { } public int getStartOffset ( ) { } public int endOffset ( ) { } public int getEndOffset ( ) { } public int position ( ) { } public int getPosition ( ) { } public String type ( ) { } public String getType ( ) { } public static AnalyzeResponse . AnalyzeToken readAnalyzeToken ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { out . writeUTF ( term ) ; out . writeInt ( startOffset ) ; out . writeInt ( endOffset ) ; out . writeVInt ( position ) ; if ( ( type ) == null ) { out . writeBoolean ( false ) ; } else { <START_BUG> out . writeBoolean ( false ) ; <END_BUG> out . writeUTF ( type ) ; } } } private List < AnalyzeResponse . AnalyzeToken > tokens ; AnalyzeResponse ( ) { } public AnalyzeResponse ( List < AnalyzeResponse . AnalyzeToken > tokens ) { } public List < AnalyzeResponse . AnalyzeToken > tokens ( ) { } public List < AnalyzeResponse . AnalyzeToken > getTokens ( ) { } @ Override public Iterator < AnalyzeResponse . AnalyzeToken > iterator ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( tokens . size ( ) ) ; for ( AnalyzeResponse . AnalyzeToken token : tokens ) { token . writeTo ( out ) ; } } }
private final AtomicBoolean open = new AtomicBoolean ( true ) ; private final Settings defaultSettings ; private AtomicInteger nextNodeId = new AtomicInteger ( 0 ) ; private final long [ ] sharedNodesSeeds ; private final NodeSettingsSource nodeSettingsSource ; private final ExecutorService executor ; public TestCluster ( long clusterSeed , String clusterName ) { } public TestCluster ( long clusterSeed , int minNumNodes , int maxNumNodes , String clusterName ) { } public TestCluster ( long clusterSeed , int minNumNodes , int maxNumNodes , String clusterName , NodeSettingsSource nodeSettingsSource ) { } public String getClusterName ( ) { } private static boolean isLocalTransportConfigured ( ) { } private Settings getSettings ( int nodeOrdinal , long nodeSeed , Settings others ) { } private static Settings getRandomNodeSettings ( long seed ) { } public static String clusterName ( String prefix , String childVMId , long clusterSeed ) { } private void ensureOpen ( ) { } private synchronized TestCluster . NodeAndClient getOrBuildRandomNode ( ) { } private synchronized TestCluster . NodeAndClient getRandomNodeAndClient ( ) { } private synchronized TestCluster . NodeAndClient getRandomNodeAndClient ( Predicate < TestCluster . NodeAndClient > predicate ) { } public void ensureAtLeastNumNodes ( int n ) { } public synchronized void ensureAtMostNumNodes ( int n ) { } private TestCluster . NodeAndClient buildNode ( Settings settings , Version version ) { } private TestCluster . NodeAndClient buildNode ( ) { } private TestCluster . NodeAndClient buildNode ( int nodeId , long seed , Settings settings , Version version ) { } private String buildNodeName ( int id ) { } @ Override public synchronized Client client ( ) { } public synchronized Client masterClient ( ) { } public synchronized Client nonMasterClient ( ) { } public synchronized Client clientNodeClient ( ) { } public synchronized Client transportClient ( ) { } public synchronized Client client ( String nodeName ) { } public synchronized Client smartClient ( ) { } public synchronized Client client ( final Predicate < Settings > filterPredicate ) { } @ Override public void close ( ) { } private final class NodeAndClient implements Closeable { private InternalNode node ; private Client client ; private Client nodeClient ; private Client transportClient ; private final AtomicBoolean closed = new AtomicBoolean ( false ) ; private final TestCluster . ClientFactory clientFactory ; private final String name ; NodeAndClient ( String name , Node node , TestCluster . ClientFactory factory ) { } Node node ( ) { } Client client ( Random random ) { } Client nodeClient ( ) { } Client transportClient ( ) { } void resetClient ( ) { } void restart ( TestCluster . RestartCallback callback ) throws Exception { } @ Override public void close ( ) { } } static class ClientFactory { public Client client ( Node node , String clusterName , Random random ) { } } static class TransportClientFactory extends TestCluster . ClientFactory { private boolean sniff ; public static TestCluster . TransportClientFactory NO_SNIFF_CLIENT_FACTORY = new TestCluster . TransportClientFactory ( false ) ; public static TestCluster . TransportClientFactory SNIFF_CLIENT_FACTORY = new TestCluster . TransportClientFactory ( true ) ; private TransportClientFactory ( boolean sniff ) { } @ Override public Client client ( Node node , String clusterName , Random random ) { } } class RandomClientFactory extends TestCluster . ClientFactory { @ Override public Client client ( Node node , String clusterName , Random random ) { } } @ Override public synchronized void beforeTest ( Random random , double transportClientRatio ) { } private synchronized void reset ( boolean wipeData ) { } @ Override public synchronized void afterTest ( ) { } private void resetClients ( ) { } private void wipeDataDirectories ( ) { if ( ! ( dataDirToClean . isEmpty ( ) ) ) { boolean deleted = false ; try { <START_BUG> deleted = FileSystemUtils . deleteRecursively ( dataDirToClean . toArray ( new File [ dataDirToClean . size ( ) ] ) , false ) ; <END_BUG> } finally { logger . info ( "Wipe<seq2seq4repair_space>data<seq2seq4repair_space>directory<seq2seq4repair_space>for<seq2seq4repair_space>all<seq2seq4repair_space>nodes<seq2seq4repair_space>locations:<seq2seq4repair_space>{}<seq2seq4repair_space>success:<seq2seq4repair_space>{}" , this . dataDirToClean , deleted ) ; this . dataDirToClean . clear ( ) ; } } } public synchronized ClusterService clusterService ( ) { } public synchronized < T > Iterable < T > getInstances ( Class < T > clazz ) { } public synchronized < T > T getInstance ( Class < T > clazz , final String node ) { } public synchronized < T > T getInstance ( Class < T > clazz ) { } private synchronized < T > T getInstanceFromNode ( Class < T > clazz , InternalNode node ) { } @ Override public synchronized int size ( ) { } @ Override public InetSocketAddress [ ] httpAddresses ( ) { } public synchronized void stopRandomNode ( ) { } public synchronized void stopRandomNode ( final Predicate < Settings > filter ) { } public synchronized void stopCurrentMasterNode ( ) { } public void stopRandomNonMasterNode ( ) { } public void restartRandomNode ( ) throws Exception { } public void restartRandomNode ( TestCluster . RestartCallback callback ) throws Exception { } private void restartAllNodes ( boolean rollingRestart , TestCluster . RestartCallback callback ) throws Exception { } private static final TestCluster . RestartCallback EMPTY_CALLBACK = new TestCluster . RestartCallback ( ) { public Settings onNodeStopped ( String node ) { } } ; public void fullRestart ( ) throws Exception { } public void rollingRestart ( ) throws Exception { } public void rollingRestart ( TestCluster . RestartCallback function ) throws Exception { } public void fullRestart ( TestCluster . RestartCallback function ) throws Exception { } private String getMasterName ( ) { } synchronized Set < String > allButN ( int numNodes ) { } private synchronized Set < String > nRandomNodes ( int numNodes ) { } public synchronized void startNodeClient ( Settings settings ) { } public synchronized Set < String > nodesInclude ( String index ) { }
public class SimpleAnimationTest extends GdxTest implements InputProcessor { @ Override public boolean needsGL20 ( ) { } private Animation currentWalk ; private float currentFrameTime ; private Vector2 position ; private Texture tex ; private Animation downWalk ; private Animation leftWalk ; private Animation rightWalk ; private Animation upWalk ; private SpriteBatch spriteBatch ; private static final float ANIMATION_SPEED = 0.2F ; @ Override public void create ( ) { } @ Override public void render ( ) { } @ Override public boolean touchDown ( int x , int y , int pointer , int button ) { position . x = x ; <START_BUG> position . y = ( - y ) + 48 ; <END_BUG> return true ; } @ Override public boolean keyDown ( int keycode ) { } @ Override public boolean keyUp ( int keycode ) { } @ Override public boolean keyTyped ( char character ) { } @ Override public boolean touchUp ( int x , int y , int pointer , int button ) { } @ Override public boolean touchDragged ( int x , int y , int pointer ) { } @ Override public boolean touchMoved ( int x , int y ) { } @ Override public boolean scrolled ( int amount ) { } }
public class FetchPhase implements SearchPhase { private final HighlightPhase highlightPhase ; @ Inject public FetchPhase ( HighlightPhase highlightPhase ) { } @ Override public Map < String , ? extends SearchParseElement > parseElements ( ) { } @ Override public void preProcess ( SearchContext context ) { } public void execute ( SearchContext context ) { } private void doExplanation ( SearchContext context , int docId , InternalSearchHit searchHit ) { } private byte [ ] extractSource ( Document doc , DocumentMapper documentMapper ) { Fieldable sourceField = doc . getFieldable ( NAME ) ; if ( sourceField != null ) { <START_BUG> return documentMapper . sourceMapper ( ) . value ( sourceField ) ; <END_BUG> } return null ; } private Uid extractUid ( SearchContext context , Document doc ) { } private Document loadDocument ( SearchContext context , FieldSelector fieldSelector , int docId ) { } private FieldSelector buildFieldSelectors ( SearchContext context ) { } }
public class TextButtonTestGL2 extends TextButtonTest { @ Override public boolean needsGL20 ( ) { <START_BUG> return super . needsGL20 ( ) ; <END_BUG> } }
public class ClusterStateResponse extends ActionResponse { private ClusterName clusterName ; private ClusterState clusterState ; public ClusterStateResponse ( ) { } public ClusterStateResponse ( ClusterName clusterName , ClusterState clusterState ) { } public ClusterState getState ( ) { } public ClusterName getClusterName ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; clusterName = ClusterName . readClusterName ( in ) ; <START_BUG> clusterState = Builder . readFrom ( in , null ) ; <END_BUG> } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public class RestSearchAction extends BaseRestHandler { private static final Pattern fieldsPattern ; private static final Pattern indicesBoostPattern ; @ Inject public RestSearchAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { SearchRequest searchRequest ; try { searchRequest = parseSearchRequest ( request ) ; searchRequest . listenerThreaded ( false ) ; SearchOperationThreading operationThreading = SearchOperationThreading . fromString ( request . param ( "operation_threading" ) , SINGLE_THREAD ) ; if ( operationThreading == ( SearchOperationThreading . NO_THREADS ) ) { operationThreading = SearchOperationThreading . SINGLE_THREAD ; } searchRequest . operationThreading ( operationThreading ) ; } catch ( Exception e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>parse<seq2seq4repair_space>search<seq2seq4repair_space>request<seq2seq4repair_space>parameters" , e ) ; } try { XContentBuilder builder = restContentBuilder ( request ) ; channel . sendResponse ( new org . elasticsearch . rest . XContentRestResponse ( request , BAD_REQUEST , builder . startObject ( ) . field ( "error" , e . getMessage ( ) ) . endObject ( ) ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } return ; } client . search ( searchRequest , new org . elasticsearch . action . ActionListener < SearchResponse > ( ) { @ Override public void onResponse ( SearchResponse response ) { try { XContentBuilder builder = restContentBuilder ( request ) ; builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; <START_BUG> channel . sendResponse ( new org . elasticsearch . rest . XContentRestResponse ( request , OK , builder ) ) ; <END_BUG> } catch ( Exception e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>execute<seq2seq4repair_space>search<seq2seq4repair_space>(building<seq2seq4repair_space>response)" , e ) ; } onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new org . elasticsearch . rest . XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } private SearchRequest parseSearchRequest ( RestRequest request ) { } private SearchSourceBuilder parseSearchSource ( RestRequest request ) { } }
public class Bresenham2 { private final Array < GridPoint2 > points = new Array < GridPoint2 > ( ) ; private final Pool < GridPoint2 > pool = new Pool < GridPoint2 > ( ) { @ Override protected GridPoint2 newObject ( ) { } } ; public Array < GridPoint2 > line ( GridPoint2 start , GridPoint2 end ) { <START_BUG> return line ( start . x , start . y , end . x , end . y ) ; <END_BUG> } public Array < GridPoint2 > line ( int startX , int startY , int endX , int endY ) { } public Array < GridPoint2 > line ( int startX , int startY , int endX , int endY , Pool < GridPoint2 > pool , Array < GridPoint2 > output ) { } }
public class GestureDetector extends InputAdapter { final GestureDetector . GestureListener listener ; private float tapSquareSize ; private long tapCountInterval ; private float longPressSeconds ; private long maxFlingDelay ; private boolean inTapSquare ; private int tapCount ; private long lastTapTime ; private float lastTapX ; private float lastTapY ; private int lastTapButton ; private int lastTapPointer ; boolean longPressFired ; private boolean pinching ; private boolean panning ; private final GestureDetector . VelocityTracker tracker = new GestureDetector . VelocityTracker ( ) ; private float tapSquareCenterX ; private float tapSquareCenterY ; private long gestureStartTime ; Vector2 pointer1 = new Vector2 ( ) ; private final Vector2 pointer2 = new Vector2 ( ) ; private final Vector2 initialPointer1 = new Vector2 ( ) ; private final Vector2 initialPointer2 = new Vector2 ( ) ; private final Task longPressTask = new Task ( ) { @ Override public void run ( ) { } } ; public GestureDetector ( GestureDetector . GestureListener listener ) { } public GestureDetector ( float halfTapSquareSize , float tapCountInterval , float longPressDuration , float maxFlingDelay , GestureDetector . GestureListener listener ) { } @ Override public boolean touchDown ( int x , int y , int pointer , int button ) { } public boolean touchDown ( float x , float y , int pointer , int button ) { } @ Override public boolean touchDragged ( int x , int y , int pointer ) { } public boolean touchDragged ( float x , float y , int pointer ) { } @ Override public boolean touchUp ( int x , int y , int pointer , int button ) { } public boolean touchUp ( float x , float y , int pointer , int button ) { } public void cancel ( ) { } public boolean isLongPressed ( ) { } public boolean isLongPressed ( float duration ) { } public boolean isPanning ( ) { } public void reset ( ) { } private boolean isWithinTapSquare ( float x , float y , float centerX , float centerY ) { } public void invalidateTapSquare ( ) { } <START_BUG> public void setTapSquareSize ( float tapSquareSize ) { <END_BUG> this . tapSquareSize = tapSquareSize ; } public void setTapCountInterval ( float tapCountInterval ) { } public void setLongPressSeconds ( float longPressSeconds ) { } public void setMaxFlingDelay ( long maxFlingDelay ) { } public static interface GestureListener { public boolean touchDown ( float x , float y , int pointer , int button ) { } public boolean tap ( float x , float y , int count , int button ) { } public boolean longPress ( float x , float y ) { } public boolean fling ( float velocityX , float velocityY , int button ) { } public boolean pan ( float x , float y , float deltaX , float deltaY ) { } public boolean panStop ( float x , float y , int pointer , int button ) { } public boolean zoom ( float initialDistance , float distance ) { } public boolean pinch ( Vector2 initialPointer1 , Vector2 initialPointer2 , Vector2 pointer1 , Vector2 pointer2 ) { } } public static class GestureAdapter implements GestureDetector . GestureListener { @ Override public boolean touchDown ( float x , float y , int pointer , int button ) { } @ Override public boolean tap ( float x , float y , int count , int button ) { } @ Override public boolean longPress ( float x , float y ) { } @ Override public boolean fling ( float velocityX , float velocityY , int button ) { } @ Override public boolean pan ( float x , float y , float deltaX , float deltaY ) { } @ Override public boolean panStop ( float x , float y , int pointer , int button ) { } @ Override public boolean zoom ( float initialDistance , float distance ) { } @ Override public boolean pinch ( Vector2 initialPointer1 , Vector2 initialPointer2 , Vector2 pointer1 , Vector2 pointer2 ) { } } static class VelocityTracker { int sampleSize = 10 ; float lastX ; float lastY ; float deltaX ; float deltaY ; long lastTime ; int numSamples ; float [ ] meanX = new float [ sampleSize ] ; float [ ] meanY = new float [ sampleSize ] ; long [ ] meanTime = new long [ sampleSize ] ; public void start ( float x , float y , long timeStamp ) { } public void update ( float x , float y , long timeStamp ) { } public float getVelocityX ( ) { } public float getVelocityY ( ) { } private float getAverage ( float [ ] values , int numSamples ) { } private long getAverage ( long [ ] values , int numSamples ) { } private float getSum ( float [ ] values , int numSamples ) { } } }
public class PrioritizedEsThreadPoolExecutor extends EsThreadPoolExecutor { private AtomicLong tieBreaker = new AtomicLong ( Long . MIN_VALUE ) ; public PrioritizedEsThreadPoolExecutor ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory ) { } public PrioritizedEsThreadPoolExecutor ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { } public PrioritizedEsThreadPoolExecutor ( int corePoolSize , int initialWorkQueuSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { } @ Override public void execute ( Runnable command ) { <START_BUG> if ( ! ( command instanceof PrioritizedRunnable ) ) { <END_BUG> command = PrioritizedRunnable . wrap ( command , NORMAL ) ; } super . execute ( command ) ; } @ Override protected < T > RunnableFuture < T > newTaskFor ( Runnable runnable , T value ) { } @ Override protected < T > RunnableFuture < T > newTaskFor ( Callable < T > callable ) { } static class PrioritizedFutureTask < T > extends FutureTask < T > implements Comparable < PrioritizedEsThreadPoolExecutor . PrioritizedFutureTask > { private final Priority priority ; private final long tieBreaker ; public PrioritizedFutureTask ( PrioritizedRunnable runnable , T value , long tieBreaker ) { } public PrioritizedFutureTask ( PrioritizedCallable < T > callable , long tieBreaker ) { } @ Override public int compareTo ( PrioritizedEsThreadPoolExecutor . PrioritizedFutureTask pft ) { } } }
public class RestClusterUpdateSettingsAction extends BaseRestHandler { @ Inject public RestClusterUpdateSettingsAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { final ClusterUpdateSettingsRequest clusterUpdateSettingsRequest = Requests . clusterUpdateSettingsRequest ( ) ; clusterUpdateSettingsRequest . listenerThreaded ( false ) ; try { Map < String , Object > source = XContentFactory . xContent ( request . content ( ) ) . createParser ( request . content ( ) ) . mapAndClose ( ) ; if ( source . containsKey ( "transient" ) ) { clusterUpdateSettingsRequest . transientSettings ( ( ( Map ) ( source . get ( "transient" ) ) ) ) ; } if ( source . containsKey ( "persistent" ) ) { clusterUpdateSettingsRequest . persistentSettings ( ( ( Map ) ( source . get ( "persistent" ) ) ) ) ; } } catch ( Exception e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>response" , e1 ) ; } return ; } client . admin ( ) . cluster ( ) . updateSettings ( clusterUpdateSettingsRequest , new org . elasticsearch . action . ActionListener < ClusterUpdateSettingsResponse > ( ) { @ Override public void onResponse ( ClusterUpdateSettingsResponse response ) { try { channel . sendResponse ( new StringRestResponse ( RestStatus . OK ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>handle<seq2seq4repair_space>cluster<seq2seq4repair_space>state" , e ) ; } try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public abstract class MetricsAggregationBuilder < B extends MetricsAggregationBuilder < B > > extends AbstractAggregationBuilder { public MetricsAggregationBuilder ( String name , String type ) { } @ Override public final XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { <START_BUG> builder . startObject ( MetricsAggregationBuilder . getName ( ) ) . startObject ( type ) ; <END_BUG> internalXContent ( builder , params ) ; return builder . endObject ( ) . endObject ( ) ; } protected abstract void internalXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class LwjglCanvas implements Application { LwjglGraphics graphics ; OpenALAudio audio ; LwjglFiles files ; LwjglInput input ; LwjglNet net ; ApplicationListener listener ; Canvas canvas ; final List < Runnable > runnables = new ArrayList ( ) ; final List < Runnable > executedRunnables = new ArrayList ( ) ; final Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; boolean running = true ; int logLevel = LOG_INFO ; Cursor cursor ; public LwjglCanvas ( ApplicationListener listener , boolean useGL2 ) { } public LwjglCanvas ( ApplicationListener listener , LwjglApplicationConfiguration config ) { } private void initialize ( ApplicationListener listener , LwjglApplicationConfiguration config ) { } protected void setDisplayMode ( int width , int height ) { } protected void setTitle ( String title ) { } @ Override public ApplicationListener getApplicationListener ( ) { } public Canvas getCanvas ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Files getFiles ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Input getInput ( ) { } @ Override public Net getNet ( ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { } void create ( ) { } protected int getFrameRate ( ) { int frameRate = ( Display . isActive ( ) ) ? graphics . config . foregroundFPS : graphics . config . backgroundFPS ; if ( frameRate == ( - 1 ) ) frameRate = 10 ; if ( frameRate == 0 ) frameRate = graphics . config . backgroundFPS ; if ( frameRate == 0 ) frameRate = 30 ; <START_BUG> return frameRate ; <END_BUG> } protected void exception ( Throwable ex ) { } protected void start ( ) { } protected void resize ( int width , int height ) { } protected void stopped ( ) { } public void stop ( ) { } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } Map < String , Preferences > preferences = new HashMap < String , Preferences > ( ) ; @ Override public Preferences getPreferences ( String name ) { } @ Override public Clipboard getClipboard ( ) { } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } public void log ( String tag , String message ) { } @ Override public void log ( String tag , String message , Exception exception ) { } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public void exit ( ) { } public void setCursor ( Cursor cursor ) { } @ Override public void addLifecycleListener ( LifecycleListener listener ) { } @ Override public void removeLifecycleListener ( LifecycleListener listener ) { } }
public class ShortFieldMapper extends NumberFieldMapper < Short > { public static final String CONTENT_TYPE = "short" ; public static class Defaults extends NumberFieldMapper . Defaults { public static final Short NULL_VALUE = null ; } public static class Builder extends NumberFieldMapper . Builder < ShortFieldMapper . Builder , ShortFieldMapper > { protected Short nullValue = ShortFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public ShortFieldMapper . Builder nullValue ( short nullValue ) { } @ Override public ShortFieldMapper build ( BuilderContext context ) { <START_BUG> ShortFieldMapper fieldMapper = new ShortFieldMapper ( buildNames ( context ) , precisionStep , fuzzyFactor , index , store , boost , omitNorms , indexOptions , nullValue , ignoreMalformed ) ; <END_BUG> fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private Short nullValue ; private String nullValueAsString ; protected ShortFieldMapper ( Names names , int precisionStep , String fuzzyFactor , Field . Index index , Field . Store store , float boost , boolean omitNorms , IndexOptions indexOptions , Short nullValue , boolean ignoreMalformed ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Short value ( Fieldable field ) { } @ Override public Short valueFromString ( String value ) { } @ Override public String indexedValue ( String value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions ) { } @ Override public Query fuzzyQuery ( String value , double minSim , int prefixLength , int maxExpansions ) { } @ Override public Query fieldQuery ( String value , @ Nullable QueryParseContext context ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter fieldFilter ( String value , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( FieldDataCache fieldDataCache , String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected boolean customBoost ( ) { } @ Override protected Fieldable innerParseCreateField ( ParseContext context ) throws IOException { } @ Override public FieldDataType fieldDataType ( ) { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } public static class CustomShortNumericField extends CustomNumericField { private final short number ; private final NumberFieldMapper mapper ; public CustomShortNumericField ( NumberFieldMapper mapper , short number ) { } @ Override public TokenStream tokenStreamValue ( ) { } @ Override public String numericAsString ( ) { } } }
public abstract class AtomicGeoPointFieldData < Script extends ScriptDocValues > implements AtomicFieldData < Script > { public abstract GeoPointValues getGeoPointValues ( ) { } @ Override <START_BUG> public BytesValues getBytesValues ( boolean needsHashes ) { <END_BUG> final GeoPointValues values = getGeoPointValues ( ) ; return new BytesValues ( values . isMultiValued ( ) ) { @ Override public int setDocument ( int docId ) { this . docId = docId ; return values . setDocument ( docId ) ; } @ Override public BytesRef nextValue ( ) { GeoPoint value = values . nextValue ( ) ; scratch . copyChars ( GeoHashUtils . encode ( value . lat ( ) , value . lon ( ) ) ) ; return scratch ; } } ; } }
public class Executor { public interface CharCallback { public void character ( char c ) { } } public static boolean execute ( File workingDir , String windowsFile , String unixFile , String parameters , Executor . CharCallback callback ) { } private static boolean startProcess ( String command , File directory , final Executor . CharCallback callback ) { try { final Process process = new ProcessBuilder ( command . split ( "<seq2seq4repair_space>" ) ) . redirectErrorStream ( true ) . directory ( directory ) . start ( ) ; Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) , 1 ) ; try { int c = 0 ; <START_BUG> while ( ( ( c = reader . read ( ) ) != ( - 1 ) ) && ( process . isAlive ( ) ) ) { <END_BUG> callback . character ( ( ( char ) ( c ) ) ) ; } } catch ( IOException e ) { } } } ) ; t . setDaemon ( true ) ; t . start ( ) ; process . waitFor ( ) ; t . interrupt ( ) ; return ( process . exitValue ( ) ) == 0 ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } } }
public class TextAreaTest implements RenderListener { GUI gui ; public void surfaceCreated ( ) { } public void render ( ) { <START_BUG> graphics . getGL10 ( ) . glClear ( GL_COLOR_BUFFER_BIT ) ; <END_BUG> gui . update ( ) ; } public void surfaceChanged ( int width , int height ) { } public void dispose ( ) { } }
public class FsStreamSnapshot implements Translog . Snapshot { private final ShardId shardId ; private final long id ; private final int totalOperations ; private final int snapshotOperations ; private final RafReference raf ; private final long length ; private final DataInputStream dis ; private Operation lastOperationRead = null ; private int position = 0 ; private byte [ ] cachedData ; public FsStreamSnapshot ( ShardId shardId , long id , RafReference raf , long length , int totalOperations , int snapshotOperations ) throws FileNotFoundException { } @ Override public long translogId ( ) { } @ Override public long position ( ) { } @ Override public long length ( ) { } @ Override public int totalOperations ( ) { } @ Override public int snapshotOperations ( ) { } @ Override public InputStream stream ( ) throws IOException { } @ Override public long lengthInBytes ( ) { } @ Override public boolean hasNext ( ) { } @ Override public Operation next ( ) { } @ Override public void seekForward ( long length ) { } @ Override public boolean release ( ) throws ElasticSearchException { try { dis . close ( ) ; } catch ( IOException e ) { } <START_BUG> raf . decreaseRefCount ( ) ; <END_BUG> return true ; } }
public class CharArray { public char [ ] items ; public int size ; public boolean ordered ; public CharArray ( ) { } public CharArray ( int capacity ) { } public CharArray ( boolean ordered , int capacity ) { } public CharArray ( CharArray array ) { } public CharArray ( char [ ] array ) { } public CharArray ( boolean ordered , char [ ] array , int startIndex , int count ) { } public void add ( char value ) { } public void addAll ( CharArray array ) { } public void addAll ( CharArray array , int offset , int length ) { } public void addAll ( char [ ] array ) { } public void addAll ( char [ ] array , int offset , int length ) { char [ ] items = this . items ; <START_BUG> int sizeNeeded = ( size ) + length ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public char get ( int index ) { } public void set ( int index , char value ) { } public void insert ( int index , char value ) { } public void swap ( int first , int second ) { } public boolean contains ( char value ) { } public int indexOf ( char value ) { } public int lastIndexOf ( char value ) { } public boolean removeValue ( char value ) { } public char removeIndex ( int index ) { } public boolean removeAll ( CharArray array ) { } public char pop ( ) { } public char peek ( ) { } public char first ( ) { } public void clear ( ) { } public void shrink ( ) { } public char [ ] ensureCapacity ( int additionalCapacity ) { } protected char [ ] resize ( int newSize ) { } public void sort ( ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public char random ( ) { } public char [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class HomePagerAdapter extends FragmentPagerAdapter implements TitleProvider { private final boolean defaultUser ; private final FragmentManager fragmentManager ; private final Resources resources ; private final Set < String > tags = new HashSet < String > ( ) ; public HomePagerAdapter ( final FragmentManager fm , final Resources resources , final boolean defaultUser ) { } @ Override public Fragment getItem ( int position ) { switch ( position ) { case 0 : <START_BUG> return new UserReceivedNewsFragment ( ) ; <END_BUG> case 1 : return new RepoListFragment ( ) ; case 2 : return defaultUser ? new MyFollowersFragment ( ) : new MembersFragment ( ) ; default : return null ; } } public HomePagerAdapter clearAdapter ( ) { } public Object instantiateItem ( ViewGroup container , int position ) { } @ Override public int getCount ( ) { } @ Override public String getTitle ( int position ) { } }
class GdxFont implements Font { final TwlRenderer renderer ; final BitmapFont bitmapFont ; private final GdxFont . FontState [ ] fontStates ; private final int yOffset ; public GdxFont ( TwlRenderer renderer , BitmapFont bitmapFont , Map < String , String > params , Collection < FontParameter > condParams ) { } public int drawText ( AnimationState as , int x , int y , CharSequence str ) { } public int drawText ( AnimationState as , int x , int y , CharSequence str , int start , int end ) { GdxFont . FontState fontState = evalFontState ( as ) ; x += fontState . offsetX ; y += ( fontState . offsetY ) + ( yOffset ) ; Color color = renderer . getColor ( fontState . color ) ; <START_BUG> return bitmapFont . draw ( renderer . spriteBatch , str , x , y , color ) ; <END_BUG> } public int drawMultiLineText ( AnimationState as , int x , int y , CharSequence str , int width , HAlignment align ) { } public FontCache cacheText ( FontCache cache , CharSequence str ) { } public FontCache cacheText ( FontCache cache , CharSequence str , int start , int end ) { } public FontCache cacheMultiLineText ( FontCache cache , CharSequence str , int width , HAlignment align ) { } public void destroy ( ) { } public int getBaseLine ( ) { } public int getLineHeight ( ) { } public int getSpaceWidth ( ) { } public int getEM ( ) { } public int getEX ( ) { } public int computeMultiLineTextWidth ( CharSequence str ) { } public int computeTextWidth ( CharSequence str ) { } public int computeTextWidth ( CharSequence str , int start , int end ) { } public int computeVisibleGlpyhs ( CharSequence str , int start , int end , int width ) { } GdxFont . FontState evalFontState ( AnimationState animationState ) { } private static class FontState { final StateExpression condition ; final de . matthiasmann . twl . Color color ; final int offsetX ; final int offsetY ; public FontState ( StateExpression condition , Map < String , String > params ) { } } private class GdxFontCache implements FontCache { final BitmapFontCache bitmapCache ; public GdxFontCache ( ) { } public void draw ( AnimationState as , int x , int y ) { } public int getWidth ( ) { } public int getHeight ( ) { } public void destroy ( ) { } } }
public class TransportBulkAction extends TransportAction < BulkRequest , BulkResponse > { private final AutoCreateIndex autoCreateIndex ; private final boolean allowIdGeneration ; private final ClusterService clusterService ; private final TransportShardBulkAction shardBulkAction ; private final TransportCreateIndexAction createIndexAction ; @ Inject public TransportBulkAction ( Settings settings , ThreadPool threadPool , TransportService transportService , ClusterService clusterService , TransportShardBulkAction shardBulkAction , TransportCreateIndexAction createIndexAction ) { } @ Override protected void doExecute ( final BulkRequest bulkRequest , final ActionListener < BulkResponse > listener ) { } private void executeBulk ( final BulkRequest bulkRequest , final long startTime , final ActionListener < BulkResponse > listener ) { } class TransportHandler extends BaseTransportRequestHandler < BulkRequest > { @ Override public BulkRequest newInstance ( ) { } @ Override public void messageReceived ( final BulkRequest request , final TransportChannel channel ) throws Exception { request . listenerThreaded ( false ) ; execute ( request , new ActionListener < BulkResponse > ( ) { @ Override public void onResponse ( BulkResponse result ) { try { channel . sendResponse ( result ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( e ) ; } catch ( Exception e1 ) { logger . warn ( ( ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>error<seq2seq4repair_space>response<seq2seq4repair_space>for<seq2seq4repair_space>action<seq2seq4repair_space>[" + ( BulkAction . NAME ) ) + "]<seq2seq4repair_space>and<seq2seq4repair_space>request<seq2seq4repair_space>[" ) + request ) + "]" ) , e1 ) ; } } } ) ; } @ Override public String executor ( ) { } } }
public class Type { String name ; Class clazz ; Class superClass ; Set < Class > assignables = new HashSet < Class > ( ) ; boolean isAbstract ; boolean isInterface ; boolean isPrimitive ; boolean isEnum ; boolean isArray ; boolean isMemberClass ; boolean isStatic ; Field [ ] fields ; Method [ ] methods ; Constructor constructor ; Class componentType ; Object [ ] enumConstants ; public Object newInstance ( ) { } public String getName ( ) { } public Class getClassOfType ( ) { } public Type getSuperclass ( ) { try { <START_BUG> return ReflectionCache . forName ( superClass . getName ( ) ) ; <END_BUG> } catch ( ClassNotFoundException e ) { return null ; } } public boolean isAssignableFrom ( Type otherType ) { } public Field getField ( String name ) { } public Field [ ] getFields ( ) { } public Field [ ] getDeclaredFields ( ) { } public Method getMethod ( String name , Class ... parameterTypes ) throws NoSuchMethodException { } public Method [ ] getMethods ( ) { } public Method [ ] getDeclaredMethods ( ) { } public Constructor getDeclaredConstructor ( ) throws NoSuchMethodException { } public boolean isAbstract ( ) { } public boolean isInterface ( ) { } public boolean isPrimitive ( ) { } public boolean isEnum ( ) { } public boolean isArray ( ) { } public boolean isMemberClass ( ) { } public boolean isStatic ( ) { } public Class getComponentType ( ) { } public int getArrayLength ( Object obj ) { } public Object getArrayElement ( Object obj , int i ) { } public void setArrayElement ( Object obj , int i , Object value ) { } public Object [ ] getEnumConstants ( ) { } @ Override public String toString ( ) { } }
public class IndexAliasesServiceTests extends ElasticsearchTestCase { public static IndexAliasesService newIndexAliasesService ( ) { } public static IndexQueryParserService newIndexQueryParserService ( ) { } public static CompressedString filter ( FilterBuilder filterBuilder ) throws IOException { } @ Test public void testFilteringAliases ( ) throws Exception { } @ Test public void testAliasFilters ( ) throws Exception { } @ Test ( expected = InvalidAliasNameException . class ) public void testRemovedAliasFilter ( ) throws Exception { } @ Test public void testUnknownAliasFilter ( ) throws Exception { IndexAliasesService indexAliasesService = IndexAliasesServiceTests . newIndexAliasesService ( ) ; indexAliasesService . add ( "cats" , IndexAliasesServiceTests . filter ( termFilter ( "animal" , "cat" ) ) ) ; indexAliasesService . add ( "dogs" , IndexAliasesServiceTests . filter ( termFilter ( "animal" , "dog" ) ) ) ; try { indexAliasesService . aliasFilter ( "unknown" ) ; <START_BUG> assert false ; <END_BUG> } catch ( InvalidAliasNameException e ) { } } }
public final class TestCluster implements Iterable < Client > { private final ESLogger logger = Loggers . getLogger ( getClass ( ) ) ; private final TreeMap < String , TestCluster . NodeAndClient > nodes = Maps . newTreeMap ( ) ; private final Set < File > dataDirToClean = new HashSet < File > ( ) ; private final String clusterName ; private final AtomicBoolean open = new AtomicBoolean ( true ) ; private final Settings defaultSettings ; private Random random ; private AtomicInteger nextNodeId = new AtomicInteger ( 0 ) ; private final int numSharedNodes ; private final long [ ] sharedNodesSeeds ; private double transportClientRatio = 0.0 ; private final NodeSettingsSource nodeSettingsSource ; TestCluster ( long clusterSeed , String clusterName ) { } TestCluster ( long clusterSeed , int numNodes , String clusterName , NodeSettingsSource nodeSettingsSource ) { } private static boolean isLocalTransportConfigured ( ) { } private Settings getSettings ( int nodeOrdinal , Settings others ) { } static String clusterName ( String prefix , String childVMId , long clusterSeed ) { } private void ensureOpen ( ) { } private synchronized TestCluster . NodeAndClient getOrBuildRandomNode ( ) { } private synchronized TestCluster . NodeAndClient getRandomNodeAndClient ( ) { } private synchronized TestCluster . NodeAndClient getRandomNodeAndClient ( Predicate < TestCluster . NodeAndClient > predicate ) { } public synchronized void ensureAtLeastNumNodes ( int n ) { } public synchronized void ensureAtMostNumNodes ( int n ) { } private TestCluster . NodeAndClient buildNode ( Settings settings ) { } private TestCluster . NodeAndClient buildNode ( ) { } private TestCluster . NodeAndClient buildNode ( int nodeId , long seed , Settings settings ) { } private String buildNodeName ( int id ) { } synchronized Client client ( ) { } public synchronized Client masterClient ( ) { } public synchronized Client nonMasterClient ( ) { } public synchronized Client clientNodeClient ( ) { } public synchronized Client client ( String nodeName ) { } public synchronized Client smartClient ( ) { } public synchronized Client client ( final Predicate < Settings > filterPredicate ) { } void close ( ) { } private final class NodeAndClient implements Closeable { private InternalNode node ; private Client client ; private Client nodeClient ; private final AtomicBoolean closed = new AtomicBoolean ( false ) ; private final TestCluster . ClientFactory clientFactory ; private final String name ; NodeAndClient ( String name , Node node , TestCluster . ClientFactory factory ) { } Node node ( ) { } Client client ( Random random ) { } Client nodeClient ( ) { } void resetClient ( ) { } void restart ( TestCluster . RestartCallback callback ) throws Exception { } @ Override public void close ( ) { } } static class ClientFactory { public Client client ( Node node , String clusterName , Random random ) { } } static class TransportClientFactory extends TestCluster . ClientFactory { private boolean sniff ; public static TestCluster . TransportClientFactory NO_SNIFF_CLIENT_FACTORY = new TestCluster . TransportClientFactory ( false ) ; public static TestCluster . TransportClientFactory SNIFF_CLIENT_FACTORY = new TestCluster . TransportClientFactory ( true ) ; public TransportClientFactory ( boolean sniff ) { } @ Override public Client client ( Node node , String clusterName , Random random ) { } } class RandomClientFactory extends TestCluster . ClientFactory { @ Override public Client client ( Node node , String clusterName , Random random ) { } } synchronized void beforeTest ( Random random , double transportClientRatio ) { } private synchronized void reset ( Random random , boolean wipeData , double transportClientRatio ) { } synchronized void afterTest ( ) { } private void resetClients ( ) { } private void wipeDataDirectories ( ) { if ( ! ( dataDirToClean . isEmpty ( ) ) ) { logger . info ( "Wipe<seq2seq4repair_space>data<seq2seq4repair_space>directory<seq2seq4repair_space>for<seq2seq4repair_space>all<seq2seq4repair_space>nodes<seq2seq4repair_space>locations:<seq2seq4repair_space>{}" , this . dataDirToClean ) ; try { <START_BUG> FileSystemUtils . deleteRecursively ( dataDirToClean . toArray ( new File [ 0 ] ) ) ; <END_BUG> } finally { this . dataDirToClean . clear ( ) ; } } } public synchronized ClusterService clusterService ( ) { } public synchronized < T > Iterable < T > getInstances ( Class < T > clazz ) { } public synchronized < T > T getInstance ( Class < T > clazz , final String node ) { } public synchronized < T > T getInstance ( Class < T > clazz ) { } private synchronized < T > T getInstanceFromNode ( Class < T > clazz , InternalNode node ) { } public synchronized int size ( ) { } public synchronized void stopRandomNode ( ) { } public synchronized void stopRandomNode ( final Predicate < Settings > filter ) { } public synchronized void stopCurrentMasterNode ( ) { } public void stopRandomNonMasterNode ( ) { } public void restartRandomNode ( ) throws Exception { } public void restartRandomNode ( TestCluster . RestartCallback callback ) throws Exception { } private void restartAllNodes ( boolean rollingRestart , TestCluster . RestartCallback callback ) throws Exception { } private static final TestCluster . RestartCallback EMPTY_CALLBACK = new TestCluster . RestartCallback ( ) { public Settings onNodeStopped ( String node ) { } } ; public void fullRestart ( ) throws Exception { } public void rollingRestart ( ) throws Exception { } public void rollingRestart ( TestCluster . RestartCallback function ) throws Exception { } public void fullRestart ( TestCluster . RestartCallback function ) throws Exception { } private String getMasterName ( ) { } synchronized Set < String > allButN ( int numNodes ) { } private synchronized Set < String > nRandomNodes ( int numNodes ) { } public synchronized void startNodeClient ( Settings settings ) { } public synchronized Set < String > nodesInclude ( String index ) { } public String startNode ( ) { } public String startNode ( Settings . Builder settings ) { } public String startNode ( Settings settings ) { }
public class ActionModule extends AbstractModule { private final Map < String , ActionModule . ActionEntry > actions = Maps . newHashMap ( ) ; static class ActionEntry < Request extends ActionRequest , Response extends ActionResponse > { public final GenericAction < Request , Response > action ; public final Class < ? extends TransportAction < Request , Response > > transportAction ; public final Class [ ] supportTransportActions ; ActionEntry ( GenericAction < Request , Response > action , Class < ? extends TransportAction < Request , Response > > transportAction , Class ... supportTransportActions ) { } } private final boolean proxy ; public ActionModule ( boolean proxy ) { } public < Request extends ActionRequest , Response extends ActionResponse > void registerAction ( GenericAction < Request , Response > action , Class < ? extends TransportAction < Request , Response > > transportAction , Class ... supportTransportActions ) { <START_BUG> actions . put ( action . name ( ) , new ActionModule . ActionEntry < Request , Response > ( action , transportAction , supportTransportActions ) ) ; <END_BUG> } @ Override protected void configure ( ) { } }
public class InternalTickTest extends BaseBulletTest { static class TestInternalTickCallback extends InternalTickCallback { public TestInternalTickCallback ( btDynamicsWorld dynamicsWorld ) { } @ Override public void onInternalTick ( btDynamicsWorld dynamicsWorld , float timeStep ) { } } final int BOXCOUNT_X = 5 ; final int BOXCOUNT_Y = 5 ; final int BOXCOUNT_Z = 1 ; final float BOXOFFSET_X = - 2.5F ; final float BOXOFFSET_Y = 0.5F ; final float BOXOFFSET_Z = 0.0F ; InternalTickTest . TestInternalTickCallback internalTickCallback ; @ Override public void create ( ) { } @ Override public void dispose ( ) { super . dispose ( ) ; if ( ( internalTickCallback ) != null ) <START_BUG> internalTickCallback . dispose ( ) ; <END_BUG> internalTickCallback = null ; } float toggleTime = 0.0F ; boolean toggleAttach = false ; @ Override public void render ( ) { } @ Override public boolean tap ( float x , float y , int count , int button ) { } }
public class SignReadScreen extends Screen { private Screen parent ; private String [ ] [ ] signs = new String [ ] [ ] { new String [ ] { "READING" , "" , "PRESS<seq2seq4repair_space>UP<seq2seq4repair_space>TO<seq2seq4repair_space>READ<seq2seq4repair_space>SIGNS" } , new String [ ] { "JUMPING" , "" , "PRESS<seq2seq4repair_space>Z<seq2seq4repair_space>TO<seq2seq4repair_space>JUMP" , "YOU<seq2seq4repair_space>CAN<seq2seq4repair_space>JUMP<seq2seq4repair_space>HIGHER<seq2seq4repair_space>BY" , "GETTING<seq2seq4repair_space>A<seq2seq4repair_space>RUNNING<seq2seq4repair_space>START" , "OR<seq2seq4repair_space>HOLDING<seq2seq4repair_space>DOWN<seq2seq4repair_space>Z" } , new String [ ] { "PROGRESSING" , "" , "LEAVE<seq2seq4repair_space>A<seq2seq4repair_space>ROOM<seq2seq4repair_space>THROUGH<seq2seq4repair_space>ANY" , "EXIT<seq2seq4repair_space>TO<seq2seq4repair_space>CONTINUE<seq2seq4repair_space>YOUR" , "ADVENTURE" } , new String [ ] { "DYING" , "" , "IF<seq2seq4repair_space>YOU<seq2seq4repair_space>DIE,<seq2seq4repair_space>YOU<seq2seq4repair_space>RESTART" , "AT<seq2seq4repair_space>THE<seq2seq4repair_space>BEGINNING<seq2seq4repair_space>OF<seq2seq4repair_space>THE" , "CURRENT<seq2seq4repair_space>ROOM" } , new String [ ] { "DODGING" , "" , "THE<seq2seq4repair_space>GUNNERS<seq2seq4repair_space>DON'T<seq2seq4repair_space>LIKE<seq2seq4repair_space>YOU" , "AND<seq2seq4repair_space>SHOOT<seq2seq4repair_space>AT<seq2seq4repair_space>YOU." , "IT<seq2seq4repair_space>WOULD<seq2seq4repair_space>BE<seq2seq4repair_space>WISE<seq2seq4repair_space>TO<seq2seq4repair_space>STAY<seq2seq4repair_space>AWAY" } , new String [ ] { "THE<seq2seq4repair_space>LAUNCHER" , "" , "AS<seq2seq4repair_space>YOU<seq2seq4repair_space>PICK<seq2seq4repair_space>UP<seq2seq4repair_space>THE<seq2seq4repair_space>LAUNCHER," , "YOU<seq2seq4repair_space>REALIZE<seq2seq4repair_space>IT'S<seq2seq4repair_space>NOT<seq2seq4repair_space>YOUR" , "AVERAGE<seq2seq4repair_space>LAUNCHER." , "" , "PRESS<seq2seq4repair_space>UP<seq2seq4repair_space>AND<seq2seq4repair_space>DOWN<seq2seq4repair_space>TO<seq2seq4repair_space>AIM" , "PRESS<seq2seq4repair_space>X<seq2seq4repair_space>TO<seq2seq4repair_space>FIRE<seq2seq4repair_space>THE<seq2seq4repair_space>LAUNCHER" } , new String [ ] { "JONESING" , "" , "DON'T<seq2seq4repair_space>FORGET<seq2seq4repair_space>YOUR<seq2seq4repair_space>FEDORA!" } , new String [ ] { "EXPLODING" , "" , "TNT<seq2seq4repair_space>BLOCKS<seq2seq4repair_space>ARE<seq2seq4repair_space>HIGHLY" , "EXPLOSIVE,<seq2seq4repair_space>AND<seq2seq4repair_space>WILL" , "REACT<seq2seq4repair_space>POORLY<seq2seq4repair_space>TO<seq2seq4repair_space>BEING" , "SHOT." } , new String [ ] { "PUSHING" , "" , "THE<seq2seq4repair_space>CAMARADERIE<seq2seq4repair_space>BOX<seq2seq4repair_space>IS" , "SOMETHING<seq2seq4repair_space>SOMETHING" , "" , "IT'S<seq2seq4repair_space>FROM<seq2seq4repair_space>PORTAL." } , new String [ ] { "BATTLING" , "" , "THE<seq2seq4repair_space>GREMLIN<seq2seq4repair_space>IS<seq2seq4repair_space>LARGE" , "AND<seq2seq4repair_space>IN<seq2seq4repair_space>YOUR<seq2seq4repair_space>WAY." , "OVERHEAT<seq2seq4repair_space>IT<seq2seq4repair_space>TO<seq2seq4repair_space>DESTROY" , "IT<seq2seq4repair_space>AND<seq2seq4repair_space>CLAIM<seq2seq4repair_space>YOUR<seq2seq4repair_space>PRIZE" } , new String [ ] { "EVADING" , "" , "THE<seq2seq4repair_space>GUNNERS<seq2seq4repair_space>SHOTS<seq2seq4repair_space>WILL" , "PASS<seq2seq4repair_space>THROUGH<seq2seq4repair_space>GLASS." , "YOU,<seq2seq4repair_space>HOWEVER,<seq2seq4repair_space>WILL<seq2seq4repair_space>NOT" } , new String [ ] { "SWEATING" , "" , "THESE<seq2seq4repair_space>SLIGHTLY<seq2seq4repair_space>MORE" , "SOPHISTICATED<seq2seq4repair_space>GREMLINS" , "HAVE<seq2seq4repair_space>LEARNED<seq2seq4repair_space>A<seq2seq4repair_space>NEW" , "TRICK" } , new String [ ] { "CONVEYING" , "" , "TIME<seq2seq4repair_space>TO<seq2seq4repair_space>BURN<seq2seq4repair_space>OFF<seq2seq4repair_space>SOME" , "FAT<seq2seq4repair_space>AND<seq2seq4repair_space>HAVE<seq2seq4repair_space>FUN<seq2seq4repair_space>WHILE" , "DOING<seq2seq4repair_space>IT!" } , new String [ ] { "BOSSFIGHTING" , "" , "BEHIND<seq2seq4repair_space>THIS<seq2seq4repair_space>DOOR,<seq2seq4repair_space>MEGAN" , "AWAITS!<seq2seq4repair_space>WHO<seq2seq4repair_space>IS<seq2seq4repair_space>MEGAN?" , "ARE<seq2seq4repair_space>YOU<seq2seq4repair_space>MEGAN?" } , new String [ ] { "THE<seq2seq4repair_space>NEW<seq2seq4repair_space>LAUNCHER" , "" , "WELL,<seq2seq4repair_space>THIS<seq2seq4repair_space>IS<seq2seq4repair_space>BAD." } , new String [ ] { "FEEDING" , "" , "THE<seq2seq4repair_space>JABBERWOCKY<seq2seq4repair_space>IS" , "HUNGRY,<seq2seq4repair_space>AND<seq2seq4repair_space>WILL<seq2seq4repair_space>EAT" , "WAY<seq2seq4repair_space>MORE<seq2seq4repair_space>THAN<seq2seq4repair_space>IT<seq2seq4repair_space>SHOULD" , "" , "PLEASE<seq2seq4repair_space>DO<seq2seq4repair_space>NOT<seq2seq4repair_space>FEED!" } , new String [ ] { "HOVERING" , "" , "THE<seq2seq4repair_space>RECOIL<seq2seq4repair_space>ON<seq2seq4repair_space>THE<seq2seq4repair_space>NEW" , "LAUNCHER<seq2seq4repair_space>SURE<seq2seq4repair_space>IS" , "POWERFUL!" } , new String [ ] { "FLYING" , "" , "SERIOUSLY,<seq2seq4repair_space>THE<seq2seq4repair_space>RECOIL" , "IS<seq2seq4repair_space>OUT<seq2seq4repair_space>OF<seq2seq4repair_space>THIS<seq2seq4repair_space>WORLD!" } , new String [ ] { "WINNING" , "" , "YOUR<seq2seq4repair_space>FINAL<seq2seq4repair_space>CHALLENGE" , "IS<seq2seq4repair_space>RIGHT<seq2seq4repair_space>DOWN<seq2seq4repair_space>THIS" , "HALLWAY." } , new String [ ] { "FRESHERERST" , "" , "BIG<seq2seq4repair_space>ADAM,<seq2seq4repair_space>GIANT<seq2seq4repair_space>SISTER." , "IT<seq2seq4repair_space>IS<seq2seq4repair_space>KNOWN<seq2seq4repair_space>BY<seq2seq4repair_space>MANY<seq2seq4repair_space>NAMES" , "BUT<seq2seq4repair_space>JUDITH<seq2seq4repair_space>4HRPG<seq2seq4repair_space>BLUEBERRY." , "" , "FISSION<seq2seq4repair_space>MAILED!" } } ; private int delay = 15 ; private int id ; public SignReadScreen ( Screen parent , int id ) { } public void render ( ) { } public void tick ( Input input ) { <START_BUG> if ( ( ( ! ( input . oldButtons [ Input . ESCAPE ] ) ) && ( input . buttons [ Input . ESCAPE ] ) ) || ( input . isTouched ( ) ) ) { <END_BUG> setScreen ( parent ) ; return ; } if ( ( delay ) > 0 ) ( delay ) -- ; if ( ( ( ( delay ) == 0 ) && ( input . buttons [ Input . SHOOT ] ) ) && ( ! ( input . oldButtons [ Input . SHOOT ] ) ) ) { setScreen ( parent ) ; } } }
public class PublishClusterStateAction extends AbstractComponent { public static interface NewClusterStateListener { void onNewClusterState ( ClusterState clusterState ) { } } private final TransportService transportService ; private final DiscoveryNodesProvider nodesProvider ; private final PublishClusterStateAction . NewClusterStateListener listener ; public PublishClusterStateAction ( Settings settings , TransportService transportService , DiscoveryNodesProvider nodesProvider , PublishClusterStateAction . NewClusterStateListener listener ) { } public void close ( ) { } public void publish ( ClusterState clusterState ) { } private class PublishClusterStateRequest implements Streamable { private ClusterState clusterState ; private PublishClusterStateRequest ( ) { } private PublishClusterStateRequest ( ClusterState clusterState ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { <START_BUG> clusterState = Builder . readFrom ( in , settings , nodesProvider . nodes ( ) . localNode ( ) ) ; <END_BUG> } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } private class PublishClusterStateRequestHandler extends BaseTransportRequestHandler < PublishClusterStateAction . PublishClusterStateRequest > { static final String ACTION = "discovery/zen/publish" ; @ Override public PublishClusterStateAction . PublishClusterStateRequest newInstance ( ) { } @ Override public void messageReceived ( PublishClusterStateAction . PublishClusterStateRequest request , TransportChannel channel ) throws Exception { } @ Override public boolean spawn ( ) { } } }
public class SoundTest extends GdxTest implements InputProcessor { Sound sound ; Music music ; float volume = 1.0F ; @ Override public void render ( ) { } @ Override public void create ( ) { } @ Override public boolean keyDown ( int keycode ) { } @ Override public boolean keyTyped ( char character ) { } @ Override public boolean keyUp ( int keycode ) { } @ Override public boolean touchDown ( int x , int y , int pointer ) { <START_BUG> sound . play ( ) ; <END_BUG> return false ; } @ Override public boolean touchDragged ( int x , int y , int pointer ) { } @ Override public boolean touchUp ( int x , int y , int pointer ) { } @ Override public boolean needsGL20 ( ) { } }
public class DefaultShaderProvider extends BaseShaderProvider { public int maxLightsCount = 5 ; @ Override protected Shader createShader ( final Renderable renderable ) { app . log ( "DefaultShaderProvider" , "Creating<seq2seq4repair_space>new<seq2seq4repair_space>shader" ) ; if ( graphics . isGL20Available ( ) ) <START_BUG> return new com . badlogic . gdx . graphics . g3d . shaders . DefaultShader ( renderable . material , ( ( renderable . lights ) == null ? - 1 : maxLightsCount ) ) ; <END_BUG> return new GLES10Shader ( maxLightsCount ) ; } }
public class IndicesExistsRequestBuilder extends MasterNodeOperationRequestBuilder < IndicesExistsRequest , IndicesExistsResponse , IndicesExistsRequestBuilder > { public IndicesExistsRequestBuilder ( IndicesAdminClient indicesClient , String ... indices ) { } public IndicesExistsRequestBuilder setIndices ( String ... indices ) { <START_BUG> request . indices ( indices ) ; <END_BUG> return this ; } @ Override protected void doExecute ( ActionListener < IndicesExistsResponse > listener ) { } }
public class RestMultiSearchAction extends BaseRestHandler { @ Inject public RestMultiSearchAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { MultiSearchRequest multiSearchRequest = new MultiSearchRequest ( ) ; multiSearchRequest . listenerThreaded ( false ) ; String [ ] indices = RestActions . splitIndices ( request . param ( "index" ) ) ; String [ ] types = RestActions . splitTypes ( request . param ( "type" ) ) ; IgnoreIndices ignoreIndices = null ; if ( request . hasParam ( "ignore_indices" ) ) { ignoreIndices = IgnoreIndices . fromString ( request . param ( "ignore_indices" ) ) ; } try { multiSearchRequest . add ( request . content ( ) , request . contentUnsafe ( ) , indices , types , request . param ( "search_type" ) , ignoreIndices ) ; } catch ( Exception e ) { try { XContentBuilder builder = restContentBuilder ( request ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . BAD_REQUEST , builder . startObject ( ) . field ( "error" , e . getMessage ( ) ) . endObject ( ) ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } return ; } client . multiSearch ( multiSearchRequest , new org . elasticsearch . action . ActionListener < MultiSearchResponse > ( ) { @ Override public void onResponse ( MultiSearchResponse response ) { try { XContentBuilder builder = restContentBuilder ( request ) ; builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class NumericRangeFilterBuilder extends BaseFilterBuilder { private final String name ; private Object from ; private Object to ; private boolean includeLower = true ; private boolean includeUpper = true ; private Boolean cache ; private String cacheKey ; private String filterName ; public NumericRangeFilterBuilder ( String name ) { } public NumericRangeFilterBuilder from ( Object from ) { } public NumericRangeFilterBuilder from ( int from ) { } public NumericRangeFilterBuilder from ( long from ) { } public NumericRangeFilterBuilder from ( float from ) { } public NumericRangeFilterBuilder from ( double from ) { } public NumericRangeFilterBuilder gt ( Object from ) { } public NumericRangeFilterBuilder gt ( int from ) { } public NumericRangeFilterBuilder gt ( long from ) { } public NumericRangeFilterBuilder gt ( float from ) { } public NumericRangeFilterBuilder gt ( double from ) { } public NumericRangeFilterBuilder gte ( Object from ) { } public NumericRangeFilterBuilder gte ( int from ) { } public NumericRangeFilterBuilder gte ( long from ) { } public NumericRangeFilterBuilder gte ( float from ) { } public NumericRangeFilterBuilder gte ( double from ) { } public NumericRangeFilterBuilder to ( Object to ) { } public NumericRangeFilterBuilder to ( int to ) { } public NumericRangeFilterBuilder to ( long to ) { } public NumericRangeFilterBuilder to ( float to ) { } public NumericRangeFilterBuilder to ( double to ) { } public NumericRangeFilterBuilder lt ( Object to ) { } public NumericRangeFilterBuilder lt ( int to ) { } public NumericRangeFilterBuilder lt ( long to ) { } public NumericRangeFilterBuilder lt ( float to ) { } public NumericRangeFilterBuilder lt ( double to ) { } <START_BUG> public NumericRangeFilterBuilder lte ( String to ) { <END_BUG> this . to = to ; this . includeUpper = true ; return this ; } public NumericRangeFilterBuilder lte ( int to ) { } public NumericRangeFilterBuilder lte ( long to ) { } public NumericRangeFilterBuilder lte ( float to ) { } public NumericRangeFilterBuilder lte ( double to ) { } public NumericRangeFilterBuilder includeLower ( boolean includeLower ) { } public NumericRangeFilterBuilder includeUpper ( boolean includeUpper ) { } public NumericRangeFilterBuilder filterName ( String filterName ) { } public NumericRangeFilterBuilder cache ( boolean cache ) { } public NumericRangeFilterBuilder cacheKey ( String cacheKey ) { } @ Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class BlitTest extends GdxTest { @ Override public boolean needsGL20 ( ) { <START_BUG> return false ; <END_BUG> } Texture rgb888 ; Texture rgba8888 ; Texture psRgb888 ; Texture psRgba8888 ; SpriteBatch batch ; public void create ( ) { } public void render ( ) { } }
if ( "objectgroup" . equals ( element ) ) { map . objectGroups . add ( currObjectGroup ) ; currObjectGroup = null ; return ; } if ( "property" . equals ( element ) ) { putProperty ( currProperty ) ; currProperty = null ; return ; } if ( "polyline" . equals ( element ) ) { putPolyLine ( polyline ) ; polyline = null ; return ; } if ( "polygon" . equals ( element ) ) { putPolyLine ( polygon ) ; polygon = null ; return ; } if ( "data" . equals ( element ) ) { if ( "base64" . equals ( encoding ) ) { if ( ( ( dataString ) == null ) | ( "" . equals ( dataString . trim ( ) ) ) ) return ; data = Base64Coder . decode ( dataString . trim ( ) ) ; if ( "gzip" . equals ( compression ) ) { unGZip ( ) ; } else if ( "zlib" . equals ( compression ) ) { unZlib ( ) ; } else if ( ( compression ) == null ) { arrangeData ( ) ; } } else if ( ( "csv" . equals ( encoding ) ) && ( ( compression ) == null ) ) { fromCSV ( ) ; } else if ( ( ( encoding ) == null ) && ( ( compression ) == null ) ) { dataCounter = 0 ; } else { throw new GdxRuntimeException ( "Unsupported<seq2seq4repair_space>encoding<seq2seq4repair_space>and/or<seq2seq4repair_space>compression<seq2seq4repair_space>format" ) ; } awaitingData = false ; return ; } if ( "property" . equals ( element ) ) { putProperty ( currProperty ) ; currProperty = null ; } } private void putPolyLine ( Polyline polyLine ) { if ( polyLine == null ) { return ; } if ( "polyline" . equals ( polyLine . name ) ) { currObject . polyline = polyLine . points ; return ; } if ( "polygon" . equals ( polyLine . name ) ) { currObject . polygon = polyLine . points ; return ; } return ; } private void putProperty ( Property property ) { if ( "tile" . equals ( property . parentType ) ) { map . setTileProperty ( ( ( currTile ) + ( currTileSet . firstgid ) ) , property . name , property . value ) ; return ; } if ( "map" . equals ( property . parentType ) ) { map . properties . put ( property . name , property . value ) ; return ; } if ( "layer" . equals ( property . parentType ) ) { currLayer . properties . put ( property . name , property . value ) ; return ; } if ( "objectgroup" . equals ( property . parentType ) ) { currObjectGroup . properties . put ( property . name , property . value ) ; return ; } if ( "object" . equals ( property . parentType ) ) { currObject . properties . put ( property . name , property . value ) ; return ; } } private void fromCSV ( ) { StringTokenizer st = new StringTokenizer ( dataString . trim ( ) , "," ) ; for ( int row = 0 ; row < ( currLayerHeight ) ; row ++ ) { for ( int col = 0 ; col < ( currLayerWidth ) ; col ++ ) { <START_BUG> currLayer . tiles [ row ] [ col ] = ( ( int ) ( Long . parseLong ( st . nextToken ( ) . trim ( ) ) ) ) ; <END_BUG> } } } private void arrangeData ( ) { int byteCounter = 0 ; for ( int row = 0 ; row < ( currLayerHeight ) ; row ++ ) { for ( int col = 0 ; col < ( currLayerWidth ) ; col ++ ) { currLayer . tiles [ row ] [ col ] = ( ( ( TiledLoader . unsignedByteToInt ( data [ ( byteCounter ++ ) ] ) ) | ( ( TiledLoader . unsignedByteToInt ( data [ ( byteCounter ++ ) ] ) ) << 8 ) ) | ( ( TiledLoader . unsignedByteToInt ( data [ ( byteCounter ++ ) ] ) ) << 16 ) ) | ( ( TiledLoader . unsignedByteToInt ( data [ ( byteCounter ++ ) ] ) ) << 24 ) ; } } } private void unZlib ( ) { Inflater zlib = new Inflater ( ) ; byte [ ] readTemp = new byte [ 4 ] ; zlib . setInput ( data , 0 , data . length ) ; for ( int row = 0 ; row < ( currLayerHeight ) ; row ++ ) { for ( int col = 0 ; col < ( currLayerWidth ) ; col ++ ) { try { zlib . inflate ( readTemp , 0 , 4 ) ; currLayer . tiles [ row ] [ col ] = ( ( ( TiledLoader . unsignedByteToInt ( readTemp [ 0 ] ) ) | ( ( TiledLoader . unsignedByteToInt ( readTemp [ 1 ] ) ) << 8 ) ) | ( ( TiledLoader . unsignedByteToInt ( readTemp [ 2 ] ) ) << 16 ) ) | ( ( TiledLoader . unsignedByteToInt ( readTemp [ 3 ] ) ) << 24 ) ; } catch ( DataFormatException e ) { throw new GdxRuntimeException ( "Error<seq2seq4repair_space>Reading<seq2seq4repair_space>TMX<seq2seq4repair_space>Layer<seq2seq4repair_space>Data." , e ) ; } } } } private void unGZip ( ) { GZIPInputStream GZIS = null ; try { GZIS = new GZIPInputStream ( new ByteArrayInputStream ( data ) , data . length ) ; } catch ( IOException e ) { throw new GdxRuntimeException ( ( "Error<seq2seq4repair_space>Reading<seq2seq4repair_space>TMX<seq2seq4repair_space>Layer<seq2seq4repair_space>Data<seq2seq4repair_space>-<seq2seq4repair_space>IOException:<seq2seq4repair_space>" + ( e . getMessage ( ) ) ) ) ; } byte [ ] readTemp = new byte [ 4 ] ; for ( int row = 0 ;
public interface IndexStore extends IndexComponent { boolean persistent ( ) { } Class < ? extends Store > shardStoreClass ( ) { } ByteSizeValue backingStoreTotalSpace ( ) { } ByteSizeValue backingStoreFreeSpace ( ) { } void deleteUnallocated ( ShardId shardId ) throws IOException { } IndexStore . StoreFilesMetaData listStoreMetaData ( ShardId shardId ) throws IOException { } static class StoreFilesMetaData implements Iterable < StoreFileMetaData > , Streamable { private boolean allocated ; private ShardId shardId ; private Map < String , StoreFileMetaData > files ; StoreFilesMetaData ( ) { } public StoreFilesMetaData ( boolean allocated , ShardId shardId , Map < String , StoreFileMetaData > files ) { } public boolean allocated ( ) { } public ShardId shardId ( ) { } public long totalSizeInBytes ( ) { long totalSizeInBytes = 0 ; for ( StoreFileMetaData file : this ) { <START_BUG> totalSizeInBytes += file . sizeInBytes ( ) ; <END_BUG> } return totalSizeInBytes ; } @ Override public Iterator < StoreFileMetaData > iterator ( ) { } public boolean fileExists ( String name ) { } public StoreFileMetaData file ( String name ) { } public static IndexStore . StoreFilesMetaData readStoreFilesMetaData ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class WallElement extends FieldElement { Body wallBody ; Collection bodySet ; float x1 ; float y1 ; float x2 ; float y2 ; float kick ; boolean killBall ; boolean retractWhenHit ; @ Override public void finishCreate ( Map params , World world ) { } public boolean isRetracted ( ) { } public void setRetracted ( boolean retracted ) { } @ Override public Collection getBodies ( ) { } @ Override public boolean shouldCallTick ( ) { } Vector2 impulseForBall ( Body ball ) { } @ Override public void handleCollision ( Body ball , Body bodyHit , Field field ) { if ( retractWhenHit ) { this . setRetracted ( true ) ; } if ( killBall ) { field . removeBall ( ball ) ; } else { Vector2 impulse = this . impulseForBall ( ball ) ; if ( impulse != null ) { <START_BUG> ball . applyLinearImpulse ( impulse , ball . getWorldCenter ( ) ) ; <END_BUG> flashForFrames ( 3 ) ; } } } @ Override public void draw ( IFieldRenderer renderer ) { } }
public class DoubleFieldsFunctionDataComparator extends FieldComparator < Double > { public static ExtendedFieldComparatorSource comparatorSource ( SearchScript script ) { } private static class InnerSource extends FieldDataType . ExtendedFieldComparatorSource { private final SearchScript script ; private InnerSource ( SearchScript script ) { } @ Override public FieldComparator newComparator ( String fieldname , int numHits , int sortPos , boolean reversed ) throws IOException { } @ Override public Type reducedType ( ) { } } private final SearchScript script ; private final double [ ] values ; private double bottom ; public DoubleFieldsFunctionDataComparator ( int numHits , SearchScript script ) { } @ Override public FieldComparator < Double > setNextReader ( AtomicReaderContext context ) throws IOException { <START_BUG> script . setNextReader ( context . reader ( ) ) ; <END_BUG> return this ; } @ Override public void setScorer ( Scorer scorer ) { } @ Override public int compare ( int slot1 , int slot2 ) { } @ Override public int compareBottom ( int doc ) { } @ Override public int compareDocToValue ( int doc , Double val2 ) throws IOException { } @ Override public void copy ( int slot , int doc ) { } @ Override public void setBottom ( final int bottom ) { } @ Override public Double value ( int slot ) { } }
public class FilterListFragment extends ItemListFragment < IssueFilter > implements Comparator < IssueFilter > { @ Inject private AccountDataManager cache ; @ Inject private AvatarLoader avatars ; @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; <START_BUG> setEmptyText ( getString ( no_filters ) ) ; <END_BUG> } @ Override public Loader < List < IssueFilter > > onCreateLoader ( int id , Bundle args ) { } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public void onResume ( ) { } @ Override protected ItemListAdapter < IssueFilter , ? extends ItemView > createAdapter ( List < IssueFilter > items ) { } @ Override public int compare ( final IssueFilter lhs , final IssueFilter rhs ) { } }
public Matrix4 set ( Matrix4 matrix ) { } public Matrix4 set ( float [ ] values ) { } public Matrix4 set ( Quaternion quaternion ) { } public Matrix4 set ( float x , float y , float z , float w ) { } public Matrix4 set ( Vector3 position , Quaternion orientation ) { } public Matrix4 set ( float translationX , float translationY , float translationZ , float quaternionX , float quaternionY , float quaternionZ , float quaternionW ) { } public Matrix4 set ( Vector3 xAxis , Vector3 yAxis , Vector3 zAxis , Vector3 pos ) { } public Matrix4 set ( Vector3 position , Quaternion orientation , Vector3 scale ) { } public Matrix4 cpy ( ) { } public Matrix4 trn ( Vector3 vector ) { } public Matrix4 trn ( float x , float y , float z ) { } public float [ ] getValues ( ) { } public Matrix4 mul ( Matrix4 matrix ) { } public Matrix4 mulLeft ( Matrix4 matrix ) { } public Matrix4 tra ( ) { } public Matrix4 idt ( ) { } public Matrix4 inv ( ) { } public float det ( ) { } public float det3x3 ( ) { } public Matrix4 setToProjection ( float near , float far , float fov , float aspectRatio ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height , float near , float far ) { } public Matrix4 setToOrtho ( float left , float right , float bottom , float top , float near , float far ) { } public Matrix4 setTranslation ( Vector3 vector ) { } public Matrix4 setTranslation ( float x , float y , float z ) { } public Matrix4 setToTranslation ( Vector3 vector ) { } public Matrix4 setToTranslation ( float x , float y , float z ) { } public Matrix4 setToTranslationAndScaling ( Vector3 translation , Vector3 scaling ) { } public Matrix4 setToTranslationAndScaling ( float translationX , float translationY , float translationZ , float scalingX , float scalingY , float scalingZ ) { } static Quaternion quat = new Quaternion ( ) ; public Matrix4 setToRotation ( Vector3 axis , float degrees ) { } public Matrix4 setToRotationRad ( Vector3 axis , float radians ) { } public Matrix4 setToRotationRad ( float axisX , float axisY , float axisZ , float radians ) { } public Matrix4 setToRotation ( float axisX , float axisY , float axisZ , float angle ) { } public Matrix4 setToRotation ( final Vector3 v1 , final Vector3 v2 ) { } public Matrix4 setToRotation ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } public Matrix4 setFromEulerAngles ( float yaw , float pitch , float roll ) { } public Matrix4 setToScaling ( Vector3 vector ) { } public Matrix4 setToScaling ( float x , float y , float z ) { } static final Vector3 l_vez = new Vector3 ( ) ; static final Vector3 l_vex = new Vector3 ( ) ; static final Vector3 l_vey = new Vector3 ( ) ; public Matrix4 setToLookAt ( Vector3 direction , Vector3 up ) { } static final Vector3 tmpVec = new Vector3 ( ) ; static final Matrix4 tmpMat = new Matrix4 ( ) ; public Matrix4 setToLookAt ( Vector3 position , Vector3 target , Vector3 up ) { } static final Vector3 right = new Vector3 ( ) ; static final Vector3 tmpForward = new Vector3 ( ) ; static final Vector3 tmpUp = new Vector3 ( ) ; public Matrix4 setToWorld ( Vector3 position , Vector3 forward , Vector3 up ) { Matrix4 . tmpForward . set ( forward ) . nor ( ) ; Matrix4 . right . set ( Matrix4 . tmpForward ) . crs ( up ) . nor ( ) ; Matrix4 . tmpUp . set ( Matrix4 . right ) . crs ( Matrix4 . tmpForward ) . nor ( ) ; <START_BUG> this . set ( Matrix4 . right , Matrix4 . tmpUp , Matrix4 . tmpForward , position ) ; <END_BUG> return this ; } public String toString ( ) { } public Matrix4 lerp ( Matrix4 matrix , float alpha ) { } public Matrix4 set ( Matrix3 mat ) { } public Matrix4 scl ( Vector3 scale ) { } public Matrix4 scl ( float x , float y , float z ) { } public Matrix4 scl ( float scale ) { } public Vector3 getTranslation ( Vector3 position ) { } public Quaternion getRotation ( Quaternion rotation , boolean normalizeAxes ) { } public Quaternion getRotation ( Quaternion rotation ) { } public float getScaleXSquared ( ) { } public float getScaleYSquared ( ) { } public float getScaleZSquared ( ) { } public float getScaleX ( ) { } public float getScaleY ( ) { } public float getScaleZ ( ) { } public Vector3 getScale ( Vector3 scale ) { } public Matrix4 toNormalMatrix ( ) { } static void matrix4_mul ( float [ ] mata , float [ ] matb ) { } static float matrix4_det ( float [ ] val ) { } static boolean matrix4_inv ( float [ ] val ) { } static void matrix4_mulVec ( float [ ] mat , float [ ] vec , int offset ) { } static void matrix4_proj ( float [ ] mat , float [ ] vec , int offset ) { } static void matrix4_rot ( float [ ] mat , float [ ] vec , int offset ) { } public static void mul ( float [ ] mata , float [ ] matb ) { }
public class StringText implements Text { public static final Text [ ] EMPTY_ARRAY = new Text [ 0 ] ; public static Text [ ] convertFromStringArray ( String [ ] strings ) { } private final String text ; public StringText ( String text ) { } @ Override public boolean hasBytes ( ) { } @ Override public BytesReference bytes ( ) { } @ Override public boolean hasString ( ) { } @ Override public String string ( ) { } @ Override public String toString ( ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } @ Override public int compareTo ( Text text ) { <START_BUG> return this . text . compareTo ( text . string ( ) ) ; <END_BUG> } }
public class IdentityMap < K , V > { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; public int size ; K [ ] keyTable ; V [ ] valueTable ; int capacity ; int stashSize ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private IdentityMap . Entries entries1 ; private IdentityMap . Entries entries2 ; private IdentityMap . Values values1 ; private IdentityMap . Values values2 ; private IdentityMap . Keys keys1 ; private IdentityMap . Keys keys2 ; public IdentityMap ( ) { } public IdentityMap ( int initialCapacity ) { } public IdentityMap ( int initialCapacity , float loadFactor ) { } public IdentityMap ( IdentityMap map ) { } public V put ( K key , V value ) { } private void putResize ( K key , V value ) { } private void push ( K insertKey , V insertValue , int index1 , K key1 , int index2 , K key2 , int index3 , K key3 ) { } private void putStash ( K key , V value ) { } public V get ( K key ) { } public V get ( K key , V defaultValue ) { } private V getStash ( K key , V defaultValue ) { } public V remove ( K key ) { } V removeStash ( K key ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean containsValue ( Object value , boolean identity ) { } public boolean containsKey ( K key ) { } private boolean containsKeyStash ( K key ) { } public K findKey ( Object value , boolean identity ) { } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public IdentityMap . Entries < K , V > entries ( ) { } public IdentityMap . Values < V > values ( ) { } public IdentityMap . Keys < K > keys ( ) { } public static class Entry < K , V > { public K key ; public V value ; public String toString ( ) { } } private static class MapIterator < K , V > { public boolean hasNext ; final IdentityMap < K , V > map ; int nextIndex ; int currentIndex ; boolean valid = true ; public MapIterator ( IdentityMap < K , V > map ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { if ( ( currentIndex ) < 0 ) throw new IllegalStateException ( "next<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>called<seq2seq4repair_space>before<seq2seq4repair_space>remove." ) ; if ( ( currentIndex ) >= ( map . capacity ) ) { map . removeStashIndex ( currentIndex ) ; <START_BUG> nextIndex = currentIndex ; <END_BUG> findNextIndex ( ) ; } else { map . keyTable [ currentIndex ] = null ; map . valueTable [ currentIndex ] = null ; } currentIndex = - 1 ; ( map . size ) -- ; } } public static class Entries < K , V > extends IdentityMap . MapIterator < K , V > implements Iterable < IdentityMap . Entry < K , V > > , Iterator < IdentityMap . Entry < K , V > > { private IdentityMap . Entry < K , V > entry = new IdentityMap . Entry ( ) ; public Entries ( IdentityMap < K , V > map ) { } public IdentityMap . Entry < K , V > next ( ) { } public boolean hasNext ( ) { } public Iterator < IdentityMap . Entry < K , V > > iterator ( ) { } } public static class Values < V > extends IdentityMap . MapIterator < Object , V > implements Iterable < V > , Iterator < V > { public Values ( IdentityMap < ? , V > map ) { } public boolean hasNext ( ) { } public V next ( ) { } public Iterator < V > iterator ( ) { } public Array < V > toArray ( ) { } public void toArray ( Array < V > array ) { } } public static class Keys < K > extends IdentityMap . MapIterator < K , Object > implements Iterable < K > , Iterator < K > { public Keys ( IdentityMap < K , ? > map ) { } public boolean hasNext ( ) { } public K next ( ) { } public Iterator < K > iterator ( ) { } public Array < K > toArray ( ) { } } }
public class UidFieldMapper extends AbstractFieldMapper < Uid > implements InternalMapper , RootMapper { public static final String NAME = "_uid" ; public static final Term TERM_FACTORY = new Term ( UidFieldMapper . NAME , "" ) ; public static final String CONTENT_TYPE = "_uid" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = UidFieldMapper . NAME ; public static final Index INDEX = Index . NOT_ANALYZED ; public static final boolean OMIT_NORMS = true ; public static final boolean OMIT_TERM_FREQ_AND_POSITIONS = false ; } public static class Builder extends Mapper . Builder < UidFieldMapper . Builder , UidFieldMapper > { protected String indexName ; public Builder ( ) { } @ Override public UidFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private ThreadLocal < UidField > fieldCache = new ThreadLocal < UidField > ( ) { @ Override protected UidField initialValue ( ) { } } ; public UidFieldMapper ( ) { } protected UidFieldMapper ( String name ) { } protected UidFieldMapper ( String name , String indexName ) { } @ Override public void preParse ( ParseContext context ) throws IOException { } @ Override public void postParse ( ParseContext context ) throws IOException { } @ Override public void parse ( ParseContext context ) throws IOException { } @ Override public void validate ( ParseContext context ) throws MapperParsingException { } @ Override public boolean includeInObject ( ) { } @ Override protected Fieldable parseCreateField ( ParseContext context ) throws IOException { } @ Override public Uid value ( Fieldable field ) { } @ Override public Uid valueFromString ( String value ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } public Term term ( String type , String id ) { } public Term term ( String uid ) { <START_BUG> return termFactory . createTerm ( uid ) ; <END_BUG> } @ Override public void close ( ) { } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public class Bresenham2 { private final Array < GridPoint2 > points = new Array < GridPoint2 > ( ) ; private final Pool < GridPoint2 > pool = new Pool < GridPoint2 > ( ) { @ Override protected GridPoint2 newObject ( ) { } } ; public Array < GridPoint2 > line ( GridPoint2 start , GridPoint2 end ) { <START_BUG> return line ( start . x , start . y , end . y , end . y ) ; <END_BUG> } public Array < GridPoint2 > line ( int startX , int startY , int endX , int endY ) { } public Array < GridPoint2 > line ( int startX , int startY , int endX , int endY , Pool < GridPoint2 > pool , Array < GridPoint2 > output ) { } }
public class Json { private static final boolean debug = false ; private JsonWriter writer ; private String typeName = "class" ; private boolean usePrototypes = true ; private OutputType outputType ; private final ObjectMap < Class , ObjectMap < String , Json . FieldMetadata > > typeToFields = new ObjectMap ( ) ; private final ObjectMap < String , Class > tagToClass = new ObjectMap ( ) ; private final ObjectMap < Class , String > classToTag = new ObjectMap ( ) ; private final ObjectMap < Class , Json . Serializer > classToSerializer = new ObjectMap ( ) ; private final ObjectMap < Class , Object [ ] > classToDefaultValues = new ObjectMap ( ) ; private Json . Serializer defaultSerializer ; private boolean ignoreUnknownFields ; public Json ( ) { } public Json ( OutputType outputType ) { } public void setIgnoreUnknownFields ( boolean ignoreUnknownFields ) { } public void setOutputType ( OutputType outputType ) { } public void addClassTag ( String tag , Class type ) { } public Class getClass ( String tag ) { } public String getTag ( Class type ) { } public void setTypeName ( String typeName ) { } public void setDefaultSerializer ( Json . Serializer defaultSerializer ) { } public < T > void setSerializer ( Class < T > type , Json . Serializer < T > serializer ) { } public < T > Json . Serializer < T > getSerializer ( Class < T > type ) { } public void setUsePrototypes ( boolean usePrototypes ) { } public void setElementType ( Class type , String fieldName , Class elementType ) { } private ObjectMap < String , Json . FieldMetadata > cacheFields ( Class type ) { } public String toJson ( Object object ) { } public String toJson ( Object object , Class knownType ) { } public String toJson ( Object object , Class knownType , Class elementType ) { } public void toJson ( Object object , FileHandle file ) { } public void toJson ( Object object , Class knownType , FileHandle file ) { } public void toJson ( Object object , Class knownType , Class elementType , FileHandle file ) { Writer writer = null ; try { <START_BUG> writer = file . writer ( false ) ; <END_BUG> toJson ( object , knownType , elementType , writer ) ; } catch ( Exception ex ) { throw new SerializationException ( ( "Error<seq2seq4repair_space>writing<seq2seq4repair_space>file:<seq2seq4repair_space>" + file ) , ex ) ; } finally { StreamUtils . closeQuietly ( writer ) ; } } public void toJson ( Object object , Writer writer ) { } public void toJson ( Object object , Class knownType , Writer writer ) { } public void toJson ( Object object , Class knownType , Class elementType , Writer writer ) { } public void setWriter ( Writer writer ) { } public JsonWriter getWriter ( ) { } public void writeFields ( Object object ) { } private Object [ ] getDefaultValues ( Class type ) { } public void writeField ( Object object , String name ) { } public void writeField ( Object object , String name , Class elementType ) { } public void writeField ( Object object , String fieldName , String jsonName ) { } public void writeField ( Object object , String fieldName , String jsonName , Class elementType ) { } public void writeValue ( String name , Object value ) { } public void writeValue ( String name , Object value , Class knownType ) { } public void writeValue ( String name , Object value , Class knownType , Class elementType ) { } public void writeValue ( Object value ) { } public void writeValue ( Object value , Class knownType ) { } public void writeValue ( Object value , Class knownType , Class elementType ) { } public void writeObjectStart ( String name ) { } public void writeObjectStart ( String name , Class actualType , Class knownType ) { } public void writeObjectStart ( ) { } public void writeObjectStart ( Class actualType , Class knownType ) { } public void writeObjectEnd ( ) { } public void writeArrayStart ( String name ) { } public void writeArrayStart ( ) { } public void writeArrayEnd ( ) { } public void writeType ( Class type ) { } public < T > T fromJson ( Class < T > type , Reader reader ) { } public < T > T fromJson ( Class < T > type , Class elementType , Reader reader ) { } public < T > T fromJson ( Class < T > type , InputStream input ) { } public < T > T fromJson ( Class < T > type , Class elementType , InputStream input ) { } public < T > T fromJson ( Class < T > type , FileHandle file ) { } public < T > T fromJson ( Class < T > type , Class elementType , FileHandle file ) { } public < T > T fromJson ( Class < T > type , char [ ] data , int offset , int length ) { } public < T > T fromJson ( Class < T > type , Class elementType , char [ ] data , int offset , int length ) { } public < T > T fromJson ( Class < T > type , String json ) { } public < T > T fromJson ( Class < T > type , Class elementType , String json ) { } public void readField ( Object object , String name , JsonValue jsonData ) { } public void readField ( Object object , String name , Class elementType , JsonValue jsonData ) { } public void readField ( Object object , String fieldName , String jsonName , JsonValue jsonData ) { }
abstract class QueryCollector extends Collector { final IndexFieldData idFieldData ; final IndexSearcher searcher ; final ConcurrentMap < HashedBytesRef , Query > queries ; final ESLogger logger ; final ExistsCollector collector = new Lucene . ExistsCollector ( ) ; final HashedBytesRef spare = new HashedBytesRef ( new BytesRef ( ) ) ; BytesValues values ; final List < Collector > facetCollectors = new ArrayList < Collector > ( ) ; final Collector facetCollector ; QueryCollector ( ESLogger logger , PercolateContext context ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { <START_BUG> values = idFieldData . load ( context ) . getBytesValues ( ) ; <END_BUG> if ( ( facetCollector ) != null ) { facetCollector . setNextReader ( context ) ; } } @ Override public boolean acceptsDocsOutOfOrder ( ) { } static QueryCollector . Match match ( ESLogger logger , PercolateContext context , HighlightPhase highlightPhase ) { } static QueryCollector . Count count ( ESLogger logger , PercolateContext context ) { } static QueryCollector . MatchAndScore matchAndScore ( ESLogger logger , PercolateContext context , HighlightPhase highlightPhase ) { } static QueryCollector . MatchAndSort matchAndSort ( ESLogger logger , PercolateContext context ) { } static final class Match extends QueryCollector { final PercolateContext context ; final HighlightPhase highlightPhase ; final List < BytesRef > matches = new ArrayList < BytesRef > ( ) ; final List < Map < String , HighlightField > > hls = new ArrayList < Map < String , HighlightField > > ( ) ; final boolean limit ; final int size ; long counter = 0 ; Match ( ESLogger logger , PercolateContext context , HighlightPhase highlightPhase ) { } @ Override public void collect ( int doc ) throws IOException { } long counter ( ) { } List < BytesRef > matches ( ) { } List < Map < String , HighlightField > > hls ( ) { } } static final class MatchAndSort extends QueryCollector { private final TopScoreDocCollector topDocsCollector ; MatchAndSort ( ESLogger logger , PercolateContext context ) { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { super . setNextReader ( context ) ; topDocsCollector . setNextReader ( context ) ; } @ Override public void setScorer ( Scorer scorer ) throws IOException { } TopDocs topDocs ( ) { } } static final class MatchAndScore extends QueryCollector { final PercolateContext context ; final HighlightPhase highlightPhase ; final List < BytesRef > matches = new ArrayList < BytesRef > ( ) ; final List < Map < String , HighlightField > > hls = new ArrayList < Map < String , HighlightField > > ( ) ; final FloatArrayList scores = new FloatArrayList ( ) ; final boolean limit ; final int size ; long counter = 0 ; private Scorer scorer ; MatchAndScore ( ESLogger logger , PercolateContext context , HighlightPhase highlightPhase ) { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } long counter ( ) { } List < BytesRef > matches ( ) { } FloatArrayList scores ( ) { } List < Map < String , HighlightField > > hls ( ) { } } static final class Count extends QueryCollector { private long counter = 0 ; Count ( ESLogger logger , PercolateContext context ) { } @ Override public void collect ( int doc ) throws IOException { } long counter ( ) { } } }
public class DesktopStarter { private static final int WINDOW_WIDTH = 800 ; private static final int WINDOW_HEIGHT = 480 ; public static void main ( String [ ] args ) { <START_BUG> new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new VeryAngryRobotsGame ( ) , "Very<seq2seq4repair_space>Angry<seq2seq4repair_space>Robots" , DesktopStarter . WINDOW_WIDTH , DesktopStarter . WINDOW_HEIGHT , false ) ; <END_BUG> } }
public class Skin implements Disposable { ObjectMap < Class , ObjectMap < String , Object > > resources = new ObjectMap ( ) ; TextureAtlas atlas ; public Skin ( ) { } public Skin ( FileHandle skinFile ) { } public Skin ( FileHandle skinFile , TextureAtlas atlas ) { } public Skin ( TextureAtlas atlas ) { } public void load ( FileHandle skinFile ) { } public void addRegions ( TextureAtlas atlas ) { } public void add ( String name , Object resource ) { } public void add ( String name , Object resource , Class type ) { } public < T > T get ( Class < T > type ) { } public < T > T get ( String name , Class < T > type ) { } public < T > T optional ( String name , Class < T > type ) { } public boolean has ( String name , Class type ) { } public < T > ObjectMap < String , T > getAll ( Class < T > type ) { } public Color getColor ( String name ) { } public BitmapFont getFont ( String name ) { } public TextureRegion getRegion ( String name ) { TextureRegion region = optional ( name , TextureRegion . class ) ; if ( region != null ) return region ; Texture texture = optional ( name , Texture . class ) ; if ( texture == null ) throw new GdxRuntimeException ( ( "No<seq2seq4repair_space>TextureRegion<seq2seq4repair_space>or<seq2seq4repair_space>Texture<seq2seq4repair_space>registered<seq2seq4repair_space>with<seq2seq4repair_space>name:<seq2seq4repair_space>" + name ) ) ; region = new TextureRegion ( texture ) ; <START_BUG> add ( name , region , Texture . class ) ; <END_BUG> return region ; } public TiledDrawable getTiledDrawable ( String name ) { } public NinePatch getPatch ( String name ) { } public Sprite getSprite ( String name ) { } public Drawable getDrawable ( String name ) { } public String find ( Object resource ) { } public Drawable newDrawable ( String name ) { } public Drawable newDrawable ( String name , float r , float g , float b , float a ) { } public Drawable newDrawable ( String name , Color tint ) { } public Drawable newDrawable ( Drawable drawable ) { } public Drawable newDrawable ( Drawable drawable , float r , float g , float b , float a ) { } public Drawable newDrawable ( Drawable drawable , Color tint ) { } public void setEnabled ( Actor actor , boolean enabled ) { } public TextureAtlas getAtlas ( ) { } public void dispose ( ) { } protected Json getJsonLoader ( final FileHandle skinFile ) { } private static Method findMethod ( Class type , String name ) { } public static class TintedDrawable { public String name ; public Color color ; } }
public class PurchaseManageriOSApple implements PurchaseManager { @ Override public String storeName ( ) { } @ Override public void install ( PurchaseObserver observer , PurchaseManagerConfig config ) { } @ Override public boolean installed ( ) { } @ Override public void dispose ( ) { } @ Override <START_BUG> public void purchase ( PurchaseListener listener , String identifier ) { <END_BUG> } @ Override public void purchaseRestore ( ) { } }
public class DiscoveryService extends AbstractLifecycleComponent < DiscoveryService > { private static class InitialStateListener implements InitialStateDiscoveryListener { private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private volatile boolean initialStateReceived ; @ Override public void initialStateProcessed ( ) { } public boolean waitForInitialState ( TimeValue timeValue ) throws InterruptedException { } } private final TimeValue initialStateTimeout ; private final Discovery discovery ; private DiscoveryService . InitialStateListener initialStateListener ; @ Inject public DiscoveryService ( Settings settings , Discovery discovery ) { } @ Override protected void doStart ( ) throws ElasticsearchException { } public void waitForInitialState ( ) { } @ Override protected void doStop ( ) throws ElasticsearchException { } @ Override protected void doClose ( ) throws ElasticsearchException { } public DiscoveryNode localNode ( ) { } public boolean initialStateReceived ( ) { } public String nodeDescription ( ) { } public void publish ( ClusterState clusterState , Discovery . AckListener ackListener ) { } public static String generateNodeId ( Settings settings ) { String seed = settings . get ( "discovery.id.seed" ) ; if ( seed != null ) { <START_BUG> Strings . randomBase64UUID ( new Random ( Long . parseLong ( seed ) ) ) ; <END_BUG> } return Strings . randomBase64UUID ( ) ; } }
public class RayPickRagdollTest extends BaseBulletTest { final Array < btTypedConstraint > constraints = new Array < btTypedConstraint > ( ) ; btPoint2PointConstraint pickConstraint = null ; btRigidBody pickedBody = null ; float pickDistance ; @ Override public void create ( ) { } @ Override public void dispose ( ) { } @ Override public boolean touchDown ( int screenX , int screenY , int pointer , int button ) { } @ Override public boolean touchUp ( int screenX , int screenY , int pointer , int button ) { } @ Override public boolean touchDragged ( int screenX , int screenY , int pointer ) { } @ Override public boolean tap ( float x , float y , int count , int button ) { } static final float PI = MathUtils . PI ; static final float PI2 = 0.5F * ( RayPickRagdollTest . PI ) ; static final float PI4 = 0.25F * ( RayPickRagdollTest . PI ) ; public void addRagdoll ( final float x , final float y , final float z ) { } protected Model createCapsuleModel ( float radius , float height ) { final float hh = radius + ( 0.5F * height ) ; <START_BUG> return ModelBuilder . createCylinder ( ( radius * 2 ) , ( hh * 2.0F ) , ( radius * 2.0F ) , 16 , new NewMaterial ( new ColorAttribute ( ColorAttribute . Diffuse , Color . WHITE ) ) , new VertexAttributes ( new com . badlogic . gdx . graphics . VertexAttribute ( Usage . Position , 3 , ShaderProgram . POSITION_ATTRIBUTE ) , new com . badlogic . gdx . graphics . VertexAttribute ( Usage . Normal , 3 , ShaderProgram . NORMAL_ATTRIBUTE ) ) ) ; <END_BUG> } }
public class SpriteBatch implements Disposable { private Mesh mesh ; private Mesh [ ] buffers ; private Texture lastTexture = null ; private float invTexWidth = 0 ; private float invTexHeight = 0 ; private int idx = 0 ; private int currBufferIdx = 0 ; private final float [ ] vertices ; private final Matrix4 transformMatrix = new Matrix4 ( ) ; private final Matrix4 projectionMatrix = new Matrix4 ( ) ; private final Matrix4 combinedMatrix = new Matrix4 ( ) ; private boolean drawing = false ; private boolean blendingDisabled = false ; private int blendSrcFunc = GL11 . GL_SRC_ALPHA ; private int blendDstFunc = GL11 . GL_ONE_MINUS_SRC_ALPHA ; private final ShaderProgram shader ; private boolean ownsShader ; float color = WHITE . toFloatBits ( ) ; private Color tempColor = new Color ( 1 , 1 , 1 , 1 ) ; public int renderCalls = 0 ; public int totalRenderCalls = 0 ; public int maxSpritesInBatch = 0 ; private ShaderProgram customShader = null ; public SpriteBatch ( ) { } public SpriteBatch ( int size ) { } public SpriteBatch ( int size , ShaderProgram defaultShader ) { } public SpriteBatch ( int size , int buffers ) { } public SpriteBatch ( int size , int buffers , ShaderProgram defaultShader ) { } public static ShaderProgram createDefaultShader ( ) { } public void begin ( ) { } public void end ( ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public void setColor ( float color ) { } public Color getColor ( ) { } public void draw ( Texture texture , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { } public void draw ( Texture texture , float x , float y , float width , float height , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { } public void draw ( Texture texture , float x , float y , int srcX , int srcY , int srcWidth , int srcHeight ) { } public void draw ( Texture texture , float x , float y , float width , float height , float u , float v , float u2 , float v2 ) { } public void draw ( Texture texture , float x , float y ) { } public void draw ( Texture texture , float x , float y , float width , float height ) { } public void draw ( Texture texture , float [ ] spriteVertices , int offset , int length ) { } public void draw ( TextureRegion region , float x , float y ) { <START_BUG> draw ( region , x , y , Math . abs ( region . getRegionWidth ( ) ) , Math . abs ( region . getRegionHeight ( ) ) ) ; <END_BUG> } public void draw ( TextureRegion region , float x , float y , float width , float height ) { } public void draw ( TextureRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation ) { } public void draw ( TextureRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation , boolean clockwise ) { } public void flush ( ) { } private void renderMesh ( ) { } public void disableBlending ( ) { } public void enableBlending ( ) { } public void setBlendFunction ( int srcFunc , int dstFunc ) { } public void dispose ( ) { } public Matrix4 getProjectionMatrix ( ) { } public Matrix4 getTransformMatrix ( ) { } public void setProjectionMatrix ( Matrix4 projection ) { } public void setTransformMatrix ( Matrix4 transform ) { } private void setupMatrices ( ) { } private void switchTexture ( Texture texture ) { } public void setShader ( ShaderProgram shader ) { } public boolean isBlendingEnabled ( ) { } public static final int X1 = 0 ; public static final int Y1 = 1 ; public static final int C1 = 2 ; public static final int U1 = 3 ; public static final int V1 = 4 ; public static final int X2 = 5 ; public static final int Y2 = 6 ; public static final int C2 = 7 ; public static final int U2 = 8 ; public static final int V2 = 9 ; public static final int X3 = 10 ; public static final int Y3 = 11 ; public static final int C3 = 12 ; public static final int U3 = 13 ; public static final int V3 = 14 ; public static final int X4 = 15 ; public static final int Y4 = 16 ; public static final int C4 = 17 ; public static final int U4 = 18 ; public static final int V4 = 19 ; }
@ ClusterScope ( scope = Scope . SUITE , numDataNodes = 3 ) public class ScriptFieldTests extends ElasticsearchIntegrationTest { @ Override protected Settings nodeSettings ( int nodeOrdinal ) { <START_BUG> return settingsBuilder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( "plugin.types" , ScriptFieldTests . CustomScriptPlugin . class . getName ( ) ) . build ( ) ; <END_BUG> } static int [ ] intArray = new int [ ] { Integer . MAX_VALUE , Integer . MIN_VALUE , 3 } ; static long [ ] longArray = new long [ ] { Long . MAX_VALUE , Long . MIN_VALUE , 9223372036854775807L } ; static float [ ] floatArray = new float [ ] { Float . MAX_VALUE , Float . MIN_VALUE , 3.3F } ; static double [ ] doubleArray = new double [ ] { Double . MAX_VALUE , Double . MIN_VALUE , 3.3 } ; public void testNativeScript ( ) throws InterruptedException , ExecutionException { } static class IntArrayScriptFactory implements NativeScriptFactory { @ Override public ExecutableScript newScript ( @ Nullable Map < String , Object > params ) { } } static class IntScript extends AbstractSearchScript { @ Override public Object run ( ) { } } static class LongArrayScriptFactory implements NativeScriptFactory { @ Override public ExecutableScript newScript ( @ Nullable Map < String , Object > params ) { } } static class LongScript extends AbstractSearchScript { @ Override public Object run ( ) { } } static class FloatArrayScriptFactory implements NativeScriptFactory { @ Override public ExecutableScript newScript ( @ Nullable Map < String , Object > params ) { } } static class FloatScript extends AbstractSearchScript { @ Override public Object run ( ) { } } static class DoubleArrayScriptFactory implements NativeScriptFactory { @ Override public ExecutableScript newScript ( @ Nullable Map < String , Object > params ) { } } static class DoubleScript extends AbstractSearchScript { @ Override public Object run ( ) { } } public static class CustomScriptPlugin extends AbstractPlugin { @ Override public String name ( ) { } @ Override public String description ( ) { } public void onModule ( ScriptModule scriptModule ) { } } }
public class IdentityMap < K , V > { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; public int size ; K [ ] keyTable ; V [ ] valueTable ; int capacity ; int stashSize ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private IdentityMap . Entries entries1 ; private IdentityMap . Entries entries2 ; private IdentityMap . Values values1 ; private IdentityMap . Values values2 ; private IdentityMap . Keys keys1 ; private IdentityMap . Keys keys2 ; public IdentityMap ( ) { } public IdentityMap ( int initialCapacity ) { } public IdentityMap ( int initialCapacity , float loadFactor ) { } public IdentityMap ( IdentityMap map ) { } public V put ( K key , V value ) { } private void putResize ( K key , V value ) { } private void push ( K insertKey , V insertValue , int index1 , K key1 , int index2 , K key2 , int index3 , K key3 ) { } private void putStash ( K key , V value ) { } public V get ( K key ) { } public V get ( K key , V defaultValue ) { } private V getStash ( K key , V defaultValue ) { } public V remove ( K key ) { } V removeStash ( K key ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean containsValue ( Object value , boolean identity ) { } public boolean containsKey ( K key ) { } private boolean containsKeyStash ( K key ) { } public K findKey ( Object value , boolean identity ) { } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public IdentityMap . Entries < K , V > entries ( ) { } public IdentityMap . Values < V > values ( ) { } public IdentityMap . Keys < K > keys ( ) { } public static class Entry < K , V > { public K key ; public V value ; public String toString ( ) { } } private static class MapIterator < K , V > { public boolean hasNext ; final IdentityMap < K , V > map ; int nextIndex ; int currentIndex ; boolean valid = true ; public MapIterator ( IdentityMap < K , V > map ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { if ( ( currentIndex ) < 0 ) throw new IllegalStateException ( "next<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>called<seq2seq4repair_space>before<seq2seq4repair_space>remove." ) ; if ( ( currentIndex ) >= ( map . capacity ) ) { map . removeStashIndex ( currentIndex ) ; <START_BUG> nextIndex = ( currentIndex ) - 1 ; <END_BUG> findNextIndex ( ) ; } else { map . keyTable [ currentIndex ] = null ; map . valueTable [ currentIndex ] = null ; } currentIndex = - 1 ; ( map . size ) -- ; } } public static class Entries < K , V > extends IdentityMap . MapIterator < K , V > implements Iterable < IdentityMap . Entry < K , V > > , Iterator < IdentityMap . Entry < K , V > > { private IdentityMap . Entry < K , V > entry = new IdentityMap . Entry ( ) ; public Entries ( IdentityMap < K , V > map ) { } public IdentityMap . Entry < K , V > next ( ) { } public boolean hasNext ( ) { } public Iterator < IdentityMap . Entry < K , V > > iterator ( ) { } } public static class Values < V > extends IdentityMap . MapIterator < Object , V > implements Iterable < V > , Iterator < V > { public Values ( IdentityMap < ? , V > map ) { } public boolean hasNext ( ) { } public V next ( ) { } public Iterator < V > iterator ( ) { } public Array < V > toArray ( ) { } public void toArray ( Array < V > array ) { } } public static class Keys < K > extends IdentityMap . MapIterator < K , Object > implements Iterable < K > , Iterator < K > { public Keys ( IdentityMap < K , ? > map ) { } public boolean hasNext ( ) { } public K next ( ) { } public Iterator < K > iterator ( ) { } public Array < K > toArray ( ) { } } }
public class TransportSearchDfsQueryAndFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchDfsQueryAndFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < DfsSearchResult > { private final AtomicArray < QueryFetchSearchResult > queryFetchResults ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , ShardSearchRequest request , SearchServiceListener < DfsSearchResult > listener ) { } @ Override protected void moveToSecondPhase ( ) { } void executeSecondPhase ( final int shardIndex , final DfsSearchResult dfsResult , final AtomicInteger counter , DiscoveryNode node , final QuerySearchRequest querySearchRequest ) { searchService . sendExecuteFetch ( node , querySearchRequest , new SearchServiceListener < QueryFetchSearchResult > ( ) { @ Override public void onResult ( QueryFetchSearchResult result ) { result . shardTarget ( dfsResult . shardTarget ( ) ) ; queryFetchResults . set ( shardIndex , result ) ; if ( ( counter . decrementAndGet ( ) ) == 0 ) { finishHim ( ) ; } } @ Override public void onFailure ( Throwable t ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "[{}]<seq2seq4repair_space>Failed<seq2seq4repair_space>to<seq2seq4repair_space>execute<seq2seq4repair_space>query<seq2seq4repair_space>phase" , t , querySearchRequest . id ( ) ) ; } <START_BUG> TransportSearchDfsQueryAndFetchAction . AsyncAction . this . addShardFailure ( shardIndex , t ) ; <END_BUG> successulOps . decrementAndGet ( ) ; if ( ( counter . decrementAndGet ( ) ) == 0 ) { finishHim ( ) ; } } } ) ; } void finishHim ( ) { } void innerFinishHim ( ) throws Exception { } } }
public class TransportRefreshAction extends TransportBroadcastOperationAction < RefreshRequest , RefreshResponse , ShardRefreshRequest , ShardRefreshResponse > { private final IndicesService indicesService ; @ Inject public TransportRefreshAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected RefreshRequest newRequest ( ) { } @ Override protected RefreshResponse newResponse ( RefreshRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardRefreshRequest newShardRequest ( ) { } @ Override protected ShardRefreshRequest newShardRequest ( ShardRouting shard , RefreshRequest request ) { } @ Override protected ShardRefreshResponse newShardResponse ( ) { } @ Override protected ShardRefreshResponse shardOperation ( ShardRefreshRequest request ) throws ElasticSearchException { IndexShard indexShard = indicesService . indexServiceSafe ( request . index ( ) ) . shardSafe ( request . shardId ( ) ) ; <START_BUG> indexShard . refresh ( new Engine . Refresh ( ) . force ( request . force ( ) ) . source ( "api" ) ) ; <END_BUG> logger . trace ( "{}<seq2seq4repair_space>refresh<seq2seq4repair_space>request<seq2seq4repair_space>executed,<seq2seq4repair_space>force:<seq2seq4repair_space>[{}]" , indexShard . shardId ( ) , request . force ( ) ) ; return new ShardRefreshResponse ( request . index ( ) , request . shardId ( ) ) ; } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , RefreshRequest request , String [ ] concreteIndices ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , RefreshRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , RefreshRequest countRequest , String [ ] concreteIndices ) { } }
public class BoundingBox implements Serializable { private static final long serialVersionUID = - 1286036817192127343L ; private static final Vector3 tmpVector = new Vector3 ( ) ; public final Vector3 min = new Vector3 ( ) ; public final Vector3 max = new Vector3 ( ) ; private final Vector3 cnt = new Vector3 ( ) ; private final Vector3 dim = new Vector3 ( ) ; @ Deprecated private Vector3 [ ] corners ; @ Deprecated public Vector3 getCenter ( ) { } public Vector3 getCenter ( Vector3 out ) { <START_BUG> return out . set ( cnt ) ; <END_BUG> } public float getCenterX ( ) { } public float getCenterY ( ) { } public float getCenterZ ( ) { } @ Deprecated protected void updateCorners ( ) { } @ Deprecated public Vector3 [ ] getCorners ( ) { } public Vector3 getCorner000 ( final Vector3 out ) { } public Vector3 getCorner001 ( final Vector3 out ) { } public Vector3 getCorner010 ( final Vector3 out ) { } public Vector3 getCorner011 ( final Vector3 out ) { } public Vector3 getCorner100 ( final Vector3 out ) { } public Vector3 getCorner101 ( final Vector3 out ) { } public Vector3 getCorner110 ( final Vector3 out ) { } public Vector3 getCorner111 ( final Vector3 out ) { } @ Deprecated public Vector3 getDimensions ( ) { } public Vector3 getDimensions ( final Vector3 out ) { } public float getWidth ( ) { } public float getHeight ( ) { } public float getDepth ( ) { } @ Deprecated public Vector3 getMin ( ) { } public Vector3 getMin ( final Vector3 out ) { } @ Deprecated public Vector3 getMax ( ) { } public Vector3 getMax ( final Vector3 out ) { } public BoundingBox ( ) { } public BoundingBox ( BoundingBox bounds ) { } public BoundingBox ( Vector3 minimum , Vector3 maximum ) { } public BoundingBox set ( BoundingBox bounds ) { } public BoundingBox set ( Vector3 minimum , Vector3 maximum ) { } public BoundingBox set ( Vector3 [ ] points ) { } public BoundingBox set ( List < Vector3 > points ) { } public BoundingBox inf ( ) { } public BoundingBox ext ( Vector3 point ) { } public BoundingBox clr ( ) { } public boolean isValid ( ) { } public BoundingBox ext ( BoundingBox a_bounds ) { } public BoundingBox ext ( BoundingBox bounds , Matrix4 transform ) { } public BoundingBox mul ( Matrix4 transform ) { } public boolean contains ( BoundingBox b ) { } public boolean intersects ( BoundingBox b ) { } public boolean contains ( Vector3 v ) { } @ Override public String toString ( ) { } public BoundingBox ext ( float x , float y , float z ) { } static final float min ( final float a , final float b ) { } static final float max ( final float a , final float b ) { } }
public class GwtFileHandle extends FileHandle { public final Preloader preloader ; private final String file ; private final FileType type ; protected GwtFileHandle ( Preloader preloader , String fileName , FileType type ) { } public GwtFileHandle ( String path ) { } public String path ( ) { } public String name ( ) { } public String extension ( ) { } public String nameWithoutExtension ( ) { } public String pathWithoutExtension ( ) { } public FileType type ( ) { } public File file ( ) { } public InputStream read ( ) { } public BufferedInputStream read ( int bufferSize ) { } public Reader reader ( ) { } public Reader reader ( String charset ) { } public BufferedReader reader ( int bufferSize ) { } public BufferedReader reader ( int bufferSize , String charset ) { } public String readString ( ) { } public String readString ( String charset ) { } public byte [ ] readBytes ( ) { } public int readBytes ( byte [ ] bytes , int offset , int size ) { } public OutputStream write ( boolean append ) { } public void write ( InputStream input , boolean append ) { } public Writer writer ( boolean append ) { } public Writer writer ( boolean append , String charset ) { } public void writeString ( String string , boolean append ) { } public void writeString ( String string , boolean append , String charset ) { } public void writeBytes ( byte [ ] bytes , boolean append ) { } public void writeBytes ( byte [ ] bytes , int offset , int length , boolean append ) { } public FileHandle [ ] list ( ) { } public FileHandle [ ] list ( String suffix ) { } public boolean isDirectory ( ) { } public FileHandle child ( String name ) { <START_BUG> return new GwtFileHandle ( preloader , ( ( ( file ) + ( file . endsWith ( "/" ) ? "" : "/" ) ) + name ) , FileType . Internal ) ; <END_BUG> } public FileHandle parent ( ) { } public FileHandle sibling ( String name ) { } public void mkdirs ( ) { } public boolean exists ( ) { } public boolean delete ( ) { } public boolean deleteDirectory ( ) { } public void copyTo ( FileHandle dest ) { } public void moveTo ( FileHandle dest ) { } public long length ( ) { } public long lastModified ( ) { } public String toString ( ) { } }
public class ViewGistActivity extends DialogFragmentActivity implements OnItemClickListener { public static final int RESULT_DELETED = RESULT_FIRST_USER ; private static final int REQUEST_CODE_COMMENT = 1 ; private static final int REQUEST_CONFIRM_DELETE = ( ViewGistActivity . REQUEST_CODE_COMMENT ) + 1 ; public static final Intent createIntent ( Gist gist ) { } public static final Intent createIntent ( String gistId ) { } @ InjectExtra ( EXTRA_GIST_ID ) private String gistId ; @ InjectExtra ( value = EXTRA_COMMENTS , optional = true ) private List < Comment > comments ; private Gist gist ; @ InjectView ( id . list ) private ListView list ; @ Inject private GistStore store ; @ Inject private ContextScopedProvider < GistService > service ; private View headerView ; private GistHeaderViewHolder headerHolder ; private View loadingView ; private RefreshAnimation refreshAnimation = new RefreshAnimation ( ) ; private boolean starred ; private boolean loadFinished ; @ Inject private AvatarHelper avatarHelper ; @ Inject private ContextScopedProvider < GistService > gistServiceProvider ; private Executor executor = Executors . newFixedThreadPool ( 1 ) ; private List < View > fileHeaders = Lists . newArrayList ( ) ; protected void onCreate ( Bundle savedInstanceState ) { } private boolean isOwner ( ) { } @ Override public boolean onCreateOptionsMenu ( Menu options ) { } @ Override public boolean onPrepareOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } private void starGist ( ) { } private void unstarGist ( ) { } @ Override public void onDialogResult ( int requestCode , int resultCode , Bundle arguments ) { } protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { } private void createComment ( final String comment ) { } private void updateFiles ( Gist gist ) { } private void updateList ( Gist gist , List < Comment > comments ) { } @ SuppressWarnings ( "unchecked" ) private ViewHoldingListAdapter < Comment > getRootAdapter ( ) { } private void refreshGist ( ) { } public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { Object item = parent . getItemAtPosition ( position ) ; if ( item instanceof GistFile ) <START_BUG> startActivity ( ViewGistFileActivity . createIntent ( gist , ( ( GistFile ) ( item ) ) ) ) ; <END_BUG> } }
public class LittleEndianInputStream extends FilterInputStream { public LittleEndianInputStream ( InputStream in ) { } public boolean readBoolean ( ) throws IOException { } <START_BUG> public byte readByte ( int b ) throws IOException { <END_BUG> int temp = in . read ( ) ; if ( temp == ( - 1 ) ) throw new EOFException ( ) ; return ( ( byte ) ( temp ) ) ; } public int readUnsignedByte ( ) throws IOException { } public short readShort ( ) throws IOException { } public int readUnsignedShort ( ) throws IOException { } public char readChar ( ) throws IOException { } public int readInt ( ) throws IOException { } public long readLong ( ) throws IOException { } public String readUTF ( ) throws IOException { } public final double readDouble ( ) throws IOException { } public final float readFloat ( ) throws IOException { } public final int skipBytes ( int n ) throws IOException { } }
public class MapperQueryParser extends QueryParser { public static final ImmutableMap < String , FieldQueryExtension > fieldQueryExtensions ; private final QueryParseContext parseContext ; private QueryParserSettings settings ; private Analyzer quoteAnalyzer ; private boolean forcedAnalyzer ; private boolean forcedQuoteAnalyzer ; private FieldMapper currentMapper ; private boolean analyzeWildcard ; private String quoteFieldSuffix ; public MapperQueryParser ( QueryParseContext parseContext ) { } public MapperQueryParser ( QueryParserSettings settings , QueryParseContext parseContext ) { } public void reset ( QueryParserSettings settings ) { } @ Override Query handleBareFuzzy ( String qfield , Token fuzzySlop , String termImage ) throws ParseException { } @ Override protected Query newTermQuery ( Term term ) { } @ Override protected Query newMatchAllDocsQuery ( ) { <START_BUG> return Queries . MATCH_ALL_QUERY ; <END_BUG> } @ Override public Query getFieldQuery ( String field , String queryText , boolean quoted ) throws ParseException { } private Query getFieldQuerySingle ( String field , String queryText , boolean quoted ) throws ParseException { } @ Override protected Query getFieldQuery ( String field , String queryText , int slop ) throws ParseException { } @ Override protected Query getRangeQuery ( String field , String part1 , String part2 , boolean startInclusive , boolean endInclusive ) throws ParseException { } private Query getRangeQuerySingle ( String field , String part1 , String part2 , boolean startInclusive , boolean endInclusive ) { } protected Query getFuzzyQuery ( String field , String termStr , String minSimilarity ) throws ParseException { } private Query getFuzzyQuerySingle ( String field , String termStr , String minSimilarity ) throws ParseException { } @ Override protected Query newFuzzyQuery ( Term term , float minimumSimilarity , int prefixLength ) { } @ Override protected Query getPrefixQuery ( String field , String termStr ) throws ParseException { } private Query getPrefixQuerySingle ( String field , String termStr ) throws ParseException { } private Query getPossiblyAnalyzedPrefixQuery ( String field , String termStr ) throws ParseException { } @ Override protected Query getWildcardQuery ( String field , String termStr ) throws ParseException { } private Query getWildcardQuerySingle ( String field , String termStr ) throws ParseException { } private Query getPossiblyAnalyzedWildcardQuery ( String field , String termStr ) throws ParseException { } @ Override protected Query getBooleanQuery ( List < BooleanClause > clauses , boolean disableCoord ) throws ParseException { } private void applyBoost ( String field , Query q ) { } private void applySlop ( Query q , int slop ) { } private Collection < String > extractMultiFields ( String field ) { } }
public final class InjectionPoint { private final boolean optional ; private final Member member ; private final ImmutableList < Dependency < ? > > dependencies ; private InjectionPoint ( Member member , ImmutableList < Dependency < ? > > dependencies , boolean optional ) { } InjectionPoint ( TypeLiteral < ? > type , Method method ) { } InjectionPoint ( TypeLiteral < ? > type , Constructor < ? > constructor ) { } InjectionPoint ( TypeLiteral < ? > type , Field field ) { } private ImmutableList < Dependency < ? > > forMember ( Member member , TypeLiteral < ? > type , Annotation [ ] [ ] paramterAnnotations ) { } private < T > Dependency < T > newDependency ( Key < T > key , boolean allowsNull , int parameterIndex ) { <START_BUG> return new Dependency < T > ( this , key , allowsNull , parameterIndex ) ; <END_BUG> } public Member getMember ( ) { } public List < Dependency < ? > > getDependencies ( ) { } public boolean isOptional ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } public static InjectionPoint forConstructorOf ( TypeLiteral < ? > type ) { } public static InjectionPoint forConstructorOf ( Class < ? > type ) { } public static Set < InjectionPoint > forStaticMethodsAndFields ( TypeLiteral type ) { } public static Set < InjectionPoint > forStaticMethodsAndFields ( Class < ? > type ) { } public static Set < InjectionPoint > forInstanceMethodsAndFields ( TypeLiteral < ? > type ) { } public static Set < InjectionPoint > forInstanceMethodsAndFields ( Class < ? > type ) { } private static void checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { } private static < M extends Member & AnnotatedElement > void addInjectionPoints ( TypeLiteral < ? > type , InjectionPoint . Factory < M > factory , boolean statics , Collection < InjectionPoint > injectionPoints , Errors errors ) { } private static < M extends Member & AnnotatedElement > void addInjectorsForMembers ( TypeLiteral < ? > typeLiteral , InjectionPoint . Factory < M > factory , boolean statics , Collection < InjectionPoint > injectionPoints , Errors errors ) { } private static boolean isStatic ( Member member ) { } private interface Factory < M extends Member & AnnotatedElement > { InjectionPoint . Factory < Field > FIELDS = new InjectionPoint . Factory < Field > ( ) { public Field [ ] getMembers ( Class < ? > type ) { } public InjectionPoint create ( TypeLiteral < ? > typeLiteral , Field member , Errors errors ) { } } ; InjectionPoint . Factory < Method > METHODS = new InjectionPoint . Factory < Method > ( ) { public Method [ ] getMembers ( Class < ? > type ) { } public InjectionPoint create ( TypeLiteral < ? > typeLiteral , Method member , Errors errors ) { } } ; M [ ] getMembers ( Class < ? > type ) { } InjectionPoint create ( TypeLiteral < ? > typeLiteral , M member , Errors errors ) { } } }
public class RestController extends AbstractLifecycleComponent < RestController > { public static final String HTTP_JSON_ENABLE = "http.jsonp.enable" ; private final PathTrie < RestHandler > getHandlers = new PathTrie ( RestUtils . REST_DECODER ) ; private final PathTrie < RestHandler > postHandlers = new PathTrie ( RestUtils . REST_DECODER ) ; private final PathTrie < RestHandler > putHandlers = new PathTrie ( RestUtils . REST_DECODER ) ; private final PathTrie < RestHandler > deleteHandlers = new PathTrie ( RestUtils . REST_DECODER ) ; private final PathTrie < RestHandler > headHandlers = new PathTrie ( RestUtils . REST_DECODER ) ; private final PathTrie < RestHandler > optionsHandlers = new PathTrie ( RestUtils . REST_DECODER ) ; private final RestController . RestHandlerFilter handlerFilter = new RestController . RestHandlerFilter ( ) ; private RestFilter [ ] filters = new RestFilter [ 0 ] ; @ Inject public RestController ( Settings settings ) { } @ Override protected void doStart ( ) throws ElasticsearchException { } @ Override protected void doStop ( ) throws ElasticsearchException { } @ Override protected void doClose ( ) throws ElasticsearchException { } public synchronized void registerFilter ( RestFilter preProcessor ) { RestFilter [ ] copy = new RestFilter [ ( filters . length ) + 1 ] ; System . arraycopy ( filters , 0 , copy , 0 , filters . length ) ; copy [ filters . length ] = preProcessor ; Arrays . sort ( copy , new Comparator < RestFilter > ( ) { @ Override public int compare ( RestFilter o1 , RestFilter o2 ) { <START_BUG> return ( o2 . order ( ) ) - ( o1 . order ( ) ) ; <END_BUG> } } ) ; filters = copy ; } public void registerHandler ( RestRequest . Method method , String path , RestHandler handler ) { } @ Nullable public RestFilterChain filterChainOrNull ( RestFilter executionFilter ) { } public RestFilterChain filterChain ( RestFilter executionFilter ) { } public void dispatchRequest ( final RestRequest request , final RestChannel channel ) { } void executeHandler ( RestRequest request , RestChannel channel ) throws Exception { } private RestHandler getHandler ( RestRequest request ) { } private String getPath ( RestRequest request ) { } class ControllerFilterChain implements RestFilterChain { private final RestFilter executionFilter ; private final AtomicInteger index = new AtomicInteger ( ) ; ControllerFilterChain ( RestFilter executionFilter ) { } @ Override public void continueProcessing ( RestRequest request , RestChannel channel ) { } } class RestHandlerFilter extends RestFilter { @ Override public void process ( RestRequest request , RestChannel channel , RestFilterChain filterChain ) throws Exception { } } }
public class MapperTests { public static XContentDocumentMapperParser newParser ( ) { } public static MapperService newMapperService ( ) { } public static AnalysisService newAnalysisService ( ) { <START_BUG> Injector injector = new ModulesBuilder ( ) . add ( new org . elasticsearch . index . settings . IndexSettingsModule ( Builder . EMPTY_SETTINGS ) , new org . elasticsearch . index . IndexNameModule ( new Index ( "test" ) ) , new org . elasticsearch . index . analysis . AnalysisModule ( Builder . EMPTY_SETTINGS ) ) . createInjector ( ) ; <END_BUG> return injector . getInstance ( AnalysisService . class ) ; } }
public class GroupCullingTest extends GdxTest { private static final int count = 100 ; private Stage stage ; private Skin skin ; private Table root ; private Label drawnLabel ; int drawn ; public void create ( ) { } @ Override public void dispose ( ) { } public void resize ( int width , int height ) { <START_BUG> stage . getViewport ( ) . update ( width , height ) ; <END_BUG> root . invalidate ( ) ; } public void render ( ) { } public boolean needsGL20 ( ) { } }
public interface Application { public enum ApplicationType { Android , Desktop , Applet , WebGL , iOS ; } public static final int LOG_NONE = 0 ; public static final int LOG_DEBUG = 3 ; public static final int LOG_INFO = 2 ; public static final int LOG_ERROR = 1 ; public ApplicationListener getApplicationListener ( ) { } public Graphics getGraphics ( ) { } public Audio getAudio ( ) { } public Input getInput ( ) { } public Files getFiles ( ) { } public Net getNet ( ) { } public void log ( String tag , String message ) { } <START_BUG> public void log ( String tag , String message , Throwable exception ) ; <END_BUG> public void error ( String tag , String message ) { } public void error ( String tag , String message , Throwable exception ) { } public void debug ( String tag , String message ) { } public void debug ( String tag , String message , Throwable exception ) { } public void setLogLevel ( int logLevel ) { } public int getLogLevel ( ) { } public Application . ApplicationType getType ( ) { } public int getVersion ( ) { } public long getJavaHeap ( ) { } public long getNativeHeap ( ) { } public Preferences getPreferences ( String name ) { } public Clipboard getClipboard ( ) { } public void postRunnable ( Runnable runnable ) { } public void exit ( ) { } public void addLifecycleListener ( LifecycleListener listener ) { } public void removeLifecycleListener ( LifecycleListener listener ) { } }
public class DocIdOrdinals implements Ordinals { private final int numDocs ; public DocIdOrdinals ( int numDocs ) { } @ Override public boolean hasSingleArrayBackingStorage ( ) { } @ Override public Object getBackingStorage ( ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override public boolean isMultiValued ( ) { } @ Override public int getNumDocs ( ) { } @ Override public int getNumOrds ( ) { <START_BUG> return ( numDocs ) + 1 ; <END_BUG> } @ Override public Ordinals . Docs ordinals ( ) { } public static class Docs implements Ordinals . Docs { private final DocIdOrdinals parent ; private final IntArrayRef intsScratch = new IntArrayRef ( new int [ 1 ] ) ; private final SingleValueIter iter = new SingleValueIter ( ) ; public Docs ( DocIdOrdinals parent ) { } @ Override public Ordinals ordinals ( ) { } @ Override public int getNumDocs ( ) { } @ Override public int getNumOrds ( ) { return parent . getNumOrds ( ) ; } @ Override public boolean isMultiValued ( ) { } @ Override public int getOrd ( int docId ) { } @ Override public IntArrayRef getOrds ( int docId ) { } @ Override public Iter getIter ( int docId ) { } @ Override public void forEachOrdinalInDoc ( int docId , OrdinalInDocProc proc ) { } } }
public class VertexBufferObjectSubData implements VertexData { static final IntBuffer tmpHandle = BufferUtils . newIntBuffer ( 1 ) ; final VertexAttributes attributes ; final FloatBuffer buffer ; final ByteBuffer byteBuffer ; int bufferHandle ; final boolean isDirect ; final boolean isStatic ; final int usage ; boolean isDirty = false ; boolean isBound = false ; public VertexBufferObjectSubData ( boolean isStatic , int numVertices , VertexAttribute ... attributes ) { } private int createBufferObject ( ) { } @ Override public VertexAttributes getAttributes ( ) { } @ Override public int getNumVertices ( ) { } @ Override public int getNumMaxVertices ( ) { } @ Override public FloatBuffer getBuffer ( ) { } private void bufferChanged ( ) { } @ Override public void setVertices ( float [ ] vertices , int offset , int count ) { } @ Override public void updateVertices ( int targetOffset , float [ ] vertices , int sourceOffset , int count ) { isDirty = true ; if ( isDirect ) { final int pos = byteBuffer . position ( ) ; byteBuffer . position ( ( targetOffset * 4 ) ) ; <START_BUG> BufferUtils . copy ( vertices , sourceOffset , byteBuffer , count ) ; <END_BUG> byteBuffer . position ( pos ) ; } else throw new GdxRuntimeException ( "Buffer<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>allocated<seq2seq4repair_space>direct." ) ; bufferChanged ( ) ; } @ Override public void bind ( ) { } @ Override public void bind ( final ShaderProgram shader ) { } @ Override public void bind ( final ShaderProgram shader , final int [ ] locations ) { } @ Override public void unbind ( ) { } @ Override public void unbind ( final ShaderProgram shader ) { } @ Override public void unbind ( final ShaderProgram shader , final int [ ] locations ) { } public void invalidate ( ) { } @ Override public void dispose ( ) { } public int getBufferHandle ( ) { } }
public class SimpleGetMappingsTests extends ElasticsearchIntegrationTest { @ Test public void getMappingsWhereThereAreNone ( ) { createIndex ( "index" ) ; GetMappingsResponse response = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( ) . execute ( ) . actionGet ( ) ; <START_BUG> assertThat ( response . mappings ( ) , hasKey ( "index" ) ) ; <END_BUG> assertThat ( response . mappings ( ) . get ( "index" ) . size ( ) , equalTo ( 0 ) ) ; } private XContentBuilder getMappingForType ( String type ) throws IOException { } @ Test public void simpleGetMappings ( ) throws Exception { } }
public class BitmapFont implements Disposable { private static final int LOG2_PAGE_SIZE = 9 ; private static final int PAGE_SIZE = 1 << ( BitmapFont . LOG2_PAGE_SIZE ) ; private static final int PAGES = 65536 / ( BitmapFont . PAGE_SIZE ) ; static final char [ ] xChars = new char [ ] { 'x' , 'e' , 'a' , 'o' , 'n' , 's' , 'r' , 'c' , 'u' , 'm' , 'v' , 'w' , 'z' } ; static final char [ ] capChars = new char [ ] { 'M' , 'N' , 'B' , 'D' , 'C' , 'E' , 'F' , 'K' , 'A' , 'G' , 'H' , 'I' , 'J' , 'L' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } ; TextureRegion region ; private final BitmapFont . TextBounds textBounds = new BitmapFont . TextBounds ( ) ; private float color = WHITE . toFloatBits ( ) ; private Color tempColor = new Color ( 1 , 1 , 1 , 1 ) ; private boolean flipped ; private boolean integer = true ; final BitmapFont . BitmapFontData data ; public static class BitmapFontData { String imagePath ; final FileHandle fontFile ; final boolean flipped ; final float lineHeight ; float capHeight = 1 ; float ascent ; float descent ; float down ; float scaleX = 1 ; float scaleY = 1 ; final BitmapFont . Glyph [ ] [ ] glyphs = new BitmapFont . Glyph [ BitmapFont . PAGES ] [ ] ; float spaceWidth ; float xHeight = 1 ; public BitmapFontData ( FileHandle fontFile , boolean flip ) { } private void setGlyph ( int ch , BitmapFont . Glyph glyph ) { } private BitmapFont . Glyph getFirstGlyph ( ) { for ( BitmapFont . Glyph [ ] page : this . glyphs ) { if ( page == null ) continue ; for ( BitmapFont . Glyph glyph : page ) { <START_BUG> if ( glyph == null ) <END_BUG> continue ; return glyph ; } } throw new GdxRuntimeException ( "No<seq2seq4repair_space>glyphs<seq2seq4repair_space>found!" ) ; } public BitmapFont . Glyph getGlyph ( char ch ) { } public String getImagePath ( ) { } public FileHandle getFontFile ( ) { } } public BitmapFont ( ) { } public BitmapFont ( boolean flip ) { } public BitmapFont ( FileHandle fontFile , TextureRegion region , boolean flip ) { } public BitmapFont ( FileHandle fontFile , boolean flip ) { } public BitmapFont ( FileHandle fontFile , FileHandle imageFile , boolean flip ) { } public BitmapFont ( FileHandle fontFile , FileHandle imageFile , boolean flip , boolean integer ) { } public BitmapFont ( BitmapFont . BitmapFontData data , TextureRegion region , boolean integer ) { } private void load ( BitmapFont . BitmapFontData data ) { } public BitmapFont . TextBounds draw ( SpriteBatch spriteBatch , CharSequence str , float x , float y ) { } public BitmapFont . TextBounds draw ( SpriteBatch spriteBatch , CharSequence str , float x , float y , int start , int end ) { } public BitmapFont . TextBounds drawMultiLine ( SpriteBatch spriteBatch , CharSequence str , float x , float y ) { } public BitmapFont . TextBounds drawMultiLine ( SpriteBatch spriteBatch , CharSequence str , float x , float y , float alignmentWidth , BitmapFont . HAlignment alignment ) { } public BitmapFont . TextBounds drawWrapped ( SpriteBatch spriteBatch , CharSequence str , float x , float y , float wrapWidth ) { } public BitmapFont . TextBounds drawWrapped ( SpriteBatch spriteBatch , CharSequence str , float x , float y , float wrapWidth , BitmapFont . HAlignment alignment ) { } public BitmapFont . TextBounds getBounds ( CharSequence str ) { } public BitmapFont . TextBounds getBounds ( CharSequence str , int start , int end ) { } public BitmapFont . TextBounds getMultiLineBounds ( CharSequence str ) { } public BitmapFont . TextBounds getWrappedBounds ( CharSequence str , float wrapWidth ) { } public void computeGlyphAdvancesAndPositions ( CharSequence str , FloatArray glyphAdvances , FloatArray glyphPositions ) { } public int computeVisibleGlyphs ( CharSequence str , int start , int end , float availableWidth ) { } public void setColor ( float color ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public Color getColor ( ) { } public void setScale ( float scaleX , float scaleY ) { } public void setScale ( float scaleXY ) { } public void scale ( float amount ) { } public float getScaleX ( ) { } public float getScaleY ( ) { } public TextureRegion getRegion ( ) { } public float getLineHeight ( ) { } public float getSpaceWidth ( ) { } public float getXHeight ( ) { } public float getCapHeight ( ) { } public float getAscent ( ) { } public float getDescent ( ) { } public boolean isFlipped ( ) { } public void dispose ( ) { } public void setFixedWidthGlyphs ( CharSequence glyphs ) { } public boolean containsCharacter ( char character ) { } public void setUseIntegerPositions ( boolean use ) { } public boolean usesIntegerPositions ( ) { } public BitmapFont . BitmapFontData getData ( ) { } static class Glyph { public int srcX ; public int srcY ; int width ; int height ; float u ; float v ; float u2 ; float v2 ; int xoffset ; int yoffset ; int xadvance ; byte [ ] [ ] kerning ; int getKerning ( char ch ) { } void setKerning ( int ch , int value ) { } } static int indexOf ( CharSequence text , char ch , int start ) { }
public class BooleanFieldMapper extends AbstractFieldMapper < Boolean > { public static final String CONTENT_TYPE = "boolean" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final FieldType FIELD_TYPE = new FieldType ( AbstractFieldMapper . Defaults . FIELD_TYPE ) ; public static final Boolean NULL_VALUE = null ; } public static class Values { public static final BytesRef TRUE = new BytesRef ( "T" ) ; public static final BytesRef FALSE = new BytesRef ( "F" ) ; } public static class Builder extends AbstractFieldMapper . Builder < BooleanFieldMapper . Builder , BooleanFieldMapper > { private Boolean nullValue = BooleanFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public BooleanFieldMapper . Builder nullValue ( boolean nullValue ) { } @ Override public BooleanFieldMapper . Builder index ( boolean index ) { } @ Override public BooleanFieldMapper . Builder store ( boolean store ) { } @ Override protected BooleanFieldMapper . Builder storeTermVectors ( boolean termVectors ) { } @ Override protected BooleanFieldMapper . Builder storeTermVectorOffsets ( boolean termVectorOffsets ) { } @ Override protected BooleanFieldMapper . Builder storeTermVectorPositions ( boolean termVectorPositions ) { } @ Override protected BooleanFieldMapper . Builder storeTermVectorPayloads ( boolean termVectorPayloads ) { } @ Override public BooleanFieldMapper . Builder boost ( float boost ) { } @ Override public BooleanFieldMapper . Builder indexName ( String indexName ) { } @ Override public BooleanFieldMapper . Builder similarity ( SimilarityProvider similarity ) { } @ Override public BooleanFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private Boolean nullValue ; protected BooleanFieldMapper ( Names names , float boost , FieldType fieldType , Boolean nullValue , PostingsFormatProvider provider , SimilarityProvider similarity ) { } @ Override public FieldType defaultFieldType ( ) { } @ Override public boolean useTermQueryWithQueryString ( ) { } @ Override public Boolean value ( Object value ) { } @ Override public Object valueForSearch ( Object value ) { } @ Override public BytesRef indexedValueForSearch ( Object value ) { } @ Override public Filter nullValueFilter ( ) { if ( ( nullValue ) == null ) { return null ; } <START_BUG> return new org . elasticsearch . common . lucene . search . TermFilter ( names ( ) . createIndexNameTerm ( ( nullValue ? "T" : "F" ) ) ) ; <END_BUG> } @ Override protected Field parseCreateField ( ParseContext context ) throws IOException { } @ Override protected String contentType ( ) { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } }
public class ParallelAction extends Action { Array < Action > actions = new Array ( 4 ) ; private boolean complete ; public ParallelAction ( ) { } public ParallelAction ( Action action1 ) { } public ParallelAction ( Action action1 , Action action2 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 , Action action4 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 , Action action4 , Action action5 ) { } public boolean act ( float delta ) { if ( complete ) return true ; complete = true ; Array < Action > actions = this . actions ; <START_BUG> for ( int i = 0 , n = actions . size ; ( i < n ) && ( ( actor ) != null ) ; i ++ ) <END_BUG> if ( ! ( actions . get ( i ) . act ( delta ) ) ) complete = false ; return complete ; } public void restart ( ) { } public void reset ( ) { } public void addAction ( Action action ) { } public void setActor ( Actor actor ) { } public Array < Action > getActions ( ) { } public String toString ( ) { } }
public class SearchRequest extends ActionRequest < SearchRequest > implements IndicesRequest . Replaceable { private SearchType searchType = SearchType . DEFAULT ; private String [ ] indices ; @ Nullable private String routing ; @ Nullable private String preference ; private BytesReference templateSource ; private boolean templateSourceUnsafe ; private String templateName ; private ScriptType templateType ; private Map < String , String > templateParams = Collections . emptyMap ( ) ; private BytesReference source ; private boolean sourceUnsafe ; private BytesReference extraSource ; private boolean extraSourceUnsafe ; private Boolean queryCache ; private Scroll scroll ; private String [ ] types = Strings . EMPTY_ARRAY ; public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions . strictExpandOpenAndForbidClosed ( ) ; private IndicesOptions indicesOptions = SearchRequest . DEFAULT_INDICES_OPTIONS ; public SearchRequest ( ) { } public SearchRequest ( SearchRequest searchRequest , ActionRequest originalRequest ) { } public SearchRequest ( ActionRequest request ) { } public SearchRequest ( String ... indices ) { } public SearchRequest ( String [ ] indices , byte [ ] source ) { } @ Override public ActionRequestValidationException validate ( ) { } public void beforeStart ( ) { } @ Override public SearchRequest indices ( String ... indices ) { } @ Override public IndicesOptions indicesOptions ( ) { } public SearchRequest indicesOptions ( IndicesOptions indicesOptions ) { } public String [ ] types ( ) { } public SearchRequest types ( String ... types ) { } public String routing ( ) { } public SearchRequest routing ( String routing ) { } public SearchRequest routing ( String ... routings ) { } public SearchRequest preference ( String preference ) { } public String preference ( ) { } public SearchRequest searchType ( SearchType searchType ) { } public SearchRequest searchType ( String searchType ) throws ElasticsearchIllegalArgumentException { } public SearchRequest source ( SearchSourceBuilder sourceBuilder ) { } public SearchRequest source ( String source ) { } public SearchRequest source ( Map source ) { } public SearchRequest source ( XContentBuilder builder ) { } public SearchRequest source ( byte [ ] source ) { } public SearchRequest source ( byte [ ] source , int offset , int length ) { } public SearchRequest source ( byte [ ] source , int offset , int length , boolean unsafe ) { } public SearchRequest source ( BytesReference source , boolean unsafe ) { } public BytesReference source ( ) { } public BytesReference templateSource ( ) { } public SearchRequest extraSource ( SearchSourceBuilder sourceBuilder ) { } public SearchRequest extraSource ( Map extraSource ) { try { XContentBuilder builder = XContentFactory . contentBuilder ( CONTENT_TYPE ) ; builder . map ( extraSource ) ; return extraSource ( builder ) ; } catch ( IOException e ) { <START_BUG> throw new org . elasticsearch . ElasticsearchGenerationException ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>generate<seq2seq4repair_space>[" + ( source ) ) + "]" ) , e ) ; <END_BUG> } } public SearchRequest extraSource ( XContentBuilder builder ) { } public SearchRequest extraSource ( String source ) { } public SearchRequest extraSource ( byte [ ] source ) { } public SearchRequest extraSource ( byte [ ] source , int offset , int length ) { } public SearchRequest extraSource ( byte [ ] source , int offset , int length , boolean unsafe ) { } public SearchRequest extraSource ( BytesReference source , boolean unsafe ) { } public SearchRequest templateSource ( BytesReference template , boolean unsafe ) { } public SearchRequest templateSource ( String template ) { } public void templateName ( String templateName ) { } public void templateType ( ScriptService . ScriptType templateType ) { } public void templateParams ( Map < String , String > params ) { } public String templateName ( ) { } public ScriptType templateType ( ) { } public Map < String , String > templateParams ( ) { } public BytesReference extraSource ( ) { } public SearchType searchType ( ) { } @ Override public String [ ] indices ( ) { } public Scroll scroll ( ) { } public SearchRequest scroll ( Scroll scroll ) { } public SearchRequest scroll ( TimeValue keepAlive ) { } public SearchRequest scroll ( String keepAlive ) { } public SearchRequest queryCache ( Boolean queryCache ) { } public Boolean queryCache ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public Matrix4 set ( float [ ] values ) { } public Matrix4 set ( Quaternion quaternion ) { } public Matrix4 set ( float x , float y , float z , float w ) { } public Matrix4 set ( Vector3 position , Quaternion orientation ) { } public Matrix4 set ( float translationX , float translationY , float translationZ , float quaternionX , float quaternionY , float quaternionZ , float quaternionW ) { } public Matrix4 set ( Vector3 xAxis , Vector3 yAxis , Vector3 zAxis , Vector3 pos ) { } public Matrix4 set ( Vector3 position , Quaternion orientation , Vector3 scale ) { } public Matrix4 cpy ( ) { } public Matrix4 trn ( Vector3 vector ) { } public Matrix4 trn ( float x , float y , float z ) { } public float [ ] getValues ( ) { } public Matrix4 mul ( Matrix4 matrix ) { } public Matrix4 mulLeft ( Matrix4 matrix ) { } public Matrix4 tra ( ) { } public Matrix4 idt ( ) { } public Matrix4 inv ( ) { } public float det ( ) { } public float det3x3 ( ) { } public Matrix4 setToProjection ( float near , float far , float fov , float aspectRatio ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height , float near , float far ) { } public Matrix4 setToOrtho ( float left , float right , float bottom , float top , float near , float far ) { } public Matrix4 setTranslation ( Vector3 vector ) { } public Matrix4 setTranslation ( float x , float y , float z ) { } public Matrix4 setToTranslation ( Vector3 vector ) { } public Matrix4 setToTranslation ( float x , float y , float z ) { } public Matrix4 setToTranslationAndScaling ( Vector3 translation , Vector3 scaling ) { } public Matrix4 setToTranslationAndScaling ( float translationX , float translationY , float translationZ , float scalingX , float scalingY , float scalingZ ) { } static Quaternion quat = new Quaternion ( ) ; public Matrix4 setToRotation ( Vector3 axis , float degrees ) { } public Matrix4 setToRotationRad ( Vector3 axis , float radians ) { } public Matrix4 setToRotationRad ( float axisX , float axisY , float axisZ , float radians ) { } public Matrix4 setToRotation ( float axisX , float axisY , float axisZ , float angle ) { } public Matrix4 setToRotation ( final Vector3 v1 , final Vector3 v2 ) { } public Matrix4 setToRotation ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } public Matrix4 setFromEulerAngles ( float yaw , float pitch , float roll ) { } public Matrix4 setToScaling ( Vector3 vector ) { } public Matrix4 setToScaling ( float x , float y , float z ) { } static final Vector3 l_vez = new Vector3 ( ) ; static final Vector3 l_vex = new Vector3 ( ) ; static final Vector3 l_vey = new Vector3 ( ) ; public Matrix4 setToLookAt ( Vector3 direction , Vector3 up ) { } static final Vector3 tmpVec = new Vector3 ( ) ; static final Matrix4 tmpMat = new Matrix4 ( ) ; public Matrix4 setToLookAt ( Vector3 position , Vector3 target , Vector3 up ) { } static final Vector3 right = new Vector3 ( ) ; static final Vector3 tmpForward = new Vector3 ( ) ; static final Vector3 tmpUp = new Vector3 ( ) ; public Matrix4 setToWorld ( Vector3 position , Vector3 forward , Vector3 up ) { Matrix4 . tmpForward . set ( forward ) . nor ( ) ; Matrix4 . right . set ( Matrix4 . tmpForward ) . crs ( up ) . nor ( ) ; Matrix4 . tmpUp . set ( Matrix4 . right ) . crs ( Matrix4 . tmpForward ) . nor ( ) ; <START_BUG> this . set ( Matrix4 . right , Matrix4 . tmpUp , Matrix4 . tmpForward . scl ( ( - 1 ) ) , position ) ; <END_BUG> return this ; } public String toString ( ) { } public Matrix4 lerp ( Matrix4 matrix , float alpha ) { } public Matrix4 set ( Matrix3 mat ) { } public Matrix4 scl ( Vector3 scale ) { } public Matrix4 scl ( float x , float y , float z ) { } public Matrix4 scl ( float scale ) { } public Vector3 getTranslation ( Vector3 position ) { } public Quaternion getRotation ( Quaternion rotation , boolean normalizeAxes ) { } public Quaternion getRotation ( Quaternion rotation ) { } public float getScaleXSquared ( ) { } public float getScaleYSquared ( ) { } public float getScaleZSquared ( ) { } public float getScaleX ( ) { } public float getScaleY ( ) { } public float getScaleZ ( ) { } public Vector3 getScale ( Vector3 scale ) { } public Matrix4 toNormalMatrix ( ) { } static void matrix4_mul ( float [ ] mata , float [ ] matb ) { } static float matrix4_det ( float [ ] val ) { } static boolean matrix4_inv ( float [ ] val ) { } static void matrix4_mulVec ( float [ ] mat , float [ ] vec , int offset ) { } static void matrix4_proj ( float [ ] mat , float [ ] vec , int offset ) { } static void matrix4_rot ( float [ ] mat , float [ ] vec , int offset ) { } public static void mul ( float [ ] mata , float [ ] matb ) { }
public class RecentRepositories implements Serializable , Comparator < Repository > { public static final int MAX_SIZE = 5 ; private static final long serialVersionUID = 580345177644233739L ; private static final int VERSION = 2 ; private static File getFile ( final Context context , final User organization ) { } private LinkedHashSet < Long > ids ; private final File file ; private int id ; public RecentRepositories ( final Context context , final User organization ) { } private void load ( ) { } private void trim ( ) { } public RecentRepositories add ( final Repository repo ) { } <START_BUG> public RecentRepositories add ( final Long id ) { <END_BUG> if ( ( ids ) == null ) load ( ) ; ids . remove ( id ) ; ids . add ( id ) ; trim ( ) ; return this ; } public RecentRepositories saveAsync ( ) { } public RecentRepositories save ( ) { } public boolean contains ( Repository repository ) { } public boolean contains ( long id ) { } @ Override public int compare ( final Repository lhs , final Repository rhs ) { } }
public class PercentilesBuilder extends ValuesSourceMetricsAggregationBuilder < PercentilesBuilder > { private double [ ] percentiles ; private Double compression ; public PercentilesBuilder ( String name ) { } public PercentilesBuilder percentiles ( double ... percentiles ) { for ( int i = 0 ; i < ( percentiles . length ) ; i ++ ) { if ( ( ( percentiles [ i ] ) < 0 ) || ( ( percentiles [ i ] ) > 100 ) ) { <START_BUG> throw new IllegalArgumentException ( ( ( "the<seq2seq4repair_space>percents<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>percentiles<seq2seq4repair_space>aggregation<seq2seq4repair_space>[" + ( name ) ) + "]<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>[0,<seq2seq4repair_space>100]<seq2seq4repair_space>range" ) ) ; <END_BUG> } } this . percentiles = percentiles ; return this ; } public PercentilesBuilder compression ( double compression ) { } @ Override protected void internalXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class DataOutputStreamOutput extends StreamOutput { private final DataOutput out ; public DataOutputStreamOutput ( DataOutput out ) { } @ Override public void writeByte ( byte b ) throws IOException { <START_BUG> out . write ( b ) ; <END_BUG> } @ Override public void writeBytes ( byte [ ] b , int offset , int length ) throws IOException { } @ Override public void flush ( ) throws IOException { } @ Override public void reset ( ) throws IOException { } @ Override public void close ( ) throws IOException { } }
final class AndroidAudio implements Audio { private SoundPool soundPool ; private final AudioManager manager ; protected final List < AndroidMusic > musics = new ArrayList < AndroidMusic > ( ) ; protected final List < Boolean > wasPlaying = new ArrayList < Boolean > ( ) ; AndroidAudio ( Activity context ) { } protected void pause ( ) { } protected void resume ( ) { } @ Override public AudioDevice newAudioDevice ( boolean isMono ) { <START_BUG> return null ; <END_BUG> } @ Override public Music newMusic ( FileHandle file ) { } @ Override public Sound newSound ( FileHandle file ) { } }
public class ContainerTest extends GdxTest { Skin skin ; Stage stage ; @ Override public void create ( ) { } Table label ( String text ) { } @ Override public void render ( ) { } @ Override public void resize ( int width , int height ) { <START_BUG> stage . setViewport ( width , height , false ) ; <END_BUG> } @ Override public void dispose ( ) { } }
final class JoglPanel extends JPanel implements KeyListener , MouseListener , MouseMotionListener , GLEventListener { private static final long serialVersionUID = - 3638194405409146221L ; private static boolean loaded = false ; private static GLContext context = null ; private final GLCanvas canvas ; private final Animator animator ; private boolean vSynch = true ; private final Point mousePosition = new Point ( ) ; private final HashSet < Integer > buttons = new HashSet < Integer > ( ) ; private final HashSet < Integer > keys = new HashSet < Integer > ( ) ; private final ArrayList < RenderListener > listeners = new ArrayList < RenderListener > ( ) ; private final ArrayList < RenderListener > setupListeners = new ArrayList < RenderListener > ( ) ; private long frameStart = System . nanoTime ( ) ; private float deltaTime = 0 ; private WindowedMean mean = new WindowedMean ( 10 ) ; private Application application = null ; private JoglInputMultiplexer multiplexer ; private static void loadLibraries ( ) { } private static void loadLibrary ( String resource ) { } JoglPanel ( Application application ) { } public void dispose ( ) { } public float getDeltaTime ( ) { } public GLCanvas getCanvas ( ) { } public void setVerticalSynch ( boolean v_synch ) { } public boolean getVerticalSynch ( ) { } public void mouseDragged ( MouseEvent arg0 ) { } public void mouseMoved ( MouseEvent arg0 ) { } public int getMouseX ( ) { } public int getMouseY ( ) { } public void mouseClicked ( MouseEvent arg0 ) { } public void mouseEntered ( MouseEvent arg0 ) { } public void mouseExited ( MouseEvent arg0 ) { } public void mousePressed ( MouseEvent arg0 ) { } public void mouseReleased ( MouseEvent arg0 ) { } public void keyPressed ( KeyEvent arg0 ) { } public void keyReleased ( KeyEvent arg0 ) { } public void keyTyped ( KeyEvent arg0 ) { } public boolean isButtonDown ( int button ) { <START_BUG> return buttons . contains ( button ) ; <END_BUG> } public boolean isKeyDown ( int key ) { } public void addGraphicListener ( RenderListener listener ) { } public void removeGraphicListener ( RenderListener listener ) { } @ Override public void display ( GLAutoDrawable arg0 ) { } @ Override public void displayChanged ( GLAutoDrawable arg0 , boolean arg1 , boolean arg2 ) { } @ Override public void init ( GLAutoDrawable arg0 ) { } @ Override public void reshape ( GLAutoDrawable arg0 , int arg1 , int arg2 , int arg3 , int arg4 ) { } public GL getGL ( ) { } public Point getLastMousePosition ( ) { } public void setInputMultiplexer ( JoglInputMultiplexer inputMultiplexer ) { } public boolean isAnyKeyDown ( ) { } }
public class QueryStringQueryBuilder extends BaseQueryBuilder implements BoostableQueryBuilder < QueryStringQueryBuilder > { public static enum Operator { OR , AND ; } private final String queryString ; private String defaultField ; private QueryStringQueryBuilder . Operator defaultOperator ; private String analyzer ; private String quoteAnalyzer ; private String quoteFieldSuffix ; private Boolean autoGeneratePhraseQueries ; private Boolean allowLeadingWildcard ; private Boolean lowercaseExpandedTerms ; private Boolean enablePositionIncrements ; private Boolean analyzeWildcard ; private Locale locale ; private float boost = - 1 ; private Fuzziness fuzziness ; private int fuzzyPrefixLength = - 1 ; private int fuzzyMaxExpansions = - 1 ; private String fuzzyRewrite ; private int phraseSlop = - 1 ; private List < String > fields ; private ObjectFloatOpenHashMap < String > fieldsBoosts ; private Boolean useDisMax ; private float tieBreaker = - 1 ; private String rewrite = null ; private String minimumShouldMatch ; private Boolean lenient ; private String queryName ; public QueryStringQueryBuilder ( String queryString ) { } public QueryStringQueryBuilder defaultField ( String defaultField ) { } public QueryStringQueryBuilder field ( String field ) { } public QueryStringQueryBuilder field ( String field , float boost ) { if ( ( fields ) == null ) { fields = Lists . newArrayList ( ) ; } fields . add ( field ) ; if ( ( fieldsBoosts ) == null ) { <START_BUG> fieldsBoosts = new ObjectFloatOpenHashMap < String > ( ) ; <END_BUG> } fieldsBoosts . put ( field , boost ) ; return this ; } public QueryStringQueryBuilder useDisMax ( boolean useDisMax ) { } public QueryStringQueryBuilder tieBreaker ( float tieBreaker ) { } public QueryStringQueryBuilder defaultOperator ( QueryStringQueryBuilder . Operator defaultOperator ) { } public QueryStringQueryBuilder analyzer ( String analyzer ) { } public QueryStringQueryBuilder quoteAnalyzer ( String analyzer ) { } public QueryStringQueryBuilder autoGeneratePhraseQueries ( boolean autoGeneratePhraseQueries ) { } public QueryStringQueryBuilder allowLeadingWildcard ( boolean allowLeadingWildcard ) { } public QueryStringQueryBuilder lowercaseExpandedTerms ( boolean lowercaseExpandedTerms ) { } public QueryStringQueryBuilder enablePositionIncrements ( boolean enablePositionIncrements ) { } public QueryStringQueryBuilder fuzziness ( Fuzziness fuzziness ) { } public QueryStringQueryBuilder fuzzyPrefixLength ( int fuzzyPrefixLength ) { } public QueryStringQueryBuilder fuzzyMaxExpansions ( int fuzzyMaxExpansions ) { } public QueryStringQueryBuilder fuzzyRewrite ( String fuzzyRewrite ) { } public QueryStringQueryBuilder phraseSlop ( int phraseSlop ) { } public QueryStringQueryBuilder analyzeWildcard ( boolean analyzeWildcard ) { } public QueryStringQueryBuilder rewrite ( String rewrite ) { } public QueryStringQueryBuilder minimumShouldMatch ( String minimumShouldMatch ) { } public QueryStringQueryBuilder boost ( float boost ) { } public QueryStringQueryBuilder quoteFieldSuffix ( String quoteFieldSuffix ) { } public QueryStringQueryBuilder lenient ( Boolean lenient ) { } public QueryStringQueryBuilder queryName ( String queryName ) { } public QueryStringQueryBuilder locale ( Locale locale ) { } @ Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class GdxInvadersDesktop { public static void main ( String [ ] argv ) { LwjglApplicationConfiguration config = new LwjglApplicationConfiguration ( ) ; config . title = "Gdx<seq2seq4repair_space>Invaders" ; config . vSyncEnabled = true ; <START_BUG> config . useGL20 = false ; <END_BUG> new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new GdxInvaders ( ) , config ) ; } }
public class BinaryFieldMapper extends AbstractFieldMapper < byte [ ] > { public static final String CONTENT_TYPE = "binary" ; public static class Builder extends AbstractFieldMapper . Builder < BinaryFieldMapper . Builder , BinaryFieldMapper > { public Builder ( String name ) { } @ Override public BinaryFieldMapper . Builder indexName ( String indexName ) { } @ Override public BinaryFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements XContentMapper . TypeParser { @ Override public XContentMapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } protected BinaryFieldMapper ( Names names ) { } @ Override public byte [ ] value ( Fieldable field ) { } @ Override public byte [ ] valueFromString ( String value ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } @ Override protected Field parseCreateField ( ParseContext context ) throws IOException { byte [ ] value ; if ( ( context . parser ( ) . currentToken ( ) ) == ( Token . VALUE_NULL ) ) { return null ; } else { value = context . parser ( ) . binaryValue ( ) ; } if ( value == null ) { return null ; } <START_BUG> return new Field ( names . indexName ( ) , value , Store . YES ) ; <END_BUG> } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class NodesFaultDetection extends AbstractComponent { public static interface Listener { void onNodeFailure ( DiscoveryNode node ) { } } private final ThreadPool threadPool ; private final TransportService transportService ; private final boolean connectOnNetworkDisconnect ; private final TimeValue pingInterval ; private final TimeValue pingRetryTimeout ; private final int pingRetryCount ; private final CopyOnWriteArrayList < NodesFaultDetection . Listener > listeners = new CopyOnWriteArrayList < NodesFaultDetection . Listener > ( ) ; private final ConcurrentMap < DiscoveryNode , NodesFaultDetection . NodeFD > nodesFD = newConcurrentMap ( ) ; private final NodesFaultDetection . FDConnectionListener connectionListener ; private volatile DiscoveryNodes latestNodes = EMPTY_NODES ; private volatile boolean running = false ; public NodesFaultDetection ( Settings settings , ThreadPool threadPool , TransportService transportService ) { } public void addListener ( NodesFaultDetection . Listener listener ) { } public void removeListener ( NodesFaultDetection . Listener listener ) { } public void updateNodes ( DiscoveryNodes nodes ) { } public NodesFaultDetection start ( ) { } public NodesFaultDetection stop ( ) { } public void close ( ) { } private void handleTransportDisconnect ( DiscoveryNode node ) { } private void notifyNodeFailure ( DiscoveryNode node ) { } private class SendPingRequest implements Runnable { private final DiscoveryNode node ; private SendPingRequest ( DiscoveryNode node ) { } @ Override public void run ( ) { if ( ! ( running ) ) { return ; } transportService . sendRequest ( node , NodesFaultDetection . PingRequestHandler . ACTION , new NodesFaultDetection . PingRequest ( ) , pingRetryTimeout , new BaseTransportResponseHandler < NodesFaultDetection . PingResponse > ( ) { @ Override public NodesFaultDetection . PingResponse newInstance ( ) { return new NodesFaultDetection . PingResponse ( ) ; } @ Override public void handleResponse ( NodesFaultDetection . PingResponse response ) { if ( running ) { NodesFaultDetection . NodeFD nodeFD = nodesFD . get ( node ) ; if ( nodeFD != null ) { nodeFD . retryCount = 0 ; threadPool . schedule ( NodesFaultDetection . SendPingRequest . this , pingInterval ) ; } } } @ Override public void handleException ( RemoteTransportException exp ) { if ( running ) { NodesFaultDetection . NodeFD nodeFD = nodesFD . get ( node ) ; if ( nodeFD != null ) { int retryCount = ++ ( nodeFD . retryCount ) ; logger . trace ( "Node<seq2seq4repair_space>[{}]<seq2seq4repair_space>failed<seq2seq4repair_space>to<seq2seq4repair_space>ping,<seq2seq4repair_space>retry<seq2seq4repair_space>[{}]<seq2seq4repair_space>out<seq2seq4repair_space>of<seq2seq4repair_space>[{}]" , exp , node , retryCount , pingRetryCount ) ; if ( retryCount >= ( pingRetryCount ) ) { <START_BUG> logger . trace ( "Node<seq2seq4repair_space>[{}]<seq2seq4repair_space>failed<seq2seq4repair_space>on<seq2seq4repair_space>ping" , node ) ; <END_BUG> if ( ( nodesFD . remove ( node ) ) != null ) { notifyNodeFailure ( node ) ; } } } } } } ) ; } } static class NodeFD { volatile int retryCount ; } private class FDConnectionListener implements TransportConnectionListener { @ Override public void onNodeConnected ( DiscoveryNode node ) { } @ Override public void onNodeDisconnected ( DiscoveryNode node ) { } } private class PingRequestHandler extends BaseTransportRequestHandler < NodesFaultDetection . PingRequest > { public static final String ACTION = "discovery/zen/fd/ping" ; @ Override public NodesFaultDetection . PingRequest newInstance ( ) { } @ Override public void messageReceived ( NodesFaultDetection . PingRequest request , TransportChannel channel ) throws Exception { } } private class PingRequest implements Streamable { private PingRequest ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } private class PingResponse implements Streamable { private PingResponse ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class TransportPercolateAction extends TransportSingleCustomOperationAction < PercolateRequest , PercolateResponse > { private final IndicesService indicesService ; @ Inject public TransportPercolateAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected PercolateRequest newRequest ( ) { } @ Override protected PercolateResponse newResponse ( ) { } @ Override protected String transportAction ( ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , PercolateRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , PercolateRequest request ) { } @ Override protected ShardsIterator shards ( ClusterState clusterState , PercolateRequest request ) { } @ Override protected PercolateResponse shardOperation ( PercolateRequest request , int shardId ) throws ElasticSearchException { IndexService indexService = indicesService . indexServiceSafe ( request . index ( ) ) ; PercolatorService percolatorService = indexService . percolateService ( ) ; <START_BUG> PercolatorExecutor . Response percolate = percolatorService . percolate ( new PercolatorExecutor . SourceRequest ( request . type ( ) , request . underlyingSource ( ) , request . underlyingSourceOffset ( ) , request . underlyingSourceLength ( ) ) ) ; <END_BUG> return new PercolateResponse ( percolate . matches ( ) ) ; } }
public class InternalSearchResponse implements Streamable , ToXContent { private InternalSearchHits hits ; private InternalFacets facets ; private Suggest suggest ; private boolean timedOut ; public static final InternalSearchResponse EMPTY = new InternalSearchResponse ( new InternalSearchHits ( new InternalSearchHit [ 0 ] , 0 , 0 ) , null , null , false ) ; private InternalSearchResponse ( ) { } public InternalSearchResponse ( InternalSearchHits hits , InternalFacets facets , Suggest suggest , boolean timedOut ) { } public boolean timedOut ( ) { } public SearchHits hits ( ) { } public Facets facets ( ) { } public Suggest suggest ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } public static InternalSearchResponse readInternalSearchResponse ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { hits = InternalSearchHits . readSearchHits ( in ) ; if ( in . readBoolean ( ) ) { facets = InternalFacets . readFacets ( in ) ; } if ( in . readBoolean ( ) ) { <START_BUG> suggest = Suggest . readSuggest ( in ) ; <END_BUG> } timedOut = in . readBoolean ( ) ; } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public class UserPagerAdapter extends FragmentPagerAdapter implements TitleProvider { private final boolean defaultUser ; private final FragmentManager fragmentManager ; private final Set < String > tags = new HashSet < String > ( ) ; public UserPagerAdapter ( final FragmentManager fm , final boolean defaultUser ) { } @ Override public Fragment getItem ( int position ) { } public UserPagerAdapter clearAdapter ( ) { } public Object instantiateItem ( ViewGroup container , int position ) { Object fragment = super . instantiateItem ( container , position ) ; <START_BUG> if ( ( position == 2 ) && ( fragment instanceof Fragment ) ) <END_BUG> tags . add ( ( ( Fragment ) ( fragment ) ) . getTag ( ) ) ; return fragment ; } @ Override public int getCount ( ) { } @ Override public String getTitle ( int position ) { } }
public class Label extends Widget { private Label . LabelStyle style ; private final TextBounds bounds = new TextBounds ( ) ; private String text ; private BitmapFontCache cache ; private float prefWidth ; private float prefHeight ; private int labelAlign = Align . LEFT ; private HAlignment lineAlign = HAlignment . LEFT ; private boolean wrap ; private float wrapWidth ; public Label ( Skin skin ) { } public Label ( String text , Skin skin ) { } public Label ( String text , String fontName , Color color , Skin skin ) { } public Label ( String text , String fontName , String colorName , Skin skin ) { } public Label ( String text , Label . LabelStyle style ) { } public Label ( String text , Label . LabelStyle style , String name ) { } public void setStyle ( Label . LabelStyle style ) { } public Label . LabelStyle getStyle ( ) { } public void setText ( String text ) { } public String getText ( ) { } public TextBounds getTextBounds ( ) { } public void setWrap ( boolean wrap ) { } public void setWrapWidth ( float wrapWidth ) { } public void setAlignment ( int wrapAlign ) { } public void setAlignment ( int labelAlign , int lineAlign ) { } public void setColor ( float color ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public Color getColor ( ) { } private void computeBounds ( ) { } @ Override public void layout ( ) { } @ Override public void draw ( SpriteBatch batch , float parentAlpha ) { validate ( ) ; cache . setPosition ( x , y ) ; <START_BUG> cache . draw ( batch , parentAlpha ) ; <END_BUG> } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public static class LabelStyle { public BitmapFont font ; public Color fontColor ; public LabelStyle ( ) { } public LabelStyle ( BitmapFont font , Color fontColor ) { } } }
public class AliasMetaData { private final String alias ; private final CompressedString filter ; private String indexRouting ; private String searchRouting ; private AliasMetaData ( String alias , CompressedString filter , String indexRouting , String searchRouting ) { } public String alias ( ) { } public String getAlias ( ) { } public CompressedString filter ( ) { } public CompressedString getFilter ( ) { } public String getSearchRouting ( ) { } public String searchRouting ( ) { } public String getIndexRouting ( ) { } public String indexRouting ( ) { } public static AliasMetaData . Builder builder ( String alias ) { } public static AliasMetaData . Builder newAliasMetaDataBuilder ( String alias ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } public static class Builder { private String alias ; private CompressedString filter ; private String indexRouting ; private String searchRouting ; public Builder ( String alias ) { } public Builder ( AliasMetaData aliasMetaData ) { } public String alias ( ) { } public AliasMetaData . Builder filter ( CompressedString filter ) { } public AliasMetaData . Builder filter ( String filter ) { } public AliasMetaData . Builder filter ( Map < String , Object > filter ) { if ( ( filter == null ) || ( filter . isEmpty ( ) ) ) { this . filter = null ; return this ; } try { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . map ( filter ) ; <START_BUG> this . filter = new CompressedString ( builder . underlyingBytes ( ) , 0 , builder . underlyingBytesLength ( ) ) ; <END_BUG> return this ; } catch ( IOException e ) { throw new ElasticSearchGenerationException ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>build<seq2seq4repair_space>json<seq2seq4repair_space>for<seq2seq4repair_space>alias<seq2seq4repair_space>request" , e ) ; } } public AliasMetaData . Builder filter ( XContentBuilder filterBuilder ) { } public AliasMetaData . Builder routing ( String routing ) { } public AliasMetaData . Builder indexRouting ( String indexRouting ) { } public AliasMetaData . Builder searchRouting ( String searchRouting ) { } public AliasMetaData build ( ) { } public static void toXContent ( AliasMetaData aliasMetaData , XContentBuilder builder , ToXContent . Params params ) throws IOException { } public static AliasMetaData fromXContent ( XContentParser parser ) throws IOException { } public static void writeTo ( AliasMetaData aliasMetaData , StreamOutput out ) throws IOException { } public static AliasMetaData readFrom ( StreamInput in ) throws IOException { } } }
public class DefaultAssetFilter implements AssetFilter { private String extension ( String file ) { } @ Override public boolean accept ( String file , boolean isDirectory ) { } @ Override public AssetType getType ( String file ) { } private boolean isImage ( String extension ) { } private boolean isText ( String extension ) { <START_BUG> return ( ( ( ( ( ( extension . equals ( "json" ) ) || ( extension . equals ( "xml" ) ) ) || ( extension . equals ( "txt" ) ) ) || ( extension . equals ( "glsl" ) ) ) || ( extension . equals ( "fnt" ) ) ) || ( extension . equals ( "pack" ) ) ) || ( extension . equals ( "obj" ) ) ; <END_BUG> } private boolean isAudio ( String extension ) { } }
public class MessageChannelHandler extends SimpleChannelUpstreamHandler { private final ESLogger logger ; private final ThreadPool threadPool ; private final TransportServiceAdapter transportServiceAdapter ; private final NettyTransport transport ; private ChannelBuffer cumulation ; public MessageChannelHandler ( NettyTransport transport , ESLogger logger ) { } @ Override public void writeComplete ( ChannelHandlerContext ctx , WriteCompletionEvent e ) throws Exception { } @ Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { } @ Override public void channelDisconnected ( ChannelHandlerContext ctx , ChannelStateEvent e ) throws Exception { } @ Override public void channelClosed ( ChannelHandlerContext ctx , ChannelStateEvent e ) throws Exception { } private int callDecode ( ChannelHandlerContext ctx , Channel channel , ChannelBuffer buffer , boolean cumulationBuffer ) throws Exception { } private void cleanup ( ChannelHandlerContext ctx , ChannelStateEvent e ) throws Exception { } private void process ( ChannelHandlerContext ctx , Channel channel , ChannelBuffer buffer , int size ) throws Exception { } private void handleResponse ( StreamInput buffer , final TransportResponseHandler handler ) { } private void handlerResponseError ( StreamInput buffer , final TransportResponseHandler handler ) { Throwable error ; try { <START_BUG> ThrowableObjectInputStream ois = new ThrowableObjectInputStream ( buffer ) ; <END_BUG> error = ( ( Throwable ) ( ois . readObject ( ) ) ) ; } catch ( Exception e ) { error = new TransportSerializationException ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>deserialize<seq2seq4repair_space>exception<seq2seq4repair_space>response<seq2seq4repair_space>from<seq2seq4repair_space>stream" , e ) ; } handleException ( handler , error ) ; } private void handleException ( final TransportResponseHandler handler , Throwable error ) { } private String handleRequest ( Channel channel , StreamInput buffer , long requestId ) throws IOException { } @ Override public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception { } class ResponseHandler implements Runnable { private final TransportResponseHandler handler ; private final Streamable streamable ; public ResponseHandler ( TransportResponseHandler handler , Streamable streamable ) { } @ SuppressWarnings ( { "unchecked" } ) @ Override public void run ( ) { } } class RequestHandler implements Runnable { private final TransportRequestHandler handler ; private final Streamable streamable ; private final NettyTransportChannel transportChannel ; private final String action ; public RequestHandler ( TransportRequestHandler handler , Streamable streamable , NettyTransportChannel transportChannel , String action ) { } @ SuppressWarnings ( { "unchecked" } ) @ Override public void run ( ) { } } }
public class BitmapFont implements Disposable { private static final int LOG2_PAGE_SIZE = 9 ; private static final int PAGE_SIZE = 1 << ( BitmapFont . LOG2_PAGE_SIZE ) ; private static final int PAGES = 65536 / ( BitmapFont . PAGE_SIZE ) ; public static final char [ ] xChars = new char [ ] { 'x' , 'e' , 'a' , 'o' , 'n' , 's' , 'r' , 'c' , 'u' , 'm' , 'v' , 'w' , 'z' } ; public static final char [ ] capChars = new char [ ] { 'M' , 'N' , 'B' , 'D' , 'C' , 'E' , 'F' , 'K' , 'A' , 'G' , 'H' , 'I' , 'J' , 'L' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } ; final BitmapFont . BitmapFontData data ; TextureRegion [ ] regions ; private final BitmapFontCache cache ; private boolean flipped ; private boolean integer ; private boolean ownsTexture ; public BitmapFont ( ) { } public BitmapFont ( boolean flip ) { } public BitmapFont ( FileHandle fontFile , TextureRegion region ) { } public BitmapFont ( FileHandle fontFile , TextureRegion region , boolean flip ) { } public BitmapFont ( FileHandle fontFile ) { } public BitmapFont ( FileHandle fontFile , boolean flip ) { } public BitmapFont ( FileHandle fontFile , FileHandle imageFile , boolean flip ) { } public BitmapFont ( FileHandle fontFile , FileHandle imageFile , boolean flip , boolean integer ) { } public BitmapFont ( BitmapFont . BitmapFontData data , TextureRegion region , boolean integer ) { } public BitmapFont ( BitmapFont . BitmapFontData data , TextureRegion [ ] regions , boolean integer ) { } private void load ( BitmapFont . BitmapFontData data ) { } public BitmapFont . TextBounds draw ( Batch batch , CharSequence str , float x , float y ) { } public BitmapFont . TextBounds draw ( Batch batch , CharSequence str , float x , float y , int start , int end ) { } public BitmapFont . TextBounds drawMultiLine ( Batch batch , CharSequence str , float x , float y ) { } public BitmapFont . TextBounds drawMultiLine ( Batch batch , CharSequence str , float x , float y , float alignmentWidth , BitmapFont . HAlignment alignment ) { } public BitmapFont . TextBounds drawWrapped ( Batch batch , CharSequence str , float x , float y , float wrapWidth ) { } public BitmapFont . TextBounds drawWrapped ( Batch batch , CharSequence str , float x , float y , float wrapWidth , BitmapFont . HAlignment alignment ) { } public BitmapFont . TextBounds getBounds ( CharSequence str ) { <START_BUG> return getBounds ( str , 0 , str . length ( ) ) ; <END_BUG> } public BitmapFont . TextBounds getBounds ( CharSequence str , BitmapFont . TextBounds textBounds ) { } public BitmapFont . TextBounds getBounds ( CharSequence str , int start , int end ) { } public BitmapFont . TextBounds getBounds ( CharSequence str , int start , int end , BitmapFont . TextBounds textBounds ) { } public BitmapFont . TextBounds getMultiLineBounds ( CharSequence str ) { } public BitmapFont . TextBounds getMultiLineBounds ( CharSequence str , BitmapFont . TextBounds textBounds ) { } public BitmapFont . TextBounds getWrappedBounds ( CharSequence str , float wrapWidth ) { } public BitmapFont . TextBounds getWrappedBounds ( CharSequence str , float wrapWidth , BitmapFont . TextBounds textBounds ) { } public void computeGlyphAdvancesAndPositions ( CharSequence str , FloatArray glyphAdvances , FloatArray glyphPositions ) { } public int computeVisibleGlyphs ( CharSequence str , int start , int end , float availableWidth ) { } public void setColor ( float color ) { } public void setColor ( Color color ) { } public void setColor ( float r , float g , float b , float a ) { } public Color getColor ( ) { } public void setScale ( float scaleX , float scaleY ) { } public void setScale ( float scaleXY ) { } public void scale ( float amount ) { } public float getScaleX ( ) { } public float getScaleY ( ) { } public TextureRegion getRegion ( ) { } public TextureRegion [ ] getRegions ( ) { } public TextureRegion getRegion ( int index ) { } public float getLineHeight ( ) { } public float getSpaceWidth ( ) { } public float getXHeight ( ) { } public float getCapHeight ( ) { } public float getAscent ( ) { } public float getDescent ( ) { } public boolean isFlipped ( ) { } public void dispose ( ) { } public void setFixedWidthGlyphs ( CharSequence glyphs ) { } public boolean containsCharacter ( char character ) { } public void setUseIntegerPositions ( boolean integer ) { } public boolean usesIntegerPositions ( ) { } public BitmapFontCache getCache ( ) { } public BitmapFont . BitmapFontData getData ( ) { } public boolean ownsTexture ( ) { } public void setOwnsTexture ( boolean ownsTexture ) { } public static class Glyph { public int id ; public int srcX ; public int srcY ; public int width ; public int height ; public float u ; public float v ; public float u2 ; public float v2 ; public int xoffset ; public int yoffset ; public int xadvance ; public byte [ ] [ ] kerning ; public int page = 0 ; public int getKerning ( char ch ) { } public void setKerning ( int ch , int value ) { } } static int indexOf ( CharSequence text , char ch , int start ) { } static boolean isWhitespace ( char c ) { } public static class TextBounds { public float width ; public float height ; public TextBounds ( ) { }
public class BouncyAndroid extends AndroidApplication { @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; <START_BUG> initialize ( new Bouncy ( ) ) ; <END_BUG> } }
public abstract class BlobStoreGateway extends SharedStorageGateway { private BlobStore blobStore ; private ByteSizeValue chunkSize ; private BlobPath basePath ; private ImmutableBlobContainer metaDataBlobContainer ; private volatile int currentIndex ; protected BlobStoreGateway ( Settings settings , ClusterService clusterService , MetaDataCreateIndexService createIndexService ) { } protected void initialize ( BlobStore blobStore , ClusterName clusterName , @ Nullable ByteSizeValue defaultChunkSize ) throws IOException { } @ Override public String toString ( ) { } public BlobStore blobStore ( ) { } public BlobPath basePath ( ) { } public ByteSizeValue chunkSize ( ) { } @ Override public void reset ( ) throws Exception { } @ Override public MetaData read ( ) throws GatewayException { } public CommitPoint findCommitPoint ( String index , int shardId ) throws IOException { } @ Override public void write ( MetaData metaData ) throws GatewayException { } private int findLatestIndex ( ) throws IOException { } private MetaData readMetaData ( byte [ ] data ) throws IOException { XContentParser parser = null ; try { parser = XContentFactory . xContent ( JSON ) . createParser ( data ) ; <START_BUG> return Builder . fromXContent ( parser , settings ) ; <END_BUG> } finally { if ( parser != null ) { parser . close ( ) ; } } } }
public class BlendingAttribute extends Attribute { public static final String Alias = "blended" ; public static final long Type = register ( BlendingAttribute . Alias ) ; public static final boolean is ( final long mask ) { } public boolean blended ; public int sourceFunction ; public int destFunction ; public float opacity = 1.0F ; public BlendingAttribute ( ) { } public BlendingAttribute ( final boolean blended , final int sourceFunc , final int destFunc , final float opacity ) { } public BlendingAttribute ( final int sourceFunc , final int destFunc , final float opacity ) { } public BlendingAttribute ( final int sourceFunc , final int destFunc ) { } public BlendingAttribute ( final boolean blended , final float opacity ) { } public BlendingAttribute ( final float opacity ) { } public BlendingAttribute ( final BlendingAttribute copyFrom ) { } @ Override public BlendingAttribute copy ( ) { } @ Override public int hashCode ( ) { <START_BUG> int result = super . hashCode ( ) ; <END_BUG> result = ( 947 * result ) + ( blended ? 1 : 0 ) ; result = ( 947 * result ) + ( sourceFunction ) ; result = ( 947 * result ) + ( destFunction ) ; result = ( 947 * result ) + ( NumberUtils . floatToRawIntBits ( opacity ) ) ; return result ; } }
public class SearchServiceTransportAction extends AbstractComponent { public static final String FREE_CONTEXT_ACTION_NAME = "indices:data/read/search[free_context]" ; public static final String CLEAR_SCROLL_CONTEXTS_ACTION_NAME = "indices:data/read/search[clear_scroll_contexts]" ; public static final String DFS_ACTION_NAME = "indices:data/read/search[phase/dfs]" ; public static final String QUERY_ACTION_NAME = "indices:data/read/search[phase/query]" ; public static final String QUERY_ID_ACTION_NAME = "indices:data/read/search[phase/query/id]" ; public static final String QUERY_SCROLL_ACTION_NAME = "indices:data/read/search[phase/query/scroll]" ; public static final String QUERY_FETCH_ACTION_NAME = "indices:data/read/search[phase/query+fetch]" ; public static final String QUERY_QUERY_FETCH_ACTION_NAME = "indices:data/read/search[phase/query/query+fetch]" ; public static final String QUERY_FETCH_SCROLL_ACTION_NAME = "indices:data/read/search[phase/query+fetch/scroll]" ; public static final String FETCH_ID_ACTION_NAME = "indices:data/read/search[phase/fetch/id]" ; public static final String SCAN_ACTION_NAME = "indices:data/read/search[phase/scan]" ; public static final String SCAN_SCROLL_ACTION_NAME = "indices:data/read/search[phase/scan/scroll]" ; static final class FreeContextResponseHandler implements TransportResponseHandler < SearchServiceTransportAction . SearchFreeContextResponse > { private final ActionListener < Boolean > listener ; FreeContextResponseHandler ( final ActionListener < Boolean > listener ) { } @ Override public SearchServiceTransportAction . SearchFreeContextResponse newInstance ( ) { } @ Override public void handleResponse ( SearchServiceTransportAction . SearchFreeContextResponse response ) { } @ Override public void handleException ( TransportException exp ) { } @ Override public String executor ( ) { } } private final ThreadPool threadPool ; private final TransportService transportService ; private final ClusterService clusterService ; private final SearchService searchService ; private final SearchServiceTransportAction . FreeContextResponseHandler freeContextResponseHandler = new SearchServiceTransportAction . FreeContextResponseHandler ( new ActionListener < Boolean > ( ) { @ Override public void onResponse ( Boolean aBoolean ) { } @ Override public void onFailure ( Throwable exp ) { } } ) ; @ Inject public SearchServiceTransportAction ( Settings settings , ThreadPool threadPool , TransportService transportService , ClusterService clusterService , SearchService searchService ) { } public void sendFreeContext ( DiscoveryNode node , final long contextId , SearchRequest request ) { } public void sendFreeContext ( DiscoveryNode node , long contextId , ClearScrollRequest request , final ActionListener < Boolean > actionListener ) { if ( clusterService . state ( ) . nodes ( ) . localNodeId ( ) . equals ( node . id ( ) ) ) { <START_BUG> boolean freed = searchService . freeContext ( contextId ) ; <END_BUG> actionListener . onResponse ( freed ) ; } else { transportService . sendRequest ( node , SearchServiceTransportAction . FREE_CONTEXT_ACTION_NAME , new SearchServiceTransportAction . SearchFreeContextRequest ( request , contextId ) , new SearchServiceTransportAction . FreeContextResponseHandler ( actionListener ) ) ; } } public void sendClearAllScrollContexts ( DiscoveryNode node , ClearScrollRequest request , final ActionListener < Boolean > actionListener ) { } public void sendExecuteDfs ( DiscoveryNode node , final ShardSearchRequest request , final SearchServiceListener < DfsSearchResult > listener ) { } public void sendExecuteQuery ( DiscoveryNode node , final ShardSearchRequest request , final SearchServiceListener < QuerySearchResultProvider > listener ) { } public void sendExecuteQuery ( DiscoveryNode node , final QuerySearchRequest request , final SearchServiceListener < QuerySearchResult > listener ) { } public void sendExecuteQuery ( DiscoveryNode node , final InternalScrollSearchRequest request , final SearchServiceListener < QuerySearchResult > listener ) { } public void sendExecuteFetch ( DiscoveryNode node , final ShardSearchRequest request , final SearchServiceListener < QueryFetchSearchResult > listener ) { } public void sendExecuteFetch ( DiscoveryNode node , final QuerySearchRequest request , final SearchServiceListener < QueryFetchSearchResult > listener ) { } public void sendExecuteFetch ( DiscoveryNode node , final InternalScrollSearchRequest request , final SearchServiceListener < QueryFetchSearchResult > listener ) { } public void sendExecuteFetch ( DiscoveryNode node , final FetchSearchRequest request , final SearchServiceListener < FetchSearchResult > listener ) { } public void sendExecuteScan ( DiscoveryNode node , final ShardSearchRequest request , final SearchServiceListener < QuerySearchResult > listener ) { } public void sendExecuteScan ( DiscoveryNode node , final InternalScrollSearchRequest request , final SearchServiceListener < QueryFetchSearchResult > listener ) { } private < T > void execute ( final Callable < ? extends T > callable , final SearchServiceListener < T > listener ) { } static class SearchFreeContextRequest extends TransportRequest implements IndicesRequest { private long id ; private OriginalIndices originalIndices ; SearchFreeContextRequest ( ) { } SearchFreeContextRequest ( SearchRequest request , long id ) { } SearchFreeContextRequest ( TransportRequest request , long id ) { } public long id ( ) { } @ Override public String [ ] indices ( ) { } @ Override public IndicesOptions indicesOptions ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } static class SearchFreeContextResponse extends TransportResponse { private boolean freed ; SearchFreeContextResponse ( ) { } SearchFreeContextResponse ( boolean freed ) { } public boolean isFreed ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } class SearchFreeContextTransportHandler extends BaseTransportRequestHandler < SearchServiceTransportAction . SearchFreeContextRequest > { @ Override public SearchServiceTransportAction . SearchFreeContextRequest newInstance ( ) { } @ Override public void messageReceived ( SearchServiceTransportAction . SearchFreeContextRequest request , TransportChannel channel ) throws Exception { } @ Override public String executor ( ) { } } static class ClearScrollContextsRequest extends TransportRequest { ClearScrollContextsRequest ( ) { } ClearScrollContextsRequest ( TransportRequest request ) { } } class ClearScrollContextsTransportHandler extends BaseTransportRequestHandler < SearchServiceTransportAction . ClearScrollContextsRequest > { @ Override public SearchServiceTransportAction . ClearScrollContextsRequest newInstance ( ) { } @ Override public void messageReceived ( SearchServiceTransportAction . ClearScrollContextsRequest request , TransportChannel channel ) throws Exception { } @ Override public String executor ( ) { } } private class SearchDfsTransportHandler extends BaseTransportRequestHandler < ShardSearchRequest > { @ Override public ShardSearchRequest newInstance ( ) { } @ Override public void messageReceived ( ShardSearchRequest request , TransportChannel channel ) throws Exception { } @ Override public String executor ( ) { } } private class SearchQueryTransportHandler extends BaseTransportRequestHandler < ShardSearchRequest > { @ Override public ShardSearchRequest newInstance ( ) { } @ Override public void messageReceived ( ShardSearchRequest request , TransportChannel channel ) throws Exception { } @ Override public String executor ( ) { } } private class SearchQueryByIdTransportHandler extends BaseTransportRequestHandler < QuerySearchRequest > { @ Override public QuerySearchRequest newInstance ( ) { }
public class Decal { private static final int VERTEX_SIZE = ( 3 + 1 ) + 2 ; public static final int SIZE = 4 * ( Decal . VERTEX_SIZE ) ; private static Vector3 tmp = new Vector3 ( ) ; private static Vector3 tmp2 = new Vector3 ( ) ; public int value ; protected float [ ] vertices = new float [ Decal . SIZE ] ; protected Vector3 position = new Vector3 ( ) ; protected Quaternion rotation = Quaternion . idt ( ) ; protected Vector2 scale = new Vector2 ( 1 , 1 ) ; public Vector2 transformationOffset = null ; protected Vector2 dimensions = new Vector2 ( ) ; protected DecalMaterial material = new DecalMaterial ( ) ; protected boolean updated = false ; protected Decal ( ) { } public void setColor ( float r , float g , float b , float a ) { } public void rotateX ( float angle ) { } public void rotateY ( float angle ) { } public void rotateZ ( float angle ) { } public void setRotation ( Vector3 dir , Vector3 up ) { } public Quaternion getRotation ( ) { } public void translateX ( float units ) { } public void setX ( float x ) { } public float getX ( ) { } public void translateY ( float units ) { } public void setY ( float y ) { } public float getY ( ) { } public void translateZ ( float units ) { } public void setZ ( float z ) { } public float getZ ( ) { } public void translate ( float x , float y , float z ) { } public void setPosition ( float x , float y , float z ) { } public Vector3 getPosition ( ) { } public void setScaleX ( float scale ) { } public float getScaleX ( ) { } public void setScaleY ( float scale ) { } public float getScaleY ( ) { } public void setScale ( float scaleX , float scaleY ) { } public void setScale ( float scale ) { } public void setWidth ( float width ) { } public float getWidth ( ) { } public void setHeight ( float height ) { } public float getHeight ( ) { } public void setDimensions ( float width , float height ) { } public float [ ] getVertices ( ) { } protected void update ( ) { } protected void transformVertices ( ) { } protected void resetVertices ( ) { } protected void updateUVs ( ) { } public void setTextureRegion ( TextureRegion textureRegion ) { } public TextureRegion getTextureRegion ( ) { } public void setBlending ( int srcBlendFactor , int dstBlendFactor ) { } public DecalMaterial getMaterial ( ) { } static final Vector3 dir = new Vector3 ( ) ; public void lookAt ( Vector3 position , Vector3 up ) { Decal . dir . set ( position ) . sub ( this . position ) . nor ( ) ; <START_BUG> setRotation ( Decal . dir , Y ) ; <END_BUG> } public static final int X1 = 0 ; public static final int Y1 = 1 ; public static final int Z1 = 2 ; public static final int C1 = 3 ; public static final int U1 = 4 ; public static final int V1 = 5 ; public static final int X2 = 6 ; public static final int Y2 = 7 ; public static final int Z2 = 8 ; public static final int C2 = 9 ; public static final int U2 = 10 ; public static final int V2 = 11 ; public static final int X3 = 12 ; public static final int Y3 = 13 ; public static final int Z3 = 14 ; public static final int C3 = 15 ; public static final int U3 = 16 ; public static final int V3 = 17 ; public static final int X4 = 18 ; public static final int Y4 = 19 ; public static final int Z4 = 20 ; public static final int C4 = 21 ; public static final int U4 = 22 ; public static final int V4 = 23 ; protected static Quaternion rotator = new Quaternion ( 0 , 0 , 0 , 0 ) ; protected static final Vector3 X_AXIS = new Vector3 ( 1 , 0 , 0 ) ; protected static final Vector3 Y_AXIS = new Vector3 ( 0 , 1 , 0 ) ; protected static final Vector3 Z_AXIS = new Vector3 ( 0 , 0 , 1 ) ; public static Decal newDecal ( TextureRegion textureRegion ) { } public static Decal newDecal ( TextureRegion textureRegion , boolean hasTransparency ) { } public static Decal newDecal ( float width , float height , TextureRegion textureRegion ) { } public static Decal newDecal ( float width , float height , TextureRegion textureRegion , boolean hasTransparency ) { } public static Decal newDecal ( float width , float height , TextureRegion textureRegion , int srcBlendFactor , int dstBlendFactor ) { } }
public class ChildrenBuilder extends AggregationBuilder < ChildrenBuilder > { private String childType ; public ChildrenBuilder ( String name ) { } public ChildrenBuilder childType ( String childType ) { } @ Override protected XContentBuilder internalXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; if ( ( childType ) == null ) { <START_BUG> throw new org . elasticsearch . search . builder . SearchSourceBuilderException ( ( ( "child_type<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>set<seq2seq4repair_space>on<seq2seq4repair_space>children<seq2seq4repair_space>aggregation<seq2seq4repair_space>[" + ( getName ( ) ) ) + "]" ) ) ; <END_BUG> } builder . field ( "type" , childType ) ; return builder . endObject ( ) ; } }
public class TransportIndexDeleteByQueryAction extends TransportIndexReplicationOperationAction < IndexDeleteByQueryRequest , IndexDeleteByQueryResponse , ShardDeleteByQueryRequest , ShardDeleteByQueryResponse > { @ Inject public TransportIndexDeleteByQueryAction ( Settings settings , ClusterService clusterService , TransportService transportService , ThreadPool threadPool , TransportShardDeleteByQueryAction shardDeleteByQueryAction ) { } @ Override protected IndexDeleteByQueryRequest newRequestInstance ( ) { } @ Override protected IndexDeleteByQueryResponse newResponseInstance ( IndexDeleteByQueryRequest request , AtomicReferenceArray shardsResponses ) { } @ Override protected boolean accumulateExceptions ( ) { } @ Override protected String transportAction ( ) { } @ Override protected void checkBlock ( IndexDeleteByQueryRequest request , ClusterState state ) { } @ Override protected GroupShardsIterator shards ( IndexDeleteByQueryRequest request ) { <START_BUG> return clusterService . operationRouting ( ) . deleteByQueryShards ( clusterService . state ( ) , request . index ( ) ) ; <END_BUG> } @ Override protected ShardDeleteByQueryRequest newShardRequestInstance ( IndexDeleteByQueryRequest request , int shardId ) { } }
public class IntegerFieldMapper extends NumberFieldMapper < Integer > { public static final String CONTENT_TYPE = "integer" ; public static class Defaults extends NumberFieldMapper . Defaults { public static final FieldType FIELD_TYPE = new FieldType ( NumberFieldMapper . Defaults . FIELD_TYPE ) ; public static final Integer NULL_VALUE = null ; } public static class Builder extends NumberFieldMapper . Builder < IntegerFieldMapper . Builder , IntegerFieldMapper > { protected Integer nullValue = IntegerFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public IntegerFieldMapper . Builder nullValue ( int nullValue ) { } @ Override public IntegerFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private Integer nullValue ; private String nullValueAsString ; protected IntegerFieldMapper ( Names names , int precisionStep , float boost , FieldType fieldType , Boolean docValues , Integer nullValue , Explicit < Boolean > ignoreMalformed , Explicit < Boolean > coerce , PostingsFormatProvider postingsProvider , DocValuesFormatProvider docValuesProvider , SimilarityProvider similarity , Loading normsLoading , @ Nullable Settings fieldDataSettings , Settings indexSettings , MultiFields multiFields , CopyTo copyTo ) { } @ Override public FieldType defaultFieldType ( ) { } @ Override public FieldDataType defaultFieldDataType ( ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Integer value ( Object value ) { } @ Override public BytesRef indexedValueForSearch ( Object value ) { } private int parseValue ( Object value ) { } @ Override public Query fuzzyQuery ( String value , Fuzziness fuzziness , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query termQuery ( Object value , @ Nullable QueryParseContext context ) { } @ Override public Filter termFilter ( Object value , @ Nullable QueryParseContext context ) { } @ Override public Query rangeQuery ( Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( QueryParseContext parseContext , Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected boolean customBoost ( ) { } @ Override protected void innerParseCreateField ( ParseContext context , List < Field > fields ) throws IOException { } protected void addIntegerFields ( ParseContext context , List < Field > fields , int value , float boost ) { if ( ( fieldType . indexed ( ) ) || ( fieldType . stored ( ) ) ) { IntegerFieldMapper . CustomIntegerNumericField field = new IntegerFieldMapper . CustomIntegerNumericField ( this , value , fieldType ) ; field . setBoost ( boost ) ; fields . add ( field ) ; } if ( hasDocValues ( ) ) { <START_BUG> addDocValue ( context , value ) ; <END_BUG> } } protected Integer nullValue ( ) { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder , boolean includeDefaults , Params params ) throws IOException { } public static class CustomIntegerNumericField extends CustomNumericField { private final int number ; private final NumberFieldMapper mapper ; public CustomIntegerNumericField ( NumberFieldMapper mapper , int number , FieldType fieldType ) { } @ Override public TokenStream tokenStream ( Analyzer analyzer , TokenStream previous ) throws IOException { } @ Override public String numericAsString ( ) { } } }
public class ShortArray { public short [ ] items ; public int size ; public boolean ordered ; public ShortArray ( ) { } public ShortArray ( int capacity ) { } public ShortArray ( boolean ordered , int capacity ) { } public ShortArray ( ShortArray array ) { } public ShortArray ( short [ ] array ) { } public ShortArray ( boolean ordered , short [ ] array , int startIndex , int count ) { } public void add ( short value ) { } public void addAll ( ShortArray array ) { } public void addAll ( ShortArray array , int offset , int length ) { } public void addAll ( short [ ] array ) { } public void addAll ( short [ ] array , int offset , int length ) { short [ ] items = this . items ; <START_BUG> int sizeNeeded = ( ( size ) + length ) - offset ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public short get ( int index ) { } public void set ( int index , short value ) { } public void insert ( int index , short value ) { } public void swap ( int first , int second ) { } public boolean contains ( short value ) { } public int indexOf ( short value ) { } public int lastIndexOf ( char value ) { } public boolean removeValue ( short value ) { } public short removeIndex ( int index ) { } public boolean removeAll ( ShortArray array ) { } public short pop ( ) { } public short peek ( ) { } public short first ( ) { } public void clear ( ) { } public void shrink ( ) { } public short [ ] ensureCapacity ( int additionalCapacity ) { } protected short [ ] resize ( int newSize ) { } public void sort ( ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public short random ( ) { } public short [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class ReproduceInfoPrinter extends RunListener { protected final ESLogger logger = Loggers . getLogger ( ElasticsearchTestCase . class ) ; @ Override public void testStarted ( Description description ) throws Exception { } @ Override public void testFinished ( Description description ) throws Exception { } @ Override public void testFailure ( Failure failure ) throws Exception { } protected ReproduceErrorMessageBuilder reproduceErrorMessageBuilder ( StringBuilder b ) { } protected TraceFormatting traces ( ) { } protected static class MavenMessageBuilder extends ReproduceErrorMessageBuilder { public MavenMessageBuilder ( StringBuilder b ) { } @ Override public ReproduceErrorMessageBuilder appendAllOpts ( Description description ) { } @ Override public ReproduceErrorMessageBuilder appendOpt ( String sysPropName , String value ) { } public ReproduceErrorMessageBuilder appendESProperties ( ) { <START_BUG> appendProperties ( "es.logger.level" , "es.node.mode" , "es.node.local" , TESTS_ENABLE_MOCK_MODULES , "tests.assertion.disabled" , "tests.security.manager" , "tests.nighly" , "tests.jvms" , "tests.client.ratio" ) ; <END_BUG> if ( ( ( System . getProperty ( "tests.jvm.argline" ) ) != null ) && ( ! ( System . getProperty ( "tests.jvm.argline" ) . isEmpty ( ) ) ) ) { appendOpt ( "tests.jvm.argline" , ( ( "\"" + ( System . getProperty ( "tests.jvm.argline" ) ) ) + "\"" ) ) ; } return this ; } protected ReproduceErrorMessageBuilder appendProperties ( String ... properties ) { } } }
public class AndroidApplication extends Activity implements Application { protected AndroidGraphics graphics ; protected AndroidInput input ; protected AndroidAudio audio ; protected AndroidFiles files ; protected ApplicationListener listener ; protected Handler handler ; protected boolean firstResume = true ; protected final List < Runnable > runnables = new ArrayList < Runnable > ( ) ; protected WakeLock wakeLock = null ; public void initialize ( ApplicationListener listener , boolean useGL2IfAvailable ) { } public void initialize ( ApplicationListener listener , AndroidApplicationConfiguration config ) { } protected LayoutParams createLayoutParams ( ) { } protected void createWakeLock ( AndroidApplicationConfiguration config ) { } public View initializeForView ( ApplicationListener listener , boolean useGL2IfAvailable ) { } public View initializeForView ( ApplicationListener listener , AndroidApplicationConfiguration config ) { } @ Override protected void onPause ( ) { } @ Override protected void onResume ( ) { } @ Override protected void onDestroy ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Files getFiles ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Input getInput ( ) { } @ Override public void log ( String tag , String message ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { <START_BUG> return ( SDK . charAt ( 0 ) ) - '0' ; <END_BUG> } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } @ Override public Preferences getPreferences ( String name ) { } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void onConfigurationChanged ( Configuration config ) { } @ Override public void log ( String tag , String message , Exception exception ) { } }
public abstract class AbstractIndexStore extends AbstractIndexComponent implements IndexStore { public static final String INDEX_STORE_THROTTLE_TYPE = "index.store.throttle.type" ; public static final String INDEX_STORE_THROTTLE_MAX_BYTES_PER_SEC = "index.store.throttle.max_bytes_per_sec" ; class ApplySettings implements IndexSettingsService . Listener { @ Override public void onRefreshSettings ( Settings settings ) { } } protected final IndexService indexService ; protected final IndicesStore indicesStore ; private volatile String rateLimitingType ; private volatile ByteSizeValue rateLimitingThrottle ; private volatile boolean nodeRateLimiting ; private final StoreRateLimiting rateLimiting = new StoreRateLimiting ( ) ; private final AbstractIndexStore . ApplySettings applySettings = new AbstractIndexStore . ApplySettings ( ) ; protected AbstractIndexStore ( Index index , @ IndexSettings Settings indexSettings , IndexService indexService , IndicesStore indicesStore ) { } @ Override <START_BUG> public void close ( boolean delete ) throws ElasticSearchException { <END_BUG> indexService . settingsService ( ) . removeListener ( applySettings ) ; } @ Override public boolean canDeleteUnallocated ( ShardId shardId ) { } @ Override public void deleteUnallocated ( ShardId shardId ) throws IOException { } @ Override public IndicesStore indicesStore ( ) { } @ Override public StoreRateLimiting rateLimiting ( ) { } }
public class IndexNameFacetCollector extends AbstractFacetCollector { private final String indexName ; private final ComparatorType comparatorType ; private final int size ; private int count = 0 ; public IndexNameFacetCollector ( String facetName , String indexName , TermsFacet . ComparatorType comparatorType , int size ) { } @ Override protected void doSetNextReader ( IndexReader reader , int docBase ) throws IOException { } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override public Facet facet ( ) { <START_BUG> return new InternalStringTermsFacet ( facetName , "_index" , comparatorType , size , Sets . newHashSet ( new InternalStringTermsFacet . StringEntry ( indexName , count ) ) , 0 ) ; <END_BUG> } }
public class Gdx2DTest extends GdxTest { SpriteBatch batch ; List < Sprite > sprites ; Texture textureFromPixmap ( Gdx2DPixmap pixmap ) { } void drawToPixmap ( Gdx2DPixmap pixmap ) { } Gdx2DPixmap [ ] testPixmaps ( ) { int [ ] formats = new int [ ] { Gdx2DPixmap . GDX2D_FORMAT_ALPHA , Gdx2DPixmap . GDX2D_FORMAT_LUMINANCE_ALPHA , Gdx2DPixmap . GDX2D_FORMAT_RGB565 , Gdx2DPixmap . GDX2D_FORMAT_RGB888 , Gdx2DPixmap . GDX2D_FORMAT_RGBA4444 , Gdx2DPixmap . GDX2D_FORMAT_RGBA8888 } ; Gdx2DPixmap [ ] pixmaps = new Gdx2DPixmap [ formats . length ] ; for ( int i = 0 ; i < ( pixmaps . length ) ; i ++ ) { <START_BUG> Gdx2DPixmap pixmap = new Gdx2DPixmap ( 32 , 32 , formats [ i ] ) ; <END_BUG> drawToPixmap ( pixmap ) ; pixmaps [ i ] = pixmap ; } return pixmaps ; } @ Override public void create ( ) { } @ Override public void render ( ) { } @ Override public boolean needsGL20 ( ) { } }
public class DoubleTermsAggregator extends LongTermsAggregator { public DoubleTermsAggregator ( String name , AggregatorFactories factories , ValuesSource . Numeric valuesSource , @ Nullable ValueFormat format , long estimatedBucketCount , Terms . Order order , BucketCountThresholds bucketCountThresholds , AggregationContext aggregationContext , Aggregator parent , SubAggCollectionMode collectionMode , boolean showTermDocCountError , IncludeExclude . LongFilter longFilter ) { } @ Override protected SortedNumericDocValues getValues ( Numeric valuesSource ) { } @ Override public DoubleTerms buildAggregation ( long owningBucketOrdinal ) { } @ Override public DoubleTerms buildEmptyAggregation ( ) { } private static Bucket convertToDouble ( InternalTerms . Bucket bucket ) { } private static DoubleTerms convertToDouble ( LongTerms terms ) { final InternalTerms [ ] buckets = terms . getBuckets ( ) . toArray ( new InternalTerms . Bucket [ 0 ] ) ; for ( int i = 0 ; i < ( buckets . length ) ; ++ i ) { buckets [ i ] = DoubleTermsAggregator . convertToDouble ( buckets [ i ] ) ; } <START_BUG> return new DoubleTerms ( terms . getName ( ) , terms . order , terms . formatter , terms . requiredSize , terms . shardSize , terms . minDocCount , Arrays . asList ( buckets ) , terms . showTermDocCountError , terms . docCountError ) ; <END_BUG> } }
@ Override public Terms terms ( String field ) throws IOException { if ( ! ( fieldMap . containsKey ( field ) ) ) { return null ; } long offset = fieldMap . lget ( ) ; final BytesStreamInput perFieldTermVectorInput = new BytesStreamInput ( this . termVectors ) ; perFieldTermVectorInput . reset ( ) ; perFieldTermVectorInput . skip ( offset ) ; final long numTerms = perFieldTermVectorInput . readVLong ( ) ; final boolean hasPositions = perFieldTermVectorInput . readBoolean ( ) ; final boolean hasOffsets = perFieldTermVectorInput . readBoolean ( ) ; final boolean hasPayloads = perFieldTermVectorInput . readBoolean ( ) ; final long sumTotalTermFreq = ( hasFieldStatistic ) ? readPotentiallyNegativeVLong ( perFieldTermVectorInput ) : - 1 ; final long sumDocFreq = ( hasFieldStatistic ) ? readPotentiallyNegativeVLong ( perFieldTermVectorInput ) : - 1 ; final int docCount = ( hasFieldStatistic ) ? readPotentiallyNegativeVInt ( perFieldTermVectorInput ) : - 1 ; return new Terms ( ) { @ Override public TermsEnum iterator ( TermsEnum reuse ) throws IOException { return new TermsEnum ( ) { int currentTerm = 0 ; int freq = 0 ; int docFreq = - 1 ; long totalTermFrequency = - 1 ; int [ ] positions = new int [ 1 ] ; int [ ] startOffsets = new int [ 1 ] ; int [ ] endOffsets = new int [ 1 ] ; BytesRef [ ] payloads = new BytesRef [ 1 ] ; final BytesRef spare = new BytesRef ( ) ; @ Override public BytesRef next ( ) throws IOException { if ( ( ( currentTerm ) ++ ) < numTerms ) { int termVectorSize = perFieldTermVectorInput . readVInt ( ) ; spare . grow ( termVectorSize ) ; perFieldTermVectorInput . readBytes ( spare . bytes , 0 , termVectorSize ) ; spare . length = termVectorSize ; if ( hasTermStatistic ) { docFreq = readPotentiallyNegativeVInt ( perFieldTermVectorInput ) ; totalTermFrequency = readPotentiallyNegativeVLong ( perFieldTermVectorInput ) ; } freq = readPotentiallyNegativeVInt ( perFieldTermVectorInput ) ; growBuffers ( ) ; writeInfos ( perFieldTermVectorInput ) ; return spare ; } else { return null ; } } private void writeInfos ( final BytesStreamInput input ) throws IOException { for ( int i = 0 ; i < ( freq ) ; i ++ ) { if ( hasPositions ) { positions [ i ] = input . readVInt ( ) ; } if ( hasOffsets ) { startOffsets [ i ] = input . readVInt ( ) ; endOffsets [ i ] = input . readVInt ( ) ; } if ( hasPayloads ) { int payloadLength = input . readVInt ( ) ; if ( payloadLength > 0 ) { if ( ( payloads [ i ] ) == null ) { payloads [ i ] = new BytesRef ( payloadLength ) ; } else { payloads [ i ] . grow ( payloadLength ) ; } input . readBytes ( payloads [ i ] . bytes , 0 , payloadLength ) ; payloads [ i ] . length = payloadLength ; payloads [ i ] . offset = 0 ; } } } } private void growBuffers ( ) { if ( hasPositions ) { positions = grow ( positions , freq ) ; } if ( hasOffsets ) { startOffsets = grow ( startOffsets , freq ) ; endOffsets = grow ( endOffsets , freq ) ; } if ( hasPayloads ) { if ( ( payloads . length ) < ( freq ) ) { final BytesRef [ ] newArray = new BytesRef [ ArrayUtil . oversize ( freq , NUM_BYTES_OBJECT_REF ) ] ; System . arraycopy ( payloads , 0 , newArray , 0 , payloads . length ) ; payloads = newArray ; } } } @ Override public Comparator < BytesRef > getComparator ( ) { return BytesRef . getUTF8SortedAsUnicodeComparator ( ) ; } @ Override <START_BUG> public SeekStatus seekCeil ( BytesRef text , boolean useCache ) throws IOException { <END_BUG> throw new UnsupportedOperationException ( ) ; } @ Override public void seekExact ( long ord ) throws IOException { throw new UnsupportedOperationException ( "Seek<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>supported" ) ; } @ Override public BytesRef term ( ) throws IOException { return spare ; } @ Override public long ord ( ) throws IOException { throw new UnsupportedOperationException ( "ordinals<seq2seq4repair_space>are<seq2seq4repair_space>not<seq2seq4repair_space>supported" ) ; } @ Override public int docFreq ( ) throws IOException { return docFreq ; } @ Override public long totalTermFreq ( ) throws IOException { return totalTermFrequency ; } @ Override public DocsEnum docs ( Bits liveDocs , DocsEnum reuse , int flags ) throws IOException { return docsAndPositions ( liveDocs , ( reuse instanceof DocsAndPositionsEnum ? ( ( DocsAndPositionsEnum ) ( reuse ) ) : null ) , 0 ) ; } @ Override public DocsAndPositionsEnum docsAndPositions ( Bits liveDocs , DocsAndPositionsEnum reuse , int flags ) throws IOException { final TermVectorFields . TermVectorsDocsAndPosEnum retVal = ( reuse instanceof TermVectorFields . TermVectorsDocsAndPosEnum ) ? ( ( TermVectorFields . TermVectorsDocsAndPosEnum ) ( reuse ) ) : new TermVectorFields . TermVectorsDocsAndPosEnum ( ) ; return retVal . reset ( ( hasPositions ? positions : null ) , ( hasOffsets ? startOffsets : null ) , ( hasOffsets ? endOffsets : null ) , ( hasPayloads ? payloads : null ) , freq ) ; } } ; } @ Override public Comparator < BytesRef > getComparator ( ) { return BytesRef . getUTF8SortedAsUnicodeComparator ( ) ; } @ Override public long size ( ) throws IOException { return numTerms ; } @ Override public long getSumTotalTermFreq ( ) throws IOException { return sumTotalTermFreq ; } @ Override public long getSumDocFreq ( ) throws IOException { return sumDocFreq ; } @ Override public int getDocCount ( ) throws IOException { return docCount ; } @ Override public boolean hasOffsets ( ) { return hasOffsets ; } @ Override public boolean hasPositions ( ) { return hasPositions ; } @ Override public boolean hasPayloads ( ) { return hasPayloads ;
public class ParticleEffectLoader extends SynchronousAssetLoader < ParticleEffect , ParticleEffectLoader . ParticleEffectParameter > { public ParticleEffectLoader ( FileHandleResolver resolver ) { } @ Override public ParticleEffect load ( AssetManager am , String fileName , FileHandle file , ParticleEffectLoader . ParticleEffectParameter param ) { } @ Override public Array < AssetDescriptor > getDependencies ( String fileName , FileHandle file , ParticleEffectLoader . ParticleEffectParameter param ) { Array < AssetDescriptor > deps = null ; if ( ( param != null ) && ( ( param . atlasFile ) != null ) ) { <START_BUG> deps = new Array ( ) ; <END_BUG> deps . add ( new AssetDescriptor < TextureAtlas > ( param . atlasFile , TextureAtlas . class ) ) ; } return deps ; } public static class ParticleEffectParameter extends AssetLoaderParameters < ParticleEffect > { public String atlasFile ; public FileHandle imagesDir ; } }
public class HttpServer extends AbstractLifecycleComponent < HttpServer > { private final Environment environment ; private final HttpServerTransport transport ; private final RestController restController ; private final NodeService nodeService ; private final boolean disableSites ; private final HttpServer . PluginSiteFilter pluginSiteFilter = new HttpServer . PluginSiteFilter ( ) ; @ Inject public HttpServer ( Settings settings , Environment environment , HttpServerTransport transport , RestController restController , NodeService nodeService ) { } static class Dispatcher implements HttpServerAdapter { private final HttpServer server ; Dispatcher ( HttpServer server ) { } @ Override public void dispatchRequest ( HttpRequest request , HttpChannel channel ) { } } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } public HttpInfo info ( ) { <START_BUG> return new HttpInfo ( transport . boundAddress ( ) ) ; <END_BUG> } public HttpStats stats ( ) { } public void internalDispatchRequest ( final HttpRequest request , final HttpChannel channel ) { } class PluginSiteFilter extends RestFilter { @ Override public void process ( RestRequest request , RestChannel channel , RestFilterChain filterChain ) { } } void handlePluginSite ( HttpRequest request , HttpChannel channel ) { } private String guessMimeType ( String path ) { } public static final Map < String , String > DEFAULT_MIME_TYPES ; }
public class JsonFloatFieldMapper extends JsonNumberFieldMapper < Float > { public static final String JSON_TYPE = "float" ; public static class Defaults extends JsonNumberFieldMapper . Defaults { public static final Float NULL_VALUE = null ; } public static class Builder extends JsonNumberFieldMapper . Builder < JsonFloatFieldMapper . Builder , JsonFloatFieldMapper > { protected Float nullValue = JsonFloatFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public JsonFloatFieldMapper . Builder nullValue ( float nullValue ) { } @ Override public JsonFloatFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements JsonTypeParser { @ Override public JsonMapper . Builder parse ( String name , JsonNode node , ParserContext parserContext ) throws MapperParsingException { } } private final Float nullValue ; private final String nullValueAsString ; protected JsonFloatFieldMapper ( Names names , int precisionStep , Field . Index index , Field . Store store , float boost , boolean omitNorms , boolean omitTermFreqAndPositions , Float nullValue ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Float value ( Fieldable field ) { byte [ ] value = field . getBinaryValue ( ) ; if ( value == null ) { <START_BUG> return Float . NaN ; <END_BUG> } return Numbers . bytesToFloat ( value ) ; } @ Override public String indexedValue ( String value ) { } @ Override public String indexedValue ( Float value ) { } @ Override public Object valueFromTerm ( String term ) { } @ Override public Object valueFromString ( String text ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override protected Field parseCreateField ( JsonParseContext jsonContext ) throws IOException { } @ Override public int sortType ( ) { } @ Override protected String jsonType ( ) { } @ Override protected void doJsonBody ( JsonBuilder builder ) throws IOException { } }
public class Sphere implements Serializable { private static final long serialVersionUID = - 6487336868908521596L ; public float radius ; public final Vector3 center ; public Sphere ( Vector3 center , float radius ) { } public boolean overlaps ( Sphere sphere ) { <START_BUG> return ( center . dst2 ( sphere . center ) ) < ( ( ( radius ) + ( sphere . radius ) ) * ( ( radius ) + ( sphere . radius ) ) ) ; <END_BUG> } }
public interface ScoreFunction { void setNextReader ( AtomicReaderContext context ) { } float score ( int docId , float subQueryScore ) { } <START_BUG> float factor ( int docId ) ; <END_BUG> Explanation explainScore ( int docId , Explanation subQueryExpl ) { } Explanation explainFactor ( int docId ) { } }
public class SimpleIdCache extends AbstractIndexComponent implements IdCache , SegmentReader . CoreClosedListener { private final ConcurrentMap < Object , SimpleIdReaderCache > idReaders ; private final boolean reuse ; IndexService indexService ; @ Inject public SimpleIdCache ( Index index , @ IndexSettings Settings indexSettings ) { } @ Override public void setIndexService ( IndexService indexService ) { } @ Override public void close ( ) throws ElasticSearchException { } @ Override public void clear ( ) { } @ Override public void onClose ( SegmentReader owner ) { } @ Override public void clear ( IndexReader reader ) { } @ Override public IdReaderCache reader ( AtomicReader reader ) { } @ SuppressWarnings ( { "unchecked" } ) @ Override public Iterator < IdReaderCache > iterator ( ) { } @ SuppressWarnings ( { "StringEquality" } ) @ Override public void refresh ( List < AtomicReaderContext > atomicReaderContexts ) throws Exception { } void onCached ( SimpleIdReaderCache readerCache ) { } void onRemoval ( SimpleIdReaderCache readerCache ) { if ( ( readerCache . shardId ) != null ) { IndexShard shard = indexService . shard ( readerCache . shardId . id ( ) ) ; if ( shard != null ) { <START_BUG> shard . idCache ( ) . onCached ( readerCache . sizeInBytes ( ) ) ; <END_BUG> } } } private HashedBytesArray checkIfCanReuse ( Map < Object , Map < String , SimpleIdCache . TypeBuilder > > builders , HashedBytesArray idAsBytes ) { } private boolean refreshNeeded ( List < AtomicReaderContext > atomicReaderContexts ) { } static class TypeBuilder { final ExtTObjectIntHasMap < HashedBytesArray > idToDoc = new ExtTObjectIntHasMap < HashedBytesArray > ( Constants . DEFAULT_CAPACITY , Constants . DEFAULT_LOAD_FACTOR , ( - 1 ) ) ; final HashedBytesArray [ ] docToId ; final ArrayList < HashedBytesArray > parentIdsValues = new ArrayList < HashedBytesArray > ( ) ; final int [ ] parentIdsOrdinals ; int t = 1 ; TypeBuilder ( IndexReader reader ) { } public HashedBytesArray canReuse ( HashedBytesArray id ) { } } }
public class SingleValueStringFieldData extends StringFieldData { private static ThreadLocal < String [ ] > valuesCache = new ThreadLocal < String [ ] > ( ) { @ Override protected String [ ] initialValue ( ) { } } ; private final int [ ] order ; public SingleValueStringFieldData ( String fieldName , FieldDataOptions options , int [ ] order , String [ ] values , int [ ] freqs ) { } @ Override public boolean multiValued ( ) { } @ Override public boolean hasValue ( int docId ) { } @ Override public void forEachValueInDoc ( int docId , StringValueInDocProc proc ) { int loc = order [ docId ] ; if ( loc == 0 ) { return ; } <START_BUG> proc . onValue ( values [ loc ] , docId ) ; <END_BUG> } @ Override public String value ( int docId ) { } @ Override public String [ ] values ( int docId ) { } }
public class SingleArrayOrdinals implements Ordinals { private final int [ ] ordinals ; private final int numOrds ; private long size = - 1 ; public SingleArrayOrdinals ( int [ ] ordinals , int numOrds ) { } @ Override public Object getBackingStorage ( ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override public boolean isMultiValued ( ) { } @ Override public int getNumDocs ( ) { } @ Override public int getNumOrds ( ) { } @ Override public SingleArrayOrdinals . Docs ordinals ( ) { } public static class Docs implements Ordinals . Docs { private final SingleArrayOrdinals parent ; private final int [ ] ordinals ; private final IntArrayRef intsScratch = new IntArrayRef ( new int [ 1 ] ) ; private final SingleValueIter iter = new SingleValueIter ( ) ; public Docs ( SingleArrayOrdinals parent , int [ ] ordinals ) { } @ Override public Ordinals ordinals ( ) { } @ Override public int getNumDocs ( ) { } @ Override public int getNumOrds ( ) { } @ Override public boolean isMultiValued ( ) { } @ Override public int getOrd ( int docId ) { } @ Override public IntArrayRef getOrds ( int docId ) { int ordinal = ordinals [ docId ] ; if ( ordinal == 0 ) return IntArrayRef . EMPTY ; <START_BUG> intsScratch . values [ 0 ] = docId ; <END_BUG> return intsScratch ; } @ Override public Iter getIter ( int docId ) { } @ Override public void forEachOrdinalInDoc ( int docId , OrdinalInDocProc proc ) { } } }
public class GetResponse implements ActionResponse , Streamable { private String index ; private String type ; private String id ; private byte [ ] source ; GetResponse ( ) { } GetResponse ( String index , String type , String id , byte [ ] source ) { } public boolean exists ( ) { <START_BUG> return ( source ) == null ; <END_BUG> } public String index ( ) { } public String type ( ) { } public String id ( ) { } public byte [ ] source ( ) { } public String sourceAsString ( ) { } @ Override public void readFrom ( DataInput in ) throws IOException , ClassNotFoundException { } @ Override public void writeTo ( DataOutput out ) throws IOException { } }
public class MergePolicyModule extends AbstractModule { private final Settings settings ; public MergePolicyModule ( Settings settings ) { } @ Override protected void configure ( ) { <START_BUG> bind ( MergePolicyProvider . class ) . to ( settings . getAsClass ( "index.merge.policy.type" , TieredMergePolicyProvider . class ) ) . asEagerSingleton ( ) ; <END_BUG> } }
public class FieldsTermsStringFacetExecutor extends FacetExecutor { private final ComparatorType comparatorType ; private final int size ; private final int shardSize ; private final IndexFieldData [ ] indexFieldDatas ; private final SearchScript script ; private final HashedAggregator aggregator ; long missing ; long total ; public FieldsTermsStringFacetExecutor ( FieldMapper [ ] fieldMappers , int size , int shardSize , InternalStringTermsFacet . ComparatorType comparatorType , boolean allTerms , SearchContext context , ImmutableSet < BytesRef > excluded , Pattern pattern , SearchScript script ) { } @ Override public FieldsTermsStringFacetExecutor . Collector collector ( ) { } @ Override public InternalFacet buildFacet ( String facetName ) { } class Collector extends FacetExecutor . Collector { private final HashedAggregator aggregator ; private BytesValues [ ] values ; public Collector ( HashedAggregator aggregator ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { for ( int i = 0 ; i < ( indexFieldDatas . length ) ; i ++ ) { <START_BUG> values [ i ] = indexFieldDatas [ i ] . load ( context ) . getBytesValues ( ) ; <END_BUG> } if ( ( script ) != null ) { script . setNextReader ( context ) ; } } @ Override public void collect ( int doc ) throws IOException { } @ Override public void postCollection ( ) { } } }
public abstract class AbstractFieldDataTests extends ElasticSearchTestCase { protected IndexFieldDataService ifdService ; protected IndexWriter writer ; protected AtomicReaderContext readerContext ; protected abstract FieldDataType getFieldDataType ( ) { } public < IFD extends IndexFieldData > IFD getForField ( String fieldName ) { } @ Before public void setup ( ) throws Exception { } protected AtomicReaderContext refreshReader ( ) throws Exception { if ( ( readerContext ) != null ) { readerContext . reader ( ) . close ( ) ; } <START_BUG> AtomicReader reader = new SlowCompositeReaderWrapper ( DirectoryReader . open ( writer , true ) ) ; <END_BUG> readerContext = reader . getContext ( ) ; return readerContext ; } @ After public void tearDown ( ) throws Exception { } }
public final void glEnable ( int cap ) { } public final void glEnableClientState ( int array ) { } public final void glFinish ( ) { } public final void glFlush ( ) { } public final void glFogf ( int pname , float param ) { } public final void glFogfv ( int pname , FloatBuffer params ) { } public final void glFrontFace ( int mode ) { } public final void glFrustumf ( float left , float right , float bottom , float top , float zNear , float zFar ) { } public final void glGenTextures ( int n , IntBuffer textures ) { } public final int glGetError ( ) { } public final void glGetIntegerv ( int pname , IntBuffer params ) { } public final String glGetString ( int name ) { } public final void glHint ( int target , int mode ) { } public final void glLightModelf ( int pname , float param ) { } public final void glLightModelfv ( int pname , FloatBuffer params ) { } public final void glLightf ( int light , int pname , float param ) { } public final void glLightfv ( int light , int pname , FloatBuffer params ) { } public final void glLineWidth ( float width ) { } public final void glLoadIdentity ( ) { } public final void glLoadMatrixf ( FloatBuffer m ) { } public final void glLogicOp ( int opcode ) { } public final void glMaterialf ( int face , int pname , float param ) { } public final void glMaterialfv ( int face , int pname , FloatBuffer params ) { } public final void glMatrixMode ( int mode ) { } public final void glMultMatrixf ( FloatBuffer m ) { } public final void glMultiTexCoord4f ( int target , float s , float t , float r , float q ) { } public final void glNormal3f ( float nx , float ny , float nz ) { } public final void glNormalPointer ( int type , int stride , Buffer pointer ) { } public final void glOrthof ( float left , float right , float bottom , float top , float zNear , float zFar ) { } public final void glPixelStorei ( int pname , int param ) { } public final void glPointSize ( float size ) { } public final void glPolygonOffset ( float factor , float units ) { } public final void glPopMatrix ( ) { } public final void glPushMatrix ( ) { } public final void glReadPixels ( int x , int y , int width , int height , int format , int type , Buffer pixels ) { } public final void glRotatef ( float angle , float x , float y , float z ) { } public final void glSampleCoverage ( float value , boolean invert ) { } public final void glScalef ( float x , float y , float z ) { } public final void glScissor ( int x , int y , int width , int height ) { } public final void glShadeModel ( int mode ) { } public final void glStencilFunc ( int func , int ref , int mask ) { } public final void glStencilMask ( int mask ) { } public final void glStencilOp ( int fail , int zfail , int zpass ) { } public final void glTexCoordPointer ( int size , int type , int stride , Buffer pointer ) { } public final void glTexEnvf ( int target , int pname , float param ) { } public final void glTexEnvfv ( int target , int pname , FloatBuffer params ) { } public final void glTexImage2D ( int target , int level , int internalformat , int width , int height , int border , int format , int type , Buffer pixels ) { } public final void glTexParameterf ( int target , int pname , float param ) { } public final void glTexSubImage2D ( int target , int level , int xoffset , int yoffset , int width , int height , int format , int type , Buffer pixels ) { } public final void glTranslatef ( float x , float y , float z ) { } public final void glVertexPointer ( int size , int type , int stride , Buffer pointer ) { } public final void glViewport ( int x , int y , int width , int height ) { } public final void glDeleteTextures ( int n , int [ ] textures , int offset ) { } public final void glFogfv ( int pname , float [ ] params , int offset ) { } public final void glGenTextures ( int n , int [ ] textures , int offset ) { } IntBuffer getBuffer = BufferUtils . createIntBuffer ( 100 ) ; public final void glGetIntegerv ( int pname , int [ ] params , int offset ) { } public final void glLightModelfv ( int pname , float [ ] params , int offset ) { } public final void glLightfv ( int light , int pname , float [ ] params , int offset ) { } public final void glLoadMatrixf ( float [ ] m , int offset ) { } public final void glMaterialfv ( int face , int pname , float [ ] params , int offset ) { } public final void glMultMatrixf ( float [ ] m , int offset ) { } public final void glTexEnvfv ( int target , int pname , float [ ] params , int offset ) { <START_BUG> glTexEnvf ( target , pname , params [ offset ] ) ; <END_BUG> } public void glPolygonMode ( int face , int mode ) { } }
public class JsonDocumentMapper implements DocumentMapper , ToJson { public static class Builder { private JsonUidFieldMapper uidFieldMapper = new JsonUidFieldMapper ( ) ; private JsonIdFieldMapper idFieldMapper = new JsonIdFieldMapper ( ) ; private JsonTypeFieldMapper typeFieldMapper = new JsonTypeFieldMapper ( ) ; private JsonSourceFieldMapper sourceFieldMapper = new JsonSourceFieldMapper ( ) ; private JsonBoostFieldMapper boostFieldMapper = new JsonBoostFieldMapper ( ) ; private Analyzer indexAnalyzer ; private Analyzer searchAnalyzer ; private final JsonObjectMapper rootObjectMapper ; private String mappingSource ; private BuilderContext builderContext = new JsonMapper . BuilderContext ( new JsonPath ( 1 ) ) ; public Builder ( JsonObjectMapper . Builder builder ) { } public JsonDocumentMapper . Builder sourceField ( JsonSourceFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder idField ( JsonIdFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder uidField ( JsonUidFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder typeField ( JsonTypeFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder boostField ( JsonBoostFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder mappingSource ( String mappingSource ) { } public JsonDocumentMapper . Builder indexAnalyzer ( Analyzer indexAnalyzer ) { } public boolean hasIndexAnalyzer ( ) { } public JsonDocumentMapper . Builder searchAnalyzer ( Analyzer searchAnalyzer ) { } public boolean hasSearchAnalyzer ( ) { } public JsonDocumentMapper build ( ) { } } private ThreadLocal < JsonParseContext > cache = new ThreadLocal < JsonParseContext > ( ) { @ Override protected JsonParseContext initialValue ( ) { } } ; private final JsonFactory jsonFactory = Jackson . defaultJsonFactory ( ) ; private final String type ; private volatile String mappingSource ; private final JsonUidFieldMapper uidFieldMapper ; private final JsonIdFieldMapper idFieldMapper ; private final JsonTypeFieldMapper typeFieldMapper ; private final JsonSourceFieldMapper sourceFieldMapper ; private final JsonBoostFieldMapper boostFieldMapper ; private final JsonObjectMapper rootObjectMapper ; private final Analyzer indexAnalyzer ; private final Analyzer searchAnalyzer ; private volatile DocumentFieldMappers fieldMappers ; private final List < FieldMapperListener > fieldMapperListeners = Lists . newArrayList ( ) ; private final Object mutex = new Object ( ) ; public JsonDocumentMapper ( JsonObjectMapper rootObjectMapper , JsonUidFieldMapper uidFieldMapper , JsonIdFieldMapper idFieldMapper , JsonTypeFieldMapper typeFieldMapper , JsonSourceFieldMapper sourceFieldMapper , Analyzer indexAnalyzer , Analyzer searchAnalyzer , @ Nullable JsonBoostFieldMapper boostFieldMapper , @ Nullable String mappingSource ) { } @ Override public String type ( ) { } @ Override public String mappingSource ( ) { } void mappingSource ( String mappingSource ) { } @ Override public UidFieldMapper uidMapper ( ) { } @ Override public IdFieldMapper idMapper ( ) { } @ Override public TypeFieldMapper typeMapper ( ) { } @ Override public SourceFieldMapper sourceMapper ( ) { } @ Override public BoostFieldMapper boostMapper ( ) { } @ Override public Analyzer indexAnalyzer ( ) { } @ Override public Analyzer searchAnalyzer ( ) { } @ Override public DocumentFieldMappers mappers ( ) { } @ Override public ParsedDocument parse ( byte [ ] source ) { } @ Override public ParsedDocument parse ( @ Nullable String type , @ Nullable String id , byte [ ] source ) throws MapperParsingException { } @ Override public ParsedDocument parse ( String type , String id , byte [ ] source , ParseListener listener ) { } void addFieldMapper ( FieldMapper fieldMapper ) { } @ Override public void addFieldMapperListener ( FieldMapperListener fieldMapperListener , boolean includeExisting ) { } @ Override public synchronized void merge ( DocumentMapper mergeWith , MergeFlags mergeFlags ) throws MergeMappingException { JsonDocumentMapper jsonMergeWith = ( ( JsonDocumentMapper ) ( mergeWith ) ) ; <START_BUG> rootObjectMapper . mergeMapping ( jsonMergeWith . rootObjectMapper , mergeFlags ) ; <END_BUG> if ( ! ( mergeFlags . simulate ( ) ) ) { mappingSource = buildSource ( ) ; } } @ Override public String buildSource ( ) throws FailedToGenerateSourceMapperException { } @ Override public void toJson ( JsonBuilder builder , Params params ) throws IOException { } }
public class LoginActivity extends RoboSherlockAccountAuthenticatorActivity { public static final String PARAM_AUTHTOKEN_TYPE = "authtokenType" ; private static final String PARAM_CONFIRMCREDENTIALS = "confirmCredentials" ; private static final String PARAM_USERNAME = "username" ; private static final String TAG = "LoginActivity" ; private static final long SYNC_PERIOD = ( 8L * 60L ) * 60L ; private static void configureSyncFor ( Account account ) { } private static class AccountLoader extends AuthenticatedUserTask < List < User > > { @ Inject private AccountDataManager cache ; protected AccountLoader ( Context context ) { } @ Override protected List < User > run ( ) throws Exception { } } private AccountManager accountManager ; @ InjectView ( id . et_login ) private AutoCompleteTextView loginText ; @ InjectView ( id . et_password ) private EditText passwordText ; private RoboAsyncTask < User > authenticationTask ; private String authToken ; private String authTokenType ; private MenuItem loginItem ; private Boolean confirmCredentials = false ; private String password ; protected boolean requestNewAccount = false ; private String username ; @ Override public void onCreate ( Bundle savedInstanceState ) { } @ Override protected void onResume ( ) { } private boolean loginEnabled ( ) { } private void updateEnablement ( ) { } @ Override public void startActivity ( Intent intent ) { } public void handleLogin ( ) { } protected void finishConfirmCredentials ( boolean result ) { } protected void finishLogin ( ) { final Intent intent = new Intent ( ) ; authToken = password ; intent . putExtra ( KEY_ACCOUNT_NAME , username ) ; intent . putExtra ( KEY_ACCOUNT_TYPE , AccountConstants . ACCOUNT_TYPE ) ; <START_BUG> if ( ( ( authTokenType ) != null ) && ( authTokenType . equals ( AccountConstants . ACCOUNT_TYPE ) ) ) <END_BUG> intent . putExtra ( KEY_AUTHTOKEN , authToken ) ; setAccountAuthenticatorResult ( intent . getExtras ( ) ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } public void onAuthenticationResult ( boolean result ) { } public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public boolean onCreateOptionsMenu ( Menu optionMenu ) { } private List < String > getEmailAddresses ( ) { } }
public class TransportShardGatewaySnapshotAction extends TransportShardReplicationOperationAction < ShardGatewaySnapshotRequest , ShardGatewaySnapshotResponse > { @ Inject public TransportShardGatewaySnapshotAction ( Settings settings , TransportService transportService , ClusterService clusterService , IndicesService indicesService , ThreadPool threadPool , ShardStateAction shardStateAction ) { } @ Override protected ShardGatewaySnapshotRequest newRequestInstance ( ) { } @ Override protected ShardGatewaySnapshotResponse newResponseInstance ( ) { } @ Override protected String transportAction ( ) { } @ Override protected ShardGatewaySnapshotResponse shardOperationOnPrimary ( ShardOperationRequest shardRequest ) { IndexShardGatewayService shardGatewayService = indicesService . indexServiceSafe ( shardRequest . request . index ( ) ) . shardInjectorSafe ( shardRequest . shardId ) . getInstance ( IndexShardGatewayService . class ) ; <START_BUG> shardGatewayService . snapshot ( ) ; <END_BUG> return new ShardGatewaySnapshotResponse ( ) ; } @ Override protected void shardOperationOnBackup ( ShardOperationRequest shardRequest ) { } @ Override protected ShardsIterator shards ( ClusterState clusterState , ShardGatewaySnapshotRequest request ) { } @ Override protected boolean ignoreBackups ( ) { } }
public class GdxInvadersDesktop { public static void main ( String [ ] argv ) { LwjglApplicationConfiguration config = new LwjglApplicationConfiguration ( ) ; config . title = "Gdx<seq2seq4repair_space>Invaders" ; config . vSyncEnabled = true ; <START_BUG> config . useGL20 = true ; <END_BUG> new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new GdxInvaders ( ) , config ) ; } }
public class RefreshRequestBuilder extends BroadcastOperationRequestBuilder < RefreshRequest , RefreshResponse , RefreshRequestBuilder > { public RefreshRequestBuilder ( IndicesAdminClient indicesClient ) { } public RefreshRequestBuilder setWaitForOperations ( boolean waitForOperations ) { <START_BUG> request . waitForOperations ( waitForOperations ) ; <END_BUG> return this ; } @ Override protected void doExecute ( ActionListener < RefreshResponse > listener ) { } }
public class ScriptStatisticalFacetCollector extends AbstractFacetCollector { private final SearchScript script ; private double min = Double . NaN ; private double max = Double . NaN ; private double total = 0 ; private double sumOfSquares = 0.0 ; private long count ; public ScriptStatisticalFacetCollector ( String facetName , String scriptLang , String script , Map < String , Object > params , SearchContext context ) { } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override protected void doSetNextReader ( IndexReader reader , int docBase ) throws IOException { } @ Override public Facet facet ( ) { <START_BUG> return new InternalStatisticalFacet ( facetName , "_na" , min , max , total , sumOfSquares , count ) ; <END_BUG> } }
public class CountRequest extends BroadcastOperationRequest { public static final float DEFAULT_MIN_SCORE = - 1.0F ; private float minScore = CountRequest . DEFAULT_MIN_SCORE ; @ Required private byte [ ] querySource ; private String [ ] types = Strings . EMPTY_ARRAY ; @ Nullable private String queryParserName ; CountRequest ( ) { } public CountRequest ( String ... indices ) { } @ Override public CountRequest operationThreading ( BroadcastOperationThreading operationThreading ) { } @ Override public CountRequest listenerThreaded ( boolean threadedListener ) { } public CountRequest queryHint ( String queryHint ) { } float minScore ( ) { } public CountRequest minScore ( float minScore ) { } byte [ ] querySource ( ) { } @ Required public CountRequest querySource ( QueryBuilder queryBuilder ) { } @ Required public CountRequest querySource ( String querySource ) { } @ Required public CountRequest querySource ( byte [ ] querySource ) { } String queryParserName ( ) { } public CountRequest queryParserName ( String queryParserName ) { } String [ ] types ( ) { } public CountRequest types ( String ... types ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } @ Override public String toString ( ) { <START_BUG> return ( ( ( ( ( "[" + ( Arrays . toString ( indices ) ) ) + "][" ) + ( Arrays . toString ( types ) ) ) + "],<seq2seq4repair_space>querySource[" ) + ( Unicode . fromBytes ( querySource ) ) ) + "]" ; <END_BUG> } }
public class BoundingBox implements Serializable { private static final long serialVersionUID = - 1286036817192127343L ; final Vector3 [ ] crn = new Vector3 [ 8 ] ; public final Vector3 min = new Vector3 ( ) ; public final Vector3 max = new Vector3 ( ) ; final Vector3 cnt = new Vector3 ( ) ; final Vector3 dim = new Vector3 ( ) ; boolean crn_dirty = true ; public Vector3 getCenter ( ) { } protected void updateCorners ( ) { } public Vector3 [ ] getCorners ( ) { } public Vector3 getDimensions ( ) { } public Vector3 getMin ( ) { } public synchronized Vector3 getMax ( ) { } public BoundingBox ( ) { } public BoundingBox ( BoundingBox bounds ) { } public BoundingBox ( Vector3 minimum , Vector3 maximum ) { } public BoundingBox set ( BoundingBox bounds ) { } public BoundingBox set ( Vector3 minimum , Vector3 maximum ) { } public BoundingBox set ( Vector3 [ ] points ) { } public BoundingBox set ( List < Vector3 > points ) { } public BoundingBox inf ( ) { } public BoundingBox ext ( Vector3 point ) { } public BoundingBox clr ( ) { } public boolean isValid ( ) { <START_BUG> return ! ( ( ( ( min . x ) == ( max . x ) ) && ( ( min . y ) == ( max . y ) ) ) && ( ( min . z ) == ( max . z ) ) ) ; <END_BUG> } public BoundingBox ext ( BoundingBox a_bounds ) { } public BoundingBox mul ( Matrix4 matrix ) { } public boolean contains ( BoundingBox bounds ) { } public boolean contains ( Vector3 v ) { } public String toString ( ) { } public BoundingBox ext ( float x , float y , float z ) { } static float min ( float a , float b ) { } static float max ( float a , float b ) { } }
public final class ElasticsearchThreadFilter implements ThreadFilter { private final Pattern nodePrefix = Pattern . compile ( ( ( ( ( ( ( ( ( ( ( ( ( "\\[(" + "(" ) + ( Pattern . quote ( TRANSPORT_CLIENT_PREFIX ) ) ) + ")?(" ) + ( Pattern . quote ( GLOBAL_CLUSTER_NODE_PREFIX ) ) ) + "|" ) + ( Pattern . quote ( SUITE_CLUSTER_NODE_PREFIX ) ) ) + "|" ) + ( Pattern . quote ( TEST_CLUSTER_NODE_PREFIX ) ) ) + "|" ) + ( Pattern . quote ( SECOND_CLUSTER_NODE_PREFIX ) ) ) + ")" ) + ")\\d+\\]" ) ) ; @ Override public boolean reject ( Thread t ) { String threadName = t . getName ( ) ; if ( ( ( threadName . contains ( ( ( "[" + ( MulticastChannel . SHARED_CHANNEL_NAME ) ) + "]" ) ) ) || ( threadName . contains ( ( ( "[" + ( ElasticsearchSingleNodeTest . nodeName ( ) ) ) + "]" ) ) ) ) || ( threadName . contains ( "Keep-Alive-Timer" ) ) ) { return true ; } <START_BUG> return ( nodePrefix . matcher ( t . getName ( ) ) . find ( ) ) || true ; <END_BUG> } }
public class ConcreteBytesRefAtomicFieldData implements AtomicOrdinalFieldData < ScriptDocValues . Strings > { private final BytesRef [ ] values ; private final Ordinals ordinals ; private int [ ] hashes ; private long size = - 1 ; public ConcreteBytesRefAtomicFieldData ( BytesRef [ ] values , Ordinals ordinals ) { } @ Override public boolean isMultiValued ( ) { } @ Override public int getNumDocs ( ) { } @ Override public boolean isValuesOrdered ( ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override public OrdinalsBytesValues getBytesValues ( ) { } @ Override public OrdinalsHashedBytesValues getHashedBytesValues ( ) { } @ Override public OrdinalsStringValues getStringValues ( ) { } @ Override public Strings getScriptValues ( ) { } static abstract class BytesValues implements org . elasticsearch . index . fielddata . OrdinalsBytesValues { protected final BytesRef [ ] values ; protected final Docs ordinals ; BytesValues ( BytesRef [ ] values , Ordinals . Docs ordinals ) { } @ Override public Docs ordinals ( ) { } @ Override public BytesRef getValueByOrd ( int ord ) { } @ Override public BytesRef getValueScratchByOrd ( int ord , BytesRef ret ) { BytesRef value = values [ ord ] ; if ( value == null ) { ret . length = 0 ; } else { ret . bytes = value . bytes ; ret . offset = value . offset ; <START_BUG> ret . length = value . offset ; <END_BUG> } return ret ; } @ Override public BytesRef getSafeValueByOrd ( int ord ) { } @ Override public boolean hasValue ( int docId ) { } @ Override public BytesRef makeSafe ( BytesRef bytes ) { } @ Override public BytesRef getValue ( int docId ) { } @ Override public BytesRef getValueScratch ( int docId , BytesRef ret ) { } @ Override public BytesRef getValueSafe ( int docId ) { } @ Override public void forEachSafeValueInDoc ( int docId , ValueInDocProc proc ) { } static class Single extends ConcreteBytesRefAtomicFieldData . BytesValues { private final BytesRefArrayRef arrayScratch = new BytesRefArrayRef ( new BytesRef [ 1 ] , 1 ) ; private final Iter . Single iter = new Iter . Single ( ) ; Single ( BytesRef [ ] values , Ordinals . Docs ordinals ) { } @ Override public boolean isMultiValued ( ) { } @ Override public BytesRefArrayRef getValues ( int docId ) { } @ Override public Iter getIter ( int docId ) { } @ Override public Iter getIterSafe ( int docId ) { } @ Override public void forEachValueInDoc ( int docId , ValueInDocProc proc ) { } } static class Multi extends ConcreteBytesRefAtomicFieldData . BytesValues { private final BytesRefArrayRef arrayScratch = new BytesRefArrayRef ( new BytesRef [ 10 ] , 0 ) ; private final ConcreteBytesRefAtomicFieldData . BytesValues . Multi . ValuesIter iter ; Multi ( BytesRef [ ] values , Ordinals . Docs ordinals ) { } @ Override public boolean isMultiValued ( ) { } @ Override public BytesRefArrayRef getValues ( int docId ) { } @ Override public Iter getIter ( int docId ) { } @ Override public Iter getIterSafe ( int docId ) { } @ Override public void forEachValueInDoc ( int docId , ValueInDocProc proc ) { } static class ValuesIter implements Iter { private final BytesRef [ ] values ; private Ordinals . Docs . Iter ordsIter ; private int ord ; ValuesIter ( BytesRef [ ] values ) { } public ConcreteBytesRefAtomicFieldData . BytesValues . Multi . ValuesIter reset ( Ordinals . Docs . Iter ordsIter ) { } @ Override public boolean hasNext ( ) { } @ Override public BytesRef next ( ) { } } } } static abstract class HashedBytesValues implements org . elasticsearch . index . fielddata . OrdinalsHashedBytesValues { protected final BytesRef [ ] values ; protected final int [ ] hashes ; protected final Docs ordinals ; protected final HashedBytesRef scratch = new HashedBytesRef ( ) ; HashedBytesValues ( BytesRef [ ] values , int [ ] hashes , Ordinals . Docs ordinals ) { } @ Override public Docs ordinals ( ) { } @ Override public HashedBytesRef getValueByOrd ( int ord ) { } @ Override public HashedBytesRef getSafeValueByOrd ( int ord ) { } @ Override public boolean hasValue ( int docId ) { } @ Override public HashedBytesRef makeSafe ( HashedBytesRef bytes ) { } @ Override public HashedBytesRef getValue ( int docId ) { } @ Override public HashedBytesRef getValueSafe ( int docId ) { } static class Single extends ConcreteBytesRefAtomicFieldData . HashedBytesValues { private final Iter . Single iter = new Iter . Single ( ) ; Single ( BytesRef [ ] values , int [ ] hashes , Ordinals . Docs ordinals ) { } @ Override public boolean isMultiValued ( ) { } @ Override public Iter getIter ( int docId ) { } @ Override public Iter getIterSafe ( int docId ) { } @ Override public void forEachValueInDoc ( int docId , ValueInDocProc proc ) { } @ Override public void forEachSafeValueInDoc ( int docId , ValueInDocProc proc ) { } } static class Multi extends ConcreteBytesRefAtomicFieldData . HashedBytesValues { private final ConcreteBytesRefAtomicFieldData . HashedBytesValues . Multi . ValuesIter iter ; private final ConcreteBytesRefAtomicFieldData . HashedBytesValues . Multi . SafeValuesIter safeIter ; Multi ( BytesRef [ ] values , int [ ] hashes , Ordinals . Docs ordinals ) { } @ Override public boolean isMultiValued ( ) { } @ Override public Iter getIter ( int docId ) { } @ Override public Iter getIterSafe ( int docId ) { } @ Override public void forEachValueInDoc ( int docId , ValueInDocProc proc ) { } @ Override public void forEachSafeValueInDoc ( int docId , ValueInDocProc proc ) { } static class ValuesIter implements Iter { private final BytesRef [ ] values ; private final int [ ] hashes ; private Ordinals . Docs . Iter ordsIter ;
public class IOSApplication implements Application { @ Override public Graphics getGraphics ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Input getInput ( ) { } @ Override public Files getFiles ( ) { } @ Override public void log ( String tag , String message ) { <START_BUG> System . out . println ( ( ( tag + ":<seq2seq4repair_space>" ) + message ) ) ; <END_BUG> } @ Override public void log ( String tag , String message , Exception exception ) { } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } @ Override public Preferences getPreferences ( String name ) { } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void exit ( ) { } }
public class AuthenticatorActivity extends RoboSherlockAccountAuthenticatorActivity { public static final String PARAM_AUTHTOKEN_TYPE = "authtokenType" ; private static final String PARAM_CONFIRMCREDENTIALS = "confirmCredentials" ; private static final String PARAM_USERNAME = "username" ; private static final String TAG = "GHAuthenticatorActivity" ; private static void configureSyncFor ( Account account ) { } private AccountManager accountManager ; @ InjectView ( id . et_login ) private EditText usernameEdit ; @ InjectView ( id . et_password ) private EditText passwordEdit ; @ InjectView ( id . b_login ) private Button okButton ; @ Inject private BlankTextFieldWarner leavingBlankTextFieldWarner ; private TextWatcher watcher = validationTextWatcher ( ) ; private RoboAsyncTask < User > authenticationTask ; private String authToken ; private String authTokenType ; private Boolean confirmCredentials = false ; private String password ; protected boolean requestNewAccount = false ; private String username ; @ Override public void onCreate ( Bundle icicle ) { } private void setNonBlankValidationFor ( EditText editText ) { } private TextWatcher validationTextWatcher ( ) { } @ Override protected void onResume ( ) { } private void updateUIWithValidation ( ) { } private boolean populated ( EditText editText ) { } @ Override protected Dialog onCreateDialog ( int id ) { <START_BUG> final ProgressDialog dialog = new com . github . mobile . ui . LightProgressDialog ( this , getText ( login_activity_authenticating ) ) ; <END_BUG> dialog . setCancelable ( true ) ; dialog . setOnCancelListener ( new OnCancelListener ( ) { @ Override public void onCancel ( DialogInterface dialog ) { if ( ( authenticationTask ) != null ) authenticationTask . cancel ( true ) ; } } ) ; return dialog ; } public void handleLogin ( View view ) { } protected void finishConfirmCredentials ( boolean result ) { } protected void finishLogin ( ) { } @ SuppressWarnings ( "deprecation" ) private void hideProgress ( ) { } @ SuppressWarnings ( "deprecation" ) private void showProgress ( ) { } public void onAuthenticationResult ( boolean result ) { } }
public class Cell < T extends Actor > implements Poolable { Value minWidth ; Value minHeight ; Value prefWidth ; Value prefHeight ; Value maxWidth ; Value maxHeight ; Value spaceTop ; Value spaceLeft ; Value spaceBottom ; Value spaceRight ; Value padTop ; Value padLeft ; Value padBottom ; Value padRight ; Float fillX ; Float fillY ; Integer align ; Integer expandX ; Integer expandY ; Integer colspan ; Boolean uniformX ; Boolean uniformY ; Actor actor ; float actorX ; float actorY ; float actorWidth ; float actorHeight ; private Table table ; boolean endRow ; int column ; int row ; int cellAboveIndex = - 1 ; float computedPadTop ; float computedPadLeft ; float computedPadBottom ; float computedPadRight ; public void setLayout ( Table table ) { } void set ( Cell defaults ) { } void merge ( Cell cell ) { } public < A extends Actor > Cell < A > setActor ( A newActor ) { } public T getActor ( ) { } public boolean hasActor ( ) { } public Cell < T > size ( Value size ) { } public Cell < T > size ( Value width , Value height ) { } public Cell < T > size ( float size ) { } public Cell < T > size ( float width , float height ) { } public Cell < T > width ( Value width ) { } public Cell < T > width ( float width ) { } public Cell < T > height ( Value height ) { } public Cell < T > height ( float height ) { } public Cell < T > minSize ( Value size ) { } public Cell < T > minSize ( Value width , Value height ) { } public Cell < T > minWidth ( Value minWidth ) { } public Cell < T > minHeight ( Value minHeight ) { } public Cell < T > minSize ( float size ) { } public Cell < T > minSize ( float width , float height ) { } public Cell < T > minWidth ( float minWidth ) { } public Cell < T > minHeight ( float minHeight ) { } public Cell < T > prefSize ( Value size ) { } public Cell < T > prefSize ( Value width , Value height ) { } public Cell < T > prefWidth ( Value prefWidth ) { } public Cell < T > prefHeight ( Value prefHeight ) { } public Cell < T > prefSize ( float width , float height ) { <START_BUG> prefSize ( new Fixed ( width ) ) ; <END_BUG> return this ; } public Cell < T > prefSize ( float size ) { } public Cell < T > prefWidth ( float prefWidth ) { } public Cell < T > prefHeight ( float prefHeight ) { } public Cell < T > maxSize ( Value size ) { } public Cell < T > maxSize ( Value width , Value height ) { } public Cell < T > maxWidth ( Value maxWidth ) { } public Cell < T > maxHeight ( Value maxHeight ) { } public Cell < T > maxSize ( float size ) { } public Cell < T > maxSize ( float width , float height ) { } public Cell < T > maxWidth ( float maxWidth ) { } public Cell < T > maxHeight ( float maxHeight ) { } public Cell < T > space ( Value space ) { } public Cell < T > space ( Value top , Value left , Value bottom , Value right ) { } public Cell < T > spaceTop ( Value spaceTop ) { } public Cell < T > spaceLeft ( Value spaceLeft ) { } public Cell < T > spaceBottom ( Value spaceBottom ) { } public Cell < T > spaceRight ( Value spaceRight ) { } public Cell < T > space ( float space ) { } public Cell < T > space ( float top , float left , float bottom , float right ) { } public Cell < T > spaceTop ( float spaceTop ) { } public Cell < T > spaceLeft ( float spaceLeft ) { } public Cell < T > spaceBottom ( float spaceBottom ) { } public Cell < T > spaceRight ( float spaceRight ) { } public Cell < T > pad ( Value pad ) { } public Cell < T > pad ( Value top , Value left , Value bottom , Value right ) { } public Cell < T > padTop ( Value padTop ) { } public Cell < T > padLeft ( Value padLeft ) { } public Cell < T > padBottom ( Value padBottom ) { } public Cell < T > padRight ( Value padRight ) { } public Cell < T > pad ( float pad ) { } public Cell < T > pad ( float top , float left , float bottom , float right ) { } public Cell < T > padTop ( float padTop ) { } public Cell < T > padLeft ( float padLeft ) { } public Cell < T > padBottom ( float padBottom ) { } public Cell < T > padRight ( float padRight ) { } public Cell < T > fill ( ) { } public Cell < T > fillX ( ) { } public Cell < T > fillY ( ) { } public Cell < T > fill ( Float x , Float y ) { } public Cell < T > fill ( boolean x , boolean y ) { } public Cell < T > fill ( boolean fill ) { }
public class JoglDebugStarter { public static void main ( String [ ] argv ) { <START_BUG> new com . badlogic . gdx . backends . jogl . JoglApplication ( new com . badlogic . gdx . tests . EdgeDetectionTest ( ) , "Debug<seq2seq4repair_space>Test" , 480 , 320 , true ) ; <END_BUG> } }
public class GistsFragment extends ListLoadingFragment < Gist > implements Comparator < Gist > { private OnItemClickListener clickListener ; @ Inject private GistService service ; public GistsFragment setClickListener ( OnItemClickListener clickListener ) { } public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public Loader < List < Gist > > onCreateLoader ( int i , Bundle bundle ) { } @ Override protected ViewHoldingListAdapter < Gist > adapterFor ( List < Gist > items ) { <START_BUG> return new ViewHoldingListAdapter < Gist > ( items , viewInflatorFor ( getActivity ( ) , gist_list_item ) , reflectiveFactoryFor ( GistViewHolder . class ) ) ; <END_BUG> } @ Override public int compare ( final Gist g1 , final Gist g2 ) { } }
public interface ScoreFunction { void setNextReader ( AtomicReaderContext context ) { } <START_BUG> float score ( int docId , float subQueryScore ) ; <END_BUG> double factor ( int docId ) { } Explanation explainScore ( int docId , Explanation subQueryExpl ) { } Explanation explainFactor ( int docId ) { } }
public abstract class GistsFragment extends PagedItemFragment < Gist > { @ Inject protected AvatarLoader avatars ; @ Inject protected GistService service ; @ Inject protected GistStore store ; @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } @ Override protected int getErrorMessage ( Exception exception ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected SingleTypeAdapter < Gist > createAdapter ( List < Gist > items ) { <START_BUG> return new GistListAdapter ( avatars , getActivity ( ) . getLayoutInflater ( ) , items . toArray ( new Gist [ items . size ( ) ] ) ) ; <END_BUG> } }
public class btOverlapCallback extends BulletBase { private long swigCPtr ; protected btOverlapCallback ( final String className , long cPtr , boolean cMemoryOwn ) { } public btOverlapCallback ( long cPtr , boolean cMemoryOwn ) { } @ Override protected void reset ( long cPtr , boolean cMemoryOwn ) { } public static long getCPtr ( btOverlapCallback obj ) { } @ Override protected void finalize ( ) throws Throwable { } @ Override protected synchronized void delete ( ) { } protected void swigDirectorDisconnect ( ) { } public void swigReleaseOwnership ( ) { } public void swigTakeOwnership ( ) { } public boolean processOverlap ( btBroadphasePair pair ) { <START_BUG> return CollisionJNI . btOverlapCallback_processOverlap ( swigCPtr , this , pair ) ; <END_BUG> } public btOverlapCallback ( ) { } }
public class NettyTransportChannel implements TransportChannel { private static final byte [ ] LENGTH_PLACEHOLDER = new byte [ 4 ] ; private final NettyTransport transport ; private final String action ; private final Channel channel ; private final long requestId ; public NettyTransportChannel ( NettyTransport transport , String action , Channel channel , long requestId ) { } @ Override public String action ( ) { } @ Override public void sendResponse ( Streamable message ) throws IOException { } @ Override public void sendResponse ( Streamable message , TransportResponseOptions options ) throws IOException { if ( transport . compress ) { <START_BUG> options . withCompress ( ) ; <END_BUG> } byte [ ] data = TransportStreams . buildResponse ( requestId , message , options ) ; ChannelBuffer buffer = ChannelBuffers . wrappedBuffer ( data ) ; channel . write ( buffer ) ; } @ Override public void sendResponse ( Throwable error ) throws IOException { } private void writeResponseExceptionHeader ( BytesStreamOutput stream ) throws IOException { } }
public class RestIndicesSegmentsAction extends BaseRestHandler { @ Inject public RestIndicesSegmentsAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { IndicesSegmentsRequest indicesSegmentsRequest = new IndicesSegmentsRequest ( splitIndices ( request . param ( "index" ) ) ) ; indicesSegmentsRequest . listenerThreaded ( false ) ; if ( request . hasParam ( "ignore_indices" ) ) { indicesSegmentsRequest . ignoreIndices ( IgnoreIndices . fromString ( request . param ( "ignore_indices" ) ) ) ; } BroadcastOperationThreading operationThreading = BroadcastOperationThreading . fromString ( request . param ( "operation_threading" ) , SINGLE_THREAD ) ; if ( operationThreading == ( BroadcastOperationThreading . NO_THREADS ) ) { operationThreading = BroadcastOperationThreading . SINGLE_THREAD ; } indicesSegmentsRequest . operationThreading ( operationThreading ) ; client . admin ( ) . indices ( ) . segments ( indicesSegmentsRequest , new org . elasticsearch . action . ActionListener < IndicesSegmentResponse > ( ) { @ Override public void onResponse ( IndicesSegmentResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; builder . field ( "ok" , true ) ; buildBroadcastShardsHeader ( builder , response ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
@ ClusterScope ( scope = Scope . SUITE , numDataNodes = 1 ) public class CustomSuggesterSearchTests extends ElasticsearchIntegrationTest { @ Override protected Settings nodeSettings ( int nodeOrdinal ) { <START_BUG> return ImmutableSettings . settingsBuilder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( "plugin.types" , CustomSuggesterPlugin . class . getName ( ) ) . build ( ) ; <END_BUG> } @ Test public void testThatCustomSuggestersCanBeRegisteredAndWork ( ) throws Exception { } }
public class GetAliasesRequestBuilder extends BaseAliasesRequestBuilder < GetAliasesResponse , GetAliasesRequestBuilder > { public GetAliasesRequestBuilder ( IndicesAdminClient client , String ... aliases ) { } @ Override protected void doExecute ( ActionListener < GetAliasesResponse > listener ) { <START_BUG> ( ( IndicesAdminClient ) ( client ) ) . getAliases ( request , listener ) ; <END_BUG> } }
public class SharedLibraryLoader { public static boolean isWindows = System . getProperty ( "os.name" ) . contains ( "Windows" ) ; public static boolean isLinux = System . getProperty ( "os.name" ) . contains ( "Linux" ) ; public static boolean isMac = System . getProperty ( "os.name" ) . contains ( "Mac" ) ; public static boolean isIos = false ; public static boolean isAndroid = false ; public static boolean isARM = System . getProperty ( "os.arch" ) . startsWith ( "arm" ) ; public static boolean is64Bit = System . getProperty ( "os.arch" ) . equals ( "amd64" ) ; public static String abi = ( ( System . getProperty ( "sun.arch.abi" ) ) != null ) ? System . getProperty ( "sun.arch.abi" ) : "" ; private static final HashSet < String > loadedLibraries = new HashSet ( ) ; private String nativesJar ; public SharedLibraryLoader ( ) { } public SharedLibraryLoader ( String nativesJar ) { } public String crc ( InputStream input ) { } public String mapLibraryName ( String libraryName ) { } public synchronized void load ( String libraryName ) { } private InputStream readFile ( String path ) { } public File extractFile ( String sourcePath , String dirName ) throws IOException { } private File getExtractedFile ( String dirName , String fileName ) { } private boolean canWrite ( File file ) { <START_BUG> if ( ( file . canWrite ( ) ) && ( file . canExecute ( ) ) ) <END_BUG> return true ; File parent = file . getParentFile ( ) ; parent . mkdirs ( ) ; if ( ! ( parent . isDirectory ( ) ) ) return false ; try { new FileOutputStream ( file ) . close ( ) ; file . delete ( ) ; return true ; } catch ( Throwable ex ) { return false ; } } private File extractFile ( String sourcePath , String sourceCrc , File extractedFile ) throws IOException { } private void loadFile ( String sourcePath ) { } private Throwable loadFile ( String sourcePath , String sourceCrc , File extractedFile ) { } }
public class RenderedCommentFragment extends DialogFragment implements LoaderCallbacks < CharSequence > { private static final String ARG_TEXT = "text" ; private static final String ARG_REPO = "repo" ; private ProgressBar progress ; private TextView bodyText ; @ Inject private HttpImageGetter imageGetter ; @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { } public void setText ( final String raw , final IRepositoryIdProvider repo ) { } private void showLoading ( final boolean loading ) { } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } @ Override public Loader < CharSequence > onCreateLoader ( int loader , Bundle args ) { final CharSequence raw = args . getCharSequence ( RenderedCommentFragment . ARG_TEXT ) ; final IRepositoryIdProvider repo = ( ( IRepositoryIdProvider ) ( args . getSerializable ( RenderedCommentFragment . ARG_REPO ) ) ) ; <START_BUG> return new com . github . mobile . ui . MarkdownLoader ( getActivity ( ) , repo , raw . toString ( ) , imageGetter ) ; <END_BUG> } @ Override public void onLoadFinished ( Loader < CharSequence > loader , CharSequence rendered ) { } @ Override public void onLoaderReset ( Loader < CharSequence > loader ) { } }
public class RestIndicesStatusAction extends BaseRestHandler { private final SettingsFilter settingsFilter ; @ Inject public RestIndicesStatusAction ( Settings settings , Client client , RestController controller , SettingsFilter settingsFilter ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { IndicesStatusRequest indicesStatusRequest = new IndicesStatusRequest ( splitIndices ( request . param ( "index" ) ) ) ; indicesStatusRequest . listenerThreaded ( false ) ; if ( request . hasParam ( "ignore_indices" ) ) { indicesStatusRequest . ignoreIndices ( IgnoreIndices . fromString ( request . param ( "ignore_indices" ) ) ) ; } indicesStatusRequest . recovery ( request . paramAsBoolean ( "recovery" , indicesStatusRequest . recovery ( ) ) ) ; indicesStatusRequest . snapshot ( request . paramAsBoolean ( "snapshot" , indicesStatusRequest . snapshot ( ) ) ) ; BroadcastOperationThreading operationThreading = BroadcastOperationThreading . fromString ( request . param ( "operation_threading" ) , SINGLE_THREAD ) ; if ( operationThreading == ( BroadcastOperationThreading . NO_THREADS ) ) { operationThreading = BroadcastOperationThreading . SINGLE_THREAD ; } indicesStatusRequest . operationThreading ( operationThreading ) ; client . admin ( ) . indices ( ) . status ( indicesStatusRequest , new org . elasticsearch . action . ActionListener < IndicesStatusResponse > ( ) { @ Override public void onResponse ( IndicesStatusResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; builder . field ( "ok" , true ) ; buildBroadcastShardsHeader ( builder , response ) ; response . toXContent ( builder , request , settingsFilter ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class Store extends AbstractIndexShardComponent { class ApplySettings implements IndexSettingsService . Listener { @ Override public void onRefreshSettings ( Settings settings ) { } } static final String CHECKSUMS_PREFIX = "_checksums-" ; public static final boolean isChecksum ( String name ) { } private final IndexStore indexStore ; private final IndexSettingsService indexSettingsService ; private final DirectoryService directoryService ; private final Store . StoreDirectory directory ; private volatile ImmutableMap < String , StoreFileMetaData > filesMetadata = ImmutableMap . of ( ) ; private volatile String [ ] files = Strings . EMPTY_ARRAY ; private final Object mutex = new Object ( ) ; private final boolean sync ; private volatile boolean compressedStoredFields ; private final Store . ApplySettings applySettings = new Store . ApplySettings ( ) ; @ Inject public Store ( ShardId shardId , @ IndexSettings Settings indexSettings , IndexStore indexStore , IndexSettingsService indexSettingsService , DirectoryService directoryService ) throws IOException { } public Directory directory ( ) { } public ImmutableMap < String , StoreFileMetaData > list ( ) throws IOException { } public StoreFileMetaData metaData ( String name ) throws IOException { } public void deleteContent ( ) throws IOException { } public void fullDelete ( ) throws IOException { } public StoreStats stats ( ) throws IOException { <START_BUG> return new StoreStats ( Directories . estimateSize ( directory ) ) ; <END_BUG> } public ByteSizeValue estimateSize ( ) throws IOException { } public void renameFile ( String from , String to ) throws IOException { } public static Map < String , String > readChecksums ( File [ ] locations ) throws IOException { } static Map < String , String > readChecksums ( Directory [ ] dirs , Map < String , String > defaultValue ) throws IOException { } public void writeChecksums ( ) throws IOException { } public boolean suggestUseCompoundFile ( ) { } public void close ( ) throws IOException { } public IndexOutput createOutputRaw ( String name ) throws IOException { } public IndexInput openInputRaw ( String name ) throws IOException { } public void writeChecksum ( String name , String checksum ) throws IOException { } public void writeChecksums ( Map < String , String > checksums ) throws IOException { } class StoreDirectory extends Directory implements ForceSyncDirectory { private final Directory [ ] delegates ; StoreDirectory ( Directory [ ] delegates ) throws IOException { } public Directory [ ] delegates ( ) { } @ Override public String [ ] listAll ( ) throws IOException { } @ Override public boolean fileExists ( String name ) throws IOException { } @ Override public long fileModified ( String name ) throws IOException { } @ Override public void touchFile ( String name ) throws IOException { } public void deleteFileChecksum ( String name ) throws IOException { } @ Override public void deleteFile ( String name ) throws IOException { } @ Override public long fileLength ( String name ) throws IOException { } @ Override public IndexOutput createOutput ( String name ) throws IOException { } public IndexOutput createOutput ( String name , boolean raw ) throws IOException { } @ Override public IndexInput openInput ( String name ) throws IOException { } @ Override public IndexInput openInput ( String name , int bufferSize ) throws IOException { } @ Override public void close ( ) throws IOException { } @ Override public Lock makeLock ( String name ) { } @ Override public void clearLock ( String name ) throws IOException { } @ Override public void setLockFactory ( LockFactory lockFactory ) throws IOException { } @ Override public LockFactory getLockFactory ( ) { } @ Override public String getLockID ( ) { } @ Override public void sync ( Collection < String > names ) throws IOException { } @ Override public void sync ( String name ) throws IOException { } @ Override public void forceSync ( String name ) throws IOException { } } class StoreIndexOutput extends IndexOutput { private final StoreFileMetaData metaData ; private final IndexOutput out ; private final String name ; StoreIndexOutput ( StoreFileMetaData metaData , IndexOutput delegate , String name ) { } @ Override public void close ( ) throws IOException { } @ Override public void copyBytes ( DataInput input , long numBytes ) throws IOException { } @ Override public long getFilePointer ( ) { } @ Override public void writeByte ( byte b ) throws IOException { } @ Override public void writeBytes ( byte [ ] b , int offset , int length ) throws IOException { } @ Override public void flush ( ) throws IOException { } @ Override public void seek ( long pos ) throws IOException { } @ Override public long length ( ) throws IOException { } @ Override public void setLength ( long length ) throws IOException { } @ Override public String toString ( ) { } } }
public class SoftBodyTest extends BaseBulletTest { btSoftBodyWorldInfo worldInfo ; btSoftBody softBody ; Texture texture ; Mesh mesh ; Model model ; ModelInstance instance ; Matrix4 tmpM = new Matrix4 ( ) ; @ Override public BulletWorld createWorld ( ) { } @ Override public void create ( ) { } @ Override public void dispose ( ) { } @ Override protected void renderWorld ( ) { softBody . getVertices ( mesh . getVerticesBuffer ( ) , softBody . getNodeCount ( ) , mesh . getVertexSize ( ) , 0 ) ; softBody . getWorldTransform ( instance . transform ) ; modelBatch . begin ( camera ) ; world . render ( modelBatch , lights ) ; <START_BUG> modelBatch . render ( lights , instance ) ; <END_BUG> modelBatch . end ( ) ; } @ Override public boolean tap ( float x , float y , int count , int button ) { } }
public class IssueDashboardActivity extends RoboFragmentActivity { @ InjectView ( id . tpi_header ) private TitlePageIndicator indicator ; @ InjectView ( id . vp_pages ) private ViewPager pager ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( issue_dashboard ) ; <START_BUG> setTitle ( getString ( dashboard_issues_title ) ) ; <END_BUG> pager . setAdapter ( new IssueDashboardPagerAdapter ( getApplicationContext ( ) , getSupportFragmentManager ( ) ) ) ; indicator . setViewPager ( pager ) ; } }
public class FloatAttribute extends Attribute { public static final String ShininessAlias = "shininess" ; public static final long Shininess = register ( FloatAttribute . ShininessAlias ) ; public static FloatAttribute createShininess ( float value ) { } public static final String AlphaTestAlias = "alphaTest" ; public static final long AlphaTest = register ( FloatAttribute . AlphaTestAlias ) ; public static FloatAttribute createAlphaTest ( float value ) { } public float value ; public FloatAttribute ( long type ) { } public FloatAttribute ( long type , float value ) { } @ Override public Attribute copy ( ) { } @ Override public int hashCode ( ) { <START_BUG> int result = super . hashCode ( ) ; <END_BUG> result = ( 977 * result ) + ( NumberUtils . floatToRawIntBits ( value ) ) ; return result ; } }
public class TransportShardDeleteByQueryAction extends TransportShardReplicationOperationAction < ShardDeleteByQueryRequest , ShardDeleteByQueryResponse > { @ Inject public TransportShardDeleteByQueryAction ( Settings settings , TransportService transportService , ClusterService clusterService , IndicesService indicesService , ThreadPool threadPool , ShardStateAction shardStateAction ) { } @ Override protected boolean checkWriteConsistency ( ) { } @ Override protected ShardDeleteByQueryRequest newRequestInstance ( ) { } @ Override protected ShardDeleteByQueryResponse newResponseInstance ( ) { } @ Override protected String transportAction ( ) { } @ Override protected void checkBlock ( ShardDeleteByQueryRequest request , ClusterState state ) { } @ Override protected ShardDeleteByQueryResponse shardOperationOnPrimary ( ShardOperationRequest shardRequest ) { } @ Override protected void shardOperationOnReplica ( ShardOperationRequest shardRequest ) { } @ Override protected ShardsIterator shards ( ClusterState clusterState , ShardDeleteByQueryRequest request ) { <START_BUG> GroupShardsIterator group = clusterService . operationRouting ( ) . deleteByQueryShards ( clusterService . state ( ) , request . index ( ) ) ; <END_BUG> for ( ShardsIterator shards : group ) { if ( ( shards . shardId ( ) . id ( ) ) == ( request . shardId ( ) ) ) { return shards ; } } throw new org . elasticsearch . ElasticSearchIllegalStateException ( ( ( "No<seq2seq4repair_space>shards<seq2seq4repair_space>iterator<seq2seq4repair_space>found<seq2seq4repair_space>for<seq2seq4repair_space>shard<seq2seq4repair_space>[" + ( request . shardId ( ) ) ) + "]" ) ) ; } }
public class BitmapFontCache { private final BitmapFont font ; private float [ ] vertices ; private int idx ; int width ; int height ; private float x ; private float y ; private float color ; public BitmapFontCache ( BitmapFont font ) { } public void setPosition ( float x , float y ) { } public void translate ( float xAmount , float yAmount ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public void draw ( SpriteBatch spriteBatch ) { <START_BUG> spriteBatch . draw ( font . texture , vertices , 0 , idx ) ; <END_BUG> } void reset ( int glyphCount ) { } private int addToCache ( CharSequence str , int x , int y , float color , int start , int end ) { } void addGlyph ( Glyph glyph , float x , float y , float color ) { } public void setText ( CharSequence str , int x , int y , Color tint ) { } public void setText ( CharSequence str , int x , int y , Color tint , int start , int end ) { } public void setMultiLineText ( CharSequence str , int x , int y , Color tint ) { } public void setMultiLineText ( CharSequence str , int x , int y , Color tint , int alignmentWidth , HAlignment alignment ) { } public void setWrappedText ( CharSequence str , int x , int y , Color tint , int wrapWidth ) { } public void setWrappedText ( CharSequence str , int x , int y , Color tint , int wrapWidth , HAlignment alignment ) { } public int getWidth ( ) { } public int getHeight ( ) { } public float getX ( ) { } public float getY ( ) { } }
public interface ShardIterator extends ShardsIterator { ShardId shardId ( ) { } <START_BUG> ShardIterator reset ( ) ; <END_BUG> }
public class ShortArray { public short [ ] items ; public int size ; public boolean ordered ; public ShortArray ( ) { } public ShortArray ( int capacity ) { } public ShortArray ( boolean ordered , int capacity ) { } public ShortArray ( ShortArray array ) { } public ShortArray ( short [ ] array ) { } public ShortArray ( boolean ordered , short [ ] array , int startIndex , int count ) { } public void add ( short value ) { } public void addAll ( ShortArray array ) { } public void addAll ( ShortArray array , int offset , int length ) { } public void addAll ( short [ ] array ) { } public void addAll ( short [ ] array , int offset , int length ) { short [ ] items = this . items ; <START_BUG> int sizeNeeded = ( size ) + length ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public short get ( int index ) { } public void set ( int index , short value ) { } public void insert ( int index , short value ) { } public void swap ( int first , int second ) { } public boolean contains ( short value ) { } public int indexOf ( short value ) { } public int lastIndexOf ( char value ) { } public boolean removeValue ( short value ) { } public short removeIndex ( int index ) { } public boolean removeAll ( ShortArray array ) { } public short pop ( ) { } public short peek ( ) { } public short first ( ) { } public void clear ( ) { } public void shrink ( ) { } public short [ ] ensureCapacity ( int additionalCapacity ) { } protected short [ ] resize ( int newSize ) { } public void sort ( ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public short random ( ) { } public short [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class IntIntMap { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; private static final int EMPTY = 0 ; public int size ; int [ ] keyTable ; int [ ] valueTable ; int capacity ; int stashSize ; int zeroValue ; boolean hasZeroValue ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private IntIntMap . Entries entries1 ; private IntIntMap . Entries entries2 ; private IntIntMap . Values values1 ; private IntIntMap . Values values2 ; private IntIntMap . Keys keys1 ; private IntIntMap . Keys keys2 ; public IntIntMap ( ) { } public IntIntMap ( int initialCapacity ) { } public IntIntMap ( int initialCapacity , float loadFactor ) { } public IntIntMap ( IntIntMap map ) { } public void put ( int key , int value ) { } public void putAll ( IntIntMap map ) { } private void putResize ( int key , int value ) { } private void push ( int insertKey , int insertValue , int index1 , int key1 , int index2 , int key2 , int index3 , int key3 ) { } private void putStash ( int key , int value ) { } public int get ( int key , int defaultValue ) { } private int getStash ( int key , int defaultValue ) { } public int getAndIncrement ( int key , int defaultValue , int increment ) { } private int getAndIncrementStash ( int key , int defaultValue , int increment ) { } public int remove ( int key , int defaultValue ) { } int removeStash ( int key , int defaultValue ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean containsValue ( int value ) { } public boolean containsKey ( int key ) { } private boolean containsKeyStash ( int key ) { } public int findKey ( int value , int notFound ) { } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public IntIntMap . Entries entries ( ) { } public IntIntMap . Values values ( ) { } public IntIntMap . Keys keys ( ) { } public static class Entry < K > { public int key ; public int value ; public String toString ( ) { } } private static class MapIterator < K > { static final int INDEX_ILLEGAL = - 2 ; static final int INDEX_ZERO = - 1 ; public boolean hasNext ; final IntIntMap map ; int nextIndex ; int currentIndex ; boolean valid = true ; public MapIterator ( IntIntMap map ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { if ( ( ( currentIndex ) == ( IntIntMap . MapIterator . INDEX_ZERO ) ) && ( map . hasZeroValue ) ) { map . hasZeroValue = false ; } else if ( ( currentIndex ) < 0 ) { throw new IllegalStateException ( "next<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>called<seq2seq4repair_space>before<seq2seq4repair_space>remove." ) ; } else if ( ( currentIndex ) >= ( map . capacity ) ) { map . removeStashIndex ( currentIndex ) ; <START_BUG> nextIndex = ( currentIndex ) - 1 ; <END_BUG> findNextIndex ( ) ; } else { map . keyTable [ currentIndex ] = IntIntMap . EMPTY ; } currentIndex = IntIntMap . MapIterator . INDEX_ILLEGAL ; ( map . size ) -- ; } } public static class Entries extends IntIntMap . MapIterator implements Iterable < IntIntMap . Entry > , Iterator < IntIntMap . Entry > { private IntIntMap . Entry entry = new IntIntMap . Entry ( ) ; public Entries ( IntIntMap map ) { } public IntIntMap . Entry next ( ) { } public boolean hasNext ( ) { } public Iterator < IntIntMap . Entry > iterator ( ) { } } public static class Values extends IntIntMap . MapIterator < Object > { public Values ( IntIntMap map ) { } public boolean hasNext ( ) { } public int next ( ) { } public IntArray toArray ( ) { } } public static class Keys extends IntIntMap . MapIterator { public Keys ( IntIntMap map ) { } public boolean hasNext ( ) { } public int next ( ) { } public IntArray toArray ( ) { } } }
public class TransportCountAction extends TransportBroadcastOperationAction < CountRequest , CountResponse , ShardCountRequest , ShardCountResponse > { private final IndicesService indicesService ; @ Inject public TransportCountAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected CountRequest newRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ShardRouting shard , CountRequest request ) { } @ Override protected ShardCountResponse newShardResponse ( ) { } @ Override protected GroupShardsIterator shards ( CountRequest request , ClusterState clusterState ) { <START_BUG> return clusterService . operationRouting ( ) . searchShards ( clusterState , request . indices ( ) , request . queryHint ( ) , request . routing ( ) ) ; <END_BUG> } @ Override protected void checkBlock ( CountRequest request , ClusterState state ) { } @ Override protected CountResponse newResponse ( CountRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardCountResponse shardOperation ( ShardCountRequest request ) throws ElasticSearchException { } }
public abstract class AbstractConcurrentMapFieldDataCache extends AbstractIndexComponent implements FieldDataCache { private final ConcurrentMap < Object , ConcurrentMap < String , FieldData > > cache ; private final Object creationMutex = new Object ( ) ; protected AbstractConcurrentMapFieldDataCache ( Index index , @ IndexSettings Settings indexSettings ) { } @ Override public void close ( ) throws ElasticSearchException { <START_BUG> cache . clear ( ) ; <END_BUG> } @ Override public void clear ( ) { } @ Override public void clear ( IndexReader reader ) { } @ Override public void clearUnreferenced ( ) { } @ Override public FieldData cache ( FieldDataType type , IndexReader reader , String fieldName ) throws IOException { } protected ConcurrentMap < String , FieldData > buildFieldDataMap ( ) { } }
public class IntArray { public int [ ] items ; public int size ; public boolean ordered ; public IntArray ( ) { } public IntArray ( int capacity ) { } public IntArray ( boolean ordered , int capacity ) { } public IntArray ( IntArray array ) { } public IntArray ( int [ ] array ) { } public IntArray ( boolean ordered , int [ ] array , int startIndex , int count ) { } public void add ( int value ) { } public void addAll ( IntArray array ) { } public void addAll ( IntArray array , int offset , int length ) { } public void addAll ( int [ ] array ) { } public void addAll ( int [ ] array , int offset , int length ) { int [ ] items = this . items ; <START_BUG> int sizeNeeded = ( ( size ) + length ) - offset ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public int get ( int index ) { } public void set ( int index , int value ) { } public void insert ( int index , int value ) { } public void swap ( int first , int second ) { } public boolean contains ( int value ) { } public int indexOf ( int value ) { } public int lastIndexOf ( int value ) { } public boolean removeValue ( int value ) { } public int removeIndex ( int index ) { } public boolean removeAll ( IntArray array ) { } public int pop ( ) { } public int peek ( ) { } public int first ( ) { } public void clear ( ) { } public void shrink ( ) { } public int [ ] ensureCapacity ( int additionalCapacity ) { } protected int [ ] resize ( int newSize ) { } public void sort ( ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public int random ( ) { } public int [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class SharedLibraryLoader { public static boolean isWindows = System . getProperty ( "os.name" ) . contains ( "Windows" ) ; public static boolean isLinux = System . getProperty ( "os.name" ) . contains ( "Linux" ) ; public static boolean isMac = System . getProperty ( "os.name" ) . contains ( "Mac" ) ; public static boolean isIos = false ; public static boolean isAndroid = false ; public static boolean isARM = System . getProperty ( "os.arch" ) . startsWith ( "arm" ) ; public static boolean is64Bit = System . getProperty ( "os.arch" ) . equals ( "amd64" ) ; public static String abi = ( ( System . getProperty ( "sun.arch.abi" ) ) != null ) ? System . getProperty ( "sun.arch.abi" ) : "" ; private static final HashSet < String > loadedLibraries = new HashSet ( ) ; private String nativesJar ; public SharedLibraryLoader ( ) { } public SharedLibraryLoader ( String nativesJar ) { } public String crc ( InputStream input ) { } public String mapLibraryName ( String libraryName ) { } public synchronized void load ( String libraryName ) { } private InputStream readFile ( String path ) { } public File extractFile ( String sourcePath , String dirName ) throws IOException { } private File getExtractedFile ( String dirName , String fileName ) { } private boolean canWrite ( File file ) { <START_BUG> if ( file . canWrite ( ) ) <END_BUG> return true ; File parent = file . getParentFile ( ) ; parent . mkdirs ( ) ; if ( ! ( parent . isDirectory ( ) ) ) return false ; try { new FileOutputStream ( file ) . close ( ) ; file . delete ( ) ; return true ; } catch ( Throwable ex ) { return false ; } } private File extractFile ( String sourcePath , String sourceCrc , File extractedFile ) throws IOException { } private void loadFile ( String sourcePath ) { } private Throwable loadFile ( String sourcePath , String sourceCrc , File extractedFile ) { } }
final String transportAction ; final String transportReplicaAction ; final String executor ; final boolean checkWriteConsistency ; protected TransportShardReplicationOperationAction ( Settings settings , TransportService transportService , ClusterService clusterService , IndicesService indicesService , ThreadPool threadPool , ShardStateAction shardStateAction ) { } @ Override protected void doExecute ( Request request , ActionListener < Response > listener ) { } protected abstract Request newRequestInstance ( ) { } protected abstract ReplicaRequest newReplicaRequestInstance ( ) { } protected abstract Response newResponseInstance ( ) { } protected abstract String transportAction ( ) { } protected abstract String executor ( ) { } protected abstract TransportShardReplicationOperationAction . PrimaryResponse < Response , ReplicaRequest > shardOperationOnPrimary ( ClusterState clusterState , TransportShardReplicationOperationAction < Request , ReplicaRequest , Response > . PrimaryOperationRequest shardRequest ) { } protected abstract void shardOperationOnReplica ( TransportShardReplicationOperationAction < Request , ReplicaRequest , Response > . ReplicaOperationRequest shardRequest ) { } protected void postPrimaryOperation ( Request request , TransportShardReplicationOperationAction . PrimaryResponse < Response , ReplicaRequest > response ) { } protected abstract ShardIterator shards ( ClusterState clusterState , Request request ) throws ElasticSearchException { } protected abstract boolean checkWriteConsistency ( ) { } protected abstract ClusterBlockException checkGlobalBlock ( ClusterState state , Request request ) { } protected abstract ClusterBlockException checkRequestBlock ( ClusterState state , Request request ) { } protected boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) { } protected TransportRequestOptions transportOptions ( ) { } protected boolean ignoreReplicas ( ) { } private String transportReplicaAction ( ) { } protected boolean retryPrimaryException ( Throwable e ) { } boolean ignoreReplicaException ( Throwable e ) { } class OperationTransportHandler extends BaseTransportRequestHandler < Request > { @ Override public Request newInstance ( ) { } @ Override public String executor ( ) { } @ Override public void messageReceived ( final Request request , final TransportChannel channel ) throws Exception { } } class ReplicaOperationTransportHandler extends BaseTransportRequestHandler < TransportShardReplicationOperationAction < Request , ReplicaRequest , Response > . ReplicaOperationRequest > { @ Override public TransportShardReplicationOperationAction < Request , ReplicaRequest , Response > . ReplicaOperationRequest newInstance ( ) { } @ Override public String executor ( ) { } @ Override public void messageReceived ( final TransportShardReplicationOperationAction < Request , ReplicaRequest , Response > . ReplicaOperationRequest request , final TransportChannel channel ) throws Exception { } } protected class PrimaryOperationRequest implements Streamable { public int shardId ; public Request request ; public PrimaryOperationRequest ( ) { } public PrimaryOperationRequest ( int shardId , Request request ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } protected class ReplicaOperationRequest extends TransportRequest { public int shardId ; public ReplicaRequest request ; public ReplicaOperationRequest ( ) { } public ReplicaOperationRequest ( int shardId , ReplicaRequest request ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } protected class AsyncShardOperationAction { private final ActionListener < Response > listener ; private final Request request ; private ClusterState clusterState ; private ShardIterator shardIt ; private final AtomicBoolean primaryOperationStarted = new AtomicBoolean ( ) ; private final ReplicationType replicationType ; AsyncShardOperationAction ( Request request , ActionListener < Response > listener ) { } public void start ( ) { } public boolean start ( final boolean fromClusterEvent ) throws ElasticSearchException { } void retry ( boolean fromClusterEvent , @ Nullable final Throwable failure ) { if ( ! fromClusterEvent ) { request . beforeLocalFork ( ) ; request . operationThreaded ( true ) ; clusterService . add ( request . timeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { if ( start ( true ) ) { clusterService . remove ( this ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; <START_BUG> listener . onFailure ( new org . elasticsearch . node . NodeClosedException ( clusterState . nodes ( ) . localNode ( ) ) ) ; <END_BUG> } @ Override public void clusterChanged ( ClusterChangedEvent event ) { if ( start ( true ) ) { clusterService . remove ( this ) ; } } @ Override public void onTimeout ( TimeValue timeValue ) { if ( start ( true ) ) { clusterService . remove ( this ) ; return ; } clusterService . remove ( this ) ; Throwable listenerFailure = failure ; if ( listenerFailure == null ) { if ( ( shardIt ) == null ) { listenerFailure = new UnavailableShardsException ( null , ( ( ( "no<seq2seq4repair_space>available<seq2seq4repair_space>shards:<seq2seq4repair_space>Timeout<seq2seq4repair_space>waiting<seq2seq4repair_space>for<seq2seq4repair_space>[" + timeValue ) + "],<seq2seq4repair_space>request:<seq2seq4repair_space>" ) + ( request . toString ( ) ) ) ) ; } else { listenerFailure = new UnavailableShardsException ( shardIt . shardId ( ) , ( ( ( ( ( ( ( "[" + ( shardIt . size ( ) ) ) + "]<seq2seq4repair_space>shardIt,<seq2seq4repair_space>[" ) + ( shardIt . sizeActive ( ) ) ) + "]<seq2seq4repair_space>active<seq2seq4repair_space>:<seq2seq4repair_space>Timeout<seq2seq4repair_space>waiting<seq2seq4repair_space>for<seq2seq4repair_space>[" ) + timeValue ) + "],<seq2seq4repair_space>request:<seq2seq4repair_space>" ) + ( request . toString ( ) ) ) ) ; } } listener . onFailure ( listenerFailure ) ; } } ) ; } } void performOnPrimary ( int primaryShardId , boolean fromDiscoveryListener , final ShardRouting shard , ClusterState clusterState ) { } void performReplicas ( final TransportShardReplicationOperationAction . PrimaryResponse < Response , ReplicaRequest > response ) { } void performOnReplica ( final TransportShardReplicationOperationAction . PrimaryResponse < Response , ReplicaRequest > response , final AtomicInteger counter , final ShardRouting shard , String nodeId ) { } } public static class PrimaryResponse < Response , ReplicaRequest > { private final ReplicaRequest replicaRequest ; private final Response response ; private final Object payload ; public PrimaryResponse ( ReplicaRequest replicaRequest , Response response , Object payload ) { } public ReplicaRequest replicaRequest ( ) { } public Response response ( ) { } public Object payload ( ) { }
public class DefaultShaderProvider extends BaseShaderProvider { public String vertexShader ; public String fragmentShader ; public DefaultShaderProvider ( final String vertexShader , final String fragmentShader ) { } public DefaultShaderProvider ( final FileHandle vertexShader , final FileHandle fragmentShader ) { } public DefaultShaderProvider ( ) { } @ Override protected Shader createShader ( final Renderable renderable ) { app . log ( "DefaultShaderProvider" , "Creating<seq2seq4repair_space>new<seq2seq4repair_space>shader" ) ; if ( graphics . isGL20Available ( ) ) { <START_BUG> return new com . badlogic . gdx . graphics . g3d . shaders . DefaultShader ( vertexShader , fragmentShader , renderable , ( ( renderable . lights ) != null ) , ( ( ( renderable . lights ) != null ) && ( ( renderable . lights . fog ) != null ) ) , 2 , 5 , 3 , ( ( renderable . bones ) == null ? 0 : 12 ) ) ; <END_BUG> } return new GLES10Shader ( ) ; } }
public abstract class AbstractFieldMapper < T > implements FieldMapper < T > , Mapper { public static class Defaults { public static final Index INDEX = Index . ANALYZED ; public static final Store STORE = Store . NO ; public static final TermVector TERM_VECTOR = TermVector . NO ; public static final float BOOST = 1.0F ; public static final boolean OMIT_NORMS = false ; public static final boolean OMIT_TERM_FREQ_AND_POSITIONS = false ; } public static abstract class OpenBuilder < T extends AbstractFieldMapper . Builder , Y extends AbstractFieldMapper > extends AbstractFieldMapper . Builder < T , Y > { protected OpenBuilder ( String name ) { } @ Override public T index ( Field . Index index ) { } @ Override public T store ( Field . Store store ) { } @ Override public T termVector ( Field . TermVector termVector ) { } @ Override public T boost ( float boost ) { } @ Override public T omitNorms ( boolean omitNorms ) { } @ Override public T omitTermFreqAndPositions ( boolean omitTermFreqAndPositions ) { } @ Override public T indexName ( String indexName ) { } @ Override public T indexAnalyzer ( NamedAnalyzer indexAnalyzer ) { } @ Override public T searchAnalyzer ( NamedAnalyzer searchAnalyzer ) { } } public static abstract class Builder < T extends AbstractFieldMapper . Builder , Y extends AbstractFieldMapper > extends Mapper . Builder < T , Y > { protected Index index = AbstractFieldMapper . Defaults . INDEX ; protected Store store = AbstractFieldMapper . Defaults . STORE ; protected TermVector termVector = AbstractFieldMapper . Defaults . TERM_VECTOR ; protected float boost = AbstractFieldMapper . Defaults . BOOST ; protected boolean omitNorms = AbstractFieldMapper . Defaults . OMIT_NORMS ; protected boolean omitTermFreqAndPositions = AbstractFieldMapper . Defaults . OMIT_TERM_FREQ_AND_POSITIONS ; protected String indexName ; protected NamedAnalyzer indexAnalyzer ; protected NamedAnalyzer searchAnalyzer ; protected Boolean includeInAll ; protected Builder ( String name ) { } protected T index ( Field . Index index ) { } protected T store ( Field . Store store ) { } protected T termVector ( Field . TermVector termVector ) { } protected T boost ( float boost ) { } protected T omitNorms ( boolean omitNorms ) { } protected T omitTermFreqAndPositions ( boolean omitTermFreqAndPositions ) { } protected T indexName ( String indexName ) { } protected T indexAnalyzer ( NamedAnalyzer indexAnalyzer ) { } protected T searchAnalyzer ( NamedAnalyzer searchAnalyzer ) { } protected T includeInAll ( Boolean includeInAll ) { } protected Names buildNames ( BuilderContext context ) { <START_BUG> return new Names ( name , buildIndexName ( context ) , ( ( indexName ) == null ? name : indexName ) , buildFullName ( context ) ) ; <END_BUG> } protected String buildIndexName ( BuilderContext context ) { } protected String buildFullName ( BuilderContext context ) { } } protected final Names names ; protected final Index index ; protected final Store store ; protected final TermVector termVector ; protected float boost ; protected final boolean omitNorms ; protected final boolean omitTermFreqAndPositions ; protected final IndexOptions indexOptions ; protected final NamedAnalyzer indexAnalyzer ; protected final NamedAnalyzer searchAnalyzer ; protected AbstractFieldMapper ( Names names , Field . Index index , Field . Store store , Field . TermVector termVector , float boost , boolean omitNorms , boolean omitTermFreqAndPositions , NamedAnalyzer indexAnalyzer , NamedAnalyzer searchAnalyzer ) { } @ Override public String name ( ) { } @ Override public Names names ( ) { } @ Override public Index index ( ) { } @ Override public Store store ( ) { } @ Override public boolean stored ( ) { } @ Override public boolean indexed ( ) { } @ Override public boolean analyzed ( ) { } @ Override public TermVector termVector ( ) { } @ Override public float boost ( ) { } @ Override public boolean omitNorms ( ) { } @ Override public boolean omitTermFreqAndPositions ( ) { } @ Override public Analyzer indexAnalyzer ( ) { } @ Override public Analyzer searchAnalyzer ( ) { } @ Override public void parse ( ParseContext context ) throws IOException { } protected abstract Fieldable parseCreateField ( ParseContext context ) throws IOException { } protected boolean customBoost ( ) { } @ Override public void traverse ( FieldMapperListener fieldMapperListener ) { } @ Override public void traverse ( ObjectMapperListener objectMapperListener ) { } @ Override public Object valueForSearch ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } @ Override public Query queryStringTermQuery ( Term term ) { } @ Override public boolean useFieldQueryWithQueryString ( ) { } @ Override public Query fieldQuery ( String value , @ Nullable QueryParseContext context ) { } @ Override public Filter fieldFilter ( String value , @ Nullable QueryParseContext context ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions ) { } @ Override public Query fuzzyQuery ( String value , double minSim , int prefixLength , int maxExpansions ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override public FieldDataType fieldDataType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } protected void doXContentBody ( XContentBuilder builder ) throws IOException { } protected abstract String contentType ( ) { } @ Override public void close ( ) { } }
public class FieldMappers implements Iterable < FieldMapper > { private final FieldMapper [ ] fieldMappers ; private final List < FieldMapper > fieldMappersAsList ; public FieldMappers ( ) { } public FieldMappers ( FieldMapper fieldMapper ) { } private FieldMappers ( FieldMapper [ ] fieldMappers ) { } public FieldMapper mapper ( ) { } public boolean isEmpty ( ) { } public List < FieldMapper > mappers ( ) { } @ Override public Iterator < FieldMapper > iterator ( ) { } public FieldMappers concat ( FieldMapper mapper ) { } public FieldMappers remove ( FieldMapper mapper ) { <START_BUG> ArrayList < FieldMapper > list = new ArrayList < FieldMapper > ( fieldMappers . length ) ; <END_BUG> for ( FieldMapper fieldMapper : fieldMappers ) { if ( ! ( fieldMapper . equals ( mapper ) ) ) { list . add ( fieldMapper ) ; } } return new FieldMappers ( list . toArray ( new FieldMapper [ list . size ( ) ] ) ) ; } }
public class DragAndDropTest extends GdxTest { Stage stage ; public void create ( ) { } public void render ( ) { } public void resize ( int width , int height ) { <START_BUG> stage . getViewport ( ) . update ( width , height , true ) ; <END_BUG> } public void dispose ( ) { } }
public class Stage extends InputAdapter { protected float width ; protected float height ; protected float centerX ; protected float centerY ; protected boolean stretch ; protected final Group root ; protected final SpriteBatch batch ; protected final Matrix4 projection ; protected final Matrix4 identity ; public Stage ( float width , float height , boolean stretch ) { } public void setViewport ( float width , float height , boolean strech ) { } public float width ( ) { } public float height ( ) { } public int left ( ) { } public float right ( ) { } public float top ( ) { } public float bottom ( ) { } public float centerX ( ) { } public float centerY ( ) { } public boolean isStretched ( ) { } public Actor findActor ( String name ) { } public List < Actor > getActors ( ) { } public List < Group > getGroups ( ) { } final Vector2 point = new Vector2 ( ) ; final Vector2 coords = new Vector2 ( ) ; public boolean touchDown ( int x , int y , int pointer , int newParam ) { } public boolean touchUp ( int x , int y , int pointer , int button ) { } public boolean touchDragged ( int x , int y , int pointer ) { } public void act ( float delta ) { } public void render ( ) { batch . setProjectionMatrix ( projection ) ; batch . setTransformMatrix ( identity ) ; batch . begin ( ) ; <START_BUG> root . render ( batch ) ; <END_BUG> batch . end ( ) ; } public void dispose ( ) { } public void addActor ( Actor actor ) { } public String graphToString ( ) { } private void graphToString ( StringBuilder buffer , Actor actor , int level ) { } public Group getRoot ( ) { } public SpriteBatch getSpriteBatch ( ) { } public Actor getLastTouchedChild ( ) { } public Actor hit ( float x , float y ) { } public void toStageCoordinates ( int x , int y , Vector2 out ) { } public void clear ( ) { } public void removeActor ( Actor actor ) { } }
public class RestAnalyzeAction extends BaseRestHandler { @ Inject public RestAnalyzeAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { String text = request . param ( "text" ) ; if ( ( text == null ) && ( request . hasContent ( ) ) ) { text = request . content ( ) . toUtf8 ( ) ; } if ( text == null ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , new ElasticSearchIllegalArgumentException ( "text<seq2seq4repair_space>is<seq2seq4repair_space>missing" ) ) ) ; } catch ( IOException e1 ) { logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>response" , e1 ) ; } return ; } AnalyzeRequest analyzeRequest = new AnalyzeRequest ( request . param ( "index" ) , text ) ; analyzeRequest . listenerThreaded ( false ) ; analyzeRequest . preferLocal ( request . paramAsBoolean ( "prefer_local" , analyzeRequest . preferLocalShard ( ) ) ) ; analyzeRequest . analyzer ( request . param ( "analyzer" ) ) ; analyzeRequest . field ( request . param ( "field" ) ) ; analyzeRequest . tokenizer ( request . param ( "tokenizer" ) ) ; analyzeRequest . tokenFilters ( request . paramAsStringArray ( "token_filters" , request . paramAsStringArray ( "filters" , null ) ) ) ; client . admin ( ) . indices ( ) . analyze ( analyzeRequest , new org . elasticsearch . action . ActionListener < AnalyzeResponse > ( ) { @ Override public void onResponse ( AnalyzeResponse response ) { try { <START_BUG> XContentBuilder builder = restContentBuilder ( request ) ; <END_BUG> builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; } catch ( Exception e ) { onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class RepoListFragment extends ListLoadingFragment < Repository > { private static final String TAG = "RLF" ; private LoaderCallbacks < List < Repository > > callback ; private OnItemClickListener clickListener ; private Collection < String > recent ; @ Inject private AccountDataManager cache ; @ InjectExtra ( EXTRA_USER ) private User user ; @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } public RepoListFragment setRecent ( Collection < String > recent ) { } public RepoListFragment setClickListener ( OnItemClickListener clickListener ) { } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } public RepoListFragment setCallback ( LoaderCallbacks < List < Repository > > callback ) { } @ Override public void onLoadFinished ( Loader < List < Repository > > loader , List < Repository > items ) { } @ Override public Loader < List < Repository > > onCreateLoader ( int id , Bundle args ) { return new com . github . mobile . android . AsyncLoader < List < Repository > > ( getActivity ( ) ) { public List < Repository > loadInBackground ( ) { try { List < Repository > repos = new ArrayList < Repository > ( cache . getRepos ( user ) ) ; Collections . sort ( repos , new Comparator < Repository > ( ) { public int compare ( Repository lhs , Repository rhs ) { String lId = lhs . generateId ( ) ; String rId = rhs . generateId ( ) ; if ( ( recent . contains ( lId ) ) && ( ! ( recent . contains ( rId ) ) ) ) return - 1 ; if ( ( recent . contains ( rId ) ) && ( ! ( recent . contains ( lId ) ) ) ) return 1 ; <START_BUG> return lId . compareToIgnoreCase ( rId ) ; <END_BUG> } } ) ; return repos ; } catch ( IOException e ) { Log . d ( RepoListFragment . TAG , "Error<seq2seq4repair_space>getting<seq2seq4repair_space>repositories" , e ) ; return Collections . emptyList ( ) ; } } } ; } @ Override protected ListAdapter adapterFor ( List < Repository > items ) { } }
public class Xml { private final Array < Xml . Element > elements = new Array ( 8 ) ; private Xml . Element root ; private Xml . Element current ; private final StringBuilder textBuffer = new StringBuilder ( 64 ) ; public Xml . Element parse ( String xml ) { } public Xml . Element parse ( Reader reader ) throws IOException { } public Xml . Element parse ( InputStream input ) throws IOException { } public Xml . Element parse ( FileHandle file ) throws IOException { } public Xml . Element parse ( char [ ] data , int offset , int length ) { } private static byte [ ] init__xml_actions_0 ( ) { } private static final byte [ ] _xml_actions = Xml . init__xml_actions_0 ( ) ; private static byte [ ] init__xml_key_offsets_0 ( ) { } private static final byte [ ] _xml_key_offsets = Xml . init__xml_key_offsets_0 ( ) ; private static char [ ] init__xml_trans_keys_0 ( ) { } private static final char [ ] _xml_trans_keys = Xml . init__xml_trans_keys_0 ( ) ; private static byte [ ] init__xml_single_lengths_0 ( ) { } private static final byte [ ] _xml_single_lengths = Xml . init__xml_single_lengths_0 ( ) ; private static byte [ ] init__xml_range_lengths_0 ( ) { } private static final byte [ ] _xml_range_lengths = Xml . init__xml_range_lengths_0 ( ) ; private static short [ ] init__xml_index_offsets_0 ( ) { } private static final short [ ] _xml_index_offsets = Xml . init__xml_index_offsets_0 ( ) ; private static byte [ ] init__xml_indicies_0 ( ) { } private static final byte [ ] _xml_indicies = Xml . init__xml_indicies_0 ( ) ; private static byte [ ] init__xml_trans_targs_0 ( ) { } private static final byte [ ] _xml_trans_targs = Xml . init__xml_trans_targs_0 ( ) ; private static byte [ ] init__xml_trans_actions_0 ( ) { } private static final byte [ ] _xml_trans_actions = Xml . init__xml_trans_actions_0 ( ) ; static final int xml_start = 1 ; static final int xml_first_final = 34 ; static final int xml_error = 0 ; static final int xml_en_elementBody = 15 ; static final int xml_en_main = 1 ; protected void open ( String name ) { } protected void attribute ( String name , String value ) { } protected String entity ( String name ) { } protected void text ( String text ) { } protected void close ( ) { } public static class Element { private final String name ; private ObjectMap < String , String > attributes ; private Array < Xml . Element > children ; private String text ; public Element ( String name ) { } public String getName ( ) { } public String getAttribute ( String name ) { } public void setAttribute ( String name , String value ) { } public int getChildCount ( ) { } public Xml . Element getChild ( int i ) { } public void addChild ( Xml . Element element ) { } public String getText ( ) { } public void setText ( String text ) { } public String toString ( ) { } public String toString ( String indent ) { } public Xml . Element getChildByName ( String name ) { } public Xml . Element getChildByNameRecursive ( String name ) { } public Array < Xml . Element > getChildrenByName ( String name ) { Array < Xml . Element > children = new Array < Xml . Element > ( ) ; if ( ( this . children ) == null ) return children ; for ( int i = 0 ; i < ( this . children . size ) ; i ++ ) { <START_BUG> Xml . Element child = children . get ( i ) ; <END_BUG> if ( child . name . equals ( name ) ) children . add ( child ) ; } return children ; } } }
public abstract class AndroidLiveWallpaperService extends WallpaperService { static final String TAG = "WallpaperService" ; static boolean DEBUG = false ; protected volatile AndroidLiveWallpaper app = null ; protected Callback view = null ; protected int viewFormat ; protected int viewWidth ; protected int viewHeight ; protected int engines = 0 ; protected int visibleEngines = 0 ; protected volatile AndroidLiveWallpaperService . AndroidWallpaperEngine linkedEngine = null ; protected void setLinkedEngine ( AndroidLiveWallpaperService . AndroidWallpaperEngine linkedEngine ) { } protected volatile boolean isPreviewNotified = false ; protected volatile boolean notifiedPreviewState = false ; volatile int [ ] sync = new int [ 0 ] ; public AndroidLiveWallpaperService ( ) { } @ Override public void onCreate ( ) { } @ Override public Engine onCreateEngine ( ) { } public void onCreateApplication ( ) { } public void initialize ( ApplicationListener listener , boolean useGL2IfAvailable ) { } public void initialize ( ApplicationListener listener , AndroidApplicationConfiguration config ) { if ( AndroidLiveWallpaperService . DEBUG ) Log . d ( AndroidLiveWallpaperService . TAG , "<seq2seq4repair_space>><seq2seq4repair_space>AndroidLiveWallpaperService<seq2seq4repair_space>-<seq2seq4repair_space>initialize()" ) ; app . initialize ( listener , config ) ; <START_BUG> if ( ( config . getTouchEventsForLiveWallpaper ) && ( ( Integer . parseInt ( SDK ) ) >= 7 ) ) <END_BUG> linkedEngine . setTouchEventsEnabled ( true ) ; } public SurfaceHolder getSurfaceHolder ( ) { } public void onDeepPauseApplication ( ) { } @ Override public void onDestroy ( ) { } @ Override protected void finalize ( ) throws Throwable { } public AndroidLiveWallpaper getLiveWallpaper ( ) { } public WindowManager getWindowManager ( ) { } public class AndroidWallpaperEngine extends Engine { protected boolean engineIsVisible = false ; protected int engineFormat ; protected int engineWidth ; protected int engineHeight ; public AndroidWallpaperEngine ( ) { } @ Override public void onCreate ( final SurfaceHolder surfaceHolder ) { } @ Override public void onSurfaceCreated ( final SurfaceHolder holder ) { } @ Override public void onSurfaceChanged ( final SurfaceHolder holder , final int format , final int width , final int height ) { } private void notifySurfaceChanged ( final int format , final int width , final int height , boolean forceUpdate ) { } @ Override public void onVisibilityChanged ( final boolean visible ) { } private void notifyVisibilityChanged ( final boolean visible ) { } public void onResume ( ) { } public void onPause ( ) { } @ Override public void onSurfaceDestroyed ( final SurfaceHolder holder ) { } @ Override public void onDestroy ( ) { } @ Override public Bundle onCommand ( final String pAction , final int pX , final int pY , final int pZ , final Bundle pExtras , final boolean pResultRequested ) { } @ Override public void onTouchEvent ( MotionEvent event ) { } boolean offsetsConsumed = true ; float xOffset = 0.0F ; float yOffset = 0.0F ; float xOffsetStep = 0.0F ; float yOffsetStep = 0.0F ; int xPixelOffset = 0 ; int yPixelOffset = 0 ; @ Override public void onOffsetsChanged ( final float xOffset , final float yOffset , final float xOffsetStep , final float yOffsetStep , final int xPixelOffset , final int yPixelOffset ) { } protected void notifyOffsetsChanged ( ) { } protected void notifyPreviewState ( ) { } } }
public class Table extends WidgetGroup { private final TableLayout layout ; private Drawable backgroundDrawable ; private boolean clip ; private Skin skin ; public Table ( ) { } public Table ( Skin skin ) { } public void draw ( SpriteBatch batch , float parentAlpha ) { } protected void drawBackground ( SpriteBatch batch , float parentAlpha ) { } private Rectangle calculateScissors ( Matrix4 transform ) { } public void invalidate ( ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMinWidth ( ) { } public float getMinHeight ( ) { } public void setBackground ( Drawable background ) { } public Drawable getBackground ( ) { } public void setClip ( boolean enabled ) { } public int getRow ( float y ) { } public void clear ( ) { } public Cell add ( String text ) { } public Cell add ( String text , String labelStyleName ) { } public Cell add ( ) { } public Cell add ( Actor actor ) { <START_BUG> return layout . add ( actor ) ; <END_BUG> } public Cell stack ( Actor ... actors ) { } public Cell row ( ) { } public Cell columnDefaults ( int column ) { } public Cell defaults ( ) { } public void layout ( ) { } public void reset ( ) { } public Cell getCell ( Actor actor ) { } public List < Cell > getCells ( ) { } public Table pad ( Value pad ) { } public Table pad ( Value top , Value left , Value bottom , Value right ) { } public Table padTop ( Value padTop ) { } public Table padLeft ( Value padLeft ) { } public Table padBottom ( Value padBottom ) { } public Table padRight ( Value padRight ) { } public Table pad ( float pad ) { } public Table pad ( float top , float left , float bottom , float right ) { } public Table padTop ( float padTop ) { } public Table padLeft ( float padLeft ) { } public Table padBottom ( float padBottom ) { } public Table padRight ( float padRight ) { } public Table align ( int align ) { } public Table center ( ) { } public Table top ( ) { } public Table left ( ) { } public Table bottom ( ) { } public Table right ( ) { } public Table debug ( ) { } public Table debugTable ( ) { } public Table debugCell ( ) { } public Table debugWidget ( ) { } public Table debug ( Debug debug ) { } public Debug getDebug ( ) { } public Value getPadTop ( ) { } public Value getPadLeft ( ) { } public Value getPadBottom ( ) { } public Value getPadRight ( ) { } public int getAlign ( ) { } public void setSkin ( Skin skin ) { } public static void drawDebug ( Stage stage ) { } private static void drawDebug ( Array < Actor > actors , SpriteBatch batch ) { } }
; Skin skin ; Stage stage ; SpriteBatch batch ; Texture texture1 ; Texture texture2 ; Actor root ; Label fpsLabel ; @ Override public void create ( ) { batch = new SpriteBatch ( ) ; skin = new Skin ( files . internal ( "data/uiskin.json" ) ) ; texture1 = new Texture ( files . internal ( "data/badlogicsmall.jpg" ) ) ; texture2 = new Texture ( files . internal ( "data/badlogic.jpg" ) ) ; TextureRegion image = new TextureRegion ( texture1 ) ; TextureRegion imageFlipped = new TextureRegion ( image ) ; imageFlipped . flip ( true , true ) ; TextureRegion image2 = new TextureRegion ( texture2 ) ; stage = new Stage ( graphics . getWidth ( ) , graphics . getHeight ( ) , false ) ; input . setInputProcessor ( stage ) ; ImageButtonStyle style = new ImageButtonStyle ( skin . get ( ButtonStyle . class ) ) ; style . imageUp = new com . badlogic . gdx . scenes . scene2d . utils . TextureRegionDrawable ( image ) ; style . imageDown = new com . badlogic . gdx . scenes . scene2d . utils . TextureRegionDrawable ( imageFlipped ) ; ImageButton iconButton = new ImageButton ( style ) ; Button buttonMulti = new com . badlogic . gdx . scenes . scene2d . ui . TextButton ( "Multi\nLine\nToggle" , skin , "toggle" ) ; Button imgButton = new Button ( new Image ( image ) , skin ) ; Button imgToggleButton = new Button ( new Image ( image ) , skin , "toggle" ) ; Label myLabel = new Label ( "this<seq2seq4repair_space>is<seq2seq4repair_space>some<seq2seq4repair_space>text." , skin ) ; myLabel . setWrap ( true ) ; Table t = new Table ( ) ; t . row ( ) ; t . add ( myLabel ) ; t . layout ( ) ; CheckBox checkBox = new CheckBox ( "Check<seq2seq4repair_space>me" , skin ) ; final Slider slider = new Slider ( 0 , 10 , 1 , false , skin ) ; TextField textfield = new TextField ( "" , skin ) ; textfield . setMessageText ( "Click<seq2seq4repair_space>here!" ) ; SelectBox dropdown = new SelectBox ( new String [ ] { "Android" , "Windows" , "Linux" , "OSX" } , skin ) ; Image imageActor = new Image ( image2 ) ; ScrollPane scrollPane = new ScrollPane ( imageActor ) ; List list = new List ( listEntries , skin ) ; ScrollPane scrollPane2 = new ScrollPane ( list , skin ) ; scrollPane2 . setFlickScroll ( false ) ; SplitPane splitPane = new SplitPane ( scrollPane , scrollPane2 , false , skin , "default-horizontal" ) ; fpsLabel = new Label ( "fps:" , skin ) ; final Label passwordLabel = new Label ( "Textfield<seq2seq4repair_space>in<seq2seq4repair_space>password<seq2seq4repair_space>mode:<seq2seq4repair_space>" , skin ) ; final TextField passwordTextField = new TextField ( "" , skin ) ; passwordTextField . setMessageText ( "password" ) ; passwordTextField . setPasswordCharacter ( '*' ) ; passwordTextField . setPasswordMode ( true ) ; Window window = new Window ( "Dialog" , skin ) ; window . setPosition ( 0 , 0 ) ; window . defaults ( ) . spaceBottom ( 10 ) ; window . row ( ) . fill ( ) . expandX ( ) ; window . add ( iconButton ) ; window . add ( buttonMulti ) ; window . add ( imgButton ) ; window . add ( imgToggleButton ) ; window . row ( ) ; window . add ( checkBox ) ; window . add ( slider ) . minWidth ( 100 ) . fillX ( ) . colspan ( 3 ) ; window . row ( ) ; window . add ( dropdown ) ; window . add ( textfield ) . minWidth ( 100 ) . expandX ( ) . fillX ( ) . colspan ( 3 ) ; window . row ( ) ; window . add ( splitPane ) . fill ( ) . expand ( ) . colspan ( 4 ) . maxHeight ( 200 ) ; window . row ( ) ; window . add ( passwordLabel ) . colspan ( 2 ) ; window . add ( passwordTextField ) . minWidth ( 100 ) . expandX ( ) . fillX ( ) . colspan ( 2 ) ; window . row ( ) ; window . add ( fpsLabel ) . colspan ( 4 ) ; window . pack ( ) ; stage . addActor ( window ) ; textfield . setTextFieldListener ( new TextFieldListener ( ) { public void keyTyped ( TextField textField , char key ) { if ( key == '\n' ) textField . getOnscreenKeyboard ( ) . show ( false ) ; } } ) ; slider . addListener ( new ChangeListener ( ) { public void changed ( ChangeEvent event , Actor actor ) { app . log ( "UITest" , ( "slider:<seq2seq4repair_space>" + ( slider . getValue ( ) ) ) ) ; } } ) ; iconButton . addListener ( new ChangeListener ( ) { public void changed ( ChangeEvent event , Actor actor ) { new com . badlogic . gdx . scenes . scene2d . ui . Dialog ( "Some<seq2seq4repair_space>Dialog" , skin , "dialog" ) { <START_BUG> protected void clicked ( Object object ) { <END_BUG> System . out . println ( ( "Chosen:<seq2seq4repair_space>" + object ) ) ; } } . text ( "Are<seq2seq4repair_space>you<seq2seq4repair_space>enjoying<seq2seq4repair_space>this<seq2seq4repair_space>demo?" ) . button ( "Yes" , true ) . button ( "No" , false ) . key ( ENTER , true ) . key ( ESCAPE , false ) . show ( stage ) ; } } ) ; } @ Override public void render ( ) { } @ Override public void resize ( int width , int height ) { } @ Override public void dispose ( ) { } }
public class IndexCache extends AbstractIndexComponent implements ClusterStateListener , CloseableComponent { private final FilterCache filterCache ; private final FieldDataCache fieldDataCache ; private final QueryParserCache queryParserCache ; private final IdCache idCache ; private final BloomCache bloomCache ; private ClusterService clusterService ; @ Inject public IndexCache ( Index index , @ IndexSettings Settings indexSettings , FilterCache filterCache , FieldDataCache fieldDataCache , QueryParserCache queryParserCache , IdCache idCache , BloomCache bloomCache ) { } @ Inject ( optional = true ) public void setClusterService ( @ Nullable ClusterService clusterService ) { } public CacheStats stats ( ) { <START_BUG> return new CacheStats ( fieldDataCache . evictions ( ) , filterCache . evictions ( ) , fieldDataCache . sizeInBytes ( ) , filterCache . sizeInBytes ( ) , filterCache . count ( ) , bloomCache . sizeInBytes ( ) ) ; <END_BUG> } public FilterCache filter ( ) { } public FieldDataCache fieldData ( ) { } public IdCache idCache ( ) { } public BloomCache bloomCache ( ) { } public QueryParserCache queryParserCache ( ) { } @ Override public void close ( ) throws ElasticSearchException { } public void clear ( IndexReader reader ) { } public void clear ( ) { } @ Override public void clusterChanged ( ClusterChangedEvent event ) { } }
public class JglfwInput implements Input { final JglfwApplication app ; final InputProcessorQueue processorQueue ; InputProcessor processor ; int pressedKeys = 0 ; boolean justTouched ; int deltaX ; int deltaY ; long currentEventTime ; public JglfwInput ( final JglfwApplication app , boolean queueEvents ) { } public void update ( ) { } public float getAccelerometerX ( ) { } public float getAccelerometerY ( ) { } public float getAccelerometerZ ( ) { } public int getX ( ) { } public int getX ( int pointer ) { } public int getY ( ) { } public int getY ( int pointer ) { } public int getDeltaX ( ) { } public int getDeltaX ( int pointer ) { } public int getDeltaY ( ) { } public int getDeltaY ( int pointer ) { } public boolean isTouched ( ) { } public boolean isTouched ( int pointer ) { } public boolean justTouched ( ) { } public boolean isButtonPressed ( int button ) { } public boolean isKeyPressed ( int key ) { } public void setOnscreenKeyboardVisible ( boolean visible ) { } public void vibrate ( int milliseconds ) { } public void vibrate ( long [ ] pattern , int repeat ) { } public void cancelVibrate ( ) { } public float getAzimuth ( ) { } public float getPitch ( ) { } public float getRoll ( ) { } public void getRotationMatrix ( float [ ] matrix ) { } public long getCurrentEventTime ( ) { } public void setCatchBackKey ( boolean catchBack ) { } public void setCatchMenuKey ( boolean catchMenu ) { } public void setInputProcessor ( InputProcessor processor ) { } public InputProcessor getInputProcessor ( ) { } public boolean isPeripheralAvailable ( Peripheral peripheral ) { } public int getRotation ( ) { } public Orientation getNativeOrientation ( ) { } public void setCursorCatched ( boolean captured ) { } public boolean isCursorCatched ( ) { } public void setCursorPosition ( int x , int y ) { } public void getTextInput ( final TextInputListener listener , final String title , final String text ) { } public void getPlaceholderTextInput ( final TextInputListener listener , final String title , final String placeholder ) { } static char characterForKeyCode ( int key ) { } public static int getGdxKeyCode ( int lwjglKeyCode ) { } public static int getJglfwKeyCode ( int gdxKeyCode ) { } static class GlfwInputProcessor extends GlfwCallbackAdapter { private int mouseX ; private int mouseY ; private int mousePressed ; private char lastCharacter ; private InputProcessor processor ; public GlfwInputProcessor ( InputProcessor processor ) { } public void key ( long window , int key , int action ) { } public void character ( long window , char character ) { } public void scroll ( long window , double scrollX , double scrollY ) { } public void mouseButton ( long window , int button , boolean pressed ) { if ( pressed ) { ( mousePressed ) ++ ; processor . touchDown ( mouseX , mouseY , 0 , button ) ; } else { <START_BUG> ( mousePressed ) -- ; <END_BUG> processor . touchUp ( mouseX , mouseY , 0 , button ) ; } } public void cursorPos ( long window , int x , int y ) { } } }
public class SourceFieldMapper extends AbstractFieldMapper < byte [ ] > implements InternalMapper , RootMapper { public static final String NAME = "_source" ; public static final String CONTENT_TYPE = "_source" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = SourceFieldMapper . NAME ; public static final boolean ENABLED = true ; public static final long COMPRESS_THRESHOLD = - 1 ; public static final String FORMAT = null ; public static final FieldType SOURCE_FIELD_TYPE = new FieldType ( AbstractFieldMapper . Defaults . FIELD_TYPE ) ; public static final String [ ] INCLUDES = Strings . EMPTY_ARRAY ; public static final String [ ] EXCLUDES = Strings . EMPTY_ARRAY ; } public static class Builder extends Mapper . Builder < SourceFieldMapper . Builder , SourceFieldMapper > { private boolean enabled = SourceFieldMapper . Defaults . ENABLED ; private long compressThreshold = SourceFieldMapper . Defaults . COMPRESS_THRESHOLD ; private Boolean compress = null ; private String format = SourceFieldMapper . Defaults . FORMAT ; private String [ ] includes = SourceFieldMapper . Defaults . INCLUDES ; private String [ ] excludes = SourceFieldMapper . Defaults . EXCLUDES ; public Builder ( ) { } public SourceFieldMapper . Builder enabled ( boolean enabled ) { } public SourceFieldMapper . Builder compress ( boolean compress ) { } public SourceFieldMapper . Builder compressThreshold ( long compressThreshold ) { } public SourceFieldMapper . Builder format ( String format ) { } public SourceFieldMapper . Builder includes ( String [ ] includes ) { } public SourceFieldMapper . Builder excludes ( String [ ] excludes ) { } @ Override public SourceFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private final boolean enabled ; private Boolean compress ; private long compressThreshold ; private String [ ] includes ; private String [ ] excludes ; private String format ; private XContentType formatContentType ; public SourceFieldMapper ( ) { } protected SourceFieldMapper ( String name , boolean enabled , String format , Boolean compress , long compressThreshold , String [ ] includes , String [ ] excludes ) { } public boolean enabled ( ) { } public BaseFieldVisitor fieldSelector ( ) { <START_BUG> return SourceFieldVisitor . INSTANCE ; <END_BUG> } @ Override public void preParse ( ParseContext context ) throws IOException { } @ Override public void postParse ( ParseContext context ) throws IOException { } @ Override public void parse ( ParseContext context ) throws IOException { } @ Override public void validate ( ParseContext context ) throws MapperParsingException { } @ Override public boolean includeInObject ( ) { } @ Override protected Field parseCreateField ( ParseContext context ) throws IOException { } public byte [ ] value ( Document document ) { } public byte [ ] nativeValue ( Field field ) { } @ Override public byte [ ] value ( Field field ) { } @ Override public byte [ ] valueFromString ( String value ) { } @ Override public String valueAsString ( Field field ) { } @ Override public String indexedValue ( String value ) { } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public class BranchFileViewActivity extends BaseActivity implements LoaderCallbacks < CharSequence > { private static final String TAG = "BranchFileViewActivity" ; private static final String ARG_TEXT = "text" ; private static final String ARG_REPO = "repo" ; public static Intent createIntent ( Repository repository , String branch , String file , String blobSha ) { } private Repository repo ; private String sha ; private String path ; private String file ; private String branch ; private boolean isMarkdownFile ; private String renderedMarkdown ; private Blob blob ; private ProgressBar loadingBar ; private WebView codeView ; private SourceEditor editor ; private MenuItem markdownItem ; @ Inject private AvatarLoader avatars ; @ Inject private HttpImageGetter imageGetter ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override public boolean onCreateOptionsMenu ( final Menu optionsMenu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public Loader < CharSequence > onCreateLoader ( int loader , Bundle args ) { } @ Override public void onLoadFinished ( Loader < CharSequence > loader , CharSequence rendered ) { } @ Override public void onLoaderReset ( Loader < CharSequence > loader ) { } private void shareFile ( ) { } private void loadMarkdown ( ) { ViewUtils . setGone ( loadingBar , false ) ; ViewUtils . setGone ( codeView , true ) ; String markdown = new String ( EncodingUtils . fromBase64 ( blob . getContent ( ) ) ) ; Bundle args = new Bundle ( ) ; args . putCharSequence ( BranchFileViewActivity . ARG_TEXT , markdown ) ; if ( ( repo ) instanceof Serializable ) <START_BUG> args . putSerializable ( BranchFileViewActivity . ARG_REPO , ( ( Serializable ) ( repo ) ) ) ; <END_BUG> getSupportLoaderManager ( ) . restartLoader ( 0 , args , this ) ; } private void loadContent ( ) { } }
public class TwoInstanceEmbeddedSearchTests extends AbstractNodesTests { private IndicesService indicesService ; private ClusterService clusterService ; private Map < String , SearchService > nodeToSearchService ; private SearchPhaseController searchPhaseController ; @ BeforeClass public void createNodeAndInitWithData ( ) throws Exception { } @ AfterClass public void closeServers ( ) { } @ Test public void testDfsQueryThenFetch ( ) throws Exception { } @ Test public void testDfsQueryThenFetchWithSort ( ) throws Exception { } @ Test public void testQueryAndFetch ( ) { } @ Test public void testSimpleFacets ( ) { } @ Test public void testSimpleFacetsTwice ( ) { } private InternalSearchRequest searchRequest ( ShardRouting shardRouting , SearchSourceBuilder builder ) { <START_BUG> return new InternalSearchRequest ( shardRouting ) . source ( builder . buildAsBytes ( ) ) ; <END_BUG> } private void index ( Client client , String id , String nameValue , int age ) { } private String source ( String id , String nameValue , int age ) { } }
public abstract class FieldMapperListener { public static class Aggregator extends FieldMapperListener { public final List < FieldMapper > mappers = new ArrayList < > ( ) ; @ Override public void fieldMapper ( FieldMapper fieldMapper ) { } } public abstract void fieldMapper ( FieldMapper fieldMapper ) { } <START_BUG> public void fieldMappers ( Iterable < FieldMapper > fieldMappers ) { <END_BUG> for ( FieldMapper mapper : fieldMappers ) { fieldMapper ( mapper ) ; } } }
public class VertexBufferObject implements VertexData { static final IntBuffer tmpHandle = BufferUtils . newIntBuffer ( 1 ) ; final VertexAttributes attributes ; final FloatBuffer buffer ; final ByteBuffer byteBuffer ; int bufferHandle ; final boolean isStatic ; final int usage ; boolean isDirty = false ; boolean isBound = false ; public VertexBufferObject ( boolean isStatic , int numVertices , VertexAttribute ... attributes ) { } public VertexBufferObject ( boolean isStatic , int numVertices , VertexAttributes attributes ) { } private int createBufferObject ( ) { } @ Override public VertexAttributes getAttributes ( ) { } @ Override public int getNumVertices ( ) { } @ Override public int getNumMaxVertices ( ) { } @ Override public FloatBuffer getBuffer ( ) { } private void bufferChanged ( ) { } @ Override public void setVertices ( float [ ] vertices , int offset , int count ) { } @ Override public void updateVertices ( int targetOffset , float [ ] vertices , int sourceOffset , int count ) { isDirty = true ; final int pos = byteBuffer . position ( ) ; byteBuffer . position ( ( targetOffset * 4 ) ) ; <START_BUG> BufferUtils . copy ( vertices , sourceOffset , byteBuffer , count ) ; <END_BUG> byteBuffer . position ( pos ) ; buffer . position ( 0 ) ; bufferChanged ( ) ; } @ Override public void bind ( ) { } @ Override public void bind ( ShaderProgram shader ) { } @ Override public void bind ( ShaderProgram shader , int [ ] locations ) { } @ Override public void unbind ( ) { } @ Override public void unbind ( final ShaderProgram shader ) { } @ Override public void unbind ( final ShaderProgram shader , final int [ ] locations ) { } public void invalidate ( ) { } @ Override public void dispose ( ) { } }
public class DocumentMapper implements ToXContent { public static class MergeResult { private final String [ ] conflicts ; public MergeResult ( String [ ] conflicts ) { } public boolean hasConflicts ( ) { } public String [ ] conflicts ( ) { } } public static class MergeFlags { public static DocumentMapper . MergeFlags mergeFlags ( ) { } private boolean simulate = true ; public MergeFlags ( ) { } public boolean simulate ( ) { } public DocumentMapper . MergeFlags simulate ( boolean simulate ) { } } public static interface ParseListener < ParseContext > { public static final DocumentMapper . ParseListener EMPTY = new DocumentMapper . ParseListenerAdapter ( ) ; boolean beforeFieldAdded ( FieldMapper fieldMapper , Fieldable fieldable , ParseContext parseContent ) { } } public static class ParseListenerAdapter implements DocumentMapper . ParseListener { @ Override public boolean beforeFieldAdded ( FieldMapper fieldMapper , Fieldable fieldable , Object parseContext ) { } } public static class Builder { private Map < Class < ? extends RootMapper > , RootMapper > rootMappers = new LinkedHashMap < Class < ? extends RootMapper > , RootMapper > ( ) ; private NamedAnalyzer indexAnalyzer ; private NamedAnalyzer searchAnalyzer ; private final String index ; @ Nullable private final Settings indexSettings ; private final RootObjectMapper rootObjectMapper ; private ImmutableMap < String , Object > meta = ImmutableMap . of ( ) ; private final BuilderContext builderContext ; public Builder ( String index , @ Nullable Settings indexSettings , RootObjectMapper . Builder builder ) { } public DocumentMapper . Builder meta ( ImmutableMap < String , Object > meta ) { } public DocumentMapper . Builder put ( RootMapper . Builder mapper ) { } public DocumentMapper . Builder indexAnalyzer ( NamedAnalyzer indexAnalyzer ) { } public boolean hasIndexAnalyzer ( ) { } public DocumentMapper . Builder searchAnalyzer ( NamedAnalyzer searchAnalyzer ) { } public boolean hasSearchAnalyzer ( ) { } public DocumentMapper build ( DocumentMapperParser docMapperParser ) { } } private ThreadLocal < ParseContext > cache = new ThreadLocal < ParseContext > ( ) { @ Override protected ParseContext initialValue ( ) { } } ; private final String index ; private final Settings indexSettings ; private final String type ; private final DocumentMapperParser docMapperParser ; private volatile ImmutableMap < String , Object > meta ; private volatile CompressedString mappingSource ; private final RootObjectMapper rootObjectMapper ; private final ImmutableMap < Class < ? extends RootMapper > , RootMapper > rootMappers ; private final RootMapper [ ] rootMappersOrdered ; private final RootMapper [ ] rootMappersNotIncludedInObject ; private final NamedAnalyzer indexAnalyzer ; private final NamedAnalyzer searchAnalyzer ; private volatile DocumentFieldMappers fieldMappers ; private volatile ImmutableMap < String , ObjectMapper > objectMappers = ImmutableMap . of ( ) ; private final List < FieldMapperListener > fieldMapperListeners = new CopyOnWriteArrayList < FieldMapperListener > ( ) ; private final List < ObjectMapperListener > objectMapperListeners = new CopyOnWriteArrayList < ObjectMapperListener > ( ) ; private boolean hasNestedObjects = false ; private final Filter typeFilter ; private final Object mutex = new Object ( ) ; private boolean initMappersAdded = true ; public DocumentMapper ( String index , @ Nullable Settings indexSettings , DocumentMapperParser docMapperParser , RootObjectMapper rootObjectMapper , ImmutableMap < String , Object > meta , NamedAnalyzer indexAnalyzer , NamedAnalyzer searchAnalyzer , Map < Class < ? extends RootMapper > , RootMapper > rootMappers ) { } public String type ( ) { } public ImmutableMap < String , Object > meta ( ) { } public CompressedString mappingSource ( ) { } public RootObjectMapper root ( ) { } public UidFieldMapper uidMapper ( ) { } @ SuppressWarnings ( { "unchecked" } ) public < T extends RootMapper > T rootMapper ( Class < T > type ) { } public TypeFieldMapper typeMapper ( ) { } public SourceFieldMapper sourceMapper ( ) { } public AllFieldMapper allFieldMapper ( ) { } public IdFieldMapper idFieldMapper ( ) { } public RoutingFieldMapper routingFieldMapper ( ) { } public ParentFieldMapper parentFieldMapper ( ) { } public TimestampFieldMapper timestampFieldMapper ( ) { } public TTLFieldMapper TTLFieldMapper ( ) { } public Analyzer indexAnalyzer ( ) { } public Analyzer searchAnalyzer ( ) { } public Filter typeFilter ( ) { } public boolean hasNestedObjects ( ) { } public DocumentFieldMappers mappers ( ) { } public ImmutableMap < String , ObjectMapper > objectMappers ( ) { } public ParsedDocument parse ( byte [ ] source ) throws MapperParsingException { } public ParsedDocument parse ( String type , String id , byte [ ] source ) throws MapperParsingException { } public ParsedDocument parse ( SourceToParse source ) throws MapperParsingException { } public ParsedDocument parse ( SourceToParse source , @ Nullable DocumentMapper . ParseListener listener ) throws MapperParsingException { } public void addFieldMapper ( FieldMapper fieldMapper ) { } public void addFieldMapperListener ( FieldMapperListener fieldMapperListener , boolean includeExisting ) { } public void addObjectMapper ( ObjectMapper objectMapper ) { } public void addObjectMapperListener ( ObjectMapperListener objectMapperListener , boolean includeExisting ) { } public synchronized DocumentMapper . MergeResult merge ( DocumentMapper mergeWith , DocumentMapper . MergeFlags mergeFlags ) { } public void refreshSource ( ) throws FailedToGenerateSourceMapperException { try { XContentBuilder builder = XContentFactory . contentBuilder ( JSON ) ; builder . startObject ( ) ; toXContent ( builder , EMPTY_PARAMS ) ; builder . endObject ( ) ; <START_BUG> this . mappingSource = new CompressedString ( builder . string ( ) ) ; <END_BUG> } catch ( Exception e ) { throw new FailedToGenerateSourceMapperException ( e . getMessage ( ) , e ) ; } } public void close ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class SpriteBatch implements Batch { private Mesh mesh ; private Mesh [ ] buffers ; private int currBufferIdx = 0 ; private final float [ ] vertices ; private int idx = 0 ; private Texture lastTexture = null ; private float invTexWidth = 0 ; private float invTexHeight = 0 ; private boolean drawing = false ; private final Matrix4 transformMatrix = new Matrix4 ( ) ; private final Matrix4 projectionMatrix = new Matrix4 ( ) ; private final Matrix4 combinedMatrix = new Matrix4 ( ) ; private boolean blendingDisabled = false ; private int blendSrcFunc = GL11 . GL_SRC_ALPHA ; private int blendDstFunc = GL11 . GL_ONE_MINUS_SRC_ALPHA ; private final ShaderProgram shader ; private ShaderProgram customShader = null ; private boolean ownsShader ; float color = WHITE . toFloatBits ( ) ; private Color tempColor = new Color ( 1 , 1 , 1 , 1 ) ; public int renderCalls = 0 ; public int totalRenderCalls = 0 ; public int maxSpritesInBatch = 0 ; public SpriteBatch ( ) { } public SpriteBatch ( int size ) { } public SpriteBatch ( int size , ShaderProgram defaultShader ) { } public SpriteBatch ( int size , int buffers ) { } public SpriteBatch ( int size , int buffers , ShaderProgram defaultShader ) { } public static ShaderProgram createDefaultShader ( ) { } @ Override public void begin ( ) { } @ Override public void end ( ) { } @ Override public void setColor ( Color tint ) { } @ Override public void setColor ( float r , float g , float b , float a ) { } @ Override public void setColor ( float color ) { } @ Override public Color getColor ( ) { int intBits = NumberUtils . floatToIntColor ( color ) ; <START_BUG> Color color = this . tempColor ; <END_BUG> color . r = ( intBits & 255 ) / 255.0F ; color . g = ( ( intBits > > > 8 ) & 255 ) / 255.0F ; color . b = ( ( intBits > > > 16 ) & 255 ) / 255.0F ; color . a = ( ( intBits > > > 24 ) & 255 ) / 255.0F ; return color ; } @ Override public void draw ( Texture texture , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { } @ Override public void draw ( Texture texture , float x , float y , float width , float height , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { } @ Override public void draw ( Texture texture , float x , float y , int srcX , int srcY , int srcWidth , int srcHeight ) { } @ Override public void draw ( Texture texture , float x , float y , float width , float height , float u , float v , float u2 , float v2 ) { } @ Override public void draw ( Texture texture , float x , float y ) { } @ Override public void draw ( Texture texture , float x , float y , float width , float height ) { } @ Override public void draw ( Texture texture , float [ ] spriteVertices , int offset , int count ) { } @ Override public void draw ( TextureRegion region , float x , float y ) { } @ Override public void draw ( TextureRegion region , float x , float y , float width , float height ) { } @ Override public void draw ( TextureRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation ) { } @ Override public void draw ( TextureRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation , boolean clockwise ) { } @ Override public void flush ( ) { } @ Override public void disableBlending ( ) { } @ Override public void enableBlending ( ) { } @ Override public void setBlendFunction ( int srcFunc , int dstFunc ) { } @ Override public int getBlendSrcFunc ( ) { } @ Override public int getBlendDstFunc ( ) { } @ Override public void dispose ( ) { } @ Override public Matrix4 getProjectionMatrix ( ) { } @ Override public Matrix4 getTransformMatrix ( ) { } @ Override public void setProjectionMatrix ( Matrix4 projection ) { } @ Override public void setTransformMatrix ( Matrix4 transform ) { } private void setupMatrices ( ) { } private void switchTexture ( Texture texture ) { } @ Override public void setShader ( ShaderProgram shader ) { } @ Override public boolean isBlendingEnabled ( ) { } }
public class GwtTestStarter extends GwtApplication { @ Override public GwtApplicationConfiguration getConfig ( ) { <START_BUG> return new GwtApplicationConfiguration ( 640 , 640 ) ; <END_BUG> } @ Override public ApplicationListener getApplicationListener ( ) { } }
class TableToolkit extends Toolkit < Actor , Table , TableLayout > { static boolean drawDebug ; static Pool < Cell > cellPool = new Pool ( ) { protected Cell newObject ( ) { } } ; public Cell obtainCell ( TableLayout layout ) { } public void freeCell ( Cell cell ) { <START_BUG> cell . free ( ) ; <END_BUG> TableToolkit . cellPool . free ( cell ) ; } public void addChild ( Actor parent , Actor child ) { } public void removeChild ( Actor parent , Actor child ) { } public float getMinWidth ( Actor actor ) { } public float getMinHeight ( Actor actor ) { } public float getPrefWidth ( Actor actor ) { } public float getPrefHeight ( Actor actor ) { } public float getMaxWidth ( Actor actor ) { } public float getMaxHeight ( Actor actor ) { } public float getWidth ( Actor widget ) { } public float getHeight ( Actor widget ) { } public void clearDebugRectangles ( TableLayout layout ) { } public void addDebugRectangle ( TableLayout layout , Debug type , float x , float y , float w , float h ) { } static class DebugRect extends Rectangle { final Debug type ; public DebugRect ( Debug type , float x , float y , float width , float height ) { } } }
public abstract class AbstractSimpleTransportTests { protected ThreadPool threadPool ; protected TransportService serviceA ; protected TransportService serviceB ; protected DiscoveryNode serviceANode ; protected DiscoveryNode serviceBNode ; @ BeforeMethod public void setUp ( ) { } @ AfterMethod public void tearDown ( ) { } protected abstract void build ( ) { } @ Test public void testHelloWorld ( ) { } @ Test public void testHelloWorldCompressed ( ) { serviceA . registerHandler ( "sayHello" , new BaseTransportRequestHandler < AbstractSimpleTransportTests . StringMessage > ( ) { @ Override public AbstractSimpleTransportTests . StringMessage newInstance ( ) { return new AbstractSimpleTransportTests . StringMessage ( ) ; } @ Override public String executor ( ) { return Names . CACHED ; } @ Override public void messageReceived ( AbstractSimpleTransportTests . StringMessage request , TransportChannel channel ) { assertThat ( "moshe" , equalTo ( request . message ) ) ; try { <START_BUG> channel . sendResponse ( new AbstractSimpleTransportTests . StringMessage ( ( "hello<seq2seq4repair_space>" + ( request . message ) ) ) , TransportResponseOptions . options ( ) . withCompress ( ) ) ; <END_BUG> } catch ( IOException e ) { e . printStackTrace ( ) ; assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } } } ) ; TransportFuture < AbstractSimpleTransportTests . StringMessage > res = serviceB . submitRequest ( serviceANode , "sayHello" , new AbstractSimpleTransportTests . StringMessage ( "moshe" ) , TransportRequestOptions . TransportRequestOptions . options ( ) . withCompress ( true ) , new BaseTransportResponseHandler < AbstractSimpleTransportTests . StringMessage > ( ) { @ Override public AbstractSimpleTransportTests . StringMessage newInstance ( ) { return new AbstractSimpleTransportTests . StringMessage ( ) ; } @ Override public String executor ( ) { return Names . CACHED ; } @ Override public void handleResponse ( AbstractSimpleTransportTests . StringMessage response ) { assertThat ( "hello<seq2seq4repair_space>moshe" , equalTo ( response . message ) ) ; } @ Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; assertThat ( ( "got<seq2seq4repair_space>exception<seq2seq4repair_space>instead<seq2seq4repair_space>of<seq2seq4repair_space>a<seq2seq4repair_space>response:<seq2seq4repair_space>" + ( exp . getMessage ( ) ) ) , false , equalTo ( true ) ) ; } } ) ; try { AbstractSimpleTransportTests . StringMessage message = res . get ( ) ; assertThat ( "hello<seq2seq4repair_space>moshe" , equalTo ( message . message ) ) ; } catch ( Exception e ) { assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } serviceA . removeHandler ( "sayHello" ) ; } @ Test public void testErrorMessage ( ) { } @ Test public void testDisconnectListener ( ) throws Exception { } @ Test public void testTimeoutSendExceptionWithNeverSendingBackResponse ( ) throws Exception { } @ Test public void testTimeoutSendExceptionWithDelayedResponse ( ) throws Exception { } private class StringMessage implements Streamable { private String message ; private StringMessage ( String message ) { } private StringMessage ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class IOSApplication implements Application { public static abstract class Delegate extends UIApplicationDelegate . Adapter { private IOSApplication app ; protected abstract IOSApplication createApplication ( ) { } @ Override public boolean didFinishLaunching ( UIApplication application , NSDictionary launchOptions ) { } @ Override public void didBecomeActive ( UIApplication application ) { } @ Override public void willResignActive ( UIApplication application ) { } @ Override public void willTerminate ( UIApplication application ) { } } UIApplication uiApp ; UIWindow uiWindow ; ApplicationListener listener ; IOSApplicationConfiguration config ; IOSGraphics graphics ; IOSAudio audio ; IOSFiles files ; IOSInput input ; IOSNet net ; int logLevel = Application . LOG_DEBUG ; float displayScaleFactor ; Array < Runnable > runnables = new Array < Runnable > ( ) ; Array < Runnable > executedRunnables = new Array < Runnable > ( ) ; Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; public IOSApplication ( ApplicationListener listener , IOSApplicationConfiguration config ) { } final boolean didFinishLaunching ( UIApplication uiApp , NSDictionary options ) { } public UIViewController getUIViewController ( ) { } CGSize getBounds ( UIViewController viewController ) { } final void didBecomeActive ( UIApplication uiApp ) { } final void willResignActive ( UIApplication uiApp ) { } final void willTerminate ( UIApplication uiApp ) { } @ Override public ApplicationListener getApplicationListener ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Input getInput ( ) { } @ Override public Files getFiles ( ) { } @ Override public Net getNet ( ) { } @ Override public void log ( String tag , String message ) { } @ Override <START_BUG> public void log ( String tag , String message , Throwable exception ) { <END_BUG> if ( ( logLevel ) > ( LOG_NONE ) ) { System . out . println ( ( ( ( "[info]<seq2seq4repair_space>" + tag ) + ":<seq2seq4repair_space>" ) + message ) ) ; exception . printStackTrace ( ) ; } } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public int getLogLevel ( ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } @ Override public Preferences getPreferences ( String name ) { } @ Override public void postRunnable ( Runnable runnable ) { } public void processRunnables ( ) { } @ Override public void exit ( ) { } @ Override public Clipboard getClipboard ( ) { } @ Override public void addLifecycleListener ( LifecycleListener listener ) { } @ Override public void removeLifecycleListener ( LifecycleListener listener ) { } }
public class NoneRecyclerTests extends AbstractRecyclerTests { @ Override protected Recycler < byte [ ] > newRecycler ( ) { <START_BUG> return new NoneRecycler < byte [ ] > ( RECYCLER_C ) ; <END_BUG> } }
public class StarredGistsFragment extends GistsFragment { @ Inject private AvatarHelper avatarHelper ; @ Override public Loader < List < Gist > > onCreateLoader ( int i , Bundle bundle ) { } @ Override protected ViewHoldingListAdapter < Gist > adapterFor ( List < Gist > items ) { <START_BUG> return new ViewHoldingListAdapter < Gist > ( items , viewInflatorFor ( getActivity ( ) , gist_list_item ) , reflectiveFactoryFor ( GistViewHolder . class , GistViewHolder . computeMaxDigits ( items ) , avatarHelper ) ) ; <END_BUG> } }
private static Builder setRandomMerge ( Random random , ImmutableSettings . Builder builder ) { } private static Builder setRandomNormsLoading ( Random random , ImmutableSettings . Builder builder ) { } private static Builder setRandomTranslogSettings ( Random random , ImmutableSettings . Builder builder ) { } public TestCluster buildAndPutCluster ( ElasticsearchIntegrationTest . Scope currentClusterScope , boolean createIfExists ) throws IOException { } private static void clearClusters ( ) throws IOException { } protected final void afterInternal ( ) throws IOException { } public static TestCluster cluster ( ) { } public static boolean isInternalCluster ( ) { } public static InternalTestCluster internalCluster ( ) { } public ClusterService clusterService ( ) { } public static Client client ( ) { } public static Client client ( @ Nullable String node ) { } public static Client dataNodeClient ( ) { } public static Iterable < Client > clients ( ) { } protected int minimumNumberOfShards ( ) { } protected int maximumNumberOfShards ( ) { } protected int numberOfShards ( ) { } protected int minimumNumberOfReplicas ( ) { } protected int maximumNumberOfReplicas ( ) { } protected int numberOfReplicas ( ) { } public void setDisruptionScheme ( ServiceDisruptionScheme scheme ) { } public void clearDisruptionScheme ( ) { } public Settings indexSettings ( ) { } public final void createIndex ( String ... names ) { } public final CreateIndexRequestBuilder prepareCreate ( String index ) { } public final CreateIndexRequestBuilder prepareCreate ( String index , int numNodes ) { } public CreateIndexRequestBuilder prepareCreate ( String index , int numNodes , ImmutableSettings . Builder settingsBuilder ) { } private Builder getExcludeSettings ( String index , int num , ImmutableSettings . Builder builder ) { } public void waitNoPendingTasksOnAll ( ) throws Exception { } public void waitNoPendingTasksOnMaster ( ) throws Exception { } public void waitForConcreteMappingsOnAll ( final String index , final String type , final String ... fieldNames ) throws Exception { } public void waitForMappingOnMaster ( final String index , final String type , final String ... fieldNames ) throws Exception { } public void allowNodes ( String index , int n ) { } public ClusterHealthStatus ensureGreen ( String ... indices ) { } public ClusterHealthStatus ensureGreen ( TimeValue timeout , String ... indices ) { } public ClusterHealthStatus waitForRelocation ( ) { } public ClusterHealthStatus waitForRelocation ( ClusterHealthStatus status ) { } public long waitForDocs ( final long numDocs ) throws InterruptedException { } public long waitForDocs ( final long numDocs , @ Nullable final BackgroundIndexer indexer ) throws InterruptedException { } public long waitForDocs ( final long numDocs , int maxWaitTime , TimeUnit maxWaitTimeUnit , @ Nullable final BackgroundIndexer indexer ) throws InterruptedException { } public void setMinimumMasterNodes ( int n ) { } public ClusterHealthStatus ensureYellow ( String ... indices ) { } public void logClusterState ( ) { } void ensureClusterSizeConsistency ( ) { } protected ClusterHealthStatus ensureSearchable ( String ... indices ) { } protected final IndexResponse index ( String index , String type , XContentBuilder source ) { } protected final IndexResponse index ( String index , String type , String id , Map < String , Object > source ) { } protected final GetResponse get ( String index , String type , String id ) { } protected final IndexResponse index ( String index , String type , String id , XContentBuilder source ) { } protected final IndexResponse index ( String index , String type , String id , Object ... source ) { } protected final IndexResponse index ( String index , String type , String id , String source ) { } protected final RefreshResponse refresh ( ) { } protected final void flushAndRefresh ( ) { } protected final FlushResponse flush ( ) { } private FlushResponse flush ( boolean ignoreNotAllowed ) { } protected OptimizeResponse optimize ( ) { waitForRelocation ( ) ; <START_BUG> OptimizeResponse actionGet = ElasticsearchIntegrationTest . client ( ) . admin ( ) . indices ( ) . prepareOptimize ( ) . setForce ( randomBoolean ( ) ) . execute ( ) . actionGet ( ) ; <END_BUG> assertNoFailures ( actionGet ) ; return actionGet ; } protected boolean indexExists ( String index ) { } protected AdminClient admin ( ) { } public void indexRandom ( boolean forceRefresh , IndexRequestBuilder ... builders ) throws InterruptedException , ExecutionException { } public void indexRandom ( boolean forceRefresh , boolean dummyDocuments , IndexRequestBuilder ... builders ) throws InterruptedException , ExecutionException { } private static final String RANDOM_BOGUS_TYPE = "RANDOM_BOGUS_TYPE______" ; public void indexRandom ( boolean forceRefresh , List < IndexRequestBuilder > builders ) throws InterruptedException , ExecutionException { } public void indexRandom ( boolean forceRefresh , boolean dummyDocuments , List < IndexRequestBuilder > builders ) throws InterruptedException , ExecutionException { } public void indexRandom ( boolean forceRefresh , boolean dummyDocuments , boolean maybeFlush , List < IndexRequestBuilder > builders ) throws InterruptedException , ExecutionException { } public static void disableTranslogFlush ( String index ) { } public static void enableTranslogFlush ( String index ) { } private static CountDownLatch newLatch ( List < CountDownLatch > latches ) { } private void postIndexAsyncActions ( String [ ] indices , List < CountDownLatch > inFlightAsyncOperations , boolean maybeFlush ) throws InterruptedException { } public static enum Scope { GLOBAL , SUITE , TEST ; } @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE } ) public @ interface ClusterScope { ElasticsearchIntegrationTest . Scope scope ( ) default ElasticsearchIntegrationTest . Scope . GLOBAL ; int numDataNodes ( ) default - 1 ; int minNumDataNodes ( ) default InternalTestCluster . DEFAULT_MIN_NUM_DATA_NODES ; int maxNumDataNodes ( ) default InternalTestCluster . DEFAULT_MAX_NUM_DATA_NODES ; int numClientNodes ( ) default InternalTestCluster . DEFAULT_NUM_CLIENT_NODES ; boolean enableRandomBenchNodes ( ) default InternalTestCluster . DEFAULT_ENABLE_RANDOM_BENCH_NODES ; double transportClientRatio ( ) default - 1 ; boolean randomDynamicTemplates ( ) default true ; } private class LatchedActionListener < Response > implements ActionListener < Response > { private final CountDownLatch latch ;
public class Hiero4 extends JFrame { static final String NEHE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ\n" + ( "abcdefghijklmnopqrstuvwxyz\n1234567890\n" + "\"!`?\'.,;:()[]{}<>|/@\\^$-%+=#_&~*" ) ; Color renderingBackgroundColor = Color . BLACK ; Preferences prefs ; Hiero4 . Renderer renderer ; FontData fontData ; FontGenerator fontGenerator ; HashSet < Character > sampleChars = new HashSet ( 256 ) ; HashSet < Character > remainingSampleChars = new HashSet ( 256 ) ; JScrollPane appliedEffectsScroll ; JPanel appliedEffectsPanel ; JButton addEffectButton ; JTextPane sampleTextPane ; JSpinner padAdvanceXSpinner ; JList effectsList ; JPanel gamePanel ; JTextField fontFileText ; JRadioButton fontFileRadio ; JRadioButton systemFontRadio ; JSpinner padBottomSpinner ; JSpinner padLeftSpinner ; JSpinner padRightSpinner ; JSpinner padTopSpinner ; JList fontList ; JSpinner fontSizeSpinner ; DefaultComboBoxModel fontListModel ; JLabel backgroundColorLabel ; JButton browseButton ; JSpinner padAdvanceYSpinner ; JCheckBox italicCheckBox ; JCheckBox boldCheckBox ; JRadioButton vectorRadio ; JRadioButton drawStringRadio ; JRadioButton freetypeRadio ; JComboBox glyphPageHeightCombo ; JComboBox glyphPageWidthCombo ; JPanel glyphCachePanel ; JRadioButton glyphCacheRadio ; JRadioButton sampleTextRadio ; JButton sampleAsciiButton ; JButton sampleNeheButton ; DefaultComboBoxModel effectsListModel ; JMenuItem openMenuItem ; JMenuItem saveMenuItem ; JMenuItem exitMenuItem ; JMenuItem saveBMFontMenuItem ; public Hiero4 ( ) { } void initialize ( ) { } void changeFont ( ) { } void updateFont ( boolean force ) { if ( ( ( fontData ) == null ) || ( ( renderer . batch ) == null ) ) return ; final String text = sampleTextPane . getText ( ) ; if ( ! force ) { boolean newCharFound = false ; remainingSampleChars . clear ( ) ; remainingSampleChars . addAll ( sampleChars ) ; for ( int i = ( text . length ( ) ) - 1 ; i >= 0 ; i -- ) { Character ch = text . charAt ( i ) ; if ( sampleChars . add ( ch ) ) newCharFound = true ; remainingSampleChars . remove ( ch ) ; } if ( ( ! newCharFound ) && ( remainingSampleChars . isEmpty ( ) ) ) return ; } sampleChars . clear ( ) ; for ( int i = ( text . length ( ) ) - 1 ; i >= 0 ; i -- ) sampleChars . add ( text . charAt ( i ) ) ; int fontSize = ( ( Integer ) ( fontSizeSpinner . getValue ( ) ) ) . intValue ( ) ; int style = Font . PLAIN ; if ( boldCheckBox . isSelected ( ) ) { style = Font . BOLD ; if ( italicCheckBox . isSelected ( ) ) style |= Font . ITALIC ; } else if ( italicCheckBox . isSelected ( ) ) style = Font . ITALIC ; fontData = fontData . deriveFont ( fontSize , style ) ; int sampleFontSize = sampleTextPane . getFont ( ) . getSize ( ) ; if ( sampleFontSize < 14 ) sampleFontSize = 14 ; sampleTextPane . setFont ( fontData . getJavaFont ( ) . deriveFont ( ( ( float ) ( sampleFontSize ) ) ) ) ; final Padding padding = new Padding ( ( ( Integer ) ( padTopSpinner . getValue ( ) ) ) , ( ( Integer ) ( padLeftSpinner . getValue ( ) ) ) , ( ( Integer ) ( padBottomSpinner . getValue ( ) ) ) , ( ( Integer ) ( padRightSpinner . getValue ( ) ) ) , ( ( Integer ) ( padAdvanceXSpinner . getValue ( ) ) ) ) ; final int width = ( ( Integer ) ( glyphPageWidthCombo . getSelectedItem ( ) ) ) ; final int height = ( ( Integer ) ( glyphPageHeightCombo . getSelectedItem ( ) ) ) ; final GeneratorMethod method ; if ( vectorRadio . isSelected ( ) ) method = GeneratorMethod . AWT_VECTOR ; else if ( drawStringRadio . isSelected ( ) ) method = GeneratorMethod . AWT_DRAWSTRING ; else method = GeneratorMethod . FREETYPE2 ; new Thread ( ) { public void run ( ) { fontGenerator = new FontGenerator ( fontData , method ) ; CharSet charset = new CharSet ( ) ; charset . setManualCharacters ( text ) ; try { fontGenerator . generate ( width , height , charset , padding , new Effect . Renderer [ 0 ] , true ) ; fontGenerator . write ( new File ( "out" ) , TEXT ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { final ByteBuffer buffer = ByteBuffer . allocateDirect ( ( ( 1024 * 1024 ) * 4 ) ) ; buffer . order ( ByteOrder . LITTLE_ENDIAN ) ; fontGenerator . getTextureData ( buffer . asIntBuffer ( ) ) ; TextureRegion glyphRegion = new TextureRegion ( new Texture ( new TextureData ( ) { Pixmap pixmap ; public int getWidth ( ) { return width ; } public int getHeight ( ) { return height ; } @ Override public Pixmap consumePixmap ( ) { this . pixmap = new Pixmap ( width , height , Format . RGBA8888 ) ; pixmap . getPixels ( ) . put ( buffer ) ; pixmap . getPixels ( ) . rewind ( ) ; return pixmap ; } @ Override public boolean disposePixmap ( ) { return true ; } @ Override public Format getFormat ( ) { return pixmap . getFormat ( ) ; } @ Override public boolean useMipMaps ( ) { return false ; } @ Override public boolean isManaged ( ) { return true ; } @ Override public TextureDataType getType ( ) { return TextureDataType . Pixmap ; } @ Override <START_BUG> public void consumeCompressedData ( int target ) { <END_BUG> } @ Override public boolean isPrepared ( ) { return true ; } @ Override public void prepare ( ) { } } ) ) ; renderer . font = new BitmapFont ( files . absolute ( "out" ) , glyphRegion , false ) ; } } ) ; } } . start ( ) ; } private void initializeEvents ( ) { } private void initializeComponents ( ) { } private void initializeMenus ( ) { } static Icon getColorIcon ( java . awt . Color color ) { } private static class Splash extends JWindow { final int minMillis ; final long startTime ; public Splash ( Frame frame , String imageFile , int minMillis ) { }
public class BufferUtils { static Array < ByteBuffer > unsafeBuffers = new Array < ByteBuffer > ( ) ; static int allocatedUnsafe = 0 ; public static void copy ( float [ ] src , Buffer dst , int numFloats , int offset ) { } public static void copy ( byte [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( short [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( char [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( int [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( long [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( float [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( double [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( Buffer src , Buffer dst , int numElements ) { } private static int positionInBytes ( Buffer dst ) { } private static int bytesToElements ( Buffer dst , int bytes ) { } private static int elementsToBytes ( Buffer dst , int elements ) { } public static FloatBuffer newFloatBuffer ( int numFloats ) { } public static DoubleBuffer newDoubleBuffer ( int numDoubles ) { } public static ByteBuffer newByteBuffer ( int numBytes ) { } public static ShortBuffer newShortBuffer ( int numShorts ) { } public static CharBuffer newCharBuffer ( int numChars ) { } public static IntBuffer newIntBuffer ( int numInts ) { } public static LongBuffer newLongBuffer ( int numLongs ) { } public static void disposeUnsafeByteBuffer ( ByteBuffer buffer ) { <START_BUG> int size = 0 ; <END_BUG> synchronized ( BufferUtils . unsafeBuffers ) { if ( ! ( BufferUtils . unsafeBuffers . removeValue ( buffer , true ) ) ) throw new IllegalArgumentException ( "buffer<seq2seq4repair_space>not<seq2seq4repair_space>allocated<seq2seq4repair_space>with<seq2seq4repair_space>newUnsafeByteBuffer<seq2seq4repair_space>or<seq2seq4repair_space>already<seq2seq4repair_space>disposed" ) ; } BufferUtils . allocatedUnsafe -= size ; BufferUtils . freeMemory ( buffer ) ; } public static ByteBuffer newUnsafeByteBuffer ( int numBytes ) { } public static int getAllocatedBytesUnsafe ( ) { } private static native void freeMemory ( ByteBuffer buffer ) { } private static native ByteBuffer newDisposableByteBuffer ( int numBytes ) { } public static native void clear ( ByteBuffer buffer , int numBytes ) { } private static native void copyJni ( float [ ] src , Buffer dst , int numFloats , int offset ) { } private static native void copyJni ( byte [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( char [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( short [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( int [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( long [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( float [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( double [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( Buffer src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } }
public class Label extends Widget { final Label . LabelStyle style ; final BitmapFontCache cache ; String text ; public Label ( String name , String text , Label . LabelStyle style ) { } public void setText ( String text ) { this . text = text ; TextBounds bounds = style . font . getMultiLineBounds ( text ) ; cache . setMultiLineText ( text , 0 , bounds . height ) ; prefWidth = bounds . width ; <START_BUG> prefHeight = bounds . height ; <END_BUG> invalidateHierarchy ( ) ; } public String getText ( ) { } public void setColor ( float color ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public Color getColor ( ) { } @ Override public void layout ( ) { } @ Override public void draw ( SpriteBatch batch , float parentAlpha ) { } @ Override public boolean touchDown ( float x , float y , int pointer ) { } @ Override public void touchUp ( float x , float y , int pointer ) { } @ Override public void touchDragged ( float x , float y , int pointer ) { } @ Override public Actor hit ( float x , float y ) { } public static class LabelStyle { public BitmapFont font ; public Color fontColor ; public LabelStyle ( ) { } public LabelStyle ( BitmapFont font , Color fontColor ) { } } }
public class FieldMappersFieldSelector implements FieldSelector { private final HashSet < String > names = new HashSet < String > ( ) ; public void add ( FieldMappers fieldMappers ) { for ( FieldMapper fieldMapper : fieldMappers ) { <START_BUG> names . add ( fieldMapper . indexName ( ) ) ; <END_BUG> } } @ Override public FieldSelectorResult accept ( String fieldName ) { } }
public class AnalyzingCompletionLookupProviderV1 extends CompletionLookupProvider { public static final int SERIALIZE_PRESERVE_SEPERATORS = 1 ; public static final int SERIALIZE_HAS_PAYLOADS = 2 ; public static final int SERIALIZE_PRESERVE_POSITION_INCREMENTS = 4 ; private static final int MAX_SURFACE_FORMS_PER_ANALYZED_FORM = 256 ; private static final int MAX_GRAPH_EXPANSIONS = - 1 ; public static final String CODEC_NAME = "analyzing" ; public static final int CODEC_VERSION = 1 ; private boolean preserveSep ; private boolean preservePositionIncrements ; private int maxSurfaceFormsPerAnalyzedForm ; private int maxGraphExpansions ; private boolean hasPayloads ; private final XAnalyzingSuggester prototype ; public static final int SEP_LABEL = 255 ; public static final int END_BYTE = 0 ; public static final int PAYLOAD_SEP = '<seq2seq4repair_space>' ; public AnalyzingCompletionLookupProviderV1 ( boolean preserveSep , boolean exactFirst , boolean preservePositionIncrements , boolean hasPayloads ) { } @ Override public String getName ( ) { } @ Override public FieldsConsumer consumer ( final IndexOutput output ) throws IOException { } private static final class CompletionPostingsConsumer extends PostingsConsumer { private final SuggestPayload spare = new SuggestPayload ( ) ; private AnalyzingCompletionLookupProviderV1 analyzingSuggestLookupProvider ; private XBuilder builder ; private int maxAnalyzedPathsForOneInput = 0 ; public CompletionPostingsConsumer ( AnalyzingCompletionLookupProviderV1 analyzingSuggestLookupProvider , XAnalyzingSuggester . XBuilder builder ) { } @ Override public void startDoc ( int docID , int freq ) throws IOException { } @ Override public void addPosition ( int position , BytesRef payload , int startOffset , int endOffset ) throws IOException { analyzingSuggestLookupProvider . parsePayload ( payload , spare ) ; <START_BUG> builder . addSurface ( spare . surfaceForm , spare . payload , spare . weight ) ; <END_BUG> maxAnalyzedPathsForOneInput = Math . max ( maxAnalyzedPathsForOneInput , ( position + 1 ) ) ; } @ Override public void finishDoc ( ) throws IOException { } public int getMaxAnalyzedPathsForOneInput ( ) { } } @ Override public LookupFactory load ( IndexInput input ) throws IOException { } @ Override public Set < IntsRef > toFiniteStrings ( TokenStream stream ) throws IOException { } }
public class GestureDetector extends InputAdapter { final GestureDetector . GestureListener listener ; private float tapSquareSize ; private long tapCountInterval ; private float longPressSeconds ; private long maxFlingDelay ; private boolean inTapSquare ; private int tapCount ; private long lastTapTime ; private float lastTapX ; private float lastTapY ; private int lastTapButton ; private int lastTapPointer ; boolean longPressFired ; private boolean pinching ; private boolean panning ; private final GestureDetector . VelocityTracker tracker = new GestureDetector . VelocityTracker ( ) ; private float tapSquareCenterX ; private float tapSquareCenterY ; private long gestureStartTime ; Vector2 pointer1 = new Vector2 ( ) ; private final Vector2 pointer2 = new Vector2 ( ) ; private final Vector2 initialPointer1 = new Vector2 ( ) ; private final Vector2 initialPointer2 = new Vector2 ( ) ; private final Task longPressTask = new Task ( ) { @ Override public void run ( ) { } } ; public GestureDetector ( GestureDetector . GestureListener listener ) { } public GestureDetector ( float halfTapSquareSize , float tapCountInterval , float longPressDuration , float maxFlingDelay , GestureDetector . GestureListener listener ) { } @ Override public boolean touchDown ( int x , int y , int pointer , int button ) { } public boolean touchDown ( float x , float y , int pointer , int button ) { } @ Override public boolean touchDragged ( int x , int y , int pointer ) { } public boolean touchDragged ( float x , float y , int pointer ) { } @ Override public boolean touchUp ( int x , int y , int pointer , int button ) { } public boolean touchUp ( float x , float y , int pointer , int button ) { } public void cancel ( ) { } public boolean isLongPressed ( ) { } public boolean isLongPressed ( float duration ) { } public boolean isPanning ( ) { } public void reset ( ) { } private boolean isWithinTapSquare ( float x , float y , float centerX , float centerY ) { } public void invalidateTapSquare ( ) { } <START_BUG> public void setTapSquareSize ( int tapSquareSize ) { <END_BUG> this . tapSquareSize = tapSquareSize ; } public void setTapCountInterval ( float tapCountInterval ) { } public void setLongPressSeconds ( float longPressSeconds ) { } public void setMaxFlingDelay ( long maxFlingDelay ) { } public static interface GestureListener { public boolean touchDown ( float x , float y , int pointer , int button ) { } public boolean tap ( float x , float y , int count , int button ) { } public boolean longPress ( float x , float y ) { } public boolean fling ( float velocityX , float velocityY , int button ) { } public boolean pan ( float x , float y , float deltaX , float deltaY ) { } public boolean panStop ( float x , float y , int pointer , int button ) { } public boolean zoom ( float initialDistance , float distance ) { } public boolean pinch ( Vector2 initialPointer1 , Vector2 initialPointer2 , Vector2 pointer1 , Vector2 pointer2 ) { } } public static class GestureAdapter implements GestureDetector . GestureListener { @ Override public boolean touchDown ( float x , float y , int pointer , int button ) { } @ Override public boolean tap ( float x , float y , int count , int button ) { } @ Override public boolean longPress ( float x , float y ) { } @ Override public boolean fling ( float velocityX , float velocityY , int button ) { } @ Override public boolean pan ( float x , float y , float deltaX , float deltaY ) { } @ Override public boolean panStop ( float x , float y , int pointer , int button ) { } @ Override public boolean zoom ( float initialDistance , float distance ) { } @ Override public boolean pinch ( Vector2 initialPointer1 , Vector2 initialPointer2 , Vector2 pointer1 , Vector2 pointer2 ) { } } static class VelocityTracker { int sampleSize = 10 ; float lastX ; float lastY ; float deltaX ; float deltaY ; long lastTime ; int numSamples ; float [ ] meanX = new float [ sampleSize ] ; float [ ] meanY = new float [ sampleSize ] ; long [ ] meanTime = new long [ sampleSize ] ; public void start ( float x , float y , long timeStamp ) { } public void update ( float x , float y , long timeStamp ) { } public float getVelocityX ( ) { } public float getVelocityY ( ) { } private float getAverage ( float [ ] values , int numSamples ) { } private long getAverage ( long [ ] values , int numSamples ) { } private float getSum ( float [ ] values , int numSamples ) { } } }
public class CubemapAttribute extends Attribute { public static final String EnvironmentMapAlias = "environmentMapTexture" ; public static final long EnvironmentMap = register ( CubemapAttribute . EnvironmentMapAlias ) ; protected static long Mask = CubemapAttribute . EnvironmentMap ; public static final boolean is ( final long mask ) { } public final TextureDescriptor < Cubemap > textureDescription ; public CubemapAttribute ( final long type ) { } public < T extends Cubemap > CubemapAttribute ( final long type , final TextureDescriptor < T > textureDescription ) { } public CubemapAttribute ( final long type , final Cubemap texture ) { } public CubemapAttribute ( final CubemapAttribute copyFrom ) { } @ Override public Attribute copy ( ) { } @ Override public int hashCode ( ) { <START_BUG> int result = ( ( int ) ( type ) ) ; <END_BUG> result = ( 967 * result ) + ( textureDescription . hashCode ( ) ) ; return result ; } }
public class BufferUtils { static Array < ByteBuffer > unsafeBuffers = new Array < ByteBuffer > ( ) ; static int allocatedUnsafe = 0 ; public static void copy ( float [ ] src , Buffer dst , int numFloats , int offset ) { } public static void copy ( byte [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( short [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( char [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( int [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( long [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( float [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( double [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( Buffer src , Buffer dst , int numElements ) { } private static int positionInBytes ( Buffer dst ) { } private static int bytesToElements ( Buffer dst , int bytes ) { } private static int elementsToBytes ( Buffer dst , int elements ) { } public static FloatBuffer newFloatBuffer ( int numFloats ) { } public static DoubleBuffer newDoubleBuffer ( int numDoubles ) { } public static ByteBuffer newByteBuffer ( int numBytes ) { } public static ShortBuffer newShortBuffer ( int numShorts ) { } public static CharBuffer newCharBuffer ( int numChars ) { } public static IntBuffer newIntBuffer ( int numInts ) { } public static LongBuffer newLongBuffer ( int numLongs ) { } public static void disposeUnsafeByteBuffer ( ByteBuffer buffer ) { } public static ByteBuffer newUnsafeByteBuffer ( int numBytes ) { } public static long getUnsafeBufferAddress ( Buffer buffer ) { <START_BUG> return BufferUtils . getBufferAddress ( buffer ) ; <END_BUG> } public static ByteBuffer newUnsafeByteBuffer ( ByteBuffer buffer ) { } public static int getAllocatedBytesUnsafe ( ) { } private static native void freeMemory ( ByteBuffer buffer ) { } private static native ByteBuffer newDisposableByteBuffer ( int numBytes ) { } private static native long getBufferAddress ( Buffer buffer ) { } public static native void clear ( ByteBuffer buffer , int numBytes ) { } private static native void copyJni ( float [ ] src , Buffer dst , int numFloats , int offset ) { } private static native void copyJni ( byte [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( char [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( short [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( int [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( long [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( float [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( double [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( Buffer src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } }
public class BigArraysTests extends ElasticsearchTestCase { public static BigArrays randombigArrays ( ) { <START_BUG> final PageCacheRecycler recycler = ( randomBoolean ( ) ) ? null : new org . elasticsearch . test . cache . recycler . MockPageCacheRecycler ( ImmutableSettings . EMPTY , new ThreadPool ( ) ) ; <END_BUG> return new org . elasticsearch . test . cache . recycler . MockBigArrays ( ImmutableSettings . EMPTY , recycler ) ; } private BigArrays bigArrays ; @ Before public void init ( ) { } public void testByteArrayGrowth ( ) { } public void testIntArrayGrowth ( ) { } public void testLongArrayGrowth ( ) { } public void testFloatArrayGrowth ( ) { } public void testDoubleArrayGrowth ( ) { } public void testObjectArrayGrowth ( ) { } public void testByteArrayFill ( ) { } public void testFloatArrayFill ( ) { } public void testDoubleArrayFill ( ) { } public void testLongArrayFill ( ) { } public void testByteArrayBulkGet ( ) { } public void testByteArrayBulkSet ( ) { } public void testByteArrayEquals ( ) { } public void testByteArrayHashCode ( ) { } private ByteArray byteArrayWithBytes ( byte [ ] bytes ) { } public void testByteAccounting ( ) throws Exception { } public void testMaxSizeExceededOnNew ( ) throws Exception { } public void testMaxSizeExceededOnResize ( ) throws Exception { } }
public Vector3 ( final Vector3 vector ) { } public Vector3 ( final float [ ] values ) { } public Vector3 ( final Vector2 vector , float z ) { } public Vector3 set ( float x , float y , float z ) { } @ Override public Vector3 set ( final Vector3 vector ) { } public Vector3 set ( final float [ ] values ) { } public Vector3 set ( final Vector2 vector , float z ) { } @ Override public Vector3 cpy ( ) { } @ Override public Vector3 add ( final Vector3 vector ) { } public Vector3 add ( float x , float y , float z ) { } public Vector3 add ( float values ) { } @ Override public Vector3 sub ( final Vector3 a_vec ) { } public Vector3 sub ( float x , float y , float z ) { } public Vector3 sub ( float value ) { } @ Override public Vector3 scl ( float scalar ) { } @ Override public Vector3 scl ( final Vector3 other ) { } public Vector3 scl ( float vx , float vy , float vz ) { } @ Override public Vector3 mulAdd ( Vector3 vec , float scalar ) { } @ Override public Vector3 mulAdd ( Vector3 vec , Vector3 mulVec ) { } public static float len ( final float x , final float y , final float z ) { } @ Override public float len ( ) { } public static float len2 ( final float x , final float y , final float z ) { } @ Override public float len2 ( ) { } public boolean idt ( final Vector3 vector ) { } public static float dst ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } @ Override public float dst ( final Vector3 vector ) { } public float dst ( float x , float y , float z ) { } public static float dst2 ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } @ Override public float dst2 ( Vector3 point ) { } public float dst2 ( float x , float y , float z ) { } @ Override public Vector3 nor ( ) { } public static float dot ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { } @ Override public float dot ( final Vector3 vector ) { } public float dot ( float x , float y , float z ) { } public Vector3 crs ( final Vector3 vector ) { } public Vector3 crs ( float x , float y , float z ) { } public Vector3 mul4x3 ( float [ ] matrix ) { } public Vector3 mul ( final Matrix4 matrix ) { } public Vector3 traMul ( final Matrix4 matrix ) { } public Vector3 mul ( Matrix3 matrix ) { } public Vector3 traMul ( Matrix3 matrix ) { } public Vector3 mul ( final Quaternion quat ) { } public Vector3 prj ( final Matrix4 matrix ) { } public Vector3 rot ( final Matrix4 matrix ) { } public Vector3 unrotate ( final Matrix4 matrix ) { } public Vector3 untransform ( final Matrix4 matrix ) { } public Vector3 rotate ( float degrees , float axisX , float axisY , float axisZ ) { } public Vector3 rotateRad ( float radians , float axisX , float axisY , float axisZ ) { } public Vector3 rotate ( final Vector3 axis , float degrees ) { } public Vector3 rotateRad ( final Vector3 axis , float radians ) { } @ Override public boolean isUnit ( ) { } @ Override public boolean isUnit ( final float margin ) { } @ Override public boolean isZero ( ) { } @ Override public boolean isZero ( final float margin ) { } @ Override public boolean isOnLine ( Vector3 other , float epsilon ) { } @ Override public boolean isOnLine ( Vector3 other ) { } @ Override public boolean isCollinear ( Vector3 other , float epsilon ) { } @ Override public boolean isCollinear ( Vector3 other ) { } @ Override public boolean isCollinearOpposite ( Vector3 other , float epsilon ) { } @ Override public boolean isCollinearOpposite ( Vector3 other ) { } @ Override public boolean isPerpendicular ( Vector3 vector ) { } @ Override public boolean isPerpendicular ( Vector3 vector , float epsilon ) { } @ Override public boolean hasSameDirection ( Vector3 vector ) { } @ Override public boolean hasOppositeDirection ( Vector3 vector ) { } @ Override public Vector3 lerp ( final Vector3 target , float alpha ) { } @ Override public Vector3 interpolate ( Vector3 target , float alpha , Interpolation interpolator ) { } public Vector3 slerp ( final Vector3 target , float alpha ) { } public String toString ( ) { <START_BUG> return ( ( ( ( x ) + "," ) + ( y ) ) + "," ) + ( z ) ; <END_BUG> } @ Override public Vector3 limit ( float limit ) { } @ Override public Vector3 clamp ( float min , float max ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } @ Override public boolean epsilonEquals ( final Vector3 other , float epsilon ) { } public boolean epsilonEquals ( float x , float y , float z , float epsilon ) { } @ Override public Vector3 setZero ( ) { } }
public class QuickSelect < T > { private T [ ] array ; private Comparator < ? super T > comp ; public int select ( T [ ] items , Comparator < T > comp , int n , int size ) { } private int partition ( int left , int right , int pivot ) { T pivotValue = array [ pivot ] ; swap ( right , pivot ) ; int storage = left ; for ( int i = left ; i < right ; i ++ ) { <START_BUG> if ( ( comp . compare ( array [ i ] , pivotValue ) ) < 0 ) { <END_BUG> swap ( storage , i ) ; storage ++ ; } } swap ( right , storage ) ; return storage ; } private int recursiveSelect ( int left , int right , int k ) { } private int medianOfThreePivot ( int leftIdx , int rightIdx ) { } private void swap ( int left , int right ) { } }
public class TransferThreadPoolExecutor extends AbstractExecutorService { private final TransferQueue < Runnable > workQueue = new org . elasticsearch . common . util . concurrent . jsr166y . LinkedTransferQueue < Runnable > ( ) ; private final AtomicInteger queueSize = new AtomicInteger ( ) ; private final ReentrantLock mainLock = new ReentrantLock ( ) ; private final Condition termination = mainLock . newCondition ( ) ; private final HashSet < TransferThreadPoolExecutor . Worker > workers = new HashSet < TransferThreadPoolExecutor . Worker > ( ) ; private final ThreadFactory threadFactory ; volatile int runState ; static final int RUNNING = 0 ; static final int SHUTDOWN = 1 ; static final int STOP = 2 ; static final int TERMINATED = 3 ; private final boolean blocking ; private final int blockingCapacity ; private final long blockingTime ; private final int corePoolSize ; private final int maximumPoolSize ; private final long keepAliveTime ; private final AtomicInteger poolSize = new AtomicInteger ( ) ; public static TransferThreadPoolExecutor newScalingExecutor ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory ) { } public static TransferThreadPoolExecutor newBlockingExecutor ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , long blockingTime , TimeUnit blockingUnit , int blockingCapacity , ThreadFactory threadFactory ) { } private TransferThreadPoolExecutor ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , boolean blocking , long blockingTime , TimeUnit blockingUnit , int blockingCapacity , ThreadFactory threadFactory ) { } @ Override public void execute ( Runnable command ) { } private void executeNonBlocking ( Runnable command ) { } private void executeBlocking ( Runnable command ) { } private void transferOrAddBlocking ( Runnable command , int currentCapacity ) { } @ Override public void shutdown ( ) { } @ Override public List < Runnable > shutdownNow ( ) { } @ Override public boolean isShutdown ( ) { } @ Override public boolean isTerminated ( ) { } @ Override public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { } public int getPoolSize ( ) { } public int getActiveCount ( ) { } public int getCorePoolSize ( ) { } public int getMaximumPoolSize ( ) { } public int getQueueSize ( ) { } private final class Worker implements Runnable { private final ReentrantLock runLock = new ReentrantLock ( ) ; Thread thread ; Worker ( ) { } boolean isActive ( ) { } void interruptIfIdle ( ) { } void interruptNow ( ) { } private void runTask ( Runnable task ) { } public void run ( ) { } } Runnable getTask ( ) { } private boolean workerCanExit ( ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; boolean canExit ; try { <START_BUG> canExit = ( ( runState ) >= ( TransferThreadPoolExecutor . STOP ) ) || ( ( ( queueSize . get ( ) ) == 0 ) && ( ( poolSize . get ( ) ) > ( corePoolSize ) ) ) ; <END_BUG> } finally { mainLock . unlock ( ) ; } return canExit ; } void interruptIdleWorkers ( ) { } void workerDone ( TransferThreadPoolExecutor . Worker w ) { } private void tryTerminate ( ) { } private Thread addWorker ( ) { } private Thread addThread ( ) { } private List < Runnable > drainQueue ( ) { } }
public class TopChildrenQuery extends Query implements ScopePhase . TopDocsPhase { private Query query ; private String scope ; private String parentType ; private String childType ; private ScoreType scoreType ; private int factor ; private int incrementalFactor ; private Map < Object , TopChildrenQuery . ParentDoc [ ] > parentDocs ; private int numHits = 0 ; private boolean [ ] properlyInvoked = new boolean [ ] { false } ; public TopChildrenQuery ( Query query , String scope , String childType , String parentType , ScoreType scoreType , int factor , int incrementalFactor ) { } @ Override public Query query ( ) { } @ Override public String scope ( ) { } @ Override public void clear ( ) { } @ Override public int numHits ( ) { } @ Override public int factor ( ) { } @ Override public int incrementalFactor ( ) { } @ Override public void processResults ( TopDocs topDocs , SearchContext context ) { } private static final TopChildrenQuery . ParentDocComparator PARENT_DOC_COMP = new TopChildrenQuery . ParentDocComparator ( ) ; static class ParentDocComparator implements Comparator < TopChildrenQuery . ParentDoc > { @ Override public int compare ( TopChildrenQuery . ParentDoc o1 , TopChildrenQuery . ParentDoc o2 ) { } } public static class ParentDoc { public int docId ; public int count ; public float maxScore = Float . NaN ; public float sumScores = 0 ; } @ Override public Query rewrite ( IndexReader reader ) throws IOException { } @ Override public void extractTerms ( Set < Term > terms ) { } @ Override public Weight createWeight ( IndexSearcher searcher ) throws IOException { } public String toString ( String field ) { } class ParentWeight extends Weight { final IndexSearcher searcher ; final Weight queryWeight ; public ParentWeight ( IndexSearcher searcher , Weight queryWeight ) throws IOException { } public Query getQuery ( ) { } @ Override public float getValueForNormalization ( ) throws IOException { } @ Override public void normalize ( float norm , float topLevelBoost ) { } @ Override public Scorer scorer ( AtomicReaderContext context , boolean scoreDocsInOrder , boolean topScorer , Bits acceptDocs ) throws IOException { } @ Override public Explanation explain ( AtomicReaderContext context , int doc ) throws IOException { } } class ParentScorer extends Scorer { private final TopChildrenQuery . ParentDoc [ ] docs ; private int index = - 1 ; private ParentScorer ( TopChildrenQuery . ParentWeight weight , TopChildrenQuery . ParentDoc [ ] docs ) throws IOException { } @ Override public int docID ( ) { } @ Override public int advance ( int target ) throws IOException { } @ Override public int nextDoc ( ) throws IOException { } @ Override public float score ( ) throws IOException { } @ Override <START_BUG> public float freq ( ) throws IOException { <END_BUG> return docs [ index ] . count ; } } }
public final class ClassReflection { public static Class forName ( String name ) throws ReflectionException { } public static String getSimpleName ( Class c ) { } public static boolean isInstance ( Class c , Object obj ) { <START_BUG> return ( obj != null ) && ( ClassReflection . isAssignableFrom ( c , obj . getClass ( ) ) ) ; <END_BUG> } public static boolean isAssignableFrom ( Class c1 , Class c2 ) { } public static boolean isMemberClass ( Class c ) { } public static boolean isStaticClass ( Class c ) { } public static < T > T newInstance ( Class < T > c ) throws ReflectionException { } public static Constructor [ ] getConstructors ( Class c ) { } public static Constructor getConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Constructor getDeclaredConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getMethods ( Class c ) { } public static Method getMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getDeclaredMethods ( Class c ) { } public static Method getDeclaredMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Field [ ] getFields ( Class c ) { } public static Field getField ( Class c , String name ) throws ReflectionException { } public static Field [ ] getDeclaredFields ( Class c ) { } public static Field getDeclaredField ( Class c , String name ) throws ReflectionException { } }
public class CommitListFragment extends PagedItemFragment < RepositoryCommit > { @ Inject protected AvatarLoader avatars ; @ Inject private CommitService service ; @ Inject private CommitStore store ; @ InjectExtra ( Intents . EXTRA_REPOSITORY ) private Repository repository ; @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override protected ResourcePager < RepositoryCommit > createPager ( ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected int getErrorMessage ( Exception exception ) { } @ Override protected SingleTypeAdapter < RepositoryCommit > createAdapter ( List < RepositoryCommit > items ) { } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode == ( RequestCodes . COMMIT_VIEW ) ) { <START_BUG> getListAdapter ( ) . getWrappedAdapter ( ) . notifyDataSetChanged ( ) ; <END_BUG> return ; } super . onActivityResult ( requestCode , resultCode , data ) ; } }
public class RoutingTable implements Iterable < IndexRoutingTable > { public static final RoutingTable EMPTY_ROUTING_TABLE = RoutingTable . builder ( ) . build ( ) ; private final long version ; private final ImmutableMap < String , IndexRoutingTable > indicesRouting ; RoutingTable ( long version , Map < String , IndexRoutingTable > indicesRouting ) { } public long version ( ) { } @ Override public UnmodifiableIterator < IndexRoutingTable > iterator ( ) { } public boolean hasIndex ( String index ) { } public IndexRoutingTable index ( String index ) { } public Map < String , IndexRoutingTable > indicesRouting ( ) { } public Map < String , IndexRoutingTable > getIndicesRouting ( ) { } public RoutingNodes routingNodes ( ClusterState state ) { } public RoutingTable validateRaiseException ( MetaData metaData ) throws RoutingValidationException { } public RoutingTableValidation validate ( MetaData metaData ) { } public List < ShardRouting > shardsWithState ( ShardRoutingState ... states ) { } public List < ShardRouting > allShards ( String ... indices ) throws IndexMissingException { } public GroupShardsIterator allShardsGrouped ( String ... indices ) throws IndexMissingException { } public GroupShardsIterator allActiveShardsGrouped ( String [ ] indices , boolean includeEmpty ) throws IndexMissingException { } public GroupShardsIterator allAssignedShardsGrouped ( String [ ] indices , boolean includeEmpty ) throws IndexMissingException { } public GroupShardsIterator activePrimaryShardsGrouped ( String [ ] indices , boolean includeEmpty ) throws IndexMissingException { } public static RoutingTable . Builder builder ( ) { } public static RoutingTable . Builder builder ( RoutingTable routingTable ) { } public static class Builder { private long version ; private final Map < String , IndexRoutingTable > indicesRouting = Maps . newHashMap ( ) ; public Builder ( ) { } public Builder ( RoutingTable routingTable ) { } public RoutingTable . Builder updateNodes ( RoutingNodes routingNodes ) { } public RoutingTable . Builder updateNumberOfReplicas ( int numberOfReplicas , String ... indices ) throws IndexMissingException { } public RoutingTable . Builder addAsNew ( IndexMetaData indexMetaData ) { } public RoutingTable . Builder addAsRecovery ( IndexMetaData indexMetaData ) { } public RoutingTable . Builder addAsRestore ( IndexMetaData indexMetaData , RestoreSource restoreSource ) { } public RoutingTable . Builder addAsNewRestore ( IndexMetaData indexMetaData , RestoreSource restoreSource ) { } public RoutingTable . Builder add ( IndexRoutingTable indexRoutingTable ) { } public RoutingTable . Builder add ( IndexRoutingTable . Builder indexRoutingTableBuilder ) { } public RoutingTable . Builder remove ( String index ) { } public RoutingTable . Builder version ( long version ) { } public RoutingTable build ( ) { } public static RoutingTable readFrom ( StreamInput in ) throws IOException { } public static void writeTo ( RoutingTable table , StreamOutput out ) throws IOException { } } public String prettyPrint ( ) { <START_BUG> StringBuilder sb = new StringBuilder ( "routing_table:\n" ) ; <END_BUG> for ( Map . Entry < String , IndexRoutingTable > entry : indicesRouting . entrySet ( ) ) { sb . append ( entry . getValue ( ) . prettyPrint ( ) ) . append ( '\n' ) ; } return sb . toString ( ) ; } }
public class BytesRefFieldComparatorSource extends IndexFieldData . XFieldComparatorSource { private final IndexFieldData indexFieldData ; public BytesRefFieldComparatorSource ( IndexFieldData indexFieldData ) { } @ Override public Type reducedType ( ) { } @ Override public FieldComparator < ? > newComparator ( String fieldname , int numHits , int sortPos , boolean reversed ) throws IOException { <START_BUG> assert fieldname . equals ( indexFieldData . getFieldName ( ) ) ; <END_BUG> if ( ( indexFieldData . valuesOrdered ( ) ) && ( ( indexFieldData ) instanceof IndexOrdinalFieldData ) ) { return new BytesRefOrdValComparator ( ( ( IndexOrdinalFieldData ) ( indexFieldData ) ) , numHits ) ; } return new BytesRefValComparator ( indexFieldData , numHits ) ; } }
public class ScriptFilterBuilder extends BaseFilterBuilder { private final String script ; private Map < String , Object > params ; private String lang ; private Boolean cache ; private String filterName ; public ScriptFilterBuilder ( String script ) { } public ScriptFilterBuilder addParam ( String name , Object value ) { } public ScriptFilterBuilder params ( Map < String , Object > params ) { <START_BUG> if ( params == null ) { <END_BUG> this . params = params ; } else { this . params . putAll ( params ) ; } return this ; } public ScriptFilterBuilder lang ( String lang ) { } public ScriptFilterBuilder filterName ( String filterName ) { } public ScriptFilterBuilder cache ( boolean cache ) { } @ Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public interface EventListener { <START_BUG> public void handle ( Event event ) ; <END_BUG> }
public class ActionRequestValidationException extends ElasticSearchException { private final List < String > validationErrors = new ArrayList < String > ( ) ; public ActionRequestValidationException ( ) { } public void addValidationError ( String error ) { } public void addValidationErrors ( Iterable < String > errors ) { } public List < String > validationErrors ( ) { } @ Override public String getMessage ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "Validation<seq2seq4repair_space>Failed:<seq2seq4repair_space>" ) ; int index = 0 ; for ( String error : validationErrors ) { <START_BUG> sb . append ( ( ++ index ) ) . append ( ":<seq2seq4repair_space>" ) . append ( error ) ; <END_BUG> } return sb . toString ( ) ; } }
public class HomeActivity extends RoboSherlockFragmentActivity { private static final String TAG = "HA" ; private static final int CODE_LOGIN = 1 ; @ Inject private ContextScopedProvider < Account > accountProvider ; @ Override public boolean onCreateOptionsMenu ( Menu optionMenu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case id . dashboard_issues : startActivity ( new Intent ( this , IssueDashboardActivity . class ) ) ; return true ; case id . gists : startActivity ( new Intent ( this , GistsActivity . class ) ) ; return true ; case id . search : onSearchRequested ( ) ; return true ; case id . bookmarks : <START_BUG> startActivity ( new Intent ( this , FilterBrowseActivity . class ) ) ; <END_BUG> return true ; default : return super . onOptionsItemSelected ( item ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { } private void loadOrgs ( ) { } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { } @ Override protected void onResume ( ) { } }
public class UserRepositoryListFragment extends PagedItemFragment < Repository > { @ Inject private RepositoryService service ; @ InjectExtra ( Intents . EXTRA_USER ) private User user ; @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; setEmptyText ( getString ( no_repositories ) ) ; <START_BUG> ListViewUtils . configure ( getActivity ( ) , getListView ( ) , true ) ; <END_BUG> } @ Override protected ResourcePager < Repository > createPager ( ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected ItemListAdapter < Repository , ? extends ItemView > createAdapter ( List < Repository > items ) { } @ Override public void onListItemClick ( ListView list , View v , int position , long id ) { } }
public class IndexAliasesService extends AbstractIndexComponent implements Iterable < IndexAlias > { private final IndexQueryParserService indexQueryParser ; private final Map < String , IndexAlias > aliases = ConcurrentCollections . newConcurrentMapWithAggressiveConcurrency ( ) ; @ Inject public IndexAliasesService ( Index index , @ IndexSettings Settings indexSettings , IndexQueryParserService indexQueryParser ) { } public boolean hasAlias ( String alias ) { } public IndexAlias alias ( String alias ) { } public IndexAlias create ( String alias , @ Nullable CompressedString filter ) { } public void add ( String alias , @ Nullable CompressedString filter ) { } public void addAll ( Map < String , IndexAlias > aliases ) { } public Filter aliasFilter ( String ... aliases ) { } private void add ( IndexAlias indexAlias ) { } public void remove ( String alias ) { } private Filter parse ( String alias , CompressedString filter ) { if ( filter == null ) { return null ; } try { byte [ ] filterSource = filter . uncompressed ( ) ; XContentParser parser = XContentFactory . xContent ( filterSource ) . createParser ( filterSource ) ; try { <START_BUG> return indexQueryParser . parseInnerFilter ( parser ) ; <END_BUG> } finally { parser . close ( ) ; } } catch ( IOException ex ) { throw new org . elasticsearch . indices . AliasFilterParsingException ( index , alias , "Invalid<seq2seq4repair_space>alias<seq2seq4repair_space>filter" , ex ) ; } } @ Override public Iterator < IndexAlias > iterator ( ) { } }
public class ParseContext { private final DocumentMapper docMapper ; private final DocumentMapperParser docMapperParser ; private final ContentPath path ; private XContentParser parser ; private Document document ; private List < Document > documents = new ArrayList < Document > ( ) ; private Analyzer analyzer ; private final String index ; @ Nullable private final Settings indexSettings ; private SourceToParse sourceToParse ; private BytesReference source ; private String id ; private ParseListener listener ; private UidField uid ; private StringBuilder stringBuilder = new StringBuilder ( ) ; private Map < String , String > ignoredValues = new HashMap < String , String > ( ) ; private boolean mappingsModified = false ; private boolean externalValueSet ; private Object externalValue ; private AllEntries allEntries = new AllEntries ( ) ; private float docBoost = 1.0F ; private Aggregator newFieldMappers = new FieldMapperListener . Aggregator ( ) ; private ObjectMapperListener . Aggregator newObjectMappers = new ObjectMapperListener . Aggregator ( ) ; public ParseContext ( String index , @ Nullable Settings indexSettings , DocumentMapperParser docMapperParser , DocumentMapper docMapper , ContentPath path ) { } public void reset ( XContentParser parser , Document document , SourceToParse source , DocumentMapper . ParseListener listener ) { } public boolean flyweight ( ) { } public Aggregator newFieldMappers ( ) { } public ObjectMapperListener . Aggregator newObjectMappers ( ) { } public DocumentMapperParser docMapperParser ( ) { } public boolean mappingsModified ( ) { } public void setMappingsModified ( ) { } public String index ( ) { } @ Nullable public Settings indexSettings ( ) { } public String type ( ) { } public SourceToParse sourceToParse ( ) { } public BytesReference source ( ) { } public void source ( BytesReference source ) { } public ContentPath path ( ) { } public XContentParser parser ( ) { } public ParseListener listener ( ) { } public Document rootDoc ( ) { } public List < Document > docs ( ) { } public Document doc ( ) { } public void addDoc ( Document doc ) { } public Document switchDoc ( Document doc ) { } public RootObjectMapper root ( ) { } public DocumentMapper docMapper ( ) { } public AnalysisService analysisService ( ) { } public String id ( ) { } public void ignoredValue ( String indexName , String value ) { } public String ignoredValue ( String indexName ) { } public void id ( String id ) { } public UidField uid ( ) { } public void uid ( UidField uid ) { } public boolean includeInAll ( Boolean includeInAll , FieldMapper mapper ) { <START_BUG> return includeInAll ( includeInAll , mapper . indexed ( ) ) ; <END_BUG> } private boolean includeInAll ( Boolean specificIncludeInAll , boolean indexed ) { } public AllEntries allEntries ( ) { } public Analyzer analyzer ( ) { } public void analyzer ( Analyzer analyzer ) { } public void externalValue ( Object externalValue ) { } public boolean externalValueSet ( ) { } public Object externalValue ( ) { } public float docBoost ( ) { } public void docBoost ( float docBoost ) { } public StringBuilder stringBuilder ( ) { } }
private Boolean explain ; private Boolean version ; private List < SortBuilder > sorts ; private boolean trackScores = false ; private Float minScore ; private long timeoutInMillis = - 1 ; private List < String > fieldNames ; private List < String > fieldDataFields ; private List < SearchSourceBuilder . ScriptField > scriptFields ; private List < SearchSourceBuilder . PartialField > partialFields ; private FetchSourceContext fetchSourceContext ; private List < FacetBuilder > facets ; private BytesReference facetsBinary ; private List < AbstractAggregationBuilder > aggregations ; private BytesReference aggregationsBinary ; private HighlightBuilder highlightBuilder ; private SuggestBuilder suggestBuilder ; private List < RescoreBuilder > rescoreBuilders ; private Integer defaultRescoreWindowSize ; private ObjectFloatOpenHashMap < String > indexBoost = null ; private String [ ] stats ; public SearchSourceBuilder ( ) { } public SearchSourceBuilder query ( QueryBuilder query ) { } public SearchSourceBuilder query ( byte [ ] queryBinary ) { } public SearchSourceBuilder query ( byte [ ] queryBinary , int queryBinaryOffset , int queryBinaryLength ) { } public SearchSourceBuilder query ( BytesReference queryBinary ) { } public SearchSourceBuilder query ( String queryString ) { } public SearchSourceBuilder query ( XContentBuilder query ) { } public SearchSourceBuilder query ( Map query ) { } public SearchSourceBuilder postFilter ( FilterBuilder postFilter ) { } public SearchSourceBuilder postFilter ( String postFilterString ) { } public SearchSourceBuilder postFilter ( byte [ ] postFilter ) { } public SearchSourceBuilder postFilter ( byte [ ] postFilterBinary , int postFilterBinaryOffset , int postFilterBinaryLength ) { } public SearchSourceBuilder postFilter ( BytesReference postFilterBinary ) { } public SearchSourceBuilder postFilter ( XContentBuilder postFilter ) { } public SearchSourceBuilder postFilter ( Map postFilter ) { } public SearchSourceBuilder from ( int from ) { } public SearchSourceBuilder size ( int size ) { } public SearchSourceBuilder minScore ( float minScore ) { } public SearchSourceBuilder explain ( Boolean explain ) { } public SearchSourceBuilder version ( Boolean version ) { } public SearchSourceBuilder timeout ( TimeValue timeout ) { } public SearchSourceBuilder timeout ( String timeout ) { } public SearchSourceBuilder sort ( String name , SortOrder order ) { } public SearchSourceBuilder sort ( String name ) { } public SearchSourceBuilder sort ( SortBuilder sort ) { } public SearchSourceBuilder trackScores ( boolean trackScores ) { } public SearchSourceBuilder facet ( FacetBuilder facet ) { } public SearchSourceBuilder facets ( byte [ ] facetsBinary ) { } public SearchSourceBuilder facets ( byte [ ] facetsBinary , int facetBinaryOffset , int facetBinaryLength ) { } public SearchSourceBuilder facets ( BytesReference facetsBinary ) { } public SearchSourceBuilder facets ( XContentBuilder facets ) { } public SearchSourceBuilder facets ( Map facets ) { } public SearchSourceBuilder aggregation ( AbstractAggregationBuilder aggregation ) { } public SearchSourceBuilder aggregations ( byte [ ] aggregationsBinary ) { } public SearchSourceBuilder aggregations ( byte [ ] aggregationsBinary , int aggregationsBinaryOffset , int aggregationsBinaryLength ) { } public SearchSourceBuilder aggregations ( BytesReference aggregationsBinary ) { } public SearchSourceBuilder aggregations ( XContentBuilder facets ) { } public SearchSourceBuilder defaultRescoreWindowSize ( int defaultRescoreWindowSize ) { } public SearchSourceBuilder aggregations ( Map aggregations ) { } public HighlightBuilder highlighter ( ) { } public SearchSourceBuilder highlight ( HighlightBuilder highlightBuilder ) { } public SuggestBuilder suggest ( ) { } public SearchSourceBuilder addRescorer ( RescoreBuilder rescoreBuilder ) { } public SearchSourceBuilder clearRescorers ( ) { } public SearchSourceBuilder fetchSource ( boolean fetch ) { } public SearchSourceBuilder fetchSource ( @ Nullable String include , @ Nullable String exclude ) { <START_BUG> return fetchSource ( ( include == null ? Strings . EMPTY_ARRAY : new String [ ] { include } ) , ( include == null ? Strings . EMPTY_ARRAY : new String [ ] { exclude } ) ) ; <END_BUG> } public SearchSourceBuilder fetchSource ( @ Nullable String [ ] includes , @ Nullable String [ ] excludes ) { } public SearchSourceBuilder fetchSource ( @ Nullable FetchSourceContext fetchSourceContext ) { } public SearchSourceBuilder noFields ( ) { } public SearchSourceBuilder fields ( List < String > fields ) { } public SearchSourceBuilder fields ( String ... fields ) { } public SearchSourceBuilder field ( String name ) { } public SearchSourceBuilder fieldDataField ( String name ) { } public SearchSourceBuilder scriptField ( String name , String script ) { } public SearchSourceBuilder scriptField ( String name , String script , Map < String , Object > params ) { } public SearchSourceBuilder scriptField ( String name , String lang , String script , Map < String , Object > params ) { } @ Deprecated public SearchSourceBuilder partialField ( String name , @ Nullable String include , @ Nullable String exclude ) { } @ Deprecated public SearchSourceBuilder partialField ( String name , @ Nullable String [ ] includes , @ Nullable String [ ] excludes ) { } public SearchSourceBuilder indexBoost ( String index , float indexBoost ) { } public SearchSourceBuilder stats ( String ... statsGroups ) { } @ Override public String toString ( ) { } public BytesReference buildAsBytes ( ) throws SearchSourceBuilderException { } public BytesReference buildAsBytes ( XContentType contentType ) throws SearchSourceBuilderException { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } private static class ScriptField { private final String fieldName ; private final String script ; private final String lang ; private final Map < String , Object > params ; private ScriptField ( String fieldName , String lang , String script , Map < String , Object > params ) { } public String fieldName ( ) { } public String script ( ) { } public String lang ( ) { } public Map < String , Object > params ( ) { } } private static class PartialField { private final String name ; private final String [ ] includes ; private final String [ ] excludes ; private PartialField ( String name , String [ ] includes , String [ ] excludes ) { }
public class UITest extends GdxTest implements InputProcessor { Texture uiTexture ; Texture badlogic ; Stage ui ; @ Override public void create ( ) { } @ Override public void render ( ) { GL10 gl = graphics . getGL10 ( ) ; gl . glClear ( GL_COLOR_BUFFER_BIT ) ; ui . act ( graphics . getDeltaTime ( ) ) ; <START_BUG> ui . render ( ) ; <END_BUG> } @ Override public boolean keyDown ( int keycode ) { } @ Override public boolean keyUp ( int keycode ) { } @ Override public boolean keyTyped ( char character ) { } @ Override public boolean touchDown ( int x , int y , int pointer , int button ) { } Vector2 point = new Vector2 ( ) ; @ Override public boolean touchUp ( int x , int y , int pointer , int button ) { } @ Override public boolean touchDragged ( int x , int y , int pointer ) { } @ Override public boolean needsGL20 ( ) { } @ Override public boolean touchMoved ( int x , int y ) { } @ Override public boolean scrolled ( int amount ) { } }
public class BouncyDesktop { public static void main ( String [ ] argv ) { <START_BUG> new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new Bouncy ( ) , "Bouncy" , 320 , 480 , true ) ; <END_BUG> } }
public class Label extends Widget { private Label . LabelStyle style ; private final TextBounds bounds = new TextBounds ( ) ; private String text ; private BitmapFontCache cache ; private float prefWidth ; private float prefHeight ; private int labelAlign = Align . LEFT ; private HAlignment lineAlign = HAlignment . LEFT ; private boolean wrap ; private float lastPrefHeight ; public Label ( Skin skin ) { } public Label ( String text , Skin skin ) { } public Label ( String text , String fontName , Color color , Skin skin ) { } public Label ( String text , String fontName , String colorName , Skin skin ) { } public Label ( String text , Label . LabelStyle style ) { } public Label ( String text , Label . LabelStyle style , String name ) { } public void setStyle ( Label . LabelStyle style ) { } public Label . LabelStyle getStyle ( ) { } public void setText ( String text ) { } public String getText ( ) { } public TextBounds getTextBounds ( ) { } public void setWrap ( boolean wrap ) { } public void setAlignment ( int wrapAlign ) { } public void setAlignment ( int labelAlign , int lineAlign ) { } public void setColor ( float color ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public Color getColor ( ) { } private void computeBounds ( ) { } @ Override public void layout ( ) { } @ Override public void draw ( SpriteBatch batch , float parentAlpha ) { } public float getPrefWidth ( ) { if ( wrap ) <START_BUG> return 150 ; <END_BUG> return bounds . width ; } public float getPrefHeight ( ) { } public static class LabelStyle { public BitmapFont font ; public Color fontColor ; public LabelStyle ( ) { } public LabelStyle ( BitmapFont font , Color fontColor ) { } } }
public class EsExecutors { public static int boundedNumberOfProcessors ( ) { } public static PrioritizedEsThreadPoolExecutor newSinglePrioritizing ( ThreadFactory threadFactory ) { } public static EsThreadPoolExecutor newScaling ( int min , int max , long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory ) { } public static EsThreadPoolExecutor newCached ( long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory ) { <START_BUG> return new EsThreadPoolExecutor ( 0 , Integer . MAX_VALUE , keepAliveTime , unit , new SynchronousQueue < Runnable > ( ) , threadFactory ) ; <END_BUG> } public static EsThreadPoolExecutor newFixed ( int size , BlockingQueue < Runnable > queue , ThreadFactory threadFactory ) { } public static EsThreadPoolExecutor newFixed ( int size , BlockingQueue < Runnable > queue , ThreadFactory threadFactory , XRejectedExecutionHandler rejectedExecutionHandler ) { } public static String threadName ( Settings settings , String namePrefix ) { } public static ThreadFactory daemonThreadFactory ( Settings settings , String namePrefix ) { } public static ThreadFactory daemonThreadFactory ( String namePrefix ) { } static class EsThreadFactory implements ThreadFactory { final ThreadGroup group ; final AtomicInteger threadNumber = new AtomicInteger ( 1 ) ; final String namePrefix ; public EsThreadFactory ( String namePrefix ) { } @ Override public Thread newThread ( Runnable r ) { } } private EsExecutors ( ) { } static class ExecutorScalingQueue < E > extends LinkedTransferQueue < E > { ThreadPoolExecutor executor ; public ExecutorScalingQueue ( ) { } @ Override public boolean offer ( E e ) { } } static class ForceQueuePolicy implements XRejectedExecutionHandler { public void rejectedExecution ( Runnable r , ThreadPoolExecutor executor ) { } @ Override public long rejected ( ) { } } }
@ ThreadSafe @ Immutable public class ImmutableSettings implements Settings { private Map < String , String > settings ; private Settings globalSettings ; private transient ClassLoader classLoader ; private ImmutableSettings ( Map < String , String > settings , Settings globalSettings , ClassLoader classLoader ) { } @ Override public Settings getGlobalSettings ( ) { } @ Override public ClassLoader getClassLoader ( ) { } @ Override public Map < String , String > getAsMap ( ) { } @ Override public Settings getComponentSettings ( Class component ) { } @ Override public Settings getComponentSettings ( String prefix , Class component ) { } @ Override public String get ( String setting ) { } @ Override public String get ( String setting , String defaultValue ) { } @ Override public Float getAsFloat ( String setting , Float defaultValue ) { } @ Override public Double getAsDouble ( String setting , Double defaultValue ) { } @ Override public Integer getAsInt ( String setting , Integer defaultValue ) { } @ Override public Long getAsLong ( String setting , Long defaultValue ) { } @ Override public Boolean getAsBoolean ( String setting , Boolean defaultValue ) { } @ Override public TimeValue . TimeValue getAsTime ( String setting , TimeValue . TimeValue defaultValue ) { } @ Override public SizeValue . SizeValue getAsSize ( String setting , SizeValue . SizeValue defaultValue ) throws SettingsException { } @ SuppressWarnings ( { "unchecked" } ) @ Override public < T > Class < ? extends T > getAsClass ( String setting , Class < ? extends T > defaultClazz ) throws NoClassSettingsException { } @ Override public < T > Class < ? extends T > getAsClass ( String setting , Class < ? extends T > defaultClazz , String prefixPackage , String suffixClassName ) throws NoClassSettingsException { } @ Override public String [ ] getAsArray ( String settingPrefix ) throws SettingsException { } @ Override public Map < String , Settings > getGroups ( String settingPrefix ) throws SettingsException { } private static ClassLoader buildClassLoader ( ) { } public static Settings readSettingsFromStream ( DataInput in ) throws IOException { } public static Settings readSettingsFromStream ( DataInput in , Settings globalSettings ) throws IOException { } public static void writeSettingsToStream ( Settings settings , DataOutput out ) throws IOException { } public static ImmutableSettings . Builder settingsBuilder ( ) { } public static class Builder implements Settings . Builder { public static final Settings EMPTY_SETTINGS = new ImmutableSettings . Builder ( ) . build ( ) ; private final Map < String , String > map = new LinkedHashMap < String , String > ( ) ; private ClassLoader classLoader ; private Settings globalSettings ; private Builder ( ) { } public String get ( String key ) { } public ImmutableSettings . Builder put ( String key , String value ) { } public ImmutableSettings . Builder putClass ( String key , Class clazz ) { } public ImmutableSettings . Builder putBoolean ( String setting , boolean value ) { } public ImmutableSettings . Builder putInt ( String setting , int value ) { } public ImmutableSettings . Builder putLong ( String setting , long value ) { } public ImmutableSettings . Builder putFloat ( String setting , float value ) { } public ImmutableSettings . Builder putDouble ( String setting , double value ) { } public ImmutableSettings . Builder putTime ( String setting , long value , TimeUnit timeUnit ) { } public ImmutableSettings . Builder putSize ( String setting , long value , SizeUnit sizeUnit ) { } public ImmutableSettings . Builder putGroup ( String settingPrefix , String groupName , String [ ] settings , String [ ] values ) throws SettingsException { } public ImmutableSettings . Builder putAll ( Settings settings ) { } public ImmutableSettings . Builder putAll ( Map < String , String > settings ) { } public ImmutableSettings . Builder putAll ( Properties properties ) { } public ImmutableSettings . Builder loadFromSource ( String source ) { } public ImmutableSettings . Builder loadFromUrl ( URL url ) throws SettingsException { } public ImmutableSettings . Builder loadFromStream ( String resourceName , InputStream is ) throws SettingsException { SettingsLoader settingsLoader = SettingsLoaderFactory . loaderFromResource ( resourceName ) ; try { <START_BUG> Map < String , String > loadedSettings = settingsLoader . load ( Streams . copyToString ( new InputStreamReader ( is ) ) ) ; <END_BUG> putAll ( loadedSettings ) ; } catch ( IOException e ) { throw new SettingsException ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>load<seq2seq4repair_space>settings<seq2seq4repair_space>from<seq2seq4repair_space>[" + resourceName ) + "]" ) ) ; } return this ; } public ImmutableSettings . Builder loadFromClasspath ( String resourceName ) throws SettingsException { } public ImmutableSettings . Builder classLoader ( ClassLoader classLoader ) { } public ImmutableSettings . Builder globalSettings ( Settings globalSettings ) { } public ImmutableSettings . Builder putProperties ( String prefix , Properties properties ) { } public ImmutableSettings . Builder replacePropertyPlaceholders ( ) { } public Settings build ( ) { } } }
public class ScaleTo extends AnimationAction { private static final ActionResetingPool < ScaleTo > pool = new ActionResetingPool < ScaleTo > ( 4 , 100 ) { @ Override protected ScaleTo newObject ( ) { } } ; protected float scaleX ; protected float scaleY ; protected float startScaleX ; protected float startScaleY ; protected float deltaScaleX ; protected float deltaScaleY ; <START_BUG> public static AnimationAction $ ( float scaleX , float scaleY , float duration ) { <END_BUG> ScaleTo action = ScaleTo . pool . obtain ( ) ; action . scaleX = scaleX ; action . scaleY = scaleY ; action . duration = duration ; action . invDuration = 1 / duration ; return action ; } @ Override public void setTarget ( Actor actor ) { } @ Override public void act ( float delta ) { } @ Override public void finish ( ) { } @ Override public Action copy ( ) { } }
public class WidgetGroup extends Group implements Layout { private boolean needsLayout = true ; private boolean fillParent ; private boolean layoutEnabled = true ; public float getMinWidth ( ) { } public float getMinHeight ( ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMaxWidth ( ) { } public float getMaxHeight ( ) { } public void setLayoutEnabled ( boolean enabled ) { } private void setLayoutEnabled ( Group parent , boolean enabled ) { <START_BUG> SnapshotArray < Actor > children = parent . getChildren ( ) ; <END_BUG> for ( int i = 0 , n = children . size ; i < n ; i ++ ) { Actor actor = children . get ( i ) ; if ( actor instanceof Layout ) ( ( Layout ) ( actor ) ) . setLayoutEnabled ( enabled ) ; else if ( actor instanceof Group ) setLayoutEnabled ( ( ( Group ) ( actor ) ) , enabled ) ; } } public void validate ( ) { } public boolean needsLayout ( ) { } public void invalidate ( ) { } public void invalidateHierarchy ( ) { } protected void childrenChanged ( ) { } protected void sizeChanged ( ) { } public void pack ( ) { } public void setFillParent ( boolean fillParent ) { } public void layout ( ) { } public void draw ( Batch batch , float parentAlpha ) { } }
public class TransportSearchQueryThenFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchQueryThenFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < QuerySearchResult > { final AtomicArray < FetchSearchResult > fetchResults ; final AtomicArray < ExtTIntArrayList > docIdsToLoad ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , ShardSearchRequest request , SearchServiceListener < QuerySearchResult > listener ) { } @ Override protected void moveToSecondPhase ( ) { } void executeFetch ( final int shardIndex , final SearchShardTarget shardTarget , final AtomicInteger counter , final FetchSearchRequest fetchSearchRequest , DiscoveryNode node ) { } void finishHim ( ) { try { innerFinishHim ( ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> ReduceSearchPhaseException failure = new ReduceSearchPhaseException ( "fetch" , "" , e , buildShardFailures ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>reduce<seq2seq4repair_space>search" , failure ) ; } listener . onFailure ( failure ) ; } finally { releaseIrrelevantSearchContexts ( firstResults , docIdsToLoad ) ; } } void innerFinishHim ( ) throws Exception { } } }
public class ByteArrayRef extends AbstractList < Byte > implements RandomAccess { public static final ByteArrayRef EMPTY = new ByteArrayRef ( new byte [ 0 ] ) ; public byte [ ] values ; public int start ; public int end ; public ByteArrayRef ( byte [ ] values ) { } public ByteArrayRef ( byte [ ] values , int length ) { } public ByteArrayRef ( byte [ ] values , int start , int end ) { } public void reset ( int newLength ) { } @ Override public int size ( ) { } @ Override public boolean isEmpty ( ) { <START_BUG> return ( size ( ) ) != 0 ; <END_BUG> } @ Override public Byte get ( int index ) { } @ Override public boolean contains ( Object target ) { } @ Override public int indexOf ( Object target ) { } @ Override public int lastIndexOf ( Object target ) { } @ Override public Byte set ( int index , Byte element ) { } @ Override public boolean equals ( Object object ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } private static int indexOf ( byte [ ] array , byte target , int start , int end ) { } private static int lastIndexOf ( byte [ ] array , byte target , int start , int end ) { } }
public class RestIndicesExistsAction extends BaseRestHandler { private final SettingsFilter settingsFilter ; @ Inject public RestIndicesExistsAction ( Settings settings , Client client , RestController controller , SettingsFilter settingsFilter ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { IndicesExistsRequest indicesExistsRequest = new IndicesExistsRequest ( splitIndices ( request . param ( "index" ) ) ) ; indicesExistsRequest . listenerThreaded ( false ) ; client . admin ( ) . indices ( ) . exists ( indicesExistsRequest , new org . elasticsearch . action . ActionListener < IndicesExistsResponse > ( ) { @ Override public void onResponse ( IndicesExistsResponse response ) { try { if ( response . exists ( ) ) { channel . sendResponse ( new StringRestResponse ( OK ) ) ; } else { channel . sendResponse ( new StringRestResponse ( NOT_FOUND ) ) ; } } catch ( Exception e ) { onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { <START_BUG> channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; <END_BUG> } catch ( Exception e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class AnimationController extends BaseAnimationController { public interface AnimationListener { void onEnd ( final AnimationController . AnimationDesc animation ) { } void onLoop ( final AnimationController . AnimationDesc animation ) { } } public static class AnimationDesc { public AnimationController . AnimationListener listener ; public Animation animation ; public float speed ; public float time ; public float offset ; public float duration ; public int loopCount ; protected AnimationDesc ( ) { } protected float update ( float delta ) { } } protected final Pool < AnimationController . AnimationDesc > animationPool = new Pool < AnimationController . AnimationDesc > ( ) { @ Override protected AnimationController . AnimationDesc newObject ( ) { } } ; public AnimationController . AnimationDesc current ; public AnimationController . AnimationDesc queued ; public float queuedTransitionTime ; public AnimationController . AnimationDesc previous ; public float transitionCurrentTime ; public float transitionTargetTime ; public boolean inAction ; public boolean paused ; public boolean allowSameAnimation ; private boolean justChangedAnimation = false ; public AnimationController ( final ModelInstance target ) { } private AnimationController . AnimationDesc obtain ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener ) { } private AnimationController . AnimationDesc obtain ( final String id , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener ) { } private AnimationController . AnimationDesc obtain ( final AnimationController . AnimationDesc anim ) { } private boolean updating ; public void update ( float delta ) { } public AnimationController . AnimationDesc setAnimation ( final String id ) { } public AnimationController . AnimationDesc setAnimation ( final String id , int loopCount ) { } public AnimationController . AnimationDesc setAnimation ( final String id , final AnimationController . AnimationListener listener ) { } public AnimationController . AnimationDesc setAnimation ( final String id , int loopCount , final AnimationController . AnimationListener listener ) { } public AnimationController . AnimationDesc setAnimation ( final String id , int loopCount , float speed , final AnimationController . AnimationListener listener ) { } public AnimationController . AnimationDesc setAnimation ( final String id , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener ) { } protected AnimationController . AnimationDesc setAnimation ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener ) { } protected AnimationController . AnimationDesc setAnimation ( final AnimationController . AnimationDesc anim ) { if ( updating ) throw new GdxRuntimeException ( "Cannot<seq2seq4repair_space>change<seq2seq4repair_space>animation<seq2seq4repair_space>during<seq2seq4repair_space>update" ) ; if ( ( current ) == null ) current = anim ; else { <START_BUG> if ( ( ( ! ( allowSameAnimation ) ) && ( anim != null ) ) && ( ( current . animation ) == ( anim . animation ) ) ) <END_BUG> anim . time = current . time ; else removeAnimation ( current . animation ) ; animationPool . free ( current ) ; current = anim ; } justChangedAnimation = true ; return anim ; } public AnimationController . AnimationDesc animate ( final String id , float transitionTime ) { } public AnimationController . AnimationDesc animate ( final String id , final AnimationController . AnimationListener listener , float transitionTime ) { } public AnimationController . AnimationDesc animate ( final String id , int loopCount , final AnimationController . AnimationListener listener , float transitionTime ) { } public AnimationController . AnimationDesc animate ( final String id , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } public AnimationController . AnimationDesc animate ( final String id , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc animate ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc animate ( final AnimationController . AnimationDesc anim , float transitionTime ) { } public AnimationController . AnimationDesc queue ( final String id , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } public AnimationController . AnimationDesc queue ( final String id , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc queue ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc queue ( final AnimationController . AnimationDesc anim , float transitionTime ) { } public AnimationController . AnimationDesc action ( final String id , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } public AnimationController . AnimationDesc action ( final String id , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc action ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc action ( final AnimationController . AnimationDesc anim , float transitionTime ) { } }
public class GdxInvadersAndroid extends AndroidApplication { @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setRequestedOrientation ( SCREEN_ORIENTATION_LANDSCAPE ) ; AndroidApplicationConfiguration config = new AndroidApplicationConfiguration ( ) ; config . useWakelock = true ; <START_BUG> config . useGL20 = true ; <END_BUG> initialize ( new GdxInvaders ( ) , config ) ; } }
public class TermsStatsStringFacetCollector extends AbstractFacetCollector { private final ComparatorType comparatorType ; private final FieldDataCache fieldDataCache ; private final String keyFieldName ; private final String valueFieldName ; private final int size ; private final int numberOfShards ; private final FieldDataType keyFieldDataType ; private FieldData keyFieldData ; private final FieldDataType valueFieldDataType ; private final SearchScript script ; private final TermsStatsStringFacetCollector . Aggregator aggregator ; public TermsStatsStringFacetCollector ( String facetName , String keyFieldName , String valueFieldName , int size , TermsStatsFacet . ComparatorType comparatorType , SearchContext context , String scriptLang , String script , Map < String , Object > params ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { keyFieldData = fieldDataCache . cache ( keyFieldDataType , context . reader ( ) , keyFieldName ) ; if ( ( script ) != null ) { <START_BUG> script . setNextReader ( context . reader ( ) ) ; <END_BUG> } else { aggregator . valueFieldData = ( ( NumericFieldData ) ( fieldDataCache . cache ( valueFieldDataType , context . reader ( ) , valueFieldName ) ) ) ; } } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override public Facet facet ( ) { } public static class Aggregator implements FieldData . StringValueInDocProc { final ExtTHashMap < BytesRef , InternalTermsStatsStringFacet . StringEntry > entries = CacheRecycler . popHashMap ( ) ; int missing = 0 ; NumericFieldData valueFieldData ; TermsStatsStringFacetCollector . Aggregator . ValueAggregator valueAggregator = new TermsStatsStringFacetCollector . Aggregator . ValueAggregator ( ) ; @ Override public void onValue ( int docId , BytesRef value ) { } @ Override public void onMissing ( int docId ) { } public static class ValueAggregator implements NumericFieldData . DoubleValueInDocProc { StringEntry stringEntry ; @ Override public void onValue ( int docId , double value ) { } } } public static class ScriptAggregator extends TermsStatsStringFacetCollector . Aggregator { private final SearchScript script ; public ScriptAggregator ( SearchScript script ) { } @ Override public void onValue ( int docId , BytesRef value ) { } } }
public class PostingsFormatService extends AbstractIndexComponent { private final ImmutableMap < String , PostingsFormatProvider > providers ; public PostingsFormatService ( Index index ) { } public PostingsFormatService ( Index index , @ IndexSettings Settings indexSettings ) { } @ Inject public PostingsFormatService ( Index index , @ IndexSettings Settings indexSettings , Map < String , PostingsFormatProvider . Factory > postingFormatFactories ) { } public PostingsFormatProvider get ( String name ) throws ElasticSearchIllegalArgumentException { PostingsFormatProvider provider = providers . get ( name ) ; <START_BUG> if ( name == null ) { <END_BUG> throw new ElasticSearchIllegalArgumentException ( ( ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>find<seq2seq4repair_space>postings_format<seq2seq4repair_space>[" + name ) + "]" ) ) ; } return provider ; } }
public class EmptyOrdinals implements Ordinals { private final int numDocs ; public EmptyOrdinals ( int numDocs ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override public boolean hasSingleArrayBackingStorage ( ) { } @ Override public Object getBackingStorage ( ) { } @ Override public boolean isMultiValued ( ) { } @ Override public int getNumDocs ( ) { } @ Override public int getNumOrds ( ) { <START_BUG> return 1 ; <END_BUG> } @ Override public EmptyOrdinals . Docs ordinals ( ) { } public static class Docs implements Ordinals . Docs { private final EmptyOrdinals parent ; public Docs ( EmptyOrdinals parent ) { } @ Override public Ordinals ordinals ( ) { } @ Override public int getNumDocs ( ) { } @ Override public int getNumOrds ( ) { return parent . getNumOrds ( ) ; } @ Override public boolean isMultiValued ( ) { } @ Override public int getOrd ( int docId ) { } @ Override public IntArrayRef getOrds ( int docId ) { } @ Override public Iter getIter ( int docId ) { } @ Override public void forEachOrdinalInDoc ( int docId , OrdinalInDocProc proc ) { } } }
public class ShapeRendererTest extends GdxTest { @ Override public boolean needsGL20 ( ) { } ShapeRenderer renderer ; PerspectiveCamera cam ; PerspectiveCamController controller ; SpriteBatch batch ; BitmapFont font ; public void create ( ) { renderer = new ShapeRenderer ( ) ; cam = new PerspectiveCamera ( 47 , graphics . getWidth ( ) , graphics . getHeight ( ) ) ; cam . position . set ( 0 , 0 , 2 ) ; cam . near = 0.1F ; controller = new PerspectiveCamController ( cam ) ; input . setInputProcessor ( controller ) ; batch = new SpriteBatch ( ) ; <START_BUG> font = new BitmapFont ( ) ; <END_BUG> } public void render ( ) { } }
public class IOSMusic implements Music { private final OALAudioTrack track ; OnCompletionListener onCompletionListener ; public IOSMusic ( OALAudioTrack track ) { } @ Override public void play ( ) { } @ Override public void pause ( ) { } @ Override public void stop ( ) { } @ Override public boolean isPlaying ( ) { <START_BUG> return track . isPlaying ( ) ; <END_BUG> } @ Override public void setLooping ( boolean isLooping ) { } @ Override public boolean isLooping ( ) { } @ Override public void setVolume ( float volume ) { } public void setPosition ( float position ) { } @ Override public float getPosition ( ) { } @ Override public void dispose ( ) { } @ Override public float getVolume ( ) { } @ Override public void setPan ( float pan , float volume ) { } @ Override public void setOnCompletionListener ( OnCompletionListener listener ) { } }
public class RecoveryAction extends AbstractIndexShardComponent { private final SizeValue fileChunkSize ; private final ThreadPool threadPool ; private final TransportService transportService ; private final InternalIndexShard indexShard ; private final Store store ; private final ConcurrentMap < String , IndexOutput > openIndexOutputs = newConcurrentMap ( ) ; private final String startTransportAction ; private final String fileChunkTransportAction ; private final String snapshotTransportAction ; @ Inject public RecoveryAction ( ShardId shardId , @ IndexSettings Settings indexSettings , ThreadPool threadPool , TransportService transportService , IndexShard indexShard , Store store ) { } public void close ( ) { } public synchronized void startRecovery ( Node node , Node targetNode , boolean markAsRelocated ) throws ElasticSearchException { } private void cleanOpenIndex ( ) { } private static class StartRecoveryRequest implements Streamable { private Node node ; private boolean markAsRelocated ; private StartRecoveryRequest ( ) { } private StartRecoveryRequest ( Node node , boolean markAsRelocated ) { } @ Override public void readFrom ( DataInput in ) throws IOException , ClassNotFoundException { } @ Override public void writeTo ( DataOutput out ) throws IOException { } } private class StartRecoveryTransportRequestHandler extends BaseTransportRequestHandler < RecoveryAction . StartRecoveryRequest > { @ Override public RecoveryAction . StartRecoveryRequest newInstance ( ) { } @ Override public void messageReceived ( final RecoveryAction . StartRecoveryRequest startRecoveryRequest , final TransportChannel channel ) throws Exception { } } private static class RecoveryStatus implements Streamable { List < String > phase1FileNames = new ArrayList < String > ( ) ; List < Long > phase1FileSizes = new ArrayList < Long > ( ) ; long phase1TotalSize ; long phase1Time ; int phase2Operations ; long phase2Time ; int phase3Operations ; long phase3Time ; private RecoveryStatus ( ) { } @ Override public void readFrom ( DataInput in ) throws IOException , ClassNotFoundException { } @ Override public void writeTo ( DataOutput out ) throws IOException { } } private class SnapshotTransportRequestHandler extends BaseTransportRequestHandler < RecoveryAction . SnapshotWrapper > { @ Override public RecoveryAction . SnapshotWrapper newInstance ( ) { } @ Override public void messageReceived ( RecoveryAction . SnapshotWrapper snapshot , TransportChannel channel ) throws Exception { if ( ! ( snapshot . phase3 ) ) { cleanOpenIndex ( ) ; } indexShard . performRecovery ( snapshot . snapshot , snapshot . phase3 ) ; if ( snapshot . phase3 ) { <START_BUG> indexShard . refresh ( true ) ; <END_BUG> } channel . sendResponse ( INSTANCE ) ; } } private static class SnapshotWrapper implements Streamable { private MemorySnapshot snapshot ; private boolean phase3 ; private SnapshotWrapper ( ) { } private SnapshotWrapper ( MemorySnapshot snapshot , boolean phase3 ) { } @ Override public void readFrom ( DataInput in ) throws IOException , ClassNotFoundException { } @ Override public void writeTo ( DataOutput out ) throws IOException { } } private class FileChunkTransportRequestHandler extends BaseTransportRequestHandler < RecoveryAction . FileChunk > { @ Override public RecoveryAction . FileChunk newInstance ( ) { } @ Override public void messageReceived ( RecoveryAction . FileChunk request , TransportChannel channel ) throws Exception { } } private static class FileChunk implements Streamable { String name ; long position ; long length ; byte [ ] content ; transient int contentLength ; private FileChunk ( ) { } private FileChunk ( String name , long position , long length , byte [ ] content , int contentLength ) { } @ Override public void readFrom ( DataInput in ) throws IOException , ClassNotFoundException { } @ Override public void writeTo ( DataOutput out ) throws IOException { } } }
public class RestSearchScrollAction extends BaseRestHandler { @ Inject public RestSearchScrollAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { String scrollId = request . param ( "scroll_id" ) ; if ( ( scrollId == null ) && ( request . hasContent ( ) ) ) { scrollId = request . content ( ) . toUtf8 ( ) ; } SearchScrollRequest searchScrollRequest = new SearchScrollRequest ( scrollId ) ; searchScrollRequest . listenerThreaded ( false ) ; try { String scroll = request . param ( "scroll" ) ; if ( scroll != null ) { searchScrollRequest . scroll ( new org . elasticsearch . search . Scroll ( parseTimeValue ( scroll , null ) ) ) ; } SearchOperationThreading operationThreading = SearchOperationThreading . fromString ( request . param ( "operation_threading" ) , null ) ; if ( operationThreading != null ) { if ( operationThreading == ( SearchOperationThreading . NO_THREADS ) ) { operationThreading = SearchOperationThreading . SINGLE_THREAD ; } searchScrollRequest . operationThreading ( operationThreading ) ; } } catch ( Exception e ) { try { XContentBuilder builder = restContentBuilder ( request ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . BAD_REQUEST , builder . startObject ( ) . field ( "error" , e . getMessage ( ) ) . endObject ( ) ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } return ; } client . searchScroll ( searchScrollRequest , new org . elasticsearch . action . ActionListener < SearchResponse > ( ) { @ Override public void onResponse ( SearchResponse response ) { try { XContentBuilder builder = restContentBuilder ( request ) ; builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , response . status ( ) , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class MasterFaultDetection extends AbstractComponent { public static interface Listener { void onMasterFailure ( DiscoveryNode masterNode ) { } void onDisconnectedFromMaster ( ) { } } private final ThreadPool threadPool ; private final TransportService transportService ; private final DiscoveryNodesProvider nodesProvider ; private final CopyOnWriteArrayList < MasterFaultDetection . Listener > listeners = new CopyOnWriteArrayList < MasterFaultDetection . Listener > ( ) ; private final boolean connectOnNetworkDisconnect ; private final TimeValue pingInterval ; private final TimeValue pingRetryTimeout ; private final int pingRetryCount ; private final MasterFaultDetection . FDConnectionListener connectionListener ; private volatile DiscoveryNode masterNode ; private volatile int retryCount ; private final AtomicBoolean notifiedMasterFailure = new AtomicBoolean ( ) ; public MasterFaultDetection ( Settings settings , ThreadPool threadPool , TransportService transportService , DiscoveryNodesProvider nodesProvider ) { } public DiscoveryNode masterNode ( ) { } public void addListener ( MasterFaultDetection . Listener listener ) { } public void removeListener ( MasterFaultDetection . Listener listener ) { } public void restart ( DiscoveryNode masterNode ) { } public void start ( DiscoveryNode masterNode ) { } public void stop ( ) { } public void close ( ) { } private void handleTransportDisconnect ( DiscoveryNode node ) { } private void notifyDisconnectedFromMaster ( ) { } private void notifyMasterFailure ( DiscoveryNode masterNode ) { } private class FDConnectionListener implements TransportConnectionListener { @ Override public void onNodeConnected ( DiscoveryNode node ) { } @ Override public void onNodeDisconnected ( DiscoveryNode node ) { } } private class SendPingRequest implements Runnable { @ Override public void run ( ) { if ( ( masterNode ) != null ) { final DiscoveryNode sentToNode = masterNode ; transportService . sendRequest ( masterNode , MasterFaultDetection . MasterPingRequestHandler . ACTION , new MasterFaultDetection . MasterPingRequest ( nodesProvider . nodes ( ) . localNode ( ) ) , pingRetryTimeout , new BaseTransportResponseHandler < MasterFaultDetection . MasterPingResponseResponse > ( ) { @ Override public MasterFaultDetection . MasterPingResponseResponse newInstance ( ) { return new MasterFaultDetection . MasterPingResponseResponse ( ) ; } @ Override public void handleResponse ( MasterFaultDetection . MasterPingResponseResponse response ) { MasterFaultDetection . this . retryCount = 0 ; if ( sentToNode . equals ( MasterFaultDetection . this . masterNode ( ) ) ) { if ( ! ( response . connectedToMaster ) ) { logger . trace ( "Master<seq2seq4repair_space>[{}]<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>us<seq2seq4repair_space>registered<seq2seq4repair_space>with<seq2seq4repair_space>it..." , masterNode ) ; notifyDisconnectedFromMaster ( ) ; } else { threadPool . schedule ( MasterFaultDetection . SendPingRequest . this , pingInterval ) ; } } } @ Override public void handleException ( RemoteTransportException exp ) { if ( sentToNode . equals ( MasterFaultDetection . this . masterNode ( ) ) ) { int retryCount = ++ ( MasterFaultDetection . this . retryCount ) ; logger . trace ( "Master<seq2seq4repair_space>[{}]<seq2seq4repair_space>failed<seq2seq4repair_space>to<seq2seq4repair_space>ping,<seq2seq4repair_space>retry<seq2seq4repair_space>[{}]<seq2seq4repair_space>out<seq2seq4repair_space>of<seq2seq4repair_space>[{}]" , exp , masterNode , retryCount , pingRetryCount ) ; if ( retryCount >= ( pingRetryCount ) ) { <START_BUG> logger . trace ( "Master<seq2seq4repair_space>[{}]<seq2seq4repair_space>failed<seq2seq4repair_space>on<seq2seq4repair_space>ping" , masterNode ) ; <END_BUG> notifyMasterFailure ( sentToNode ) ; } } } } ) ; } } } private class MasterPingRequestHandler extends BaseTransportRequestHandler < MasterFaultDetection . MasterPingRequest > { public static final String ACTION = "discovery/zen/fd/masterPing" ; @ Override public MasterFaultDetection . MasterPingRequest newInstance ( ) { } @ Override public void messageReceived ( MasterFaultDetection . MasterPingRequest request , TransportChannel channel ) throws Exception { } } private class MasterPingRequest implements Streamable { private DiscoveryNode node ; private MasterPingRequest ( ) { } private MasterPingRequest ( DiscoveryNode node ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } private class MasterPingResponseResponse implements Streamable { private boolean connectedToMaster ; private MasterPingResponseResponse ( ) { } private MasterPingResponseResponse ( boolean connectedToMaster ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class SimpleIcuAnalysisTests { @ Test public void testDefaultsIcuAnalysis ( ) { Index index = new Index ( "test" ) ; <START_BUG> Injector injector = new ModulesBuilder ( ) . add ( new org . elasticsearch . index . settings . IndexSettingsModule ( EMPTY_SETTINGS ) , new org . elasticsearch . index . IndexNameModule ( index ) , new AnalysisModule ( EMPTY_SETTINGS ) . addProcessor ( new IcuAnalysisBinderProcessor ( ) ) ) . createInjector ( ) ; <END_BUG> AnalysisService analysisService = injector . getInstance ( AnalysisService . class ) ; TokenFilterFactory filterFactory = analysisService . tokenFilter ( "icu_normalizer" ) ; MatcherAssert . assertThat ( filterFactory , instanceOf ( IcuNormalizerTokenFilterFactory . class ) ) ; } }
public class Vector2 implements Vector < Vector2 > , Serializable { private static final long serialVersionUID = 913902788239530931L ; public static final Vector2 X = new Vector2 ( 1 , 0 ) ; public static final Vector2 Y = new Vector2 ( 0 , 1 ) ; public static final Vector2 Zero = new Vector2 ( 0 , 0 ) ; public float x ; public float y ; public Vector2 ( ) { } public Vector2 ( float x , float y ) { } public Vector2 ( Vector2 v ) { } @ Override public Vector2 cpy ( ) { } public static float len ( float x , float y ) { } @ Override public float len ( ) { } public static float len2 ( float x , float y ) { } @ Override public float len2 ( ) { } @ Override public Vector2 set ( Vector2 v ) { } public Vector2 set ( float x , float y ) { } @ Override public Vector2 sub ( Vector2 v ) { } public Vector2 sub ( float x , float y ) { } @ Override public Vector2 nor ( ) { } @ Override public Vector2 add ( Vector2 v ) { } public Vector2 add ( float x , float y ) { } public static float dot ( float x1 , float y1 , float x2 , float y2 ) { } @ Override public float dot ( Vector2 v ) { } public float dot ( float ox , float oy ) { } @ Override public Vector2 scl ( float scalar ) { } public Vector2 scl ( float x , float y ) { } @ Override public Vector2 scl ( Vector2 v ) { } @ Override public Vector2 mulAdd ( Vector2 vec , float scalar ) { } @ Override public Vector2 mulAdd ( Vector2 vec , Vector2 mulVec ) { } public static float dst ( float x1 , float y1 , float x2 , float y2 ) { } @ Override public float dst ( Vector2 v ) { } public float dst ( float x , float y ) { } public static float dst2 ( float x1 , float y1 , float x2 , float y2 ) { } @ Override public float dst2 ( Vector2 v ) { } public float dst2 ( float x , float y ) { } @ Override public Vector2 limit ( float limit ) { } @ Override public Vector2 clamp ( float min , float max ) { } @ Override public String toString ( ) { } public Vector2 mul ( Matrix3 mat ) { } public float crs ( Vector2 v ) { } public float crs ( float x , float y ) { } public float angle ( ) { } public float angle ( Vector reference ) { } public float angleRad ( ) { } public float angleRad ( Vector reference ) { <START_BUG> return ( ( float ) ( Math . atan2 ( crs ( reference ) , dot ( reference ) ) ) ) * ( MathUtils . radiansToDegrees ) ; <END_BUG> } public Vector2 setAngle ( float degrees ) { } public Vector2 setAngleRad ( float radians ) { } public Vector2 rotate ( float degrees ) { } public Vector2 rotateRad ( float radians ) { } public Vector2 rotate90 ( int dir ) { } @ Override public Vector2 lerp ( Vector2 target , float alpha ) { } @ Override public Vector2 interpolate ( Vector2 target , float alpha , Interpolation interpolator ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } @ Override public boolean epsilonEquals ( Vector2 other , float epsilon ) { } public boolean epsilonEquals ( float x , float y , float epsilon ) { } @ Override public boolean isUnit ( ) { } @ Override public boolean isUnit ( final float margin ) { } @ Override public boolean isZero ( ) { } @ Override public boolean isZero ( final float margin ) { } @ Override public boolean isOnLine ( Vector2 other ) { } @ Override public boolean isOnLine ( Vector2 other , float epsilon ) { } @ Override public boolean isCollinear ( Vector2 other , float epsilon ) { } @ Override public boolean isCollinear ( Vector2 other ) { } @ Override public boolean isCollinearOpposite ( Vector2 other , float epsilon ) { } @ Override public boolean isCollinearOpposite ( Vector2 other ) { } @ Override public boolean isPerpendicular ( Vector2 vector ) { } @ Override public boolean isPerpendicular ( Vector2 vector , float epsilon ) { } @ Override public boolean hasSameDirection ( Vector2 vector ) { } @ Override public boolean hasOppositeDirection ( Vector2 vector ) { } @ Override public Vector2 setZero ( ) { } }
@ ClusterScope ( randomDynamicTemplates = false ) public class ElasticsearchRestTests extends ElasticsearchIntegrationTest { public static final String REST_TESTS = "tests.rest" ; public static final String REST_TESTS_SUITE = "tests.rest.suite" ; public static final String REST_TESTS_BLACKLIST = "tests.rest.blacklist" ; public static final String REST_TESTS_SPEC = "tests.rest.spec" ; private static final String DEFAULT_TESTS_PATH = "/rest-api-spec/test" ; private static final String DEFAULT_SPEC_PATH = "/rest-api-spec/api" ; private static final String PATHS_SEPARATOR = "," ; private final PathMatcher [ ] blacklistPathMatchers ; private static RestTestExecutionContext restTestExecutionContext ; private final RestTestCandidate testCandidate ; public ElasticsearchRestTests ( @ Name ( "yaml" ) RestTestCandidate testCandidate ) { } @ ParametersFactory public static Iterable < Object [ ] > parameters ( ) throws IOException , RestTestParseException { } private static List < RestTestCandidate > collectTestCandidates ( ) throws IOException , RestTestParseException { } private static String [ ] resolvePathsProperty ( String propertyName , String defaultValue ) { } @ BeforeClass public static void initExecutionContext ( ) throws IOException , RestException { } @ AfterClass public static void close ( ) { } @ Before public void reset ( ) throws IOException , RestException { } private static String buildSkipMessage ( String description , SkipSection skipSection ) { } @ Override protected boolean randomizeNumberOfShardsAndReplicas ( ) { <START_BUG> return COMPATIBILITY_VERSION . onOrAfter ( V_1_2_0 ) ; <END_BUG> } @ Test public void test ( ) throws IOException { } }
public class GistFragment extends RoboSherlockFragment implements OnItemClickListener { private static final int REQUEST_CODE_COMMENT = 1 ; private String gistId ; private List < Comment > comments ; private Gist gist ; @ InjectView ( id . list ) private ListView list ; @ Inject private GistStore store ; @ Inject private ContextScopedProvider < GistService > service ; private View headerView ; private GistHeaderViewHolder headerHolder ; private View loadingView ; private RefreshAnimation refreshAnimation = new RefreshAnimation ( ) ; private boolean starred ; private boolean loadFinished ; @ Inject private AvatarHelper avatarHelper ; @ Inject private ContextScopedProvider < GistService > gistServiceProvider ; private Executor executor = Executors . newFixedThreadPool ( 1 ) ; private List < View > fileHeaders = Lists . newArrayList ( ) ; @ SuppressWarnings ( "unchecked" ) public void onCreate ( Bundle savedInstanceState ) { } public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } public void onActivityCreated ( Bundle savedInstanceState ) { } private boolean isOwner ( ) { } @ Override public void onCreateOptionsMenu ( Menu options , MenuInflater inflater ) { } @ Override public void onPrepareOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } private void starGist ( ) { } private void unstarGist ( ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } private void createComment ( final String comment ) { } private void updateFiles ( Gist gist ) { } private void updateList ( Gist gist , List < Comment > comments ) { } @ SuppressWarnings ( "unchecked" ) private ViewHoldingListAdapter < Comment > getRootAdapter ( ) { } private void refreshGist ( ) { new com . github . mobile . android . async . AuthenticatedUserTask < com . github . mobile . android . core . gist . FullGist > ( getActivity ( ) , executor ) { public com . github . mobile . android . core . gist . FullGist run ( ) throws Exception { Gist gist = store . refreshGist ( gistId ) ; GistService gistService = service . get ( getContext ( ) ) ; List < Comment > comments ; if ( ( gist . getComments ( ) ) > 0 ) comments = gistService . getComments ( gistId ) ; else comments = java . util . Collections . emptyList ( ) ; return new com . github . mobile . android . core . gist . FullGist ( gist , gistService . isStarred ( gistId ) , comments ) ; } protected void onException ( Exception e ) throws RuntimeException { <START_BUG> com . github . mobile . android . util . ErrorHelper . show ( getActivity ( ) . getApplicationContext ( ) , e , string . error_gist_load ) ; <END_BUG> } protected void onSuccess ( com . github . mobile . android . core . gist . FullGist fullGist ) throws Exception { starred = fullGist . isStarred ( ) ; loadFinished = true ; gist = fullGist . getGist ( ) ; comments = fullGist ; getArguments ( ) . putSerializable ( EXTRA_COMMENTS , fullGist ) ; updateList ( fullGist . getGist ( ) , fullGist ) ; } protected void onFinally ( ) throws RuntimeException { refreshAnimation . stop ( ) ; } } . execute ( ) ; } public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { } }
public final class AndroidGraphics implements Renderer , Graphics { final View view ; int width ; int height ; AndroidApplication app ; GLCommon gl ; GL10 gl10 ; GL11 gl11 ; GL20 gl20 ; GLU glu ; String extensions ; private long lastFrameTime = System . nanoTime ( ) ; private float deltaTime = 0 ; private long frameStart = System . nanoTime ( ) ; private int frames = 0 ; private int fps ; private WindowedMean mean = new WindowedMean ( 5 ) ; volatile boolean created = false ; volatile boolean running = false ; volatile boolean pause = false ; volatile boolean resume = false ; volatile boolean destroy = false ; private float ppiX = 0 ; private float ppiY = 0 ; private float ppcX = 0 ; private float ppcY = 0 ; private float density = 1 ; private final AndroidApplicationConfiguration config ; private BufferFormat bufferFormat = new BufferFormat ( 5 , 6 , 5 , 0 , 16 , 0 , 0 , false ) ; public AndroidGraphics ( AndroidApplication activity , AndroidApplicationConfiguration config , ResolutionStrategy resolutionStrategy ) { } private View createGLSurfaceView ( Activity activity , boolean useGL2 , ResolutionStrategy resolutionStrategy ) { } private EGLConfigChooser getEglConfigChooser ( ) { } private void updatePpi ( ) { } private boolean checkGL20 ( ) { } @ Override public GL10 getGL10 ( ) { } @ Override public GL11 getGL11 ( ) { } @ Override public GL20 getGL20 ( ) { } @ Override public int getHeight ( ) { } @ Override public int getWidth ( ) { } @ Override public boolean isGL11Available ( ) { } @ Override public boolean isGL20Available ( ) { } private static boolean isPowerOfTwo ( int value ) { } private void setupGL ( javax . microedition . khronos . opengles . GL10 gl ) { } @ Override public void onSurfaceChanged ( javax . microedition . khronos . opengles . GL10 gl , int width , int height ) { } @ Override public void onSurfaceCreated ( javax . microedition . khronos . opengles . GL10 gl , EGLConfig config ) { } private void logConfig ( EGLConfig config ) { } int [ ] value = new int [ 1 ] ; private int getAttrib ( EGL10 egl , EGLDisplay display , EGLConfig config , int attrib , int defValue ) { } Object synch = new Object ( ) ; void resume ( ) { } void pause ( ) { } void destroy ( ) { } @ Override public void onDrawFrame ( javax . microedition . khronos . opengles . GL10 gl ) { } @ Override public float getDeltaTime ( ) { } @ Override public GraphicsType getType ( ) { } @ Override public int getFramesPerSecond ( ) { } public void clearManagedCaches ( ) { } public View getView ( ) { } @ Override public GLCommon getGLCommon ( ) { } @ Override public float getPpiX ( ) { } @ Override public float getPpiY ( ) { } @ Override public float getPpcX ( ) { } @ Override public float getPpcY ( ) { } @ Override public float getDensity ( ) { } @ Override public GLU getGLU ( ) { } @ Override public boolean supportsDisplayModeChange ( ) { } @ Override public boolean setDisplayMode ( DisplayMode displayMode ) { } @ Override public DisplayMode [ ] getDisplayModes ( ) { } @ Override public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { } @ Override public void setTitle ( String title ) { } @ Override <START_BUG> public void setIcon ( Pixmap pixmap ) { <END_BUG> } private class AndroidDisplayMode extends DisplayMode { protected AndroidDisplayMode ( int width , int height , int refreshRate , int bitsPerPixel ) { } } @ Override public DisplayMode getDesktopDisplayMode ( ) { } @ Override public BufferFormat getBufferFormat ( ) { } @ Override public void setVSync ( boolean vsync ) { } @ Override public boolean supportsExtension ( String extension ) { } }
public class FloatFieldMapper extends NumberFieldMapper < Float > { public static final String CONTENT_TYPE = "float" ; public static class Defaults extends NumberFieldMapper . Defaults { public static final FieldType FIELD_TYPE = new FieldType ( NumberFieldMapper . Defaults . FIELD_TYPE ) ; public static final Float NULL_VALUE = null ; } public static class Builder extends NumberFieldMapper . Builder < FloatFieldMapper . Builder , FloatFieldMapper > { protected Float nullValue = FloatFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public FloatFieldMapper . Builder nullValue ( float nullValue ) { } @ Override public FloatFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private Float nullValue ; private String nullValueAsString ; protected FloatFieldMapper ( Names names , int precisionStep , float boost , FieldType fieldType , Float nullValue , Explicit < Boolean > ignoreMalformed , PostingsFormatProvider provider , SimilarityProvider similarity , @ Nullable Settings fieldDataSettings ) { } @ Override public FieldType defaultFieldType ( ) { } @ Override public FieldDataType defaultFieldDataType ( ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Float value ( Object value ) { } @ Override public BytesRef indexedValueForSearch ( Object value ) { int intValue = NumericUtils . floatToSortableInt ( parseValue ( value ) ) ; BytesRef bytesRef = new BytesRef ( ) ; <START_BUG> NumericUtils . intToPrefixCoded ( intValue , precisionStep ( ) , bytesRef ) ; <END_BUG> return bytesRef ; } private float parseValue ( Object value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query termQuery ( Object value , @ Nullable QueryParseContext context ) { } @ Override public Query rangeQuery ( Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter termFilter ( Object value , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( IndexFieldDataService fieldData , Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected boolean customBoost ( ) { } @ Override protected Field innerParseCreateField ( ParseContext context ) throws IOException { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } public static class CustomFloatNumericField extends CustomNumericField { private final float number ; private final NumberFieldMapper mapper ; public CustomFloatNumericField ( NumberFieldMapper mapper , float number , FieldType fieldType ) { } @ Override public TokenStream tokenStream ( Analyzer analyzer ) throws IOException { } @ Override public String numericAsString ( ) { } } }
public class StreamUtils { public static final int DEFAULT_BUFFER_SIZE = 8192 ; public static final byte [ ] EMPTY_BYTES = new byte [ 0 ] ; public static void copyStream ( InputStream input , OutputStream output ) throws IOException { } public static void copyStream ( InputStream input , OutputStream output , int bufferSize ) throws IOException { } public static byte [ ] copyStreamToByteArray ( InputStream input ) throws IOException { } public static byte [ ] copyStreamToByteArray ( InputStream input , int estimatedSize ) throws IOException { } public static String copyStreamToString ( InputStream input ) throws IOException { } public static String copyStreamToString ( InputStream input , int approxStringLength ) throws IOException { } public static void closeQuietly ( Closeable c ) { if ( c != null ) try { c . close ( ) ; <START_BUG> } catch ( IOException e ) { <END_BUG> } } private static class OptimizedByteArrayOutputStream extends ByteArrayOutputStream { OptimizedByteArrayOutputStream ( int initialSize ) { } @ Override public synchronized byte [ ] toByteArray ( ) { } } }
public class Decal { private static final int VERTEX_SIZE = ( 3 + 1 ) + 2 ; public static final int SIZE = 4 * ( Decal . VERTEX_SIZE ) ; private static Vector3 tmp = new Vector3 ( ) ; private static Vector3 tmp2 = new Vector3 ( ) ; public int value ; protected float [ ] vertices = new float [ Decal . SIZE ] ; protected Vector3 position = new Vector3 ( ) ; protected Quaternion rotation = new Quaternion ( ) ; protected Vector2 scale = new Vector2 ( 1 , 1 ) ; public Vector2 transformationOffset = null ; protected Vector2 dimensions = new Vector2 ( ) ; protected DecalMaterial material = new DecalMaterial ( ) ; protected boolean updated = false ; protected Decal ( ) { } public void setColor ( float r , float g , float b , float a ) { } public void rotateX ( float angle ) { } public void rotateY ( float angle ) { } public void rotateZ ( float angle ) { } public void setRotation ( Vector3 dir , Vector3 up ) { Decal . tmp . set ( up ) . crs ( dir ) . nor ( ) ; Decal . tmp2 . set ( dir ) . crs ( Decal . tmp ) . nor ( ) ; <START_BUG> rotation . setFromAxes ( Decal . tmp . x , Decal . tmp . y , Decal . tmp . z , Decal . tmp2 . x , Decal . tmp2 . y , Decal . tmp2 . z , dir . x , dir . y , dir . z ) ; <END_BUG> updated = false ; } public Quaternion getRotation ( ) { } public void translateX ( float units ) { } public void setX ( float x ) { } public float getX ( ) { } public void translateY ( float units ) { } public void setY ( float y ) { } public float getY ( ) { } public void translateZ ( float units ) { } public void setZ ( float z ) { } public float getZ ( ) { } public void translate ( float x , float y , float z ) { } public void setPosition ( float x , float y , float z ) { } public Vector3 getPosition ( ) { } public void setScaleX ( float scale ) { } public float getScaleX ( ) { } public void setScaleY ( float scale ) { } public float getScaleY ( ) { } public void setScale ( float scaleX , float scaleY ) { } public void setScale ( float scale ) { } public void setWidth ( float width ) { } public float getWidth ( ) { } public void setHeight ( float height ) { } public float getHeight ( ) { } public void setDimensions ( float width , float height ) { } public float [ ] getVertices ( ) { } protected void update ( ) { } protected void transformVertices ( ) { } protected void resetVertices ( ) { } protected void updateUVs ( ) { } public void setTextureRegion ( TextureRegion textureRegion ) { } public TextureRegion getTextureRegion ( ) { } public void setBlending ( int srcBlendFactor , int dstBlendFactor ) { } public DecalMaterial getMaterial ( ) { } static final Vector3 dir = new Vector3 ( ) ; public void lookAt ( Vector3 position , Vector3 up ) { } public static final int X1 = 0 ; public static final int Y1 = 1 ; public static final int Z1 = 2 ; public static final int C1 = 3 ; public static final int U1 = 4 ; public static final int V1 = 5 ; public static final int X2 = 6 ; public static final int Y2 = 7 ; public static final int Z2 = 8 ; public static final int C2 = 9 ; public static final int U2 = 10 ; public static final int V2 = 11 ; public static final int X3 = 12 ; public static final int Y3 = 13 ; public static final int Z3 = 14 ; public static final int C3 = 15 ; public static final int U3 = 16 ; public static final int V3 = 17 ; public static final int X4 = 18 ; public static final int Y4 = 19 ; public static final int Z4 = 20 ; public static final int C4 = 21 ; public static final int U4 = 22 ; public static final int V4 = 23 ; protected static Quaternion rotator = new Quaternion ( 0 , 0 , 0 , 0 ) ; protected static final Vector3 X_AXIS = new Vector3 ( 1 , 0 , 0 ) ; protected static final Vector3 Y_AXIS = new Vector3 ( 0 , 1 , 0 ) ; protected static final Vector3 Z_AXIS = new Vector3 ( 0 , 0 , 1 ) ; public static Decal newDecal ( TextureRegion textureRegion ) { } public static Decal newDecal ( TextureRegion textureRegion , boolean hasTransparency ) { } public static Decal newDecal ( float width , float height , TextureRegion textureRegion ) { } public static Decal newDecal ( float width , float height , TextureRegion textureRegion , boolean hasTransparency ) { } public static Decal newDecal ( float width , float height , TextureRegion textureRegion , int srcBlendFactor , int dstBlendFactor ) { } }
public class JoglGraphics extends JoglGraphicsBase implements GLEventListener { ApplicationListener listener = null ; boolean useGL2 ; boolean created = false ; boolean exclusiveMode = false ; final JoglGraphics . JoglDisplayMode desktopMode ; final JoglApplicationConfiguration config ; public JoglGraphics ( ApplicationListener listener , JoglApplicationConfiguration config ) { } public void create ( ) { } public void pause ( ) { } public void resume ( ) { } @ Override public void init ( GLAutoDrawable drawable ) { } @ Override public void reshape ( GLAutoDrawable drawable , int x , int y , int width , int height ) { } @ Override public void display ( GLAutoDrawable arg0 ) { } @ Override public void displayChanged ( GLAutoDrawable arg0 , boolean arg1 , boolean arg2 ) { } public void destroy ( ) { } @ Override public float getPpiX ( ) { } @ Override public float getPpiY ( ) { } @ Override public float getPpcX ( ) { } @ Override public float getPpcY ( ) { } @ Override public boolean supportsDisplayModeChange ( ) { } protected static class JoglDisplayMode extends DisplayMode { final java . awt . DisplayMode mode ; protected JoglDisplayMode ( int width , int height , int refreshRate , int bitsPerPixel , java . awt . DisplayMode mode ) { } } @ Override public DisplayMode [ ] getDisplayModes ( ) { } @ Override public void setTitle ( String title ) { } @ Override public void setIcon ( Pixmap pixmap ) { } @ Override public DisplayMode getDesktopDisplayMode ( ) { } @ Override public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { } protected JoglGraphics . JoglDisplayMode findBestMatch ( int width , int height ) { } @ Override public boolean setDisplayMode ( DisplayMode displayMode ) { } private boolean setWindowedMode ( int width , int height ) { } protected static JFrame findJFrame ( Component component ) { } @ Override public void setVSync ( boolean vsync ) { } @ Override public BufferFormat getBufferFormat ( ) { GLCapabilities caps = canvas . getChosenGLCapabilities ( ) ; <START_BUG> return new BufferFormat ( caps . getRedBits ( ) , caps . getGreenBits ( ) , caps . getBlueBits ( ) , caps . getAlphaBits ( ) , caps . getDepthBits ( ) , caps . getStencilBits ( ) , caps . getNumSamples ( ) ) ; <END_BUG> } }
public class Bits { long [ ] bits = new long [ ] { 0 } ; public Bits ( ) { } public Bits ( int nbits ) { } public boolean get ( int index ) { } public boolean getAndClear ( int index ) { } public boolean getAndSet ( int index ) { } public void set ( int index ) { } public void flip ( int index ) { } private void checkCapacity ( int len ) { } public void clear ( int index ) { } public void clear ( ) { } public int numBits ( ) { } public int length ( ) { } public boolean isEmpty ( ) { } public int nextSetBit ( int fromIndex ) { } public int nextClearBit ( int fromIndex ) { } public void and ( Bits other ) { int commonWords = Math . min ( bits . length , other . bits . length ) ; for ( int i = 0 ; commonWords > i ; i ++ ) { bits [ i ] &= other . bits [ i ] ; } if ( ( bits . length ) > commonWords ) { <START_BUG> for ( int i = other . bits . length , s = bits . length ; s > i ; i ++ ) { <END_BUG> bits [ i ] = 0L ; } } } public void andNot ( Bits other ) { } public void or ( Bits other ) { } public void xor ( Bits other ) { } public boolean intersects ( Bits other ) { } public boolean containsAll ( Bits other ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } }
public class MoreLikeThisQueryBuilder extends BaseQueryBuilder implements BoostableQueryBuilder < MoreLikeThisQueryBuilder > { public static final class Item extends MultiGetRequest . Item implements ToXContent { private BytesReference doc ; public Item ( ) { } public Item ( String index , @ Nullable String type , String id ) { } public BytesReference doc ( ) { } public MoreLikeThisQueryBuilder . Item doc ( XContentBuilder doc ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } } private final String [ ] fields ; private String likeText ; private List < String > ids = new ArrayList < > ( ) ; private List < MoreLikeThisQueryBuilder . Item > docs = new ArrayList < > ( ) ; private Boolean include = null ; private String minimumShouldMatch = null ; private int minTermFreq = - 1 ; private int maxQueryTerms = - 1 ; private String [ ] stopWords = null ; private int minDocFreq = - 1 ; private int maxDocFreq = - 1 ; private int minWordLength = - 1 ; private int maxWordLength = - 1 ; private float boostTerms = - 1 ; private float boost = - 1 ; private String analyzer ; private Boolean failOnUnsupportedField ; private String queryName ; public MoreLikeThisQueryBuilder ( ) { } public MoreLikeThisQueryBuilder ( String ... fields ) { } public MoreLikeThisQueryBuilder likeText ( String likeText ) { } public MoreLikeThisQueryBuilder ids ( String ... ids ) { } public MoreLikeThisQueryBuilder docs ( MoreLikeThisQueryBuilder . Item ... docs ) { } public MoreLikeThisQueryBuilder addItem ( MoreLikeThisQueryBuilder . Item item ) { } public MoreLikeThisQueryBuilder include ( boolean include ) { } public MoreLikeThisQueryBuilder minimumShouldMatch ( String minimumShouldMatch ) { } @ Deprecated public MoreLikeThisQueryBuilder percentTermsToMatch ( float percentTermsToMatch ) { <START_BUG> return minimumShouldMatch ( ( ( ( int ) ( percentTermsToMatch * 100 ) ) + "%" ) ) ; <END_BUG> } public MoreLikeThisQueryBuilder minTermFreq ( int minTermFreq ) { } public MoreLikeThisQueryBuilder maxQueryTerms ( int maxQueryTerms ) { } public MoreLikeThisQueryBuilder stopWords ( String ... stopWords ) { } public MoreLikeThisQueryBuilder minDocFreq ( int minDocFreq ) { } public MoreLikeThisQueryBuilder maxDocFreq ( int maxDocFreq ) { } public MoreLikeThisQueryBuilder minWordLength ( int minWordLength ) { } public MoreLikeThisQueryBuilder maxWordLength ( int maxWordLength ) { } public MoreLikeThisQueryBuilder boostTerms ( float boostTerms ) { } public MoreLikeThisQueryBuilder analyzer ( String analyzer ) { } public MoreLikeThisQueryBuilder boost ( float boost ) { } public MoreLikeThisQueryBuilder failOnUnsupportedField ( boolean fail ) { } public MoreLikeThisQueryBuilder queryName ( String queryName ) { } @ Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class NewsListAdapter extends ItemListAdapter < Event , NewsItemView > { public static boolean isValid ( final Event event ) { } private static void appendComment ( final StyledText details , final Comment comment ) { } private static void appendCommitComment ( final StyledText details , final CommitComment comment ) { } private static void appendText ( final StyledText details , String text ) { } private static void formatCommitComment ( Event event , StyledText main , StyledText details ) { } private static void formatDownload ( Event event , StyledText main , StyledText details ) { } private static void formatCreate ( Event event , StyledText main , StyledText details ) { } private static void formatDelete ( Event event , StyledText main , StyledText details ) { } private static void formatFollow ( Event event , StyledText main , StyledText details ) { main . bold ( event . getActor ( ) . getLogin ( ) ) ; main . append ( "<seq2seq4repair_space>started<seq2seq4repair_space>following<seq2seq4repair_space>" ) ; <START_BUG> main . append ( ( ( org . eclipse . egit . github . core . event . FollowPayload ) ( event . getPayload ( ) ) ) . getTarget ( ) . getLogin ( ) ) ; <END_BUG> } private static void formatFork ( Event event , StyledText main , StyledText details ) { } private static void formatGist ( Event event , StyledText main , StyledText details ) { } private static void formatWiki ( Event event , StyledText main , StyledText details ) { } private static void formatIssueComment ( Event event , StyledText main , StyledText details ) { } private static void formatIssues ( Event event , StyledText main , StyledText details ) { } private static void formatAddMember ( Event event , StyledText main , StyledText details ) { } private static void formatPublic ( Event event , StyledText main , StyledText details ) { } private static void formatWatch ( Event event , StyledText main , StyledText details ) { } private static void formatReviewComment ( Event event , StyledText main , StyledText details ) { } private static void formatPullRequest ( Event event , StyledText main , StyledText details ) { } private static void formatPush ( Event event , StyledText main , StyledText details ) { } private static void formatTeamAdd ( Event event , StyledText main , StyledText details ) { } private final AvatarLoader avatars ; public NewsListAdapter ( LayoutInflater inflater , Event [ ] elements , AvatarLoader avatars ) { } public NewsListAdapter ( LayoutInflater inflater , AvatarLoader avatars ) { } @ Override public long getItemId ( final int position ) { } @ Override protected void update ( final int position , final NewsItemView view , final Event event ) { } @ Override protected NewsItemView createView ( final View view ) { } }
public abstract class TabPagerActivity < V extends PagerAdapter & FragmentProvider > extends PagerActivity implements OnTabChangeListener , TabContentFactory { protected ViewPager pager ; protected TabHost host ; protected V adapter ; @ Override public void onPageSelected ( final int position ) { } @ Override public void onTabChanged ( String tabId ) { } @ Override public View createTabContent ( String tag ) { <START_BUG> return ViewUtils . setGone ( new View ( this ) , true ) ; <END_BUG> } protected abstract V createAdapter ( ) { } protected String getTitle ( final int position ) { } protected String getIcon ( final int position ) { } protected TabPagerActivity < V > setGone ( boolean gone ) { } protected void setCurrentItem ( final int position ) { } protected int getContentView ( ) { } private void updateCurrentItem ( final int newPosition ) { } private void createPager ( ) { } protected void createTabs ( ) { } protected void configureTabPager ( ) { } @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override protected FragmentProvider getProvider ( ) { } }
public class TransportGetAction extends TransportSingleOperationAction < GetRequest , GetResponse > { @ Inject public TransportGetAction ( Settings settings , ClusterService clusterService , TransportService transportService , IndicesService indicesService , ThreadPool threadPool ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected void checkBlock ( GetRequest request , ClusterState state ) { } @ Override protected GetResponse shardOperation ( GetRequest request , int shardId ) throws ElasticSearchException { } private FieldSelector buildFieldSelectors ( DocumentMapper docMapper , String ... fields ) { } private byte [ ] extractSource ( Document doc , DocumentMapper documentMapper ) { byte [ ] source = null ; Fieldable sourceField = doc . getFieldable ( documentMapper . sourceMapper ( ) . names ( ) . indexName ( ) ) ; if ( sourceField != null ) { <START_BUG> source = documentMapper . sourceMapper ( ) . value ( sourceField ) ; <END_BUG> doc . removeField ( documentMapper . sourceMapper ( ) . names ( ) . indexName ( ) ) ; } return source ; } @ Override protected GetRequest newRequest ( ) { } @ Override protected GetResponse newResponse ( ) { } }
public class Decal { private static final int VERTEX_SIZE = ( 3 + 1 ) + 2 ; public static final int SIZE = 4 * ( Decal . VERTEX_SIZE ) ; private static Vector3 tmp = new Vector3 ( ) ; private static Vector3 tmp2 = new Vector3 ( ) ; public int value ; protected float [ ] vertices = new float [ Decal . SIZE ] ; protected Vector3 position = new Vector3 ( ) ; protected Quaternion rotation = new Quaternion ( ) ; protected Vector2 scale = new Vector2 ( 1 , 1 ) ; public Vector2 transformationOffset = null ; protected Vector2 dimensions = new Vector2 ( ) ; protected DecalMaterial material = new DecalMaterial ( ) ; protected boolean updated = false ; protected Decal ( ) { } public void setColor ( float r , float g , float b , float a ) { } public void rotateX ( float angle ) { } public void rotateY ( float angle ) { } public void rotateZ ( float angle ) { } public void setRotation ( Vector3 dir , Vector3 up ) { Decal . tmp . set ( up ) . crs ( dir ) . nor ( ) ; Decal . tmp2 . set ( dir ) . crs ( Decal . tmp ) . nor ( ) ; <START_BUG> rotation . setFromAxes ( Decal . tmp . x , Decal . tmp2 . x , dir . x , Decal . tmp . y , Decal . tmp2 . y , dir . y , Decal . tmp . z , Decal . tmp2 . z , dir . z ) ; <END_BUG> updated = false ; } public Quaternion getRotation ( ) { } public void translateX ( float units ) { } public void setX ( float x ) { } public float getX ( ) { } public void translateY ( float units ) { } public void setY ( float y ) { } public float getY ( ) { } public void translateZ ( float units ) { } public void setZ ( float z ) { } public float getZ ( ) { } public void translate ( float x , float y , float z ) { } public void setPosition ( float x , float y , float z ) { } public Vector3 getPosition ( ) { } public void setScaleX ( float scale ) { } public float getScaleX ( ) { } public void setScaleY ( float scale ) { } public float getScaleY ( ) { } public void setScale ( float scaleX , float scaleY ) { } public void setScale ( float scale ) { } public void setWidth ( float width ) { } public float getWidth ( ) { } public void setHeight ( float height ) { } public float getHeight ( ) { } public void setDimensions ( float width , float height ) { } public float [ ] getVertices ( ) { } protected void update ( ) { } protected void transformVertices ( ) { } protected void resetVertices ( ) { } protected void updateUVs ( ) { } public void setTextureRegion ( TextureRegion textureRegion ) { } public TextureRegion getTextureRegion ( ) { } public void setBlending ( int srcBlendFactor , int dstBlendFactor ) { } public DecalMaterial getMaterial ( ) { } static final Vector3 dir = new Vector3 ( ) ; public void lookAt ( Vector3 position , Vector3 up ) { } public static final int X1 = 0 ; public static final int Y1 = 1 ; public static final int Z1 = 2 ; public static final int C1 = 3 ; public static final int U1 = 4 ; public static final int V1 = 5 ; public static final int X2 = 6 ; public static final int Y2 = 7 ; public static final int Z2 = 8 ; public static final int C2 = 9 ; public static final int U2 = 10 ; public static final int V2 = 11 ; public static final int X3 = 12 ; public static final int Y3 = 13 ; public static final int Z3 = 14 ; public static final int C3 = 15 ; public static final int U3 = 16 ; public static final int V3 = 17 ; public static final int X4 = 18 ; public static final int Y4 = 19 ; public static final int Z4 = 20 ; public static final int C4 = 21 ; public static final int U4 = 22 ; public static final int V4 = 23 ; protected static Quaternion rotator = new Quaternion ( 0 , 0 , 0 , 0 ) ; protected static final Vector3 X_AXIS = new Vector3 ( 1 , 0 , 0 ) ; protected static final Vector3 Y_AXIS = new Vector3 ( 0 , 1 , 0 ) ; protected static final Vector3 Z_AXIS = new Vector3 ( 0 , 0 , 1 ) ; public static Decal newDecal ( TextureRegion textureRegion ) { } public static Decal newDecal ( TextureRegion textureRegion , boolean hasTransparency ) { } public static Decal newDecal ( float width , float height , TextureRegion textureRegion ) { } public static Decal newDecal ( float width , float height , TextureRegion textureRegion , boolean hasTransparency ) { } public static Decal newDecal ( float width , float height , TextureRegion textureRegion , int srcBlendFactor , int dstBlendFactor ) { } }
public class BaseAnimationController { public static final class Transform implements Poolable { public final Vector3 translation = new Vector3 ( ) ; public final Quaternion rotation = new Quaternion ( ) ; public final Vector3 scale = new Vector3 ( 1 , 1 , 1 ) ; public Transform ( ) { } public BaseAnimationController . Transform idt ( ) { } public BaseAnimationController . Transform set ( final Vector3 t , final Quaternion r , final Vector3 s ) { } public BaseAnimationController . Transform set ( final BaseAnimationController . Transform other ) { } public BaseAnimationController . Transform lerp ( final BaseAnimationController . Transform target , final float alpha ) { } public BaseAnimationController . Transform lerp ( final Vector3 targetT , final Quaternion targetR , final Vector3 targetS , final float alpha ) { } public Matrix4 toMatrix4 ( final Matrix4 out ) { out . idt ( ) ; out . translate ( translation ) ; out . rotate ( rotation ) ; <START_BUG> out . scale ( scale . x , scale . y , scale . z ) ; <END_BUG> return out ; } @ Override public void reset ( ) { } } private final Pool < BaseAnimationController . Transform > transformPool = new Pool < BaseAnimationController . Transform > ( ) { @ Override protected BaseAnimationController . Transform newObject ( ) { } } ; private static final ObjectMap < Node , BaseAnimationController . Transform > transforms = new ObjectMap < Node , BaseAnimationController . Transform > ( ) ; private boolean applying = false ; public final ModelInstance target ; public BaseAnimationController ( final ModelInstance target ) { } protected void begin ( ) { } protected void apply ( final Animation animation , final float time , final float weight ) { } protected void end ( ) { } protected void applyAnimation ( final Animation animation , final float time ) { } protected void applyAnimations ( final Animation anim1 , final float time1 , final Animation anim2 , final float time2 , final float weight ) { } private static final BaseAnimationController . Transform tmpT = new BaseAnimationController . Transform ( ) ; protected static void applyAnimation ( final ObjectMap < Node , BaseAnimationController . Transform > out , final Pool < BaseAnimationController . Transform > pool , final float alpha , final Animation animation , final float time ) { } }
public class PolygonSpriteBatch { private Mesh mesh ; private Mesh [ ] buffers ; private Texture lastTexture = null ; private int idx = 0 ; private int currBufferIdx = 0 ; private final float [ ] vertices ; private final Matrix4 transformMatrix = new Matrix4 ( ) ; private final Matrix4 projectionMatrix = new Matrix4 ( ) ; private final Matrix4 combinedMatrix = new Matrix4 ( ) ; private boolean drawing = false ; private boolean blendingDisabled = false ; private int blendSrcFunc = GL11 . GL_SRC_ALPHA ; private int blendDstFunc = GL11 . GL_ONE_MINUS_SRC_ALPHA ; private final ShaderProgram shader ; private boolean ownsShader ; float color = WHITE . toFloatBits ( ) ; private Color tempColor = new Color ( 1 , 1 , 1 , 1 ) ; public int renderCalls = 0 ; public int totalRenderCalls = 0 ; public int maxVerticesInBatch = 0 ; private ShaderProgram customShader = null ; public PolygonSpriteBatch ( ) { } public PolygonSpriteBatch ( int size ) { } public PolygonSpriteBatch ( int size , ShaderProgram defaultShader ) { } public PolygonSpriteBatch ( int size , int buffers ) { } public PolygonSpriteBatch ( int size , int buffers , ShaderProgram defaultShader ) { } public static ShaderProgram createDefaultShader ( ) { } public void begin ( ) { } public void end ( ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public void setColor ( float color ) { } public Color getColor ( ) { } public void draw ( PolygonRegion region , float x , float y ) { <START_BUG> draw ( region , x , y , Math . abs ( region . getRegion ( ) . getRegionWidth ( ) ) , Math . abs ( region . getRegion ( ) . getRegionHeight ( ) ) ) ; <END_BUG> } public void draw ( PolygonRegion region , float x , float y , float width , float height ) { } public void draw ( PolygonRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation ) { } public void draw ( PolygonRegion region , float [ ] spriteVertices , int offset , int length ) { } public void flush ( ) { } private void renderMesh ( ) { } public void disableBlending ( ) { } public void enableBlending ( ) { } public void setBlendFunction ( int srcFunc , int dstFunc ) { } public void dispose ( ) { } public Matrix4 getProjectionMatrix ( ) { } public Matrix4 getTransformMatrix ( ) { } public void setProjectionMatrix ( Matrix4 projection ) { } public void setTransformMatrix ( Matrix4 transform ) { } private void setupMatrices ( ) { } private void switchTexture ( Texture texture ) { } public void setShader ( ShaderProgram shader ) { } public boolean isBlendingEnabled ( ) { } }
final class JoglPanel extends JPanel implements KeyListener , MouseListener , MouseMotionListener , GLEventListener { private static final long serialVersionUID = - 3638194405409146221L ; private static boolean loaded = false ; private static GLContext context = null ; private final GLCanvas canvas ; private final Animator animator ; private boolean vSynch = true ; private final Point mousePosition = new Point ( ) ; private final HashSet < Integer > buttons = new HashSet < Integer > ( ) ; private final HashSet < Integer > keys = new HashSet < Integer > ( ) ; private final ArrayList < RenderListener > listeners = new ArrayList < RenderListener > ( ) ; private final ArrayList < RenderListener > setupListeners = new ArrayList < RenderListener > ( ) ; private long frameStart = System . nanoTime ( ) ; private float deltaTime = 0 ; private WindowedMean mean = new WindowedMean ( 10 ) ; private Application application = null ; private JoglInputMultiplexer multiplexer ; private static void loadLibraries ( ) { } private static void loadLibrary ( String resource ) { } JoglPanel ( Application application ) { } public void dispose ( ) { } public float getDeltaTime ( ) { } public GLCanvas getCanvas ( ) { } public void setVerticalSynch ( boolean v_synch ) { } public boolean getVerticalSynch ( ) { } public void mouseDragged ( MouseEvent arg0 ) { } public void mouseMoved ( MouseEvent arg0 ) { } public int getMouseX ( ) { } public int getMouseY ( ) { } public void mouseClicked ( MouseEvent arg0 ) { } public void mouseEntered ( MouseEvent arg0 ) { } public void mouseExited ( MouseEvent arg0 ) { } public void mousePressed ( MouseEvent arg0 ) { } public void mouseReleased ( MouseEvent arg0 ) { } public void keyPressed ( KeyEvent arg0 ) { } public void keyReleased ( KeyEvent arg0 ) { } public void keyTyped ( KeyEvent arg0 ) { } public boolean isButtonDown ( int button ) { } public boolean isKeyDown ( int key ) { } public void addGraphicListener ( RenderListener listener ) { } public void removeGraphicListener ( RenderListener listener ) { } @ Override public void display ( GLAutoDrawable arg0 ) { } @ Override public void displayChanged ( GLAutoDrawable arg0 , boolean arg1 , boolean arg2 ) { } @ Override public void init ( GLAutoDrawable arg0 ) { for ( RenderListener listener : listeners ) listener . surfaceCreated ( ) ; <START_BUG> setVerticalSynch ( false ) ; <END_BUG> } @ Override public void reshape ( GLAutoDrawable arg0 , int arg1 , int arg2 , int arg3 , int arg4 ) { } public GL getGL ( ) { } public Point getLastMousePosition ( ) { } public void setInputMultiplexer ( JoglInputMultiplexer inputMultiplexer ) { } public boolean isAnyKeyDown ( ) { } }
public class Facets implements Streamable , ToJson { private final List < Facet > EMPTY = ImmutableList . of ( ) ; private List < Facet > facets ; private Facets ( ) { } public Facets ( List < Facet > facets ) { } public List < Facet > facets ( ) { } public CountFacet . CountFacet countFacet ( String name ) { } public Facet facet ( String name ) { } @ Override public void toJson ( JsonBuilder builder , Params params ) throws IOException { } public static Facets readFacets ( DataInput in ) throws IOException , ClassNotFoundException { } @ Override public void readFrom ( DataInput in ) throws IOException , ClassNotFoundException { } @ Override public void writeTo ( DataOutput out ) throws IOException { <START_BUG> out . write ( facets . size ( ) ) ; <END_BUG> for ( Facet facet : facets ) { out . write ( facet . type ( ) . id ( ) ) ; facet . writeTo ( out ) ; } } }
public class DefaultShaderProvider extends BaseShaderProvider { public String vertexShader ; public String fragmentShader ; public DefaultShaderProvider ( final String vertexShader , final String fragmentShader ) { } public DefaultShaderProvider ( final FileHandle vertexShader , final FileHandle fragmentShader ) { } public DefaultShaderProvider ( ) { } @ Override protected Shader createShader ( final Renderable renderable ) { app . log ( "DefaultShaderProvider" , "Creating<seq2seq4repair_space>new<seq2seq4repair_space>shader" ) ; if ( graphics . isGL20Available ( ) ) { <START_BUG> return new com . badlogic . gdx . graphics . g3d . shaders . DefaultShader ( vertexShader , fragmentShader , renderable . material , renderable . mesh . getVertexAttributes ( ) , ( ( renderable . lights ) != null ) , ( ( ( renderable . lights ) != null ) && ( ( renderable . lights . fog ) != null ) ) , 2 , 5 , 3 , ( ( renderable . bones ) == null ? 0 : 12 ) ) ; <END_BUG> } return new GLES10Shader ( ) ; } }
public class BoundedValueScriptHistogramFacetCollector extends AbstractFacetCollector { private final String indexFieldName ; private final ComparatorType comparatorType ; private final FieldDataCache fieldDataCache ; private final FieldDataType fieldDataType ; private NumericFieldData fieldData ; private final SearchScript valueScript ; private final BoundedValueScriptHistogramFacetCollector . HistogramProc histoProc ; public BoundedValueScriptHistogramFacetCollector ( String facetName , String fieldName , String scriptLang , String valueScript , Map < String , Object > params , long interval , long from , long to , HistogramFacet . ComparatorType comparatorType , SearchContext context ) { } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { fieldData = ( ( NumericFieldData ) ( fieldDataCache . cache ( fieldDataType , context . reader ( ) , indexFieldName ) ) ) ; <START_BUG> valueScript . setNextReader ( context . reader ( ) ) ; <END_BUG> } @ Override public Facet facet ( ) { } public static long bucket ( double value , long interval ) { } public static class HistogramProc implements NumericFieldData . LongValueInDocProc { final long from ; final long to ; final long interval ; final long offset ; final int size ; final Object [ ] entries ; private final SearchScript valueScript ; public HistogramProc ( long from , long to , long interval , long offset , int size , SearchScript valueScript ) { } @ Override public void onValue ( int docId , long value ) { } } }
public class DeleteByQueryRequest extends IndicesReplicationOperationRequest { private static final XContentType contentType = Requests . CONTENT_TYPE ; private BytesReference querySource ; private boolean querySourceUnsafe ; private String [ ] types = Strings . EMPTY_ARRAY ; @ Nullable private String routing ; public DeleteByQueryRequest ( String ... indices ) { } public DeleteByQueryRequest ( ) { } @ Override public DeleteByQueryRequest listenerThreaded ( boolean threadedListener ) { } @ Override public ActionRequestValidationException validate ( ) { } public DeleteByQueryRequest indices ( String ... indices ) { } BytesReference querySource ( ) { } @ Required public DeleteByQueryRequest query ( QueryBuilder queryBuilder ) { } @ Required public DeleteByQueryRequest query ( String querySource ) { } @ Required public DeleteByQueryRequest query ( Map querySource ) { } @ Required public DeleteByQueryRequest query ( XContentBuilder builder ) { } @ Required public DeleteByQueryRequest query ( byte [ ] querySource ) { } @ Required public DeleteByQueryRequest query ( byte [ ] querySource , int offset , int length , boolean unsafe ) { } public DeleteByQueryRequest query ( BytesReference source , boolean unsafe ) { } String [ ] types ( ) { } @ Override public String routing ( ) { } public DeleteByQueryRequest routing ( String routing ) { } public DeleteByQueryRequest routing ( String ... routings ) { } public DeleteByQueryRequest types ( String ... types ) { } public DeleteByQueryRequest timeout ( TimeValue timeout ) { } public DeleteByQueryRequest timeout ( String timeout ) { } public DeleteByQueryRequest replicationType ( ReplicationType replicationType ) { } public DeleteByQueryRequest consistencyLevel ( WriteConsistencyLevel consistencyLevel ) { } public DeleteByQueryRequest replicationType ( String replicationType ) { } public void readFrom ( StreamInput in ) throws IOException { } public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; <START_BUG> out . writeBytesReference ( querySource , true ) ; <END_BUG> if ( ( routing ) == null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeUTF ( routing ) ; } out . writeVInt ( types . length ) ; for ( String type : types ) { out . writeUTF ( type ) ; } } @ Override public String toString ( ) { } }
public class ImportTest extends BaseBulletTest { btBulletWorldImporter importer ; Model model ; public class MyImporter extends btBulletWorldImporter { public MyImporter ( btDynamicsWorld world ) { } @ Override public btRigidBody createRigidBody ( boolean isDynamic , float mass , Matrix4 startTransform , btCollisionShape shape , String bodyName ) { } } @ Override public void create ( ) { } @ Override public boolean tap ( float x , float y , int count , int button ) { } @ Override public void dispose ( ) { super . dispose ( ) ; importer . deleteAllData ( ) ; <START_BUG> importer . dispose ( ) ; <END_BUG> importer = null ; } }
public class BulkRequest extends ActionRequest < BulkRequest > { private static final int REQUEST_OVERHEAD = 50 ; final List < ActionRequest > requests = Lists . newArrayList ( ) ; List < Object > payloads = null ; protected TimeValue timeout = BulkShardRequest . DEFAULT_TIMEOUT ; private ReplicationType replicationType = ReplicationType . DEFAULT ; private WriteConsistencyLevel consistencyLevel = WriteConsistencyLevel . DEFAULT ; private boolean refresh = false ; private long sizeInBytes = 0 ; public BulkRequest add ( ActionRequest ... requests ) { } public BulkRequest add ( ActionRequest request ) { } public BulkRequest add ( ActionRequest request , @ Nullable Object payload ) { } public BulkRequest add ( Iterable < ActionRequest > requests ) { } public BulkRequest add ( IndexRequest request ) { } public BulkRequest add ( IndexRequest request , @ Nullable Object payload ) { } BulkRequest internalAdd ( IndexRequest request , @ Nullable Object payload ) { } public BulkRequest add ( UpdateRequest request ) { } public BulkRequest add ( UpdateRequest request , @ Nullable Object payload ) { } BulkRequest internalAdd ( UpdateRequest request , @ Nullable Object payload ) { } public BulkRequest add ( DeleteRequest request ) { } public BulkRequest add ( DeleteRequest request , @ Nullable Object payload ) { } private void addPayload ( Object payload ) { if ( ( payloads ) == null ) { if ( payload == null ) { return ; } <START_BUG> payloads = new ArrayList < Object > ( ( ( requests . size ( ) ) + 10 ) ) ; <END_BUG> for ( int i = 1 ; i < ( requests . size ( ) ) ; i ++ ) { payloads . add ( null ) ; } } payloads . add ( payload ) ; } public List < ActionRequest > requests ( ) { } @ Nullable public List < Object > payloads ( ) { } public int numberOfActions ( ) { } public long estimatedSizeInBytes ( ) { } public BulkRequest add ( byte [ ] data , int from , int length , boolean contentUnsafe ) throws Exception { } public BulkRequest add ( byte [ ] data , int from , int length , boolean contentUnsafe , @ Nullable String defaultIndex , @ Nullable String defaultType ) throws Exception { } public BulkRequest add ( BytesReference data , boolean contentUnsafe , @ Nullable String defaultIndex , @ Nullable String defaultType ) throws Exception { } public BulkRequest add ( BytesReference data , boolean contentUnsafe , @ Nullable String defaultIndex , @ Nullable String defaultType , boolean allowExplicitIndex ) throws Exception { } public BulkRequest add ( BytesReference data , boolean contentUnsafe , @ Nullable String defaultIndex , @ Nullable String defaultType , @ Nullable String defaultRouting , @ Nullable Object payload , boolean allowExplicitIndex ) throws Exception { } public BulkRequest consistencyLevel ( WriteConsistencyLevel consistencyLevel ) { } public WriteConsistencyLevel consistencyLevel ( ) { } public BulkRequest refresh ( boolean refresh ) { } public boolean refresh ( ) { } public BulkRequest replicationType ( ReplicationType replicationType ) { } public ReplicationType replicationType ( ) { } public final BulkRequest timeout ( TimeValue timeout ) { } public final BulkRequest timeout ( String timeout ) { } public TimeValue timeout ( ) { } private int findNextMarker ( byte marker , int from , BytesReference data , int length ) { } @ Override public ActionRequestValidationException validate ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public abstract class AbstractRangeBuilder < B extends AbstractRangeBuilder < B > > extends ValuesSourceAggregationBuilder < B > { protected static class Range implements ToXContent { private String key ; private Object from ; private Object to ; public Range ( String key , Object from , Object to ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } } protected List < AbstractRangeBuilder . Range > ranges = Lists . newArrayList ( ) ; protected AbstractRangeBuilder ( String name , String type ) { } @ Override protected XContentBuilder doInternalXContent ( XContentBuilder builder , Params params ) throws IOException { if ( ranges . isEmpty ( ) ) { <START_BUG> throw new org . elasticsearch . search . builder . SearchSourceBuilderException ( ( ( "at<seq2seq4repair_space>least<seq2seq4repair_space>one<seq2seq4repair_space>range<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>defined<seq2seq4repair_space>for<seq2seq4repair_space>range<seq2seq4repair_space>aggregation<seq2seq4repair_space>[" + ( AbstractRangeBuilder . getName ( ) ) ) + "]" ) ) ; <END_BUG> } builder . startArray ( "ranges" ) ; for ( AbstractRangeBuilder . Range range : ranges ) { range . toXContent ( builder , params ) ; } return builder . endArray ( ) ; } }
@ ClusterScope ( scope = Scope . TEST , numNodes = 0 ) public class ShardsAllocatorModuleTests extends ElasticsearchIntegrationTest { public void testLoadDefaultShardsAllocator ( ) { } public void testLoadByShortKeyShardsAllocator ( ) { } public void testLoadByClassNameShardsAllocator ( ) { } private void assertAllocatorInstance ( Settings settings , Class < ? extends ShardsAllocator > clazz ) { <START_BUG> while ( ( cluster ( ) . numNodes ( ) ) != 0 ) { <END_BUG> cluster ( ) . stopRandomNode ( ) ; } cluster ( ) . startNode ( settings ) ; ShardsAllocator instance = cluster ( ) . getInstance ( ShardsAllocator . class ) ; assertThat ( instance , instanceOf ( clazz ) ) ; } }
public class TransportIndexDeleteByQueryAction extends TransportIndexReplicationOperationAction < IndexDeleteByQueryRequest , IndexDeleteByQueryResponse , ShardDeleteByQueryRequest , ShardDeleteByQueryResponse > { private final IndicesService indicesService ; @ Inject public TransportIndexDeleteByQueryAction ( Settings settings , ClusterService clusterService , TransportService transportService , IndicesService indicesService , ThreadPool threadPool , TransportShardDeleteByQueryAction shardDeleteByQueryAction ) { } @ Override protected IndexDeleteByQueryRequest newRequestInstance ( ) { } @ Override protected IndexDeleteByQueryResponse newResponseInstance ( IndexDeleteByQueryRequest request , AtomicReferenceArray shardsResponses ) { } @ Override protected boolean accumulateExceptions ( ) { } @ Override protected String transportAction ( ) { } @ Override protected void checkBlock ( IndexDeleteByQueryRequest request , ClusterState state ) { } @ Override protected GroupShardsIterator shards ( IndexDeleteByQueryRequest request ) { <START_BUG> return indicesService . indexServiceSafe ( request . index ( ) ) . operationRouting ( ) . deleteByQueryShards ( clusterService . state ( ) ) ; <END_BUG> } @ Override protected ShardDeleteByQueryRequest newShardRequestInstance ( IndexDeleteByQueryRequest request , int shardId ) { } }
public class TransportFlushAction extends TransportBroadcastOperationAction < FlushRequest , FlushResponse , ShardFlushRequest , ShardFlushResponse > { private final IndicesService indicesService ; @ Inject public TransportFlushAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService , ActionFilters actionFilters ) { } @ Override protected String executor ( ) { } @ Override protected FlushRequest newRequest ( ) { } @ Override protected FlushResponse newResponse ( FlushRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardFlushRequest newShardRequest ( ) { } @ Override protected ShardFlushRequest newShardRequest ( int numShards , ShardRouting shard , FlushRequest request ) { <START_BUG> return new ShardFlushRequest ( shard . index ( ) , shard . id ( ) , request ) ; <END_BUG> } @ Override protected ShardFlushResponse newShardResponse ( ) { } @ Override protected ShardFlushResponse shardOperation ( ShardFlushRequest request ) throws ElasticsearchException { } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , FlushRequest request , String [ ] concreteIndices ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , FlushRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , FlushRequest countRequest , String [ ] concreteIndices ) { } }
public class PointSpriteParticleBatch extends BufferedParticleBatch < PointSpriteControllerRenderData > { private static boolean pointSpritesEnabled = false ; protected static final Vector3 TMP_V1 = new Vector3 ( ) ; protected static final int sizeAndRotationUsage = 1 << 9 ; protected static final VertexAttributes CPU_ATTRIBUTES = new VertexAttributes ( new VertexAttribute ( Usage . Position , 3 , ShaderProgram . POSITION_ATTRIBUTE ) , new VertexAttribute ( Usage . Color , 4 , ShaderProgram . COLOR_ATTRIBUTE ) , new VertexAttribute ( Usage . TextureCoordinates , 4 , "a_region" ) , new VertexAttribute ( PointSpriteParticleBatch . sizeAndRotationUsage , 3 , "a_sizeAndRotation" ) ) ; protected static final int CPU_VERTEX_SIZE = ( ( short ) ( ( PointSpriteParticleBatch . CPU_ATTRIBUTES . vertexSize ) / 4 ) ) ; protected static final int CPU_POSITION_OFFSET = ( ( short ) ( ( PointSpriteParticleBatch . CPU_ATTRIBUTES . findByUsage ( Position ) . offset ) / 4 ) ) ; protected static final int CPU_COLOR_OFFSET = ( ( short ) ( ( PointSpriteParticleBatch . CPU_ATTRIBUTES . findByUsage ( Color ) . offset ) / 4 ) ) ; protected static final int CPU_REGION_OFFSET = ( ( short ) ( ( PointSpriteParticleBatch . CPU_ATTRIBUTES . findByUsage ( TextureCoordinates ) . offset ) / 4 ) ) ; protected static final int CPU_SIZE_AND_ROTATION_OFFSET = ( ( short ) ( ( PointSpriteParticleBatch . CPU_ATTRIBUTES . findByUsage ( PointSpriteParticleBatch . sizeAndRotationUsage ) . offset ) / 4 ) ) ; private static void enablePointSprites ( ) { } private float [ ] vertices ; Renderable renderable ; public PointSpriteParticleBatch ( ) { } public PointSpriteParticleBatch ( int capacity ) { } @ Override protected void allocParticlesData ( int capacity ) { } protected void allocRenderable ( ) { renderable = new Renderable ( ) ; renderable . primitiveType = GL20 . GL_POINTS ; renderable . meshPartOffset = 0 ; <START_BUG> renderable . material = new com . badlogic . gdx . graphics . g3d . Material ( new com . badlogic . gdx . graphics . g3d . attributes . BlendingAttribute ( GL20 . GL_ONE , GL20 . GL_ONE_MINUS_SRC_ALPHA , 1.0F ) , new com . badlogic . gdx . graphics . g3d . attributes . DepthTestAttribute ( GL20 . GL_LEQUAL , false ) , TextureAttribute . createDiffuse ( ( ( Texture ) ( null ) ) ) ) ; <END_BUG> } public void setTexture ( Texture texture ) { } public Texture getTexture ( ) { } @ Override protected void flush ( int [ ] offsets ) { } @ Override public void getRenderables ( Array < Renderable > renderables , Pool < Renderable > pool ) { } @ Override public void save ( AssetManager manager , ResourceData resources ) { } @ Override public void load ( AssetManager manager , ResourceData resources ) { } }
public class TimerService extends AbstractComponent { public static enum ExecutionType { DEFAULT , THREADED ; } private final ThreadPool threadPool ; private final TimerService . TimeEstimator timeEstimator ; private final ScheduledFuture timeEstimatorFuture ; private final Timer timer ; private final TimeValue tickDuration ; private final int ticksPerWheel ; public TimerService ( ThreadPool threadPool ) { } @ Inject public TimerService ( Settings settings , ThreadPool threadPool ) { } public void close ( ) { } public long estimatedTimeInMillis ( ) { } public Timeout newTimeout ( TimerTask task , TimeValue delay , TimerService . ExecutionType executionType ) { } public Timeout newTimeout ( TimerTask task , long delay , TimeUnit unit , TimerService . ExecutionType executionType ) { } private class ThreadedTimerTask implements TimerTask { private final ThreadPool threadPool ; private final TimerTask task ; private ThreadedTimerTask ( ThreadPool threadPool , TimerTask task ) { } @ Override public void run ( final Timeout timeout ) throws Exception { <START_BUG> threadPool . execute ( new Runnable ( ) { <END_BUG> @ Override public void run ( ) { try { task . run ( timeout ) ; } catch ( Exception e ) { logger . warn ( ( ( "An<seq2seq4repair_space>exception<seq2seq4repair_space>was<seq2seq4repair_space>thrown<seq2seq4repair_space>by<seq2seq4repair_space>" + ( TimerTask . class . getSimpleName ( ) ) ) + "." ) , e ) ; } } } ) ; } } private static class TimeEstimator implements Runnable { private long time = System . currentTimeMillis ( ) ; @ Override public void run ( ) { } public long time ( ) { } } }
public abstract class GistsFragment extends PagedItemFragment < Gist > { @ Inject protected AvatarLoader avatars ; @ Inject protected GistService service ; @ Inject protected GistStore store ; @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( ( requestCode == ( RequestCodes . GIST_VIEW ) ) || ( requestCode == ( RequestCodes . GIST_CREATE ) ) ) { <START_BUG> getListAdapter ( ) . getWrappedAdapter ( ) . notifyDataSetChanged ( ) ; <END_BUG> forceRefresh ( ) ; return ; } super . onActivityResult ( requestCode , resultCode , data ) ; } @ Override protected int getErrorMessage ( Exception exception ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected SingleTypeAdapter < Gist > createAdapter ( List < Gist > items ) { } }
public class TransportValidateQueryAction extends TransportBroadcastOperationAction < ValidateQueryRequest , ValidateQueryResponse , ShardValidateQueryRequest , ShardValidateQueryResponse > { private final IndicesService indicesService ; private final ScriptService scriptService ; @ Inject public TransportValidateQueryAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService , ScriptService scriptService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected ValidateQueryRequest newRequest ( ) { } @ Override protected ShardValidateQueryRequest newShardRequest ( ) { } @ Override protected ShardValidateQueryRequest newShardRequest ( ShardRouting shard , ValidateQueryRequest request ) { } @ Override protected ShardValidateQueryResponse newShardResponse ( ) { } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , ValidateQueryRequest request , String [ ] concreteIndices ) { Map < String , Set < String > > routingMap = clusterState . metaData ( ) . resolveSearchRouting ( Integer . toString ( ThreadLocalRandom . current ( ) . nextInt ( 1000 ) ) , request . indices ( ) ) ; <START_BUG> return clusterService . operationRouting ( ) . searchShards ( clusterState , request . indices ( ) , concreteIndices , null , routingMap , "_local" ) ; <END_BUG> } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , ValidateQueryRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , ValidateQueryRequest countRequest , String [ ] concreteIndices ) { } @ Override protected ValidateQueryResponse newResponse ( ValidateQueryRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardValidateQueryResponse shardOperation ( ShardValidateQueryRequest request ) throws ElasticSearchException { } }
public class IndicesFieldDataCache extends AbstractComponent implements RemovalListener < IndicesFieldDataCache . Key , AtomicFieldData > { Cache < IndicesFieldDataCache . Key , AtomicFieldData > cache ; private volatile String size ; private volatile long sizeInBytes ; private volatile TimeValue expire ; @ Inject public IndicesFieldDataCache ( Settings settings ) { } private void buildCache ( ) { } private void computeSizeInBytes ( ) { } public void close ( ) { } public IndexFieldDataCache buildIndexFieldDataCache ( @ Nullable IndexService indexService , Index index , FieldMapper . Names fieldNames , FieldDataType fieldDataType ) { } @ Override public void onRemoval ( RemovalNotification < IndicesFieldDataCache . Key , AtomicFieldData > notification ) { <START_BUG> if ( ( notification . getKey ( ) ) != null ) { <END_BUG> IndicesFieldDataCache . IndexFieldCache indexCache = notification . getKey ( ) . indexCache ; notification . getKey ( ) . listener . onUnload ( indexCache . fieldNames , indexCache . fieldDataType , notification . wasEvicted ( ) , notification . getKey ( ) . sizeInBytes , notification . getValue ( ) ) ; } } public static class FieldDataWeigher implements Weigher < IndicesFieldDataCache . Key , AtomicFieldData > { @ Override public int weigh ( IndicesFieldDataCache . Key key , AtomicFieldData fieldData ) { } } class IndexFieldCache implements SegmentReader . CoreClosedListener , IndexFieldDataCache { @ Nullable private final IndexService indexService ; final Index index ; final Names fieldNames ; final FieldDataType fieldDataType ; IndexFieldCache ( @ Nullable IndexService indexService , Index index , FieldMapper . Names fieldNames , FieldDataType fieldDataType ) { } @ Override public < FD extends AtomicFieldData , IFD extends IndexFieldData < FD > > FD load ( final AtomicReaderContext context , final IFD indexFieldData ) throws Exception { } @ Override public void onClose ( SegmentReader owner ) { } @ Override public void clear ( ) { } @ Override public void clear ( String fieldName ) { } @ Override public void clear ( IndexReader reader ) { } } public static class Key { public final IndicesFieldDataCache . IndexFieldCache indexCache ; public final Object readerKey ; @ Nullable public Listener listener ; long sizeInBytes = - 1 ; Key ( IndicesFieldDataCache . IndexFieldCache indexCache , Object readerKey ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } } }
public class NoneRecycler < T > extends AbstractRecycler < T > { public NoneRecycler ( C < T > c ) { } @ Override public V < T > obtain ( int sizing ) { <START_BUG> return new NoneRecycler . NV < T > ( c . newInstance ( sizing ) ) ; <END_BUG> } @ Override public void close ( ) { } public static class NV < T > implements Recycler . V < T > { T value ; NV ( T value ) { } @ Override public T v ( ) { } @ Override public boolean isRecycled ( ) { } @ Override public boolean release ( ) { } } }
public class IssueDashboardPagerAdapter extends FragmentStatePagerAdapter { private final Resources resources ; public IssueDashboardPagerAdapter ( final Resources resources , final FragmentManager fragmentManager ) { } @ Override public int getCount ( ) { } @ Override public Fragment getItem ( final int position ) { } @ Override <START_BUG> public CharSequence getPageTitle ( int position ) { <END_BUG> switch ( position ) { case 0 : return resources . getString ( dashboard_watched ) ; case 1 : return resources . getString ( dashboard_assigned ) ; case 2 : return resources . getString ( dashboard_created ) ; case 3 : return resources . getString ( dashboard_mentioned ) ; default : return null ; } } }
public final class ClassReflection { public static Class forName ( String name ) throws ReflectionException { } public static String getSimpleName ( Class c ) { } public static boolean isInstance ( Class c , Object obj ) { } public static boolean isAssignableFrom ( Class c1 , Class c2 ) { Type c1Type = ReflectionCache . getType ( c1 ) ; Type c2Type = ReflectionCache . getType ( c2 ) ; <START_BUG> return c1Type . isAssignableFrom ( c2Type ) ; <END_BUG> } public static boolean isMemberClass ( Class c ) { } public static boolean isStaticClass ( Class c ) { } public static < T > T newInstance ( Class < T > c ) throws ReflectionException { } public static Constructor [ ] getConstructors ( Class c ) { } public static Constructor getConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Constructor getDeclaredConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getMethods ( Class c ) { } public static Method getMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getDeclaredMethods ( Class c ) { } public static Method getDeclaredMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Field [ ] getFields ( Class c ) { } public static Field getField ( Class c , String name ) throws ReflectionException { } public static Field [ ] getDeclaredFields ( Class c ) { } public static Field getDeclaredField ( Class c , String name ) throws ReflectionException { } }
public class ClusterStateResponse extends ActionResponse { private ClusterName clusterName ; private ClusterState clusterState ; public ClusterStateResponse ( ) { } public ClusterStateResponse ( ClusterName clusterName , ClusterState clusterState ) { } public ClusterState getState ( ) { } public ClusterName getClusterName ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; clusterName = ClusterName . readClusterName ( in ) ; <START_BUG> clusterState = Builder . readFrom ( in , null , clusterName ) ; <END_BUG> } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public class ThriftRestRequest extends AbstractRestRequest implements RestRequest { private final RestRequest request ; private final String rawPath ; private final Map < String , String > params ; public ThriftRestRequest ( org . elasticsearch . thrift . RestRequest request ) { } @ Override public Method method ( ) { } @ Override public String uri ( ) { } @ Override public String rawPath ( ) { } @ Override public boolean hasContent ( ) { } @ Override public boolean contentUnsafe ( ) { } @ Override public byte [ ] contentByteArray ( ) { } @ Override public int contentByteArrayOffset ( ) { if ( ! ( request . isSetBody ( ) ) ) { return 0 ; } <START_BUG> return request . bufferForBody ( ) . arrayOffset ( ) ; <END_BUG> } @ Override public int contentLength ( ) { } @ Override public String contentAsString ( ) { } @ Override public String header ( String name ) { } @ Override public boolean hasParam ( String key ) { } @ Override public String param ( String key ) { } @ Override public Map < String , String > params ( ) { } @ Override public String param ( String key , String defaultValue ) { } }
@ Override public void glPixelStorei ( int pname , int param ) { } @ Override public void glPolygonOffset ( float factor , float units ) { } @ Override public void glReadPixels ( int x , int y , int width , int height , int format , int type , Buffer pixels ) { } @ Override public void glReleaseShaderCompiler ( ) { } @ Override public void glRenderbufferStorage ( int target , int internalformat , int width , int height ) { } @ Override public void glSampleCoverage ( float value , boolean invert ) { } @ Override public void glScissor ( int x , int y , int width , int height ) { } @ Override public void glShaderBinary ( int n , IntBuffer shaders , int binaryformat , Buffer binary , int length ) { } @ Override public void glShaderSource ( int shader , String string ) { } @ Override public void glStencilFunc ( int func , int ref , int mask ) { } @ Override public void glStencilFuncSeparate ( int face , int func , int ref , int mask ) { } @ Override public void glStencilMask ( int mask ) { } @ Override public void glStencilMaskSeparate ( int face , int mask ) { } @ Override public void glStencilOp ( int fail , int zfail , int zpass ) { } @ Override public void glStencilOpSeparate ( int face , int fail , int zfail , int zpass ) { } @ Override public void glTexImage2D ( int target , int level , int internalformat , int width , int height , int border , int format , int type , Buffer pixels ) { } @ Override public void glTexParameterf ( int target , int pname , float param ) { } @ Override public void glTexParameterfv ( int target , int pname , FloatBuffer params ) { } @ Override public void glTexParameteri ( int target , int pname , int param ) { } @ Override public void glTexParameteriv ( int target , int pname , IntBuffer params ) { } @ Override public void glTexSubImage2D ( int target , int level , int xoffset , int yoffset , int width , int height , int format , int type , Buffer pixels ) { } @ Override public void glUniform1f ( int location , float x ) { } @ Override public void glUniform1fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform1i ( int location , int x ) { } @ Override public void glUniform1iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniform2f ( int location , float x , float y ) { } @ Override public void glUniform2fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform2i ( int location , int x , int y ) { } @ Override public void glUniform2iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniform3f ( int location , float x , float y , float z ) { } @ Override public void glUniform3fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform3i ( int location , int x , int y , int z ) { } @ Override public void glUniform3iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniform4f ( int location , float x , float y , float z , float w ) { } @ Override public void glUniform4fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform4i ( int location , int x , int y , int z , int w ) { } @ Override public void glUniform4iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniformMatrix2fv ( int location , int count , boolean transpose , FloatBuffer value ) { } @ Override public void glUniformMatrix3fv ( int location , int count , boolean transpose , FloatBuffer value ) { } @ Override public void glUniformMatrix4fv ( int location , int count , boolean transpose , FloatBuffer value ) { <START_BUG> gl . glUniformMatrix2x4fv ( location , count , transpose , value ) ; <END_BUG> } @ Override public void glUseProgram ( int program ) { } @ Override public void glValidateProgram ( int program ) { } @ Override public void glVertexAttrib1f ( int indx , float x ) { } @ Override public void glVertexAttrib1fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttrib2f ( int indx , float x , float y ) { } @ Override public void glVertexAttrib2fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttrib3f ( int indx , float x , float y , float z ) { } @ Override public void glVertexAttrib3fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttrib4f ( int indx , float x , float y , float z , float w ) { } @ Override public void glVertexAttrib4fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttribPointer ( int indx , int size , int type , boolean normalized , int stride , Buffer ptr ) { } @ Override public void glViewport ( int x , int y , int width , int height ) { } @ Override public void glDrawElements ( int mode , int count , int type , int indices ) { } @ Override public void glVertexAttribPointer ( int indx , int size , int type , boolean normalized , int stride , int ptr ) { } }
public class ElasticsearchAssertions { public static void assertAcked ( AcknowledgedRequestBuilder < ? , ? , ? , ? > builder ) { } public static void assertNoTimeout ( ClusterHealthRequestBuilder requestBuilder ) { } public static void assertNoTimeout ( ClusterHealthResponse response ) { <START_BUG> assertThat ( ( ( "ClusterHealthResponse<seq2seq4repair_space>has<seq2seq4repair_space>timed<seq2seq4repair_space>out<seq2seq4repair_space>-<seq2seq4repair_space>returned<seq2seq4repair_space>status:<seq2seq4repair_space>[" + ( response . getStatus ( ) ) ) + "]" ) , response . isTimedOut ( ) , is ( false ) ) ; <END_BUG> } public static void assertAcked ( AcknowledgedResponse response ) { } public static void assertAcked ( DeleteIndexRequestBuilder builder ) { } public static void assertAcked ( DeleteIndexResponse response ) { } public static String formatShardStatus ( BroadcastOperationResponse response ) { } public static String formatShardStatus ( SearchResponse response ) { } public static void assertHitCount ( SearchResponse searchResponse , long expectedHitCount ) { } public static void assertSearchHits ( SearchResponse searchResponse , String ... ids ) { } public static void assertOrderedSearchHits ( SearchResponse searchResponse , String ... ids ) { } public static void assertHitCount ( CountResponse countResponse , long expectedHitCount ) { } public static void assertMatchCount ( PercolateResponse percolateResponse , long expectedHitCount ) { } public static void assertExists ( GetResponse response ) { } public static void assertFirstHit ( SearchResponse searchResponse , Matcher < SearchHit > matcher ) { } public static void assertSecondHit ( SearchResponse searchResponse , Matcher < SearchHit > matcher ) { } public static void assertThirdHit ( SearchResponse searchResponse , Matcher < SearchHit > matcher ) { } public static void assertSearchHit ( SearchResponse searchResponse , int number , Matcher < SearchHit > matcher ) { } public static void assertNoFailures ( SearchResponse searchResponse ) { } public static void assertFailures ( SearchResponse searchResponse ) { } public static void assertNoFailures ( BulkResponse response ) { } public static void assertFailures ( SearchRequestBuilder searchRequestBuilder , RestStatus restStatus , Matcher < String > reasonMatcher ) { } public static void assertNoFailures ( BroadcastOperationResponse response ) { } public static void assertAllSuccessful ( BroadcastOperationResponse response ) { } public static void assertAllSuccessful ( SearchResponse response ) { } public static void assertSearchHit ( SearchHit searchHit , Matcher < SearchHit > matcher ) { } public static void assertHighlight ( SearchResponse resp , int hit , String field , int fragment , Matcher < String > matcher ) { } public static void assertHighlight ( SearchResponse resp , int hit , String field , int fragment , int totalFragments , Matcher < String > matcher ) { } public static void assertHighlight ( SearchHit hit , String field , int fragment , Matcher < String > matcher ) { } public static void assertHighlight ( SearchHit hit , String field , int fragment , int totalFragments , Matcher < String > matcher ) { } private static void assertHighlight ( SearchResponse resp , int hit , String field , int fragment , Matcher < Integer > fragmentsMatcher , Matcher < String > matcher ) { } private static void assertHighlight ( SearchHit hit , String field , int fragment , Matcher < Integer > fragmentsMatcher , Matcher < String > matcher ) { } public static void assertNotHighlighted ( SearchResponse resp , int hit , String field ) { } public static void assertSuggestionSize ( Suggest searchSuggest , int entry , int size , String key ) { } public static void assertSuggestion ( Suggest searchSuggest , int entry , int ord , String key , String text ) { } public static void assertSuggestion ( Suggest searchSuggest , int entry , String key , String ... text ) { } public static void assertSuggestion ( Suggest searchSuggest , int entry , String key , int size , String ... text ) { } public static void assertIndexTemplateMissing ( GetIndexTemplatesResponse templatesResponse , String name ) { } public static void assertIndexTemplateExists ( GetIndexTemplatesResponse templatesResponse , String name ) { } public static Matcher < SearchHit > hasId ( final String id ) { } public static Matcher < SearchHit > hasType ( final String type ) { } public static Matcher < SearchHit > hasIndex ( final String index ) { } public static Matcher < SearchHit > hasScore ( final float score ) { } public static < T extends Query > T assertBooleanSubQuery ( Query query , Class < T > subqueryType , int i ) { } public static < E extends Throwable > void assertThrows ( ActionRequestBuilder < ? , ? , ? , ? > builder , Class < E > exceptionClass ) { } public static < E extends Throwable > void assertThrows ( ActionRequestBuilder < ? , ? , ? , ? > builder , Class < E > exceptionClass , String extraInfo ) { } public static < E extends Throwable > void assertThrows ( ActionFuture future , Class < E > exceptionClass ) { } public static < E extends Throwable > void assertThrows ( ActionFuture future , Class < E > exceptionClass , String extraInfo ) { } public static < E extends Throwable > void assertThrows ( ActionRequestBuilder < ? , ? , ? , ? > builder , RestStatus status ) { } public static < E extends Throwable > void assertThrows ( ActionRequestBuilder < ? , ? , ? , ? > builder , RestStatus status , String extraInfo ) { } public static < E extends Throwable > void assertThrows ( ActionFuture future , RestStatus status ) { } public static void assertThrows ( ActionFuture future , RestStatus status , String extraInfo ) { } private static BytesReference serialize ( Version version , Streamable streamable ) throws IOException { } public static void assertVersionSerializable ( Streamable streamable ) { } public static void assertVersionSerializable ( Version version , Streamable streamable ) { } private static Streamable tryCreateNewInstance ( Streamable streamable ) throws IllegalAccessException , InstantiationException , NoSuchMethodException , InvocationTargetException { } public static SearchResponse assertSearchResponse ( SearchRequestBuilder request ) { }
@ ClusterScope ( scope = Scope . TEST , numDataNodes = 0 , numClientNodes = 0 , transportClientRatio = 0 ) public class RecoveryPercolatorTests extends ElasticsearchIntegrationTest { @ Override protected int numberOfShards ( ) { } @ Override protected Settings nodeSettings ( int nodeOrdinal ) { <START_BUG> return builder ( ) . put ( "gateway.type" , "local" ) . build ( ) ; <END_BUG> } @ Test @ Slow public void testRestartNodePercolator1 ( ) throws Exception { } @ Test @ Slow public void testRestartNodePercolator2 ( ) throws Exception { } @ Test @ Slow @ TestLogging ( "index.percolator:TRACE,percolator:TRACE" ) public void testLoadingPercolateQueriesDuringCloseAndOpen ( ) throws Exception { } @ Test @ Slow public void testSinglePercolator_recovery ( ) throws Exception { } @ Test @ Slow public void testMultiPercolator_recovery ( ) throws Exception { } private void percolatorRecovery ( final boolean multiPercolate ) throws Exception { } }
public final class DefaultTextureBinder implements TextureBinder { public static final int ROUNDROBIN = 0 ; public static final int WEIGHTED = 1 ; public static final int MAX_GLES_UNITS = 32 ; private final int offset ; private final int count ; private final int reuseWeight ; private final TextureDescriptor [ ] textures ; private final int [ ] weights ; private final int method ; private boolean reused ; private int reuseCount = 0 ; private int bindCount = 0 ; public DefaultTextureBinder ( final int method ) { } public DefaultTextureBinder ( final int method , final int offset ) { } public DefaultTextureBinder ( final int method , final int offset , final int count ) { } public DefaultTextureBinder ( final int method , final int offset , final int count , final int reuseWeight ) { } private static int getMaxTextureUnits ( ) { } @ Override public void begin ( ) { } @ Override public void end ( ) { for ( int i = 0 ; i < ( count ) ; i ++ ) { if ( ( textures [ i ] . texture ) != null ) { <START_BUG> gl . glActiveTexture ( ( ( GL20 . GL_TEXTURE0 ) + i ) ) ; <END_BUG> gl . glBindTexture ( GL_TEXTURE_2D , 0 ) ; textures [ i ] . texture = null ; } } gl . glActiveTexture ( GL_TEXTURE0 ) ; } @ Override public final int bind ( final TextureDescriptor textureDesc ) { } private final int bindTexture ( final TextureDescriptor textureDesc , final boolean rebind ) { } private int currentTexture = 0 ; private final int bindTextureRoundRobin ( final Texture texture ) { } private final int bindTextureWeighted ( final Texture texture ) { } @ Override public final int getBindCount ( ) { } @ Override public final int getReuseCount ( ) { } @ Override public final void resetCounts ( ) { } }
final class LwjglInput implements Input { class KeyEvent { static final int KEY_DOWN = 0 ; static final int KEY_UP = 1 ; static final int KEY_TYPED = 2 ; long timeStamp ; int type ; int keyCode ; char keyChar ; } class TouchEvent { static final int TOUCH_DOWN = 0 ; static final int TOUCH_UP = 1 ; static final int TOUCH_DRAGGED = 2 ; static final int TOUCH_SCROLLED = 3 ; static final int TOUCH_MOVED = 4 ; long timeStamp ; int type ; int x ; int y ; int scrollAmount ; int button ; int pointer ; } Pool < LwjglInput . KeyEvent > usedKeyEvents = new Pool < LwjglInput . KeyEvent > ( 16 , 1000 ) { protected LwjglInput . KeyEvent newObject ( ) { } } ; Pool < LwjglInput . TouchEvent > usedTouchEvents = new Pool < LwjglInput . TouchEvent > ( 16 , 1000 ) { protected LwjglInput . TouchEvent newObject ( ) { } } ; List < LwjglInput . KeyEvent > keyEvents = new ArrayList < LwjglInput . KeyEvent > ( ) ; List < LwjglInput . TouchEvent > touchEvents = new ArrayList < LwjglInput . TouchEvent > ( ) ; boolean mousePressed = false ; int mouseX ; int mouseY ; int deltaX ; int deltaY ; int pressedKeys = 0 ; boolean justTouched = false ; Set < Integer > pressedButtons = new HashSet < Integer > ( ) ; InputProcessor processor ; char lastKeyCharPressed ; float keyRepeatTimer ; long currentEventTimeStamp ; public LwjglInput ( ) { } public float getAccelerometerX ( ) { } public float getAccelerometerY ( ) { } public float getAccelerometerZ ( ) { } public void getTextInput ( final TextInputListener listener , final String title , final String text ) { } public int getX ( ) { } public int getY ( ) { <START_BUG> return ( ( graphics . getHeight ( ) ) - 1 ) - ( Mouse . getY ( ) ) ; <END_BUG> } public boolean isAccelerometerAvailable ( ) { } public boolean isKeyPressed ( int key ) { } public boolean isTouched ( ) { } public int getX ( int pointer ) { } public int getY ( int pointer ) { } public boolean isTouched ( int pointer ) { } public boolean supportsMultitouch ( ) { } @ Override public void setOnscreenKeyboardVisible ( boolean visible ) { } @ Override public void setCatchBackKey ( boolean catchBack ) { } void processEvents ( ) { } public static int getGdxKeyCode ( int lwjglKeyCode ) { } public static int getLwjglKeyCode ( int gdxKeyCode ) { } public void update ( ) { } private int toGdxButton ( int button ) { } void updateMouse ( ) { } void updateKeyboard ( ) { } @ Override public void setInputProcessor ( InputProcessor processor ) { } @ Override public InputProcessor getInputProcessor ( ) { } @ Override public void vibrate ( int milliseconds ) { } @ Override public boolean justTouched ( ) { } private int toLwjglButton ( int button ) { } @ Override public boolean isButtonPressed ( int button ) { } @ Override public void vibrate ( long [ ] pattern , int repeat ) { } @ Override public void cancelVibrate ( ) { } @ Override public float getAzimuth ( ) { } @ Override public float getPitch ( ) { } @ Override public float getRoll ( ) { } @ Override public boolean isPeripheralAvailable ( Peripheral peripheral ) { } @ Override public int getRotation ( ) { } @ Override public Orientation getNativeOrientation ( ) { } @ Override public void setCursorCatched ( boolean catched ) { } @ Override public boolean isCursorCatched ( ) { } @ Override public int getDeltaX ( ) { } @ Override public int getDeltaX ( int pointer ) { } @ Override public int getDeltaY ( ) { } @ Override public int getDeltaY ( int pointer ) { } @ Override public void setCursorPosition ( int x , int y ) { } @ Override public void setCatchMenuKey ( boolean catchMenu ) { } @ Override public long getCurrentEventTime ( ) { } @ Override public void getRotationMatrix ( float [ ] matrix ) { } }
@ MBean ( objectName = "" , description = "" ) public class IndexShardManagement extends AbstractIndexShardComponent implements CloseableComponent { public static String buildShardGroupName ( ShardId shardId ) { } private final JmxService jmxService ; private final IndexShard indexShard ; private final Store store ; private final Translog translog ; @ Inject public IndexShardManagement ( ShardId shardId , @ IndexSettings Settings indexSettings , JmxService jmxService , IndexShard indexShard , Store store , Translog translog ) { } public void close ( ) { } @ ManagedAttribute ( description = "Index<seq2seq4repair_space>Name" ) public String getIndex ( ) { } @ ManagedAttribute ( description = "Shard<seq2seq4repair_space>Id" ) public int getShardId ( ) { } @ ManagedAttribute ( description = "Storage<seq2seq4repair_space>Size" ) public String getStoreSize ( ) { } @ ManagedAttribute ( description = "The<seq2seq4repair_space>current<seq2seq4repair_space>transaction<seq2seq4repair_space>log<seq2seq4repair_space>id" ) public long getTranslogId ( ) { } @ ManagedAttribute ( description = "Number<seq2seq4repair_space>of<seq2seq4repair_space>transaction<seq2seq4repair_space>log<seq2seq4repair_space>operations" ) public long getTranslogNumberOfOperations ( ) { <START_BUG> return translog . size ( ) ; <END_BUG> } @ ManagedAttribute ( description = "Estimated<seq2seq4repair_space>size<seq2seq4repair_space>in<seq2seq4repair_space>memory<seq2seq4repair_space>the<seq2seq4repair_space>transaction<seq2seq4repair_space>log<seq2seq4repair_space>takes" ) public String getTranslogSize ( ) { } @ ManagedAttribute ( description = "The<seq2seq4repair_space>state<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>shard" ) public String getState ( ) { } @ ManagedAttribute ( description = "Primary" ) public boolean isPrimary ( ) { } @ ManagedAttribute ( description = "The<seq2seq4repair_space>state<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>shard<seq2seq4repair_space>as<seq2seq4repair_space>perceived<seq2seq4repair_space>by<seq2seq4repair_space>the<seq2seq4repair_space>cluster" ) public String getRoutingState ( ) { } @ ManagedAttribute ( description = "The<seq2seq4repair_space>number<seq2seq4repair_space>of<seq2seq4repair_space>documents<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>index" ) public int getNumDocs ( ) { } @ ManagedAttribute ( description = "The<seq2seq4repair_space>total<seq2seq4repair_space>number<seq2seq4repair_space>of<seq2seq4repair_space>documents<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>index<seq2seq4repair_space>(including<seq2seq4repair_space>deleted<seq2seq4repair_space>ones)" ) public int getMaxDoc ( ) { } }
public class JglfwInput implements Input { final JglfwApplication app ; final InputProcessorQueue processorQueue ; InputProcessor processor ; int pressedKeys = 0 ; boolean justTouched ; int deltaX ; int deltaY ; long currentEventTime ; public JglfwInput ( final JglfwApplication app , boolean queueEvents ) { } public void update ( ) { } public float getAccelerometerX ( ) { } public float getAccelerometerY ( ) { } public float getAccelerometerZ ( ) { } public int getX ( ) { } public int getX ( int pointer ) { } public int getY ( ) { } public int getY ( int pointer ) { } public int getDeltaX ( ) { } public int getDeltaX ( int pointer ) { } public int getDeltaY ( ) { } public int getDeltaY ( int pointer ) { } public boolean isTouched ( ) { } public boolean isTouched ( int pointer ) { } public boolean justTouched ( ) { } public boolean isButtonPressed ( int button ) { } public boolean isKeyPressed ( int key ) { } public void setOnscreenKeyboardVisible ( boolean visible ) { } public void vibrate ( int milliseconds ) { } public void vibrate ( long [ ] pattern , int repeat ) { } public void cancelVibrate ( ) { } public float getAzimuth ( ) { } public float getPitch ( ) { } public float getRoll ( ) { } public void getRotationMatrix ( float [ ] matrix ) { } public long getCurrentEventTime ( ) { } public void setCatchBackKey ( boolean catchBack ) { } public void setCatchMenuKey ( boolean catchMenu ) { } public void setInputProcessor ( InputProcessor processor ) { } public InputProcessor getInputProcessor ( ) { } public boolean isPeripheralAvailable ( Peripheral peripheral ) { } public int getRotation ( ) { } public Orientation getNativeOrientation ( ) { } public void setCursorCatched ( boolean captured ) { } public boolean isCursorCatched ( ) { } public void setCursorPosition ( int x , int y ) { } public void getTextInput ( final TextInputListener listener , final String title , final String text ) { } public void getPlaceholderTextInput ( final TextInputListener listener , final String title , final String placeholder ) { } static char characterForKeyCode ( int key ) { } public static int getGdxKeyCode ( int lwjglKeyCode ) { } public static int getJglfwKeyCode ( int gdxKeyCode ) { } static class GlfwInputProcessor extends GlfwCallbackAdapter { private int mouseX ; private int mouseY ; private int mousePressed ; private char lastCharacter ; private InputProcessor processor ; public GlfwInputProcessor ( InputProcessor processor ) { } public void key ( long window , int key , int action ) { } public void character ( long window , char character ) { } public void scroll ( long window , double scrollX , double scrollY ) { } public void mouseButton ( long window , int button , boolean pressed ) { if ( pressed ) { ( mousePressed ) ++ ; processor . touchDown ( mouseX , mouseY , 0 , button ) ; } else { <START_BUG> mousePressed = Math . max ( 0 , ( ( mousePressed ) - 1 ) ) ; <END_BUG> processor . touchUp ( mouseX , mouseY , 0 , button ) ; } } public void cursorPos ( long window , int x , int y ) { } } }
public class CreateGistActivity extends RoboSherlockFragmentActivity { @ InjectView ( id . et_gist_description ) private EditText descriptionText ; @ InjectView ( id . et_gist_name ) private EditText nameText ; @ InjectView ( id . et_gist_content ) private EditText contentText ; @ InjectView ( id . cb_public ) private CheckBox publicCheckBox ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( gist_create ) ; setTitle ( new_gist ) ; String text = getIntent ( ) . getStringExtra ( Intent . EXTRA_TEXT ) ; <START_BUG> if ( TextUtils . isEmpty ( text ) ) <END_BUG> contentText . setText ( text ) ; contentText . addTextChangedListener ( new TextWatcherAdapter ( ) { @ Override public void afterTextChanged ( Editable s ) { invalidateOptionsMenu ( ) ; } } ) ; } @ Override public boolean onCreateOptionsMenu ( Menu options ) { } @ Override public boolean onPrepareOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } private void createGist ( ) { } }
public class ShareGistActivity extends RoboActivity { public static final int RESULT_CREATED = 1 ; private static final String TAG = "GHShare" ; @ InjectView ( id . gistNameText ) private EditText nameText ; @ InjectView ( id . gistContentText ) private EditText contentText ; @ InjectView ( id . publicCheck ) private CheckBox publicCheckBox ; @ InjectView ( id . createGistButton ) private Button createButton ; @ Inject ContextScopedProvider < GistService > gistServiceProvider ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } private void createGist ( ) { final boolean isPublic = publicCheckBox . isChecked ( ) ; String enteredName = nameText . getText ( ) . toString ( ) . trim ( ) ; final String name = ( ( enteredName . length ( ) ) > 0 ) ? enteredName : "file.txt" ; final String content = contentText . getText ( ) . toString ( ) ; final ProgressDialog progress = new ProgressDialog ( this ) ; progress . setMessage ( getString ( creating_gist ) ) ; progress . show ( ) ; new roboguice . util . RoboAsyncTask < org . eclipse . egit . github . core . Gist > ( this ) { public org . eclipse . egit . github . core . Gist call ( ) throws Exception { org . eclipse . egit . github . core . Gist gist = new org . eclipse . egit . github . core . Gist ( ) ; gist . setDescription ( "Android<seq2seq4repair_space>created<seq2seq4repair_space>Gist" ) ; gist . setPublic ( isPublic ) ; org . eclipse . egit . github . core . GistFile file = new org . eclipse . egit . github . core . GistFile ( ) ; file . setContent ( content ) ; file . setFilename ( name ) ; gist . setFiles ( java . util . Collections . singletonMap ( name , file ) ) ; return gistServiceProvider . get ( ShareGistActivity . this ) . createGist ( gist ) ; } protected void onSuccess ( org . eclipse . egit . github . core . Gist gist ) throws Exception { progress . cancel ( ) ; <START_BUG> startActivity ( ViewGistActivity . createIntent ( ShareGistActivity . this , gist ) ) ; <END_BUG> setResult ( ShareGistActivity . RESULT_CREATED ) ; finish ( ) ; } protected void onException ( Exception e ) throws RuntimeException { progress . cancel ( ) ; android . util . Log . e ( ShareGistActivity . TAG , e . getMessage ( ) , e ) ; android . widget . Toast . makeText ( ShareGistActivity . this , e . getMessage ( ) , 5000 ) . show ( ) ; } } . execute ( ) ; } }
public abstract class ESLoggerFactory { private static volatile ESLoggerFactory defaultFactory = new JdkESLoggerFactory ( ) ; public static void setDefaultFactory ( ESLoggerFactory defaultFactory ) { } public static ESLogger getLogger ( String prefix , String name ) { <START_BUG> return ESLoggerFactory . defaultFactory . newInstance ( prefix . intern ( ) , name . intern ( ) ) ; <END_BUG> } public static ESLogger getLogger ( String name ) { } public ESLogger newInstance ( String name ) { } protected abstract ESLogger newInstance ( String prefix , String name ) { } }
public class BitmapFontCache { private final BitmapFont font ; private float [ ] [ ] vertexData ; private int [ ] idx ; private int [ ] tmpGlyphCount ; private float x ; private float y ; private float color = WHITE . toFloatBits ( ) ; private final Color tempColor = new Color ( 1 , 1 , 1 , 1 ) ; private final TextBounds textBounds = new TextBounds ( ) ; private boolean integer = true ; private int glyphCount = 0 ; private IntArray [ ] glyphIndices ; public BitmapFontCache ( BitmapFont font ) { } public BitmapFontCache ( BitmapFont font , boolean integer ) { } public void setPosition ( float x , float y ) { } public void translate ( float xAmount , float yAmount ) { } public void setColors ( float color ) { } public void setColors ( Color tint ) { } public void setColors ( float r , float g , float b , float a ) { } public void setColors ( Color tint , int start , int end ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public void setColor ( float color ) { } public Color getColor ( ) { } public void draw ( Batch spriteBatch ) { TextureRegion [ ] regions = font . getRegions ( ) ; for ( int j = 0 , n = vertexData . length ; j < n ; j ++ ) { <START_BUG> if ( ( idx [ j ] ) > 0 ) { <END_BUG> float [ ] vertices = vertexData [ j ] ; spriteBatch . draw ( regions [ j ] . getTexture ( ) , vertices , 0 , idx [ j ] ) ; } } } public void draw ( Batch spriteBatch , int start , int end ) { } public void draw ( Batch spriteBatch , float alphaModulation ) { } public void clear ( ) { } private void requireSequence ( CharSequence seq , int start , int end ) { } private void require ( int page , int glyphCount ) { } private float addToCache ( CharSequence str , float x , float y , int start , int end ) { } private void addGlyph ( Glyph glyph , float x , float y , float width , float height ) { } public TextBounds setText ( CharSequence str , float x , float y ) { } public TextBounds setText ( CharSequence str , float x , float y , int start , int end ) { } public TextBounds addText ( CharSequence str , float x , float y ) { } public TextBounds addText ( CharSequence str , float x , float y , int start , int end ) { } public TextBounds setMultiLineText ( CharSequence str , float x , float y ) { } public TextBounds setMultiLineText ( CharSequence str , float x , float y , float alignmentWidth , HAlignment alignment ) { } public TextBounds addMultiLineText ( CharSequence str , float x , float y ) { } public TextBounds addMultiLineText ( CharSequence str , float x , float y , float alignmentWidth , HAlignment alignment ) { } public TextBounds setWrappedText ( CharSequence str , float x , float y , float wrapWidth ) { } public TextBounds setWrappedText ( CharSequence str , float x , float y , float wrapWidth , HAlignment alignment ) { } public TextBounds addWrappedText ( CharSequence str , float x , float y , float wrapWidth ) { } public TextBounds addWrappedText ( CharSequence str , float x , float y , float wrapWidth , HAlignment alignment ) { } public TextBounds getBounds ( ) { } public float getX ( ) { } public float getY ( ) { } public BitmapFont getFont ( ) { } public void setUseIntegerPositions ( boolean use ) { } public boolean usesIntegerPositions ( ) { } public float [ ] getVertices ( ) { } public float [ ] getVertices ( int page ) { } }
public class AudioTools { public static native void convertToFloat ( ShortBuffer source , FloatBuffer target , int numSamples ) { } <START_BUG> public static native void convertToShort ( FloatBuffer source , FloatBuffer target , int numSamples ) ; <END_BUG> public static native void convertToMono ( ShortBuffer source , ShortBuffer target , int numSamples ) { } public static native void convertToMono ( FloatBuffer source , FloatBuffer target , int numSamples ) { } public static native float spectralFlux ( FloatBuffer spectrumA , FloatBuffer spectrumB , int numSamples ) { } public static FloatBuffer allocateFloatBuffer ( int numSamples , int numChannels ) { } public static ShortBuffer allocateShortBuffer ( int numSamples , int numChannels ) { } }
public class IndexQueryParserService extends AbstractIndexComponent { public static final class Defaults { public static final String QUERY_PREFIX = "index.queryparser.query" ; public static final String FILTER_PREFIX = "index.queryparser.filter" ; } private CloseableThreadLocal < QueryParseContext > cache = new CloseableThreadLocal < QueryParseContext > ( ) { @ Override protected QueryParseContext initialValue ( ) { } } ; final CacheRecycler cacheRecycler ; final AnalysisService analysisService ; final ScriptService scriptService ; final MapperService mapperService ; final SimilarityService similarityService ; final IndexCache indexCache ; final IndexFieldDataService fieldDataService ; final IndexEngine indexEngine ; private final Map < String , QueryParser > queryParsers ; private final Map < String , FilterParser > filterParsers ; private String defaultField ; private boolean queryStringLenient ; @ Inject public IndexQueryParserService ( Index index , @ IndexSettings Settings indexSettings , IndicesQueriesRegistry indicesQueriesRegistry , CacheRecycler cacheRecycler , ScriptService scriptService , AnalysisService analysisService , MapperService mapperService , IndexCache indexCache , IndexFieldDataService fieldDataService , IndexEngine indexEngine , @ Nullable SimilarityService similarityService , @ Nullable Map < String , QueryParserFactory > namedQueryParsers , @ Nullable Map < String , FilterParserFactory > namedFilterParsers ) { } public void close ( ) { } public String defaultField ( ) { } public boolean queryStringLenient ( ) { } public QueryParser queryParser ( String name ) { } public FilterParser filterParser ( String name ) { } public ParsedQuery parse ( QueryBuilder queryBuilder ) throws ElasticSearchException { } public ParsedQuery parse ( byte [ ] source ) throws ElasticSearchException { } public ParsedQuery parse ( byte [ ] source , int offset , int length ) throws ElasticSearchException { } public ParsedQuery parse ( BytesReference source ) throws ElasticSearchException { } public ParsedQuery parse ( String source ) throws QueryParsingException { } public ParsedQuery parse ( XContentParser parser ) { } @ Nullable public ParsedFilter parseInnerFilter ( XContentParser parser ) throws IOException { } @ Nullable public Query parseInnerQuery ( XContentParser parser ) throws IOException { } private ParsedQuery parse ( QueryParseContext parseContext , XContentParser parser ) throws IOException , QueryParsingException { parseContext . reset ( parser ) ; Query query = parseContext . parseInnerQuery ( ) ; if ( query == null ) { <START_BUG> query = Queries . NO_MATCH_QUERY ; <END_BUG> } return new ParsedQuery ( query , parseContext . copyNamedFilters ( ) ) ; } private void add ( Map < String , FilterParser > map , FilterParser filterParser ) { } private void add ( Map < String , QueryParser > map , QueryParser queryParser ) { } }
public class DateFieldMapper extends NumberFieldMapper < Long > { public static final String CONTENT_TYPE = "date" ; public static class Defaults extends NumberFieldMapper . Defaults { public static final FormatDateTimeFormatter DATE_TIME_FORMATTER = Joda . forPattern ( "dateOptionalTime" ) ; public static final String NULL_VALUE = null ; public static final TimeUnit TIME_UNIT = TimeUnit . MILLISECONDS ; public static final boolean PARSE_UPPER_INCLUSIVE = true ; } public static class Builder extends NumberFieldMapper . Builder < DateFieldMapper . Builder , DateFieldMapper > { protected TimeUnit timeUnit = DateFieldMapper . Defaults . TIME_UNIT ; protected String nullValue = DateFieldMapper . Defaults . NULL_VALUE ; protected FormatDateTimeFormatter dateTimeFormatter = DateFieldMapper . Defaults . DATE_TIME_FORMATTER ; public Builder ( String name ) { } public DateFieldMapper . Builder timeUnit ( TimeUnit timeUnit ) { } public DateFieldMapper . Builder nullValue ( String nullValue ) { } public DateFieldMapper . Builder dateTimeFormatter ( FormatDateTimeFormatter dateTimeFormatter ) { } @ Override public DateFieldMapper build ( BuilderContext context ) { boolean parseUpperInclusive = DateFieldMapper . Defaults . PARSE_UPPER_INCLUSIVE ; if ( ( context . indexSettings ( ) ) != null ) { parseUpperInclusive = context . indexSettings ( ) . getAsBoolean ( "index.mapping.date.parse_upper_inclusive" , DateFieldMapper . Defaults . PARSE_UPPER_INCLUSIVE ) ; } <START_BUG> DateFieldMapper fieldMapper = new DateFieldMapper ( buildNames ( context ) , dateTimeFormatter , precisionStep , fuzzyFactor , index , store , boost , omitNorms , indexOptions , nullValue , timeUnit , parseUpperInclusive , ignoreMalformed ) ; <END_BUG> fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } protected final FormatDateTimeFormatter dateTimeFormatter ; private final boolean parseUpperInclusive ; private final DateMathParser dateMathParser ; private String nullValue ; protected final TimeUnit timeUnit ; protected DateFieldMapper ( Names names , FormatDateTimeFormatter dateTimeFormatter , int precisionStep , String fuzzyFactor , Field . Index index , Field . Store store , float boost , boolean omitNorms , IndexOptions indexOptions , String nullValue , TimeUnit timeUnit , boolean parseUpperInclusive , boolean ignoreMalformed ) { } @ Override protected double parseFuzzyFactor ( String fuzzyFactor ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Long value ( Fieldable field ) { } @ Override public Long valueFromString ( String value ) { } @ Override public Object valueForSearch ( Fieldable field ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions ) { } @ Override public Query fuzzyQuery ( String value , double minSim , int prefixLength , int maxExpansions ) { } @ Override public Query fieldQuery ( String value , @ Nullable QueryParseContext context ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter fieldFilter ( String value , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( FieldDataCache fieldDataCache , String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected boolean customBoost ( ) { } @ Override protected Fieldable innerParseCreateField ( ParseContext context ) throws IOException { } @ Override public FieldDataType fieldDataType ( ) { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } private long parseStringValue ( String value ) { } }
public class JglfwApplication implements Application { JglfwGraphics graphics ; JglfwFiles files ; JglfwInput input ; JglfwNet net ; final ApplicationListener listener ; private final Array < Runnable > runnables = new Array ( ) ; private final Array < Runnable > executedRunnables = new Array ( ) ; private final Array < LifecycleListener > lifecycleListeners = new Array ( ) ; private final Map < String , Preferences > preferences = new HashMap ( ) ; private final JglfwClipboard clipboard = new JglfwClipboard ( ) ; private final GlfwCallbacks callbacks = new GlfwCallbacks ( ) ; private int logLevel = LOG_INFO ; volatile boolean running = true ; boolean isPaused ; private boolean forceExit ; private boolean runOnEDT ; private int foregroundFPS ; private int backgroundFPS ; private int hiddenFPS ; public JglfwApplication ( ApplicationListener listener ) { } public JglfwApplication ( ApplicationListener listener , String title , int width , int height , boolean useGL2 ) { } private static JglfwApplicationConfiguration createConfig ( String title , int width , int height , boolean useGL2 ) { } public JglfwApplication ( final ApplicationListener listener , final JglfwApplicationConfiguration config ) { } protected void exception ( Throwable ex ) { } void initialize ( JglfwApplicationConfiguration config ) { } protected void start ( ) { } protected void frame ( ) { } public boolean executeRunnables ( ) { } void sleep ( int millis ) { } void render ( long time ) { } protected void end ( ) { } public ApplicationListener getApplicationListener ( ) { } public JglfwGraphics getGraphics ( ) { } public Audio getAudio ( ) { } public JglfwInput getInput ( ) { } public JglfwFiles getFiles ( ) { } public JglfwNet getNet ( ) { } public ApplicationType getType ( ) { } public int getVersion ( ) { } public long getJavaHeap ( ) { } public long getNativeHeap ( ) { } public Preferences getPreferences ( String name ) { } public Clipboard getClipboard ( ) { } public void postRunnable ( Runnable runnable ) { } public boolean isPaused ( ) { } public void setForegroundFPS ( int foregroundFPS ) { } public void setBackgroundFPS ( int backgroundFPS ) { } public void setHiddenFPS ( int hiddenFPS ) { } protected boolean shouldExit ( ) { } public void exit ( ) { } public void setLogLevel ( int logLevel ) { } @ Override public int getLogLevel ( ) { } public void debug ( String tag , String message ) { } public void debug ( String tag , String message , Throwable exception ) { } public void log ( String tag , String message ) { } <START_BUG> public void log ( String tag , String message , Exception exception ) { <END_BUG> if ( ( logLevel ) >= ( LOG_INFO ) ) { System . out . println ( ( ( tag + ":<seq2seq4repair_space>" ) + message ) ) ; exception . printStackTrace ( System . out ) ; } } public void error ( String tag , String message ) { } public void error ( String tag , String message , Throwable exception ) { } public void addLifecycleListener ( LifecycleListener listener ) { } public void removeLifecycleListener ( LifecycleListener listener ) { } public GlfwCallbacks getCallbacks ( ) { } }
public class QueryFilterParser implements FilterParser { public static final String NAME = "query" ; @ Inject public QueryFilterParser ( ) { } @ Override public String [ ] names ( ) { } @ Override public Filter parse ( QueryParseContext parseContext ) throws IOException , QueryParsingException { Query query = parseContext . parseInnerQuery ( ) ; if ( query == null ) { return null ; } <START_BUG> return Queries . wrap ( query ) ; <END_BUG> } }
public class UISimpleTest extends GdxTest { Skin skin ; Stage stage ; SpriteBatch batch ; @ Override public void create ( ) { } @ Override public void render ( ) { } @ Override public void resize ( int width , int height ) { <START_BUG> stage . setViewport ( width , height , false ) ; <END_BUG> } @ Override public void dispose ( ) { } }
public class ParallelAction extends Action { Array < Action > actions = new Array ( 4 ) ; private boolean complete ; public ParallelAction ( ) { } public ParallelAction ( Action action1 ) { } public ParallelAction ( Action action1 , Action action2 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 , Action action4 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 , Action action4 , Action action5 ) { } public boolean act ( float delta ) { if ( complete ) return true ; complete = true ; Array < Action > actions = this . actions ; <START_BUG> for ( int i = 0 , n = actions . size ; i < n ; i ++ ) <END_BUG> if ( ! ( actions . get ( i ) . act ( delta ) ) ) complete = false ; return complete ; } public void restart ( ) { } public void reset ( ) { } public void addAction ( Action action ) { } public void setActor ( Actor actor ) { } public Array < Action > getActions ( ) { } public String toString ( ) { } }
public class JsonQueryParseContext { private final Index index ; private final MapperService mapperService ; private final FilterCache filterCache ; private final JsonQueryParserRegistry queryParserRegistry ; private JsonParser jp ; public JsonQueryParseContext ( Index index , JsonQueryParserRegistry queryParserRegistry , MapperService mapperService , FilterCache filterCache ) { } public void reset ( JsonParser jp ) { } public JsonParser jp ( ) { } public MapperService mapperService ( ) { } public FilterCache filterCache ( ) { } public Filter cacheFilterIfPossible ( Filter filter ) { } public Query parseInnerQuery ( ) throws IOException , QueryParsingException { } public Filter parseInnerFilter ( ) throws IOException , QueryParsingException { } public FieldMapper fieldMapper ( String name ) { } public String indexName ( String name ) { MapperService . SmartNameFieldMappers smartMapper = smartFieldMappers ( name ) ; if ( smartMapper == null ) { return name ; } if ( ( smartMapper . fieldMappers ( ) . mapper ( ) ) != null ) { <START_BUG> return smartMapper . fieldMappers ( ) . mapper ( ) . indexName ( ) ; <END_BUG> } return name ; } public SmartNameFieldMappers smartFieldMappers ( String name ) { } }
public class IssueUtils { <START_BUG> public static boolean isPullRequest ( Issue issue ) { <END_BUG> return ( ( issue != null ) && ( ( issue . getPullRequest ( ) ) != null ) ) && ( ! ( TextUtils . isEmpty ( issue . getPullRequest ( ) . getHtmlUrl ( ) ) ) ) ; } public static Issue toIssue ( final PullRequest pullRequest ) { } }
public class IndexRequest extends ShardReplicationOperationRequest { public static enum OpType { INDEX ( ( ( byte ) ( 0 ) ) ) , CREATE ( ( ( byte ) ( 1 ) ) ) ; private byte id ; OpType ( byte id ) { } public byte id ( ) { } public static IndexRequest . OpType fromId ( byte id ) { } } private String type ; private String id ; private byte [ ] source ; private int sourceOffset ; private int sourceLength ; private boolean sourceUnsafe ; private boolean sourceFromBuilder ; private IndexRequest . OpType opType = IndexRequest . OpType . INDEX ; public IndexRequest ( ) { } public IndexRequest ( String index ) { } public IndexRequest ( String index , String type , String id ) { } @ Override public ActionRequestValidationException validate ( ) { } @ Override public void beforeLocalFork ( ) { } public boolean sourceFromBuilder ( ) { } @ Override public IndexRequest index ( String index ) { } @ Override public IndexRequest listenerThreaded ( boolean threadedListener ) { } @ Override public IndexRequest operationThreaded ( boolean threadedOperation ) { } public String type ( ) { } @ Required public IndexRequest type ( String type ) { } public String id ( ) { } public IndexRequest id ( String id ) { } public byte [ ] source ( ) { if ( ( sourceUnsafe ) || ( ( sourceOffset ) > 0 ) ) { <START_BUG> source = Arrays . copyOfRange ( source , sourceOffset , sourceLength ) ; <END_BUG> sourceOffset = 0 ; sourceUnsafe = false ; } return source ; } @ Required public IndexRequest source ( Map source ) throws ElasticSearchGenerationException { } @ Required public IndexRequest source ( Map source , XContentType contentType ) throws ElasticSearchGenerationException { } @ Required public IndexRequest source ( String source ) { } @ Required public IndexRequest source ( XContentBuilder sourceBuilder ) { } public IndexRequest source ( byte [ ] source ) { } @ Required public IndexRequest source ( byte [ ] source , int offset , int length ) { } @ Required public IndexRequest source ( byte [ ] source , int offset , int length , boolean unsafe ) { } public IndexRequest timeout ( TimeValue timeout ) { } public IndexRequest timeout ( String timeout ) { } public IndexRequest opType ( IndexRequest . OpType opType ) { } public IndexRequest opType ( String opType ) throws ElasticSearchIllegalArgumentException { } @ Override public IndexRequest replicationType ( ReplicationType replicationType ) { } public IndexRequest replicationType ( String replicationType ) { } public IndexRequest create ( boolean create ) { } public IndexRequest . OpType opType ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } @ Override public String toString ( ) { } }
public class ContactAddedListenerByWrapper { private long swigCPtr ; protected boolean swigCMemOwn ; protected ContactAddedListenerByWrapper ( long cPtr , boolean cMemoryOwn ) { } public static long getCPtr ( ContactAddedListenerByWrapper obj ) { } protected void finalize ( ) { } public synchronized void delete ( ) { } protected void swigDirectorDisconnect ( ) { } public void swigReleaseOwnership ( ) { } public void swigTakeOwnership ( ) { } public boolean onContactAdded ( btManifoldPoint cp , btCollisionObjectWrapper colObj0Wrap , int partId0 , int index0 , boolean match0 , btCollisionObjectWrapper colObj1Wrap , int partId1 , int index1 , boolean match1 ) { <START_BUG> return gdxBulletJNI . ContactAddedListenerByWrapper_onContactAdded ( swigCPtr , this , btManifoldPoint . getCPtr ( cp ) , cp , btCollisionObjectWrapper . getCPtr ( colObj0Wrap ) , colObj0Wrap , partId0 , index0 , match0 , btCollisionObjectWrapper . getCPtr ( colObj1Wrap ) , colObj1Wrap , partId1 , index1 , match1 ) ; <END_BUG> } public ContactAddedListenerByWrapper ( ) { } }
public class ScriptBytesValues extends SortingBinaryDocValues implements ScriptValues { private final SearchScript script ; public ScriptBytesValues ( SearchScript script ) { } @ Override public SearchScript script ( ) { } private void set ( int i , Object o ) { if ( o == null ) { <START_BUG> values [ i ] . length = 0 ; <END_BUG> } else { values [ i ] . copyChars ( o . toString ( ) ) ; } } @ Override public void setDocument ( int docId ) { } }
final class JoglFiles implements Files { private final String externalPath = ( System . getProperty ( "user.home" ) ) + "/" ; @ Override public FileHandle getFileHandle ( String filename , FileType type ) { File file = null ; if ( ( type == ( FileType . Absolute ) ) || ( type == ( FileType . Internal ) ) ) file = new File ( filename ) ; else file = new File ( ( ( this . externalPath ) + filename ) ) ; if ( ( file . exists ( ) ) == false ) throw new GdxRuntimeException ( ( ( "File<seq2seq4repair_space>'" + filename ) + "'<seq2seq4repair_space>doesn't<seq2seq4repair_space>exist" ) ) ; else <START_BUG> return new JoglFileHandle ( file ) ; <END_BUG> } @ Override public String [ ] listDirectory ( String directory , FileType type ) { } @ Override public boolean makeDirectory ( String directory , FileType type ) { } @ Override public InputStream readFile ( String fileName , FileType type ) { } @ Override public OutputStream writeFile ( String filename , FileType type ) { } }
public class CubocDesktop { public static void main ( String [ ] argv ) { <START_BUG> new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new Cubocy ( ) , "Cubocy" , 480 , 320 ) ; <END_BUG> app . setLogLevel ( LOG_DEBUG ) ; } }
public class TypeFieldMapper extends AbstractFieldMapper < String > implements InternalMapper { public static final String NAME = "_type" ; public static final Term TERM_FACTORY = new Term ( TypeFieldMapper . NAME , "" ) ; public static final String CONTENT_TYPE = "_type" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = TypeFieldMapper . NAME ; public static final String INDEX_NAME = TypeFieldMapper . NAME ; public static final Index INDEX = Index . NOT_ANALYZED ; public static final Store STORE = Store . NO ; public static final boolean OMIT_NORMS = true ; public static final boolean OMIT_TERM_FREQ_AND_POSITIONS = true ; } public static class Builder extends AbstractFieldMapper . Builder < TypeFieldMapper . Builder , TypeFieldMapper > { public Builder ( ) { } @ Override public TypeFieldMapper build ( BuilderContext context ) { } } public TypeFieldMapper ( ) { } protected TypeFieldMapper ( String name , String indexName ) { } public TypeFieldMapper ( String name , String indexName , Field . Index index , Field . Store store , Field . TermVector termVector , float boost , boolean omitNorms , boolean omitTermFreqAndPositions ) { } public String value ( Document document ) { } @ Override public String value ( Fieldable field ) { } @ Override public String valueFromString ( String value ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } public Term term ( String value ) { } @ Override public Filter fieldFilter ( String value ) { } @ Override public Query fieldQuery ( String value , QueryParseContext context ) { <START_BUG> return new org . apache . lucene . search . DeletionAwareConstantScoreQuery ( context . cacheFilter ( fieldFilter ( value ) ) ) ; <END_BUG> } @ Override public boolean useFieldQueryWithQueryString ( ) { } @ Override protected Field parseCreateField ( ParseContext context ) throws IOException { } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public class GwtFileHandle extends FileHandle { public final Preloader preloader ; private final String file ; private final FileType type ; protected GwtFileHandle ( Preloader preloader , String fileName , FileType type ) { } public GwtFileHandle ( String path ) { } public String path ( ) { } public String name ( ) { } public String extension ( ) { } public String nameWithoutExtension ( ) { } public String pathWithoutExtension ( ) { } public FileType type ( ) { } public File file ( ) { } public InputStream read ( ) { } public BufferedInputStream read ( int bufferSize ) { } public Reader reader ( ) { } public Reader reader ( String charset ) { } public BufferedReader reader ( int bufferSize ) { } public BufferedReader reader ( int bufferSize , String charset ) { } public String readString ( ) { } public String readString ( String charset ) { } public byte [ ] readBytes ( ) { } public int readBytes ( byte [ ] bytes , int offset , int size ) { } public OutputStream write ( boolean append ) { } public void write ( InputStream input , boolean append ) { } public Writer writer ( boolean append ) { } public Writer writer ( boolean append , String charset ) { } public void writeString ( String string , boolean append ) { } public void writeString ( String string , boolean append , String charset ) { } public void writeBytes ( byte [ ] bytes , boolean append ) { } public void writeBytes ( byte [ ] bytes , int offset , int length , boolean append ) { } public FileHandle [ ] list ( ) { } public FileHandle [ ] list ( String suffix ) { } public boolean isDirectory ( ) { } public FileHandle child ( String name ) { <START_BUG> return new GwtFileHandle ( preloader , ( ( file . isEmpty ( ) ? "" : ( file ) + ( file . endsWith ( "/" ) ? "" : "/" ) ) + name ) , FileType . Internal ) ; <END_BUG> } public FileHandle parent ( ) { } public FileHandle sibling ( String name ) { } public void mkdirs ( ) { } public boolean exists ( ) { } public boolean delete ( ) { } public boolean deleteDirectory ( ) { } public void copyTo ( FileHandle dest ) { } public void moveTo ( FileHandle dest ) { } public long length ( ) { } public long lastModified ( ) { } public String toString ( ) { } }
public class SoftThreadLocalRecyclerTests extends AbstractRecyclerTests { @ Override protected Recycler < byte [ ] > newRecycler ( ) { <START_BUG> return new SoftThreadLocalRecycler < byte [ ] > ( RECYCLER_C , randomIntBetween ( 5 , 10 ) ) ; <END_BUG> } }
public class UISimpleTest extends GdxTest { Skin skin ; Stage stage ; SpriteBatch batch ; @ Override public void create ( ) { } @ Override public void render ( ) { } @ Override public void resize ( int width , int height ) { <START_BUG> stage . getViewport ( ) . update ( width , height , true ) ; <END_BUG> } @ Override public void dispose ( ) { } }
public class GatewayRecoveryStatus { public enum Stage { INIT ( ( ( byte ) ( 0 ) ) ) , RETRY ( ( ( byte ) ( 1 ) ) ) , INDEX ( ( ( byte ) ( 2 ) ) ) , TRANSLOG ( ( ( byte ) ( 3 ) ) ) , FINALIZE ( ( ( byte ) ( 4 ) ) ) , DONE ( ( ( byte ) ( 5 ) ) ) ; private final byte value ; Stage ( byte value ) { } public byte value ( ) { } public static GatewayRecoveryStatus . Stage fromValue ( byte value ) { } } final GatewayRecoveryStatus . Stage stage ; final long startTime ; final long time ; final long throttlingTime ; final long indexThrottlingTime ; final long indexSize ; final long reusedIndexSize ; final long recoveredIndexSize ; final long recoveredTranslogOperations ; public GatewayRecoveryStatus ( GatewayRecoveryStatus . Stage stage , long startTime , long time , long throttlingTime , long indexThrottlingTime , long indexSize , long reusedIndexSize , long recoveredIndexSize , long recoveredTranslogOperations ) { } public GatewayRecoveryStatus . Stage stage ( ) { } public long startTime ( ) { } public long getStartTime ( ) { } public TimeValue time ( ) { } public TimeValue getTime ( ) { } public TimeValue throttlingTime ( ) { } public TimeValue getThrottlingTime ( ) { } public TimeValue indexThrottlingTime ( ) { } public TimeValue getIndexThrottlingTime ( ) { } public ByteSizeValue indexSize ( ) { } public ByteSizeValue getIndexSize ( ) { } public ByteSizeValue reusedIndexSize ( ) { } public ByteSizeValue getReusedIndexSize ( ) { } public ByteSizeValue expectedRecoveredIndexSize ( ) { } public ByteSizeValue getExpectedRecoveredIndexSize ( ) { } public ByteSizeValue recoveredIndexSize ( ) { } public ByteSizeValue getRecoveredIndexSize ( ) { } public int indexRecoveryProgress ( ) { if ( ( recoveredIndexSize ) == 0 ) { <START_BUG> if ( ( indexSize ) == ( reusedIndexSize ) ) { <END_BUG> return 100 ; } return 0 ; } return ( ( int ) ( ( ( ( double ) ( recoveredIndexSize ) ) / ( expectedRecoveredIndexSize ( ) . bytes ( ) ) ) * 100 ) ) ; } public int getIndexRecoveryProgress ( ) { } public long recoveredTranslogOperations ( ) { } public long getRecoveredTranslogOperations ( ) { } }
public class MultiMatchQueryBuilder extends BaseQueryBuilder implements BoostableQueryBuilder < MultiMatchQueryBuilder > { private final Object text ; private final List < String > fields ; private ObjectFloatOpenHashMap < String > fieldsBoosts ; private MultiMatchQueryBuilder . Type type ; private Operator operator ; private String analyzer ; private Float boost ; private Integer slop ; private Fuzziness fuzziness ; private Integer prefixLength ; private Integer maxExpansions ; private String minimumShouldMatch ; private String rewrite = null ; private String fuzzyRewrite = null ; private Boolean useDisMax ; private Float tieBreaker ; private Boolean lenient ; private Float cutoffFrequency = null ; private ZeroTermsQuery zeroTermsQuery = null ; private String queryName ; public enum Type { BEST_FIELDS ( MatchQuery . Type . BOOLEAN , 0.0F , new ParseField ( "best_fields" , "boolean" ) ) , MOST_FIELDS ( MatchQuery . Type . BOOLEAN , 1.0F , new ParseField ( "most_fields" ) ) , CROSS_FIELDS ( MatchQuery . Type . BOOLEAN , 0.0F , new ParseField ( "cross_fields" ) ) , PHRASE ( MatchQuery . Type . PHRASE , 0.0F , new ParseField ( "phrase" ) ) , PHRASE_PREFIX ( MatchQuery . Type . PHRASE_PREFIX , 0.0F , new ParseField ( "phrase_prefix" ) ) ; private MatchQuery . Type matchQueryType ; private final float tieBreaker ; private final ParseField parseField ; Type ( MatchQuery . Type matchQueryType , float tieBreaker , ParseField parseField ) { } public float tieBreaker ( ) { } public MatchQuery . Type matchQueryType ( ) { } public ParseField parseField ( ) { } public static MultiMatchQueryBuilder . Type parse ( String value ) { } public static MultiMatchQueryBuilder . Type parse ( String value , EnumSet < ParseField . Flag > flags ) { } } public MultiMatchQueryBuilder ( Object text , String ... fields ) { } public MultiMatchQueryBuilder field ( String field ) { } public MultiMatchQueryBuilder field ( String field , float boost ) { fields . add ( field ) ; if ( ( fieldsBoosts ) == null ) { <START_BUG> fieldsBoosts = new ObjectFloatOpenHashMap < String > ( ) ; <END_BUG> } fieldsBoosts . put ( field , boost ) ; return this ; } public MultiMatchQueryBuilder type ( MultiMatchQueryBuilder . Type type ) { } public MultiMatchQueryBuilder type ( Object type ) { } public MultiMatchQueryBuilder operator ( MatchQueryBuilder . Operator operator ) { } public MultiMatchQueryBuilder analyzer ( String analyzer ) { } public MultiMatchQueryBuilder boost ( float boost ) { } public MultiMatchQueryBuilder slop ( int slop ) { } public MultiMatchQueryBuilder fuzziness ( Object fuzziness ) { } public MultiMatchQueryBuilder prefixLength ( int prefixLength ) { } public MultiMatchQueryBuilder maxExpansions ( int maxExpansions ) { } public MultiMatchQueryBuilder minimumShouldMatch ( String minimumShouldMatch ) { } public MultiMatchQueryBuilder rewrite ( String rewrite ) { } public MultiMatchQueryBuilder fuzzyRewrite ( String fuzzyRewrite ) { } @ Deprecated public MultiMatchQueryBuilder useDisMax ( boolean useDisMax ) { } public MultiMatchQueryBuilder tieBreaker ( float tieBreaker ) { } public MultiMatchQueryBuilder lenient ( boolean lenient ) { } public MultiMatchQueryBuilder cutoffFrequency ( float cutoff ) { } public MultiMatchQueryBuilder zeroTermsQuery ( MatchQueryBuilder . ZeroTermsQuery zeroTermsQuery ) { } public MultiMatchQueryBuilder queryName ( String queryName ) { } @ Override public void doXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public abstract class Camera { public final Vector3 position = new Vector3 ( ) ; public final Vector3 direction = new Vector3 ( 0 , 0 , ( - 1 ) ) ; public final Vector3 up = new Vector3 ( 0 , 1 , 0 ) ; public final Matrix4 projection = new Matrix4 ( ) ; public final Matrix4 view = new Matrix4 ( ) ; public final Matrix4 combined = new Matrix4 ( ) ; public final Matrix4 invProjectionView = new Matrix4 ( ) ; public float near = 1 ; public float far = 100 ; public float viewportWidth = 0 ; public float viewportHeight = 0 ; public final Frustum frustum = new Frustum ( ) ; private final Matrix4 tmpMat = new Matrix4 ( ) ; private final Vector3 tmpVec = new Vector3 ( ) ; public abstract void update ( ) { } public abstract void update ( boolean updateFrustum ) { } public void apply ( GL10 gl ) { } public void lookAt ( float x , float y , float z ) { } final Vector3 right = new Vector3 ( ) ; public void normalizeUp ( ) { } public void rotate ( float angle , float axisX , float axisY , float axisZ ) { } public void rotate ( Vector3 axis , float angle ) { } public void rotateAround ( Vector3 point , Vector3 axis , float angle ) { tmpVec . set ( point ) ; tmpVec . sub ( position ) ; translate ( tmpVec ) ; rotate ( axis , angle ) ; tmpVec . rotate ( axis , angle ) ; <START_BUG> translate ( tmpVec . mul ( ( - 1 ) ) ) ; <END_BUG> } public void translate ( float x , float y , float z ) { } public void translate ( Vector3 vec ) { } public void unproject ( Vector3 vec , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } public void unproject ( Vector3 vec ) { } public void project ( Vector3 vec ) { } public void project ( Vector3 vec , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } final Ray ray = new Ray ( new Vector3 ( ) , new Vector3 ( ) ) ; public Ray getPickRay ( float x , float y , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } public Ray getPickRay ( float x , float y ) { } }
public class TransportNodesHotThreadsAction extends TransportNodesOperationAction < NodesHotThreadsRequest , NodesHotThreadsResponse , TransportNodesHotThreadsAction . NodeRequest , NodeHotThreads > { @ Inject public TransportNodesHotThreadsAction ( Settings settings , ClusterName clusterName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected NodesHotThreadsResponse newResponse ( NodesHotThreadsRequest request , AtomicReferenceArray responses ) { } @ Override protected NodesHotThreadsRequest newRequest ( ) { } @ Override protected TransportNodesHotThreadsAction . NodeRequest newNodeRequest ( ) { } @ Override protected TransportNodesHotThreadsAction . NodeRequest newNodeRequest ( String nodeId , NodesHotThreadsRequest request ) { } @ Override protected NodeHotThreads newNodeResponse ( ) { } @ Override protected NodeHotThreads nodeOperation ( TransportNodesHotThreadsAction . NodeRequest request ) throws ElasticSearchException { HotThreads hotThreads = new HotThreads ( ) . busiestThreads ( request . request . threads ) . type ( request . request . type ) . interval ( request . request . interval ) . threadElementsSnapshotCount ( request . request . snapshots ) ; try { <START_BUG> return new NodeHotThreads ( clusterService . state ( ) . nodes ( ) . localNode ( ) , hotThreads . detect ( ) ) ; <END_BUG> } catch ( Exception e ) { throw new ElasticSearchException ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>detect<seq2seq4repair_space>hot<seq2seq4repair_space>threads" , e ) ; } } @ Override protected boolean accumulateExceptions ( ) { } static class NodeRequest extends NodeOperationRequest { NodesHotThreadsRequest request ; NodeRequest ( ) { } NodeRequest ( String nodeId , NodesHotThreadsRequest request ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class TransportRefreshAction extends TransportBroadcastOperationAction < RefreshRequest , RefreshResponse , ShardRefreshRequest , ShardRefreshResponse > { private final IndicesService indicesService ; @ Inject public TransportRefreshAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected RefreshRequest newRequest ( ) { } @ Override protected RefreshResponse newResponse ( RefreshRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardRefreshRequest newShardRequest ( ) { } @ Override protected ShardRefreshRequest newShardRequest ( ShardRouting shard , RefreshRequest request ) { } @ Override protected ShardRefreshResponse newShardResponse ( ) { } @ Override protected ShardRefreshResponse shardOperation ( ShardRefreshRequest request ) throws ElasticSearchException { IndexShard indexShard = indicesService . indexServiceSafe ( request . index ( ) ) . shardSafe ( request . shardId ( ) ) ; <START_BUG> indexShard . refresh ( new org . elasticsearch . index . engine . Engine . Refresh ( request . waitForOperations ( ) ) ) ; <END_BUG> return new ShardRefreshResponse ( request . index ( ) , request . shardId ( ) ) ; } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , RefreshRequest request , String [ ] concreteIndices ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , RefreshRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , RefreshRequest countRequest , String [ ] concreteIndices ) { } }
@ ThreadSafe public class JsonObjectMapper implements JsonIncludeInAllMapper , JsonMapper { public static final String JSON_TYPE = "object" ; public static class Defaults { public static final boolean ENABLED = true ; public static final boolean DYNAMIC = true ; public static final Type PATH_TYPE = Type . FULL ; public static final FormatDateTimeFormatter [ ] DATE_TIME_FORMATTERS = new FormatDateTimeFormatter [ ] { JsonDateFieldMapper . Defaults . DATE_TIME_FORMATTER } ; } public static class Builder extends JsonMapper . Builder < JsonObjectMapper . Builder , JsonObjectMapper > { private boolean enabled = JsonObjectMapper . Defaults . ENABLED ; private boolean dynamic = JsonObjectMapper . Defaults . DYNAMIC ; private Type pathType = JsonObjectMapper . Defaults . PATH_TYPE ; private List < FormatDateTimeFormatter > dateTimeFormatters = Lists . newArrayList ( ) ; private Boolean includeInAll ; private final List < JsonMapper . Builder > mappersBuilders = Lists . newArrayList ( ) ; public Builder ( String name ) { } public JsonObjectMapper . Builder enabled ( boolean enabled ) { } public JsonObjectMapper . Builder dynamic ( boolean dynamic ) { } public JsonObjectMapper . Builder pathType ( JsonPath . Type pathType ) { } public JsonObjectMapper . Builder noDateTimeFormatter ( ) { } public JsonObjectMapper . Builder includeInAll ( boolean includeInAll ) { } public JsonObjectMapper . Builder dateTimeFormatter ( Iterable < FormatDateTimeFormatter > dateTimeFormatters ) { } public JsonObjectMapper . Builder dateTimeFormatter ( FormatDateTimeFormatter [ ] dateTimeFormatters ) { } public JsonObjectMapper . Builder dateTimeFormatter ( FormatDateTimeFormatter dateTimeFormatter ) { } public JsonObjectMapper . Builder add ( JsonMapper . Builder builder ) { } @ Override public JsonObjectMapper build ( BuilderContext context ) { } } private final String name ; private final boolean enabled ; private final boolean dynamic ; private final Type pathType ; private final FormatDateTimeFormatter [ ] dateTimeFormatters ; private Boolean includeInAll ; private volatile ImmutableMap < String , JsonMapper > mappers = ImmutableMap . of ( ) ; private final Object mutex = new Object ( ) ; protected JsonObjectMapper ( String name ) { } protected JsonObjectMapper ( String name , boolean enabled , boolean dynamic , JsonPath . Type pathType ) { } protected JsonObjectMapper ( String name , boolean enabled , boolean dynamic , JsonPath . Type pathType , FormatDateTimeFormatter [ ] dateTimeFormatters ) { } JsonObjectMapper ( String name , boolean enabled , boolean dynamic , JsonPath . Type pathType , FormatDateTimeFormatter [ ] dateTimeFormatters , Map < String , JsonMapper > mappers ) { } @ Override public String name ( ) { } @ Override public void includeInAll ( Boolean includeInAll ) { } public JsonObjectMapper putMapper ( JsonMapper mapper ) { } @ Override public void traverse ( FieldMapperListener fieldMapperListener ) { } public void parse ( JsonParseContext jsonContext ) throws IOException { } private void serializeNullValue ( JsonParseContext jsonContext , String lastFieldName ) throws IOException { } private void serializeObject ( JsonParseContext jsonContext , String currentFieldName ) throws IOException { } private void serializeArray ( JsonParseContext jsonContext , String lastFieldName ) throws IOException { } private void serializeValue ( JsonParseContext jsonContext , String currentFieldName , JsonToken token ) throws IOException { } @ Override public void merge ( JsonMapper mergeWith , JsonMergeContext mergeContext ) throws MergeMappingException { } @ Override public void toJson ( JsonBuilder builder , Params params ) throws IOException { <START_BUG> toJson ( builder , params , null ) ; <END_BUG> } public void toJson ( JsonBuilder builder , Params params , JsonMapper ... additionalMappers ) throws IOException { } }
public class FieldsTermsStringFacetCollector extends AbstractFacetCollector { private final FieldDataCache fieldDataCache ; private final String [ ] indexFieldsNames ; private final ComparatorType comparatorType ; private final int size ; private final int numberOfShards ; private final FieldDataType [ ] fieldsDataType ; private FieldData [ ] fieldsData ; private final FieldsTermsStringFacetCollector . StaticAggregatorValueProc aggregator ; private final SearchScript script ; public FieldsTermsStringFacetCollector ( String facetName , String [ ] fieldsNames , int size , InternalStringTermsFacet . ComparatorType comparatorType , boolean allTerms , SearchContext context , ImmutableSet < BytesRef > excluded , Pattern pattern , String scriptLang , String script , Map < String , Object > params ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { for ( int i = 0 ; i < ( indexFieldsNames . length ) ; i ++ ) { fieldsData [ i ] = fieldDataCache . cache ( fieldsDataType [ i ] , context . reader ( ) , indexFieldsNames [ i ] ) ; } if ( ( script ) != null ) { <START_BUG> script . setNextReader ( context . reader ( ) ) ; <END_BUG> } } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override public Facet facet ( ) { } public static class AggregatorValueProc extends FieldsTermsStringFacetCollector . StaticAggregatorValueProc { private final ImmutableSet < BytesRef > excluded ; private final Matcher matcher ; private final SearchScript script ; public AggregatorValueProc ( TObjectIntHashMap < BytesRef > facets , ImmutableSet < BytesRef > excluded , Pattern pattern , SearchScript script ) { } @ Override public void onValue ( int docId , BytesRef value ) { } } public static class StaticAggregatorValueProc implements FieldData . StringValueInDocProc , FieldData . StringValueProc { private final TObjectIntHashMap < BytesRef > facets ; private int missing ; private int total ; public StaticAggregatorValueProc ( TObjectIntHashMap < BytesRef > facets ) { } @ Override public void onValue ( BytesRef value ) { } @ Override public void onValue ( int docId , BytesRef value ) { } @ Override public void onMissing ( int docId ) { } public final TObjectIntHashMap < BytesRef > facets ( ) { } public final int missing ( ) { } public final int total ( ) { } } }
public class ScriptTermsStringFieldFacetCollector extends AbstractFacetCollector { private final ComparatorType comparatorType ; private final int size ; private final int numberOfShards ; private final SearchScript script ; private final Matcher matcher ; private final ImmutableSet < BytesRef > excluded ; private final TObjectIntHashMap < BytesRef > facets ; private int missing ; private int total ; public ScriptTermsStringFieldFacetCollector ( String facetName , int size , InternalStringTermsFacet . ComparatorType comparatorType , SearchContext context , ImmutableSet < BytesRef > excluded , Pattern pattern , String scriptLang , String script , Map < String , Object > params ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { <START_BUG> script . setNextReader ( context . reader ( ) ) ; <END_BUG> } @ Override protected void doCollect ( int doc ) throws IOException { } private boolean match ( String value ) { } @ Override public Facet facet ( ) { } }
public class BulletTestCollection extends GdxTest implements InputProcessor , GestureListener { protected final BulletTest [ ] tests = new BulletTest [ ] { new ShootTest ( ) , new KinematicTest ( ) , new ConstraintsTest ( ) , new MeshShapeTest ( ) , new ConvexHullTest ( ) , new RayCastTest ( ) , new RayPickRagdollTest ( ) , new InternalTickTest ( ) , new CollisionWorldTest ( ) , new CollisionTest ( ) , new FrustumCullingTest ( ) , new ContactCallbackTest ( ) , new SoftBodyTest ( ) , new SoftMeshTest ( ) } ; protected int testIndex = 0 ; private Application app = null ; private BitmapFont font ; private Stage hud ; private Label fpsLabel ; private Label titleLabel ; private Label instructLabel ; private int loading = 0 ; @ Override public void render ( ) { } @ Override public void create ( ) { } @ Override public void dispose ( ) { } public void next ( ) { } public void loadnext ( ) { } @ Override public boolean keyDown ( int keycode ) { } @ Override public boolean keyTyped ( char character ) { } @ Override public boolean keyUp ( int keycode ) { } @ Override public boolean touchDown ( int x , int y , int pointer , int button ) { } @ Override public boolean touchDragged ( int x , int y , int pointer ) { } @ Override public boolean touchUp ( int x , int y , int pointer , int button ) { } @ Override public boolean needsGL20 ( ) { <START_BUG> return true ; <END_BUG> } @ Override public boolean mouseMoved ( int x , int y ) { } @ Override public boolean scrolled ( int amount ) { } @ Override public boolean touchDown ( float x , float y , int pointer , int button ) { } @ Override public boolean tap ( float x , float y , int count , int button ) { } @ Override public boolean longPress ( float x , float y ) { } @ Override public boolean fling ( float velocityX , float velocityY , int button ) { } @ Override public boolean pan ( float x , float y , float deltaX , float deltaY ) { } @ Override public boolean zoom ( float originalDistance , float currentDistance ) { } @ Override public boolean pinch ( Vector2 initialFirstPointer , Vector2 initialSecondPointer , Vector2 firstPointer , Vector2 secondPointer ) { } }
public class ValueCountAggregator extends MetricsAggregator . SingleValue { private final BytesValuesSource valuesSource ; private BytesValues values ; LongArray counts ; public ValueCountAggregator ( String name , long expectedBucketsCount , BytesValuesSource valuesSource , AggregationContext aggregationContext , Aggregator parent ) { } @ Override public boolean shouldCollect ( ) { } @ Override public void setNextReader ( AtomicReaderContext reader ) { } @ Override public void collect ( int doc , long owningBucketOrdinal ) throws IOException { } @ Override public double metric ( long owningBucketOrd ) { <START_BUG> return counts . get ( owningBucketOrd ) ; <END_BUG> } @ Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) { } @ Override public InternalAggregation buildEmptyAggregation ( ) { } @ Override public void doRelease ( ) { } public static class Factory extends ValueSourceAggregatorFactory . LeafOnly < BytesValuesSource > { public Factory ( String name , ValuesSourceConfig < BytesValuesSource > valuesSourceBuilder ) { } @ Override protected Aggregator createUnmapped ( AggregationContext aggregationContext , Aggregator parent ) { } @ Override protected Aggregator create ( BytesValuesSource valuesSource , long expectedBucketsCount , AggregationContext aggregationContext , Aggregator parent ) { } } }
public class Facets implements Iterable < Facet > , Streamable , ToXContent { private final List < Facet > EMPTY = ImmutableList . of ( ) ; private List < Facet > facets = EMPTY ; private Map < String , Facet > facetsAsMap ; private Facets ( ) { } public Facets ( List < Facet > facets ) { } @ Override public Iterator < Facet > iterator ( ) { } public List < Facet > facets ( ) { } public Map < String , Facet > getFacets ( ) { <START_BUG> return facetsAsMap ; <END_BUG> } public Map < String , Facet > facetsAsMap ( ) { } public CountFacet . CountFacet countFacet ( String name ) { } public Facet facet ( String name ) { } @ Override public void toXContent ( XContentBuilder builder , Params params ) throws IOException { } public static Facets readFacets ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public class CustomQueryWrappingFilter extends NoCacheFilter implements Releasable { private final Query query ; private IndexSearcher searcher ; private IdentityHashMap < AtomicReader , DocIdSet > docIdSets ; public CustomQueryWrappingFilter ( Query query ) { } public final Query getQuery ( ) { } @ Override public DocIdSet getDocIdSet ( final AtomicReaderContext context , final Bits acceptDocs ) throws IOException { final SearchContext searchContext = SearchContext . current ( ) ; if ( ( docIdSets ) == null ) { assert ( searcher ) == null ; IndexSearcher searcher = searchContext . searcher ( ) ; docIdSets = new IdentityHashMap ( ) ; this . searcher = searcher ; searchContext . addReleasable ( this , COLLECTION ) ; final Weight weight = searcher . createNormalizedWeight ( query ) ; for ( final AtomicReaderContext leaf : searcher . getTopReaderContext ( ) . leaves ( ) ) { final DocIdSet set = DocIdSets . toCacheable ( leaf . reader ( ) , new DocIdSet ( ) { @ Override public DocIdSetIterator iterator ( ) throws IOException { <START_BUG> return weight . scorer ( leaf , true , false , null ) ; <END_BUG> } @ Override public boolean isCacheable ( ) { return false ; } } ) ; docIdSets . put ( leaf . reader ( ) , set ) ; } } else { assert ( searcher ) == ( SearchContext . current ( ) . searcher ( ) ) ; } final DocIdSet set = docIdSets . get ( context . reader ( ) ) ; if ( ( set != null ) && ( acceptDocs != null ) ) { return BitsFilteredDocIdSet . wrap ( set , acceptDocs ) ; } return set ; } @ Override public void close ( ) throws ElasticsearchException { } @ Override public String toString ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } public static boolean shouldUseCustomQueryWrappingFilter ( Query query ) { } }
public class JsonDocumentMapper implements DocumentMapper , ToJson { public static class Builder { private JsonUidFieldMapper uidFieldMapper = new JsonUidFieldMapper ( ) ; private JsonIdFieldMapper idFieldMapper = new JsonIdFieldMapper ( ) ; private JsonTypeFieldMapper typeFieldMapper = new JsonTypeFieldMapper ( ) ; private JsonSourceFieldMapper sourceFieldMapper = new JsonSourceFieldMapper ( ) ; private JsonBoostFieldMapper boostFieldMapper = new JsonBoostFieldMapper ( ) ; private JsonAllFieldMapper allFieldMapper = new JsonAllFieldMapper ( ) ; private NamedAnalyzer indexAnalyzer ; private NamedAnalyzer searchAnalyzer ; private final JsonObjectMapper rootObjectMapper ; private String mappingSource ; private BuilderContext builderContext = new JsonMapper . BuilderContext ( new JsonPath ( 1 ) ) ; public Builder ( JsonObjectMapper . Builder builder ) { } public JsonDocumentMapper . Builder sourceField ( JsonSourceFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder idField ( JsonIdFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder uidField ( JsonUidFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder typeField ( JsonTypeFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder boostField ( JsonBoostFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder allField ( JsonAllFieldMapper . Builder builder ) { } public JsonDocumentMapper . Builder mappingSource ( String mappingSource ) { } public JsonDocumentMapper . Builder indexAnalyzer ( NamedAnalyzer indexAnalyzer ) { } public boolean hasIndexAnalyzer ( ) { } public JsonDocumentMapper . Builder searchAnalyzer ( NamedAnalyzer searchAnalyzer ) { } public boolean hasSearchAnalyzer ( ) { } public JsonDocumentMapper build ( ) { } } private ThreadLocal < JsonParseContext > cache = new ThreadLocal < JsonParseContext > ( ) { @ Override protected JsonParseContext initialValue ( ) { } } ; private final JsonFactory jsonFactory = Jackson . defaultJsonFactory ( ) ; private final String type ; private volatile String mappingSource ; private final JsonUidFieldMapper uidFieldMapper ; private final JsonIdFieldMapper idFieldMapper ; private final JsonTypeFieldMapper typeFieldMapper ; private final JsonSourceFieldMapper sourceFieldMapper ; private final JsonBoostFieldMapper boostFieldMapper ; private final JsonAllFieldMapper allFieldMapper ; private final JsonObjectMapper rootObjectMapper ; private final Analyzer indexAnalyzer ; private final Analyzer searchAnalyzer ; private volatile DocumentFieldMappers fieldMappers ; private final List < FieldMapperListener > fieldMapperListeners = Lists . newArrayList ( ) ; private final Object mutex = new Object ( ) ; public JsonDocumentMapper ( JsonObjectMapper rootObjectMapper , JsonUidFieldMapper uidFieldMapper , JsonIdFieldMapper idFieldMapper , JsonTypeFieldMapper typeFieldMapper , JsonSourceFieldMapper sourceFieldMapper , JsonAllFieldMapper allFieldMapper , Analyzer indexAnalyzer , Analyzer searchAnalyzer , @ Nullable JsonBoostFieldMapper boostFieldMapper , @ Nullable String mappingSource ) { } @ Override public String type ( ) { } @ Override public String mappingSource ( ) { } void mappingSource ( String mappingSource ) { } @ Override public UidFieldMapper uidMapper ( ) { } @ Override public IdFieldMapper idMapper ( ) { } @ Override public TypeFieldMapper typeMapper ( ) { } @ Override public SourceFieldMapper sourceMapper ( ) { } @ Override public BoostFieldMapper boostMapper ( ) { } @ Override public AllFieldMapper allFieldMapper ( ) { } @ Override public Analyzer indexAnalyzer ( ) { } @ Override public Analyzer searchAnalyzer ( ) { } @ Override public DocumentFieldMappers mappers ( ) { } @ Override public ParsedDocument parse ( byte [ ] source ) { } @ Override public ParsedDocument parse ( @ Nullable String type , @ Nullable String id , byte [ ] source ) throws MapperParsingException { } @ Override public ParsedDocument parse ( String type , String id , byte [ ] source , ParseListener listener ) { } void addFieldMapper ( FieldMapper fieldMapper ) { } @ Override public void addFieldMapperListener ( FieldMapperListener fieldMapperListener , boolean includeExisting ) { } @ Override public synchronized MergeResult merge ( DocumentMapper mergeWith , MergeFlags mergeFlags ) { } @ Override public String buildSource ( ) throws FailedToGenerateSourceMapperException { } @ Override public void toJson ( JsonBuilder builder , Params params ) throws IOException { <START_BUG> rootObjectMapper . toJson ( builder , params , allFieldMapper ) ; <END_BUG> } }
public abstract class SnappyCompressedIndexInput extends CompressedIndexInput < SnappyCompressorContext > { protected int chunkSize ; protected int maxCompressedChunkLength ; protected byte [ ] inputBuffer ; public SnappyCompressedIndexInput ( IndexInput in , SnappyCompressorContext context ) throws IOException { } @ Override protected void readHeader ( IndexInput in ) throws IOException { } @ Override protected void doClose ( ) throws IOException { } @ Override <START_BUG> public Object clone ( ) { <END_BUG> SnappyCompressedIndexInput cloned = ( ( SnappyCompressedIndexInput ) ( super . clone ( ) ) ) ; cloned . inputBuffer = new byte [ inputBuffer . length ] ; return cloned ; } }
public interface Rescorer { public String name ( ) { } <START_BUG> public void rescore ( TopDocs topDocs , SearchContext context , RescoreSearchContext rescoreContext ) throws IOException ; <END_BUG> public Explanation explain ( int topLevelDocId , SearchContext context , RescoreSearchContext rescoreContext , Explanation sourceExplanation ) throws IOException { } public RescoreSearchContext parse ( XContentParser parser , SearchContext context ) throws IOException { } public void extractTerms ( SearchContext context , RescoreSearchContext rescoreContext , Set < Term > termsSet ) { } }
public class GitHubAccount { public final String username ; public final String password ; public GitHubAccount ( String username , String password ) { } @ Override public String toString ( ) { <START_BUG> return ( ( ( getClass ( ) . getSimpleName ( ) ) + "[" ) + ( username ) ) + "]" ; <END_BUG> } }
public class InterpolationTest extends GdxTest { Stage stage ; private Skin skin ; private Table table ; List < String > list ; String [ ] interpolationNames ; String selectedInterpolation ; private ShapeRenderer renderer ; float graphSize = 400 ; float steps = ( graphSize ) / 2 ; float time = 0 ; float duration = 2.5F ; Vector2 startPosition = new Vector2 ( ) ; Vector2 targetPosition = new Vector2 ( ) ; Vector2 position = new Vector2 ( ) ; void resetPositions ( ) { } Vector2 getPosition ( float time ) { } private Interpolation getInterpolation ( String name ) { } @ Override public void create ( ) { } public void render ( ) { } public void resize ( int width , int height ) { <START_BUG> stage . getViewport ( ) . update ( width , height ) ; <END_BUG> table . invalidateHierarchy ( ) ; renderer . setProjectionMatrix ( stage . getViewport ( ) . getCamera ( ) . combined ) ; } public void dispose ( ) { } }
public class IndexFieldMapper extends AbstractFieldMapper < String > implements InternalMapper , RootMapper { public static final String NAME = "_index" ; public static final String CONTENT_TYPE = "_index" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = IndexFieldMapper . NAME ; public static final String INDEX_NAME = IndexFieldMapper . NAME ; public static final Index INDEX = Index . NOT_ANALYZED ; public static final Store STORE = Store . NO ; public static final boolean OMIT_NORMS = true ; public static final boolean OMIT_TERM_FREQ_AND_POSITIONS = true ; public static final boolean ENABLED = false ; } public static class Builder extends AbstractFieldMapper . Builder < IndexFieldMapper . Builder , IndexFieldMapper > { private boolean enabled = IndexFieldMapper . Defaults . ENABLED ; public Builder ( ) { } public IndexFieldMapper . Builder enabled ( boolean enabled ) { } @ Override public IndexFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private final boolean enabled ; public IndexFieldMapper ( ) { } protected IndexFieldMapper ( String name , String indexName ) { } public IndexFieldMapper ( String name , String indexName , Field . Store store , Field . TermVector termVector , float boost , boolean omitNorms , boolean omitTermFreqAndPositions , boolean enabled ) { } public boolean enabled ( ) { } public String value ( Document document ) { } @ Override public String value ( Fieldable field ) { } @ Override public String valueFromString ( String value ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } public Term term ( String value ) { <START_BUG> return termFactory . createTerm ( value ) ; <END_BUG> } @ Override public void preParse ( ParseContext context ) throws IOException { } @ Override public void postParse ( ParseContext context ) throws IOException { } @ Override public void parse ( ParseContext context ) throws IOException { } @ Override public void validate ( ParseContext context ) throws MapperParsingException { } @ Override public boolean includeInObject ( ) { } @ Override protected Field parseCreateField ( ParseContext context ) throws IOException { } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public class GamepadTest extends GdxTest { String descriptor ; Skin skin ; Table ui ; Stage stage ; ScrollPane scrollPane ; List < String > console ; @ Override public void create ( ) { } void print ( String message ) { } void clear ( ) { } private void setupUi ( ) { } @ Override public void resize ( int width , int height ) { ui . setSize ( width , height ) ; ui . invalidate ( ) ; <START_BUG> stage . getViewport ( ) . update ( width , height ) ; <END_BUG> } @ Override public void render ( ) { } }
public class MainMenu extends CubocScreen { TextureRegion title ; SpriteBatch batch ; float time = 0 ; public MainMenu ( Game game ) { } @ Override public void show ( ) { } @ Override public void render ( float delta ) { } @ Override public void hide ( ) { <START_BUG> System . out . println ( "dispose<seq2seq4repair_space>main<seq2seq4repair_space>menu" ) ; <END_BUG> batch . dispose ( ) ; title . getTexture ( ) . dispose ( ) ; } }
public class TmxMapLoader extends SynchronousAssetLoader < TiledMap , TmxMapLoader . Parameters > { public static class Parameters extends AssetLoaderParameters < TiledMap > { } private static final int FLAG_FLIP_HORIZONTALLY = - 2147483648 ; private static final int FLAG_FLIP_VERTICALLY = 1073741824 ; private static final int FLAG_FLIP_DIAGONALLY = 536870912 ; private static final int MASK_CLEAR = - 536870912 ; private XmlReader xml = new XmlReader ( ) ; private Element root ; public TmxMapLoader ( ) { } public TmxMapLoader ( FileHandleResolver resolver ) { } public TiledMap load ( String fileName ) { } @ Override public TiledMap load ( AssetManager assetManager , String fileName , TmxMapLoader . Parameters parameter ) { } @ Override public Array < AssetDescriptor > getDependencies ( String fileName , TmxMapLoader . Parameters parameter ) { } private TiledMap loadTilemap ( Element root , FileHandle tmxFile , ImageResolver imageResolver ) { } private Array < FileHandle > loadTilesets ( Element root , FileHandle tmxFile ) throws IOException { } private void loadTileSet ( TiledMap map , Element element , FileHandle tmxFile , ImageResolver imageResolver ) { } private void loadTileLayer ( TiledMap map , Element element ) { } public void loadObjectGroup ( TiledMap map , Element element ) { } private void loadObject ( MapLayer layer , Element element ) { } private void loadProperties ( MapProperties properties , Element element ) { if ( element . getName ( ) . equals ( "properties" ) ) { for ( Element property : element . getChildrenByName ( "property" ) ) { String name = property . getAttribute ( "name" , null ) ; <START_BUG> String value = property . getAttribute ( name , null ) ; <END_BUG> if ( value == null ) { value = property . getText ( ) ; } properties . put ( name , value ) ; } } } private static FileHandle getRelativeFileHandle ( FileHandle file , String path ) { } private static int unsignedByteToInt ( byte b ) { } }
public class IndexerClusterService extends AbstractLifecycleComponent < IndexerClusterService > { private final ClusterService clusterService ; private final PublishIndexerClusterStateAction publishAction ; private final List < IndexerClusterStateListener > clusterStateListeners = new CopyOnWriteArrayList < IndexerClusterStateListener > ( ) ; private volatile ExecutorService updateTasksExecutor ; private volatile IndexerClusterState clusterState = IndexerClusterState . builder ( ) . build ( ) ; @ Inject public IndexerClusterService ( Settings settings , TransportService transportService , ClusterService clusterService ) { } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } public void add ( IndexerClusterStateListener listener ) { } public void remove ( IndexerClusterStateListener listener ) { } public void submitStateUpdateTask ( final String source , final IndexerClusterStateUpdateTask updateTask ) { } private class UpdateClusterStateListener implements PublishIndexerClusterStateAction . NewClusterStateListener { @ Override public void onNewClusterState ( final IndexerClusterState clusterState ) { ClusterState state = clusterService . state ( ) ; <START_BUG> if ( ! ( state . nodes ( ) . localNodeMaster ( ) ) ) { <END_BUG> logger . warn ( "master<seq2seq4repair_space>should<seq2seq4repair_space>not<seq2seq4repair_space>receive<seq2seq4repair_space>new<seq2seq4repair_space>cluster<seq2seq4repair_space>state<seq2seq4repair_space>from<seq2seq4repair_space>[{}]" , state . nodes ( ) . masterNode ( ) ) ; return ; } submitStateUpdateTask ( "received_state" , new IndexerClusterStateUpdateTask ( ) { @ Override public IndexerClusterState execute ( IndexerClusterState currentState ) { return clusterState ; } } ) ; } } }
final class LwjglInput implements Input { class KeyEvent { static final int KEY_DOWN = 0 ; static final int KEY_UP = 1 ; static final int KEY_TYPED = 2 ; long timeStamp ; int type ; int keyCode ; char keyChar ; } class TouchEvent { static final int TOUCH_DOWN = 0 ; static final int TOUCH_UP = 1 ; static final int TOUCH_DRAGGED = 2 ; static final int TOUCH_SCROLLED = 3 ; static final int TOUCH_MOVED = 4 ; long timeStamp ; int type ; int x ; int y ; int scrollAmount ; int button ; int pointer ; } Pool < LwjglInput . KeyEvent > usedKeyEvents = new Pool < LwjglInput . KeyEvent > ( 16 , 1000 ) { protected LwjglInput . KeyEvent newObject ( ) { } } ; Pool < LwjglInput . TouchEvent > usedTouchEvents = new Pool < LwjglInput . TouchEvent > ( 16 , 1000 ) { protected LwjglInput . TouchEvent newObject ( ) { } } ; List < LwjglInput . KeyEvent > keyEvents = new ArrayList < LwjglInput . KeyEvent > ( ) ; List < LwjglInput . TouchEvent > touchEvents = new ArrayList < LwjglInput . TouchEvent > ( ) ; boolean mousePressed = false ; int mouseX ; int mouseY ; int deltaX ; int deltaY ; int pressedKeys = 0 ; boolean justTouched = false ; Set < Integer > pressedButtons = new HashSet < Integer > ( ) ; InputProcessor processor ; char lastKeyCharPressed ; float keyRepeatTimer ; long currentEventTimeStamp ; public LwjglInput ( ) { } public float getAccelerometerX ( ) { } public float getAccelerometerY ( ) { } public float getAccelerometerZ ( ) { } public void getTextInput ( final TextInputListener listener , final String title , final String text ) { } public int getX ( ) { } public int getY ( ) { <START_BUG> return ( graphics . getHeight ( ) ) - ( Mouse . getY ( ) ) ; <END_BUG> } public boolean isAccelerometerAvailable ( ) { } public boolean isKeyPressed ( int key ) { } public boolean isTouched ( ) { } public int getX ( int pointer ) { } public int getY ( int pointer ) { } public boolean isTouched ( int pointer ) { } public boolean supportsMultitouch ( ) { } @ Override public void setOnscreenKeyboardVisible ( boolean visible ) { } @ Override public void setCatchBackKey ( boolean catchBack ) { } void processEvents ( ) { } public static int getGdxKeyCode ( int lwjglKeyCode ) { } public static int getLwjglKeyCode ( int gdxKeyCode ) { } public void update ( ) { } private int toGdxButton ( int button ) { } void updateMouse ( ) { } void updateKeyboard ( ) { } @ Override public void setInputProcessor ( InputProcessor processor ) { } @ Override public InputProcessor getInputProcessor ( ) { } @ Override public void vibrate ( int milliseconds ) { } @ Override public boolean justTouched ( ) { } private int toLwjglButton ( int button ) { } @ Override public boolean isButtonPressed ( int button ) { } @ Override public void vibrate ( long [ ] pattern , int repeat ) { } @ Override public void cancelVibrate ( ) { } @ Override public float getAzimuth ( ) { } @ Override public float getPitch ( ) { } @ Override public float getRoll ( ) { } @ Override public boolean isPeripheralAvailable ( Peripheral peripheral ) { } @ Override public int getRotation ( ) { } @ Override public Orientation getNativeOrientation ( ) { } @ Override public void setCursorCatched ( boolean catched ) { } @ Override public boolean isCursorCatched ( ) { } @ Override public int getDeltaX ( ) { } @ Override public int getDeltaX ( int pointer ) { } @ Override public int getDeltaY ( ) { } @ Override public int getDeltaY ( int pointer ) { } @ Override public void setCursorPosition ( int x , int y ) { } @ Override public void setCatchMenuKey ( boolean catchMenu ) { } @ Override public long getCurrentEventTime ( ) { } }
public class RestMultiGetAction extends BaseRestHandler { @ Inject public RestMultiGetAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { MultiGetRequest multiGetRequest = new MultiGetRequest ( ) ; multiGetRequest . listenerThreaded ( false ) ; multiGetRequest . refresh ( request . paramAsBoolean ( "refresh" , multiGetRequest . refresh ( ) ) ) ; multiGetRequest . preference ( request . param ( "preference" ) ) ; multiGetRequest . realtime ( request . paramAsBooleanOptional ( "realtime" , null ) ) ; String [ ] sFields = null ; String sField = request . param ( "fields" ) ; if ( sField != null ) { sFields = Strings . splitStringByCommaToArray ( sField ) ; } try { multiGetRequest . add ( request . param ( "index" ) , request . param ( "type" ) , sFields , request . content ( ) ) ; } catch ( Exception e ) { try { XContentBuilder builder = restContentBuilder ( request ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . BAD_REQUEST , builder . startObject ( ) . field ( "error" , e . getMessage ( ) ) . endObject ( ) ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } return ; } client . multiGet ( multiGetRequest , new org . elasticsearch . action . ActionListener < MultiGetResponse > ( ) { @ Override public void onResponse ( MultiGetResponse response ) { try { XContentBuilder builder = restContentBuilder ( request ) ; response . toXContent ( builder , request ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class UnicastBackwardsCompatibilityTest extends ElasticsearchBackwardsCompatIntegrationTest { @ Override protected Settings nodeSettings ( int nodeOrdinal ) { } @ Override protected Settings externalNodeSettings ( int nodeOrdinal ) { <START_BUG> return ImmutableSettings . settingsBuilder ( ) . put ( "transport.tcp.port" , ( 9390 + nodeOrdinal ) ) . put ( "discovery.zen.ping.multicast.enabled" , false ) . put ( "discovery.zen.ping.unicast.hosts" , "localhost:9380,localhost:9381,localhost:9390,localhost:9391" ) . put ( super . nodeSettings ( nodeOrdinal ) ) . build ( ) ; <END_BUG> } @ Test public void testUnicastDiscovery ( ) { } }
public class TermsStringFacetCollector extends AbstractFacetCollector { static ThreadLocal < ThreadLocals . CleanableValue < Deque < TObjectIntHashMap < String > > > > cache = new ThreadLocal < ThreadLocals . CleanableValue < Deque < TObjectIntHashMap < String > > > > ( ) { @ Override protected ThreadLocals . CleanableValue < Deque < TObjectIntHashMap < String > > > initialValue ( ) { } } ; private final FieldDataCache fieldDataCache ; private final String indexFieldName ; private final ComparatorType comparatorType ; private final int size ; private final int numberOfShards ; private final FieldDataType fieldDataType ; private FieldData fieldData ; private final TermsStringFacetCollector . StaticAggregatorValueProc aggregator ; private final SearchScript script ; public TermsStringFacetCollector ( String facetName , String fieldName , int size , TermsFacet . ComparatorType comparatorType , boolean allTerms , SearchContext context , ImmutableSet < BytesRef > excluded , Pattern pattern , String scriptLang , String script , Map < String , Object > params ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { fieldData = fieldDataCache . cache ( fieldDataType , context . reader ( ) , indexFieldName ) ; if ( ( script ) != null ) { <START_BUG> script . setNextReader ( context . reader ( ) ) ; <END_BUG> } } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override public Facet facet ( ) { } public static class AggregatorValueProc extends TermsStringFacetCollector . StaticAggregatorValueProc { private final ImmutableSet < BytesRef > excluded ; private final Matcher matcher ; private final SearchScript script ; public AggregatorValueProc ( TObjectIntHashMap < BytesRef > facets , ImmutableSet < BytesRef > excluded , Pattern pattern , SearchScript script ) { } @ Override public void onValue ( int docId , BytesRef value ) { } } public static class StaticAggregatorValueProc implements FieldData . StringValueInDocProc , FieldData . StringValueProc { private final TObjectIntHashMap < BytesRef > facets ; private int missing = 0 ; private int total = 0 ; public StaticAggregatorValueProc ( TObjectIntHashMap < BytesRef > facets ) { } @ Override public void onValue ( BytesRef value ) { } @ Override public void onValue ( int docId , BytesRef value ) { } @ Override public void onMissing ( int docId ) { } public final TObjectIntHashMap < BytesRef > facets ( ) { } public final int missing ( ) { } public int total ( ) { } } }
public class CountdownEventAction < T extends Event > extends EventAction < T > { int count ; int current ; public CountdownEventAction ( Class < ? extends T > eventClass , int count ) { } public boolean handle ( T event ) { ( current ) ++ ; <START_BUG> return ( current ) >= ( count ) ; <END_BUG> } }
public class Bits { long [ ] bits = new long [ ] { 0 } ; public boolean get ( int index ) { } public void set ( int index ) { } public void flip ( int index ) { } private void checkCapacity ( int len ) { <START_BUG> if ( len > ( bits . length ) ) { <END_BUG> long [ ] newBits = new long [ len + 1 ] ; System . arraycopy ( bits , 0 , newBits , 0 , bits . length ) ; bits = newBits ; } } public void clear ( int index ) { } public void clear ( ) { } public int numBits ( ) { } }
public interface IReflectionCache { public Collection < Type > getKnownTypes ( ) { } public Type forName ( String name ) { } <START_BUG> public Object newArray ( Class componentType , int size ) ; <END_BUG> public int getArrayLength ( Type type , Object obj ) { } public Object getArrayElement ( Type type , Object obj , int i ) { } public void setArrayElement ( Type type , Object obj , int i , Object value ) { } public Object get ( Field field , Object obj ) throws IllegalAccessException { } public void set ( Field field , Object obj , Object value ) throws IllegalAccessException { } public Object invoke ( Method m , Object obj , Object [ ] params ) { } }
public abstract class TransportClusterInfoAction < Request extends ClusterInfoRequest , Response extends ActionResponse > extends TransportMasterNodeOperationAction < Request , Response > { public TransportClusterInfoAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } @ Override protected String executor ( ) { } @ Override protected final boolean localExecute ( Request request ) { } @ Override protected final void masterOperation ( final Request request , final ClusterState state , final ActionListener < Response > listener ) throws ElasticSearchException { <START_BUG> String [ ] concreteIndices = state . metaData ( ) . concreteIndices ( request . indices ( ) , request . ignoreIndices ( ) , true ) ; <END_BUG> request . indices ( concreteIndices ) ; doMasterOperation ( request , state , listener ) ; } protected abstract void doMasterOperation ( Request request , ClusterState state , final ActionListener < Response > listener ) throws ElasticSearchException { } }
public class ParticleEditor extends JFrame { LwjglCanvas lwjglCanvas ; JPanel rowsPanel ; EffectPanel effectPanel ; private JSplitPane splitPane ; ParticleEffect effect = new ParticleEffect ( ) ; final HashMap < ParticleEmitter , ParticleEditor . ParticleData > particleData = new HashMap ( ) ; public ParticleEditor ( ) { } void reloadRows ( ) { } void addRow ( JPanel row ) { } public void setVisible ( String name , boolean visible ) { } public ParticleEmitter getEmitter ( ) { } public ImageIcon getIcon ( ParticleEmitter emitter ) { } public void setIcon ( ParticleEmitter emitters , ImageIcon icon ) { } public void setEnabled ( ParticleEmitter emitter , boolean enabled ) { } public boolean isEnabled ( ParticleEmitter emitter ) { } private void initializeComponents ( ) { } class Renderer implements ApplicationListener , InputProcessor { private float maxActiveTimer ; private int maxActive ; private int lastMaxActive ; private boolean mouseDown ; private int activeCount ; private int mouseX ; private int mouseY ; private BitmapFont font ; private SpriteBatch spriteBatch ; private Sprite bgImage ; public void create ( ) { if ( ( spriteBatch ) != null ) return ; <START_BUG> ( ( com . badlogic . gdx . backends . lwjgl . LwjglGraphics ) ( Gdx . graphics ) ) . setEnforcePotImages ( false ) ; <END_BUG> spriteBatch = new SpriteBatch ( ) ; font = new BitmapFont ( files . getFileHandle ( "default.fnt" , Internal ) , files . getFileHandle ( "default.png" , Internal ) , true ) ; effectPanel . newEmitter ( "Untitled" , true ) ; input . setInputProcessor ( this ) ; } @ Override public void resize ( int width , int height ) { } public void render ( ) { } private void loadImage ( ParticleEmitter emitter ) { } public boolean keyDown ( int keycode ) { } public boolean keyUp ( int keycode ) { } public boolean keyTyped ( char character ) { } public boolean touchDown ( int x , int y , int pointer , int newParam ) { } public boolean touchUp ( int x , int y , int pointer , int button ) { } public boolean touchDragged ( int x , int y , int pointer ) { } @ Override public void dispose ( ) { } @ Override public void pause ( ) { } @ Override public void resume ( ) { } @ Override public boolean touchMoved ( int x , int y ) { } @ Override public boolean scrolled ( int amount ) { } } static class ParticleData { public ImageIcon icon ; public String imagePath ; public boolean enabled = true ; } public static void main ( String [ ] args ) { } }
public class TribeTests extends ElasticsearchIntegrationTest { private static TestCluster cluster2 ; private Node tribeNode ; private Client tribeClient ; @ BeforeClass public static void setupSecondCluster ( ) throws Exception { ElasticsearchIntegrationTest . beforeClass ( ) ; <START_BUG> TribeTests . cluster2 = new TestCluster ( randomLong ( ) , 2 , 2 , Strings . randomBase64UUID ( getRandom ( ) ) , 0 ) ; <END_BUG> TribeTests . cluster2 . beforeTest ( getRandom ( ) , 0.1 ) ; TribeTests . cluster2 . ensureAtLeastNumDataNodes ( 2 ) ; } @ AfterClass public static void tearDownSecondCluster ( ) { } @ After public void tearDownTribeNode ( ) { } private void setupTribeNode ( Settings settings ) { } @ Test public void testGlobalReadWriteBlocks ( ) throws Exception { } @ Test public void testIndexWriteBlocks ( ) throws Exception { } @ Test public void testOnConflictDrop ( ) throws Exception { } @ Test public void testOnConflictPrefer ( ) throws Exception { } private void testOnConflictPrefer ( String tribe ) throws Exception { } @ Test public void testTribeOnOneCluster ( ) throws Exception { } private void awaitIndicesInClusterState ( final String ... indices ) throws Exception { } private void awaitSameNodeCounts ( ) throws Exception { } private int countDataNodesForTribe ( String tribeName , DiscoveryNodes nodes ) { } }
public class RestIndicesExistsAction extends BaseRestHandler { private final SettingsFilter settingsFilter ; @ Inject public RestIndicesExistsAction ( Settings settings , Client client , RestController controller , SettingsFilter settingsFilter ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { IndicesExistsRequest indicesExistsRequest = new IndicesExistsRequest ( splitIndices ( request . param ( "index" ) ) ) ; indicesExistsRequest . listenerThreaded ( false ) ; client . admin ( ) . indices ( ) . exists ( indicesExistsRequest , new org . elasticsearch . action . ActionListener < IndicesExistsResponse > ( ) { @ Override public void onResponse ( IndicesExistsResponse response ) { try { if ( response . exists ( ) ) { channel . sendResponse ( new StringRestResponse ( OK ) ) ; } else { channel . sendResponse ( new StringRestResponse ( NOT_FOUND ) ) ; } } catch ( Exception e ) { onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { <START_BUG> channel . sendResponse ( new StringRestResponse ( INTERNAL_SERVER_ERROR ) ) ; <END_BUG> } catch ( Exception e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class ScriptService extends AbstractComponent { private final String defaultLang ; private final ImmutableMap < String , ScriptEngineService > scriptEngines ; private final ConcurrentMap < String , CompiledScript > staticCache = ConcurrentCollections . newConcurrentMap ( ) ; private final Cache < ScriptService . CacheKey , CompiledScript > cache = CacheBuilder . newBuilder ( ) . build ( ) ; private final boolean disableDynamic ; public ScriptService ( Settings settings ) { } @ Inject public ScriptService ( Settings settings , Environment env , Set < ScriptEngineService > scriptEngines ) { } private void processScriptsDirectory ( String prefix , File dir ) { } public void close ( ) { } public CompiledScript compile ( String script ) { } public CompiledScript compile ( String lang , String script ) { } public ExecutableScript executable ( String lang , String script , Map vars ) { } public ExecutableScript executable ( CompiledScript compiledScript , Map vars ) { } public SearchScript search ( CompiledScript compiledScript , SearchLookup lookup , @ Nullable Map < String , Object > vars ) { } public SearchScript search ( SearchLookup lookup , String lang , String script , @ Nullable Map < String , Object > vars ) { } public SearchScript search ( MapperService mapperService , FieldDataCache fieldDataCache , String lang , String script , @ Nullable Map < String , Object > vars ) { <START_BUG> return search ( compile ( lang , script ) , new SearchLookup ( mapperService , fieldDataCache ) , vars ) ; <END_BUG> } public Object execute ( CompiledScript compiledScript , Map vars ) { } public void clear ( ) { } private boolean dynamicScriptDisabled ( String lang ) { } public static class CacheKey { public final String lang ; public final String script ; public CacheKey ( String lang , String script ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } } public static class DocScoreNativeScriptFactory implements NativeScriptFactory { @ Override public ExecutableScript newScript ( @ Nullable Map < String , Object > params ) { } } public static class DocScoreSearchScript extends AbstractFloatSearchScript { @ Override public float runAsFloat ( ) { } } }
public class XContentMapperTests { public static XContentDocumentMapperParser newParser ( ) { <START_BUG> return new XContentDocumentMapperParser ( new org . elasticsearch . index . analysis . AnalysisService ( new Index ( "test" ) ) ) ; <END_BUG> } public static MapperService newMapperService ( ) { } }
public class DefaultAssetFilter implements AssetFilter { private String extension ( String file ) { } @ Override public boolean accept ( String file , boolean isDirectory ) { } @ Override public AssetType getType ( String file ) { } private boolean isImage ( String extension ) { } private boolean isText ( String extension ) { <START_BUG> return ( ( ( ( ( ( ( extension . equals ( "json" ) ) || ( extension . equals ( "xml" ) ) ) || ( extension . equals ( "txt" ) ) ) || ( extension . equals ( "glsl" ) ) ) || ( extension . equals ( "fnt" ) ) ) || ( extension . equals ( "pack" ) ) ) || ( extension . equals ( "obj" ) ) ) || ( extension . equals ( "atlas" ) ) ; <END_BUG> } private boolean isAudio ( String extension ) { } }
public interface FieldMapper < T > { public static class Names { private final String name ; private final String indexName ; private final String indexNameClean ; private final String fullName ; private final String sourcePath ; private final Term indexNameTermFactory ; public Names ( String name ) { } public Names ( String name , String indexName , String indexNameClean , String fullName ) { } public Names ( String name , String indexName , String indexNameClean , String fullName , @ Nullable String sourcePath ) { } public String name ( ) { } public String indexName ( ) { } public String indexNameClean ( ) { } public String fullName ( ) { } public String sourcePath ( ) { } public Term indexNameTerm ( ) { } public Term createIndexNameTerm ( String value ) { <START_BUG> return indexNameTermFactory . createTerm ( value ) ; <END_BUG> } } FieldMapper . Names names ( ) { } boolean indexed ( ) { } boolean analyzed ( ) { } boolean stored ( ) { } boolean storeTermVectors ( ) { } boolean storeTermVectorOffsets ( ) { } boolean storeTermVectorPositions ( ) { } boolean storeTermVectorPayloads ( ) { } float boost ( ) { } boolean omitNorms ( ) { } IndexOptions indexOptions ( ) { } Analyzer indexAnalyzer ( ) { } Analyzer searchAnalyzer ( ) { } Analyzer searchQuoteAnalyzer ( ) { } Object valueForSearch ( Field field ) { } T value ( Field field ) { } T valueFromString ( String value ) { } String valueAsString ( Field field ) { } String indexedValue ( String value ) { } boolean useFieldQueryWithQueryString ( ) { } Query fieldQuery ( String value , @ Nullable QueryParseContext context ) { } Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions ) { } Query fuzzyQuery ( String value , double minSim , int prefixLength , int maxExpansions ) { } Query prefixQuery ( String value , @ Nullable MultiTermQuery . RewriteMethod method , @ Nullable QueryParseContext context ) { } Filter prefixFilter ( String value , @ Nullable QueryParseContext context ) { } Query queryStringTermQuery ( Term term ) { } Filter fieldFilter ( String value , @ Nullable QueryParseContext context ) { } Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Nullable Filter nullValueFilter ( ) { } FieldDataType fieldDataType ( ) { } }
public class MappingUpdatedAction extends TransportMasterNodeOperationAction < MappingUpdatedAction . MappingUpdatedRequest , MappingUpdatedAction . MappingUpdatedResponse > { private final MetaDataMappingService metaDataMappingService ; @ Inject public MappingUpdatedAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , MetaDataMappingService metaDataMappingService ) { } @ Override protected String transportAction ( ) { } @ Override protected MappingUpdatedAction . MappingUpdatedRequest newRequest ( ) { } @ Override protected MappingUpdatedAction . MappingUpdatedResponse newResponse ( ) { } @ Override protected MappingUpdatedAction . MappingUpdatedResponse masterOperation ( MappingUpdatedAction . MappingUpdatedRequest request , ClusterState state ) throws ElasticSearchException { try { metaDataMappingService . updateMapping ( request . index ( ) , request . type ( ) , request . mappingSource ( ) ) ; <START_BUG> } catch ( IOException e ) { <END_BUG> throw new ElasticSearchParseException ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>parse<seq2seq4repair_space>mapping<seq2seq4repair_space>form<seq2seq4repair_space>compressed<seq2seq4repair_space>string" , e ) ; } return new MappingUpdatedAction . MappingUpdatedResponse ( ) ; } public static class MappingUpdatedResponse implements ActionResponse { @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } public static class MappingUpdatedRequest extends MasterNodeOperationRequest { private String index ; private String type ; private CompressedString mappingSource ; MappingUpdatedRequest ( ) { } public MappingUpdatedRequest ( String index , String type , CompressedString mappingSource ) { } public String index ( ) { } public String type ( ) { } public CompressedString mappingSource ( ) { } @ Override public ActionRequestValidationException validate ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class JsonIntegerFieldMapper extends JsonNumberFieldMapper < Integer > { public static final String JSON_TYPE = "integer" ; public static class Defaults extends JsonNumberFieldMapper . Defaults { public static final Integer NULL_VALUE = null ; } public static class Builder extends JsonNumberFieldMapper . Builder < JsonIntegerFieldMapper . Builder , JsonIntegerFieldMapper > { protected Integer nullValue = JsonIntegerFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public JsonIntegerFieldMapper . Builder nullValue ( int nullValue ) { } @ Override public JsonIntegerFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements JsonTypeParser { @ Override public JsonMapper . Builder parse ( String name , JsonNode node , ParserContext parserContext ) throws MapperParsingException { } } private final Integer nullValue ; private final String nullValueAsString ; protected JsonIntegerFieldMapper ( Names names , int precisionStep , Field . Index index , Field . Store store , float boost , boolean omitNorms , boolean omitTermFreqAndPositions , Integer nullValue ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Integer value ( Fieldable field ) { byte [ ] value = field . getBinaryValue ( ) ; if ( value == null ) { <START_BUG> return Integer . MIN_VALUE ; <END_BUG> } return Numbers . bytesToInt ( value ) ; } @ Override public String indexedValue ( String value ) { } @ Override public String indexedValue ( Integer value ) { } @ Override public Object valueFromTerm ( String term ) { } @ Override public Object valueFromString ( String text ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override protected Field parseCreateField ( JsonParseContext jsonContext ) throws IOException { } @ Override public int sortType ( ) { } @ Override protected String jsonType ( ) { } @ Override protected void doJsonBody ( JsonBuilder builder ) throws IOException { } }
public abstract class ActionRequestBuilder < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder > { protected final Request request ; protected final InternalGenericClient client ; protected ActionRequestBuilder ( InternalGenericClient client , Request request ) { } public Request request ( ) { } @ SuppressWarnings ( "unchecked" ) public final RequestBuilder setListenerThreaded ( boolean listenerThreaded ) { } @ SuppressWarnings ( "unchecked" ) public final RequestBuilder putHeader ( String key , Object value ) { } public ListenableActionFuture < Response > execute ( ) { <START_BUG> PlainListenableActionFuture < Response > future = new PlainListenableActionFuture < Response > ( request . listenerThreaded ( ) , client . threadPool ( ) ) ; <END_BUG> execute ( future ) ; return future ; } public Response get ( ) throws ElasticsearchException { } public Response get ( TimeValue timeout ) throws ElasticsearchException { } public Response get ( String timeout ) throws ElasticsearchException { } public void execute ( ActionListener < Response > listener ) { } protected abstract void doExecute ( ActionListener < Response > listener ) { } }
public class RestHeadAction extends BaseRestHandler { @ Inject public RestHeadAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { final GetRequest getRequest = new GetRequest ( request . param ( "index" ) , request . param ( "type" ) , request . param ( "id" ) ) ; getRequest . listenerThreaded ( false ) ; getRequest . operationThreaded ( true ) ; getRequest . refresh ( request . paramAsBoolean ( "refresh" , getRequest . refresh ( ) ) ) ; getRequest . parent ( request . param ( "parent" ) ) ; getRequest . routing ( request . param ( "routing" ) ) ; getRequest . preference ( request . param ( "preference" ) ) ; getRequest . realtime ( request . paramAsBooleanOptional ( "realtime" , null ) ) ; getRequest . fields ( EMPTY_ARRAY ) ; client . get ( getRequest , new org . elasticsearch . action . ActionListener < GetResponse > ( ) { @ Override public void onResponse ( GetResponse response ) { try { if ( ! ( response . isExists ( ) ) ) { channel . sendResponse ( new StringRestResponse ( RestStatus . NOT_FOUND ) ) ; } else { channel . sendResponse ( new StringRestResponse ( RestStatus . OK ) ) ; } <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new StringRestResponse ( ExceptionsHelper . status ( e ) ) ) ; } catch ( Exception e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public interface DirectoryService { <START_BUG> Directory build ( ) throws IOException ; <END_BUG> void renameFile ( Directory dir , String from , String to ) throws IOException { } void fullDelete ( Directory dir ) throws IOException { } }
public class AggregationPhase implements SearchPhase { private final AggregationParseElement parseElement ; private final AggregationBinaryParseElement binaryParseElement ; @ Inject public AggregationPhase ( AggregationParseElement parseElement , AggregationBinaryParseElement binaryParseElement ) { } @ Override public Map < String , ? extends SearchParseElement > parseElements ( ) { } @ Override public void preProcess ( SearchContext context ) { } @ Override public void execute ( SearchContext context ) throws ElasticsearchException { } public static class AggregationsCollector extends XCollector { private final AggregationContext aggregationContext ; private final Aggregator [ ] collectors ; public AggregationsCollector ( Collection < Aggregator > collectors , AggregationContext aggregationContext ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { } @ Override public boolean acceptsDocsOutOfOrder ( ) { <START_BUG> return true ; <END_BUG> } @ Override public void postCollection ( ) throws IOException { } } }
public class StatisticalFacetCollector extends AbstractFacetCollector { private final String fieldName ; private final FieldDataCache fieldDataCache ; private final Type fieldDataType ; private NumericFieldData fieldData ; private final StatisticalFacetCollector . StatsProc statsProc = new StatisticalFacetCollector . StatsProc ( ) ; public StatisticalFacetCollector ( String facetName , String fieldName , FieldDataCache fieldDataCache , MapperService mapperService ) { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void setNextReader ( IndexReader reader , int docBase ) throws IOException { } @ Override public Facet facet ( ) { <START_BUG> return new InternalStatisticalFacet ( facetName , statsProc . min ( ) , statsProc . max ( ) , statsProc . total ( ) , statsProc . sumOfSquares ( ) , statsProc . count ( ) ) ; <END_BUG> } public static class StatsProc implements NumericFieldData . DoubleValueInDocProc { private double min = Double . NaN ; private double max = Double . NaN ; private double total = 0 ; private double sumOfSquares = 0.0 ; private long count ; @ Override public void onValue ( int docId , double value ) { } public final double min ( ) { } public final double max ( ) { } public final double total ( ) { } public final long count ( ) { } public final double sumOfSquares ( ) { } } }
public class ConstraintsTest extends BaseBulletTest { final Array < btTypedConstraint > constraints = new Array < btTypedConstraint > ( ) ; @ Override public void create ( ) { } @ Override public void dispose ( ) { for ( int i = 0 ; i < ( constraints . size ) ; i ++ ) { ( ( btDynamicsWorld ) ( collisionWorld ) ) . removeConstraint ( constraints . get ( i ) ) ; <START_BUG> constraints . get ( i ) . delete ( ) ; <END_BUG> } constraints . clear ( ) ; super . dispose ( ) ; } @ Override public boolean tap ( float x , float y , int count , int button ) { } }
public abstract class WordScorer { protected final IndexReader reader ; protected final String field ; protected final Terms terms ; protected final long vocabluarySize ; protected double realWordLikelyhood ; protected final BytesRef spare = new BytesRef ( ) ; protected final BytesRef separator ; protected final TermsEnum termsEnum ; private final long numTerms ; private final boolean useTotalTermFreq ; public WordScorer ( IndexReader reader , String field , double realWordLikelyHood , BytesRef separator ) throws IOException { } public WordScorer ( IndexReader reader , Terms terms , String field , double realWordLikelyHood , BytesRef separator ) throws IOException { } public long frequency ( BytesRef term ) throws IOException { <START_BUG> if ( termsEnum . seekExact ( term , true ) ) { <END_BUG> return useTotalTermFreq ? termsEnum . totalTermFreq ( ) : termsEnum . docFreq ( ) ; } return 0 ; } protected double channelScore ( Candidate candidate , Candidate original ) throws IOException { } public double score ( Candidate [ ] path , CandidateSet [ ] candidateSet , int at , int gramSize ) throws IOException { } protected double scoreUnigram ( Candidate word ) throws IOException { } protected double scoreBigram ( Candidate word , Candidate w_1 ) throws IOException { } protected double scoreTrigram ( Candidate word , Candidate w_1 , Candidate w_2 ) throws IOException { } public static interface WordScorerFactory { public WordScorer newScorer ( IndexReader reader , Terms terms , String field , double realWordLikelyhood , BytesRef separator ) throws IOException { } } }
public class CustomBoostFactorQuery extends Query { private Query subQuery ; private float boostFactor ; public CustomBoostFactorQuery ( Query subQuery , float boostFactor ) { } public Query getSubQuery ( ) { } public float getBoostFactor ( ) { } @ Override public Query rewrite ( IndexReader reader ) throws IOException { } @ Override public void extractTerms ( Set < Term > terms ) { } @ Override public Weight createWeight ( Searcher searcher ) throws IOException { } private class CustomBoostFactorWeight extends Weight { Searcher searcher ; Weight subQueryWeight ; public CustomBoostFactorWeight ( Searcher searcher ) throws IOException { } public Query getQuery ( ) { } public float getValue ( ) { } @ Override public float sumOfSquaredWeights ( ) throws IOException { } @ Override public void normalize ( float norm ) { } @ Override public Scorer scorer ( IndexReader reader , boolean scoreDocsInOrder , boolean topScorer ) throws IOException { <START_BUG> Scorer subQueryScorer = subQueryWeight . scorer ( reader , true , false ) ; <END_BUG> if ( subQueryScorer == null ) { return null ; } return new CustomBoostFactorQuery . CustomBoostFactorScorer ( getSimilarity ( searcher ) , reader , this , subQueryScorer ) ; } @ Override public Explanation explain ( IndexReader reader , int doc ) throws IOException { } } private class CustomBoostFactorScorer extends Scorer { private final CustomBoostFactorQuery . CustomBoostFactorWeight weight ; private final float subQueryWeight ; private final Scorer scorer ; private final IndexReader reader ; private CustomBoostFactorScorer ( Similarity similarity , IndexReader reader , CustomBoostFactorQuery . CustomBoostFactorWeight w , Scorer scorer ) throws IOException { } @ Override public int docID ( ) { } @ Override public int advance ( int target ) throws IOException { } @ Override public int nextDoc ( ) throws IOException { } @ Override public float score ( ) throws IOException { } public Explanation explain ( int doc ) throws IOException { } } public String toString ( String field ) { } public boolean equals ( Object o ) { } public int hashCode ( ) { } }
public class CountRequest extends BroadcastOperationRequest { private static final XContentType contentType = Requests . CONTENT_TYPE ; public static final float DEFAULT_MIN_SCORE = - 1.0F ; private float minScore = CountRequest . DEFAULT_MIN_SCORE ; @ Nullable protected String queryHint ; private byte [ ] querySource ; private int querySourceOffset ; private int querySourceLength ; private boolean querySourceUnsafe ; private String [ ] types = Strings . EMPTY_ARRAY ; private String queryParserName ; CountRequest ( ) { } public CountRequest ( String ... indices ) { } @ Override public ActionRequestValidationException validate ( ) { } public String queryHint ( ) { } @ Override public CountRequest operationThreading ( BroadcastOperationThreading operationThreading ) { } @ Override protected void beforeLocalFork ( ) { if ( querySourceUnsafe ) { <START_BUG> querySource = Arrays . copyOfRange ( querySource , querySourceOffset , querySourceLength ) ; <END_BUG> querySourceOffset = 0 ; querySourceUnsafe = false ; } } @ Override public CountRequest listenerThreaded ( boolean threadedListener ) { } public CountRequest indices ( String ... indices ) { } public CountRequest queryHint ( String queryHint ) { } float minScore ( ) { } public CountRequest minScore ( float minScore ) { } byte [ ] querySource ( ) { } int querySourceOffset ( ) { } int querySourceLength ( ) { } @ Required public CountRequest query ( QueryBuilder queryBuilder ) { } @ Required public CountRequest query ( Map querySource ) { } @ Required public CountRequest query ( XContentBuilder builder ) { } @ Required public CountRequest query ( String querySource ) { } @ Required public CountRequest query ( byte [ ] querySource ) { } @ Required public CountRequest query ( byte [ ] querySource , int offset , int length , boolean unsafe ) { } String queryParserName ( ) { } public CountRequest queryParserName ( String queryParserName ) { } String [ ] types ( ) { } public CountRequest types ( String ... types ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } @ Override public String toString ( ) { } }
public class IndexNameFacetCollector extends AbstractFacetCollector { private final String indexName ; private final ComparatorType comparatorType ; private final int size ; private int count = 0 ; public IndexNameFacetCollector ( String facetName , String indexName , TermsFacet . ComparatorType comparatorType , int size ) { } @ Override protected void doSetNextReader ( IndexReader reader , int docBase ) throws IOException { } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override public Facet facet ( ) { <START_BUG> return new InternalStringTermsFacet ( facetName , "_index" , comparatorType , size , Sets . newHashSet ( new InternalStringTermsFacet . StringEntry ( indexName , count ) ) ) ; <END_BUG> } }
public class LongFieldMapper extends NumberFieldMapper < Long > { public static final String CONTENT_TYPE = "long" ; public static class Defaults extends NumberFieldMapper . Defaults { public static final FieldType LONG_FIELD_TYPE = new FieldType ( NumberFieldMapper . Defaults . NUMBER_FIELD_TYPE ) ; public static final Long NULL_VALUE = null ; } public static class Builder extends NumberFieldMapper . Builder < LongFieldMapper . Builder , LongFieldMapper > { protected Long nullValue = LongFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public LongFieldMapper . Builder nullValue ( long nullValue ) { } @ Override public LongFieldMapper build ( BuilderContext context ) { <START_BUG> fieldType . setOmitNorms ( ( ( fieldType . omitNorms ( ) ) || ( ( boost ) != 1.0F ) ) ) ; <END_BUG> LongFieldMapper fieldMapper = new LongFieldMapper ( buildNames ( context ) , precisionStep , fuzzyFactor , boost , fieldType , nullValue , ignoreMalformed ( context ) ) ; fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private Long nullValue ; private String nullValueAsString ; protected LongFieldMapper ( Names names , int precisionStep , String fuzzyFactor , float boost , FieldType fieldType , Long nullValue , Explicit < Boolean > ignoreMalformed ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Long value ( Field field ) { } @ Override public Long valueFromString ( String value ) { } @ Override public String indexedValue ( String value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query fuzzyQuery ( String value , double minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query fieldQuery ( String value , @ Nullable QueryParseContext context ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter fieldFilter ( String value , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( FieldDataCache fieldDataCache , String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected boolean customBoost ( ) { } @ Override protected Field innerParseCreateField ( ParseContext context ) throws IOException { } @ Override public FieldDataType fieldDataType ( ) { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } public static class CustomLongNumericField extends CustomNumericField { private final long number ; private final NumberFieldMapper mapper ; public CustomLongNumericField ( NumberFieldMapper mapper , long number , FieldType fieldType ) { } @ Override public TokenStream tokenStream ( Analyzer analyzer ) throws IOException { } @ Override public String numericAsString ( ) { } } }
public class TransportService extends AbstractLifecycleComponent < TransportService > { private final Transport transport ; private final ThreadPool threadPool ; private final TimerService timerService ; final ConcurrentMap < String , TransportRequestHandler > serverHandlers = newConcurrentMap ( ) ; final ConcurrentMapLong < TransportService . RequestHolder > clientHandlers = ConcurrentCollections . newConcurrentMapLong ( ) ; final AtomicLong requestIds = new AtomicLong ( ) ; final CopyOnWriteArrayList < TransportConnectionListener > connectionListeners = new CopyOnWriteArrayList < TransportConnectionListener > ( ) ; final AtomicLong rxBytes = new AtomicLong ( ) ; final AtomicLong rxCount = new AtomicLong ( ) ; final AtomicLong txBytes = new AtomicLong ( ) ; final AtomicLong txCount = new AtomicLong ( ) ; final Map < Long , TransportService . TimeoutInfoHolder > timeoutInfoHandlers = Collections . synchronizedMap ( new LinkedHashMap < Long , TransportService . TimeoutInfoHolder > ( 100 , 0.75F , true ) { protected boolean removeEldestEntry ( Map . Entry eldest ) { } } ) ; private boolean throwConnectException = false ; public TransportService ( Transport transport , ThreadPool threadPool , TimerService timerService ) { } @ Inject public TransportService ( Settings settings , Transport transport , ThreadPool threadPool , TimerService timerService ) { } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } public boolean addressSupported ( Class < ? extends TransportAddress > address ) { } public TransportInfo info ( ) { } public TransportStats stats ( ) { } public BoundTransportAddress boundAddress ( ) { } public boolean nodeConnected ( DiscoveryNode node ) { } public void connectToNode ( DiscoveryNode node ) throws ConnectTransportException { } public void disconnectFromNode ( DiscoveryNode node ) { } public void addConnectionListener ( TransportConnectionListener listener ) { } public void removeConnectionListener ( TransportConnectionListener listener ) { } public void throwConnectException ( boolean throwConnectException ) { } public < T extends Streamable > TransportFuture < T > submitRequest ( DiscoveryNode node , String action , Streamable message , TransportResponseHandler < T > handler ) throws TransportException { } public < T extends Streamable > TransportFuture < T > submitRequest ( DiscoveryNode node , String action , Streamable message , TransportRequestOptions options , TransportResponseHandler < T > handler ) throws TransportException { } public < T extends Streamable > void sendRequest ( final DiscoveryNode node , final String action , final Streamable message , final TransportResponseHandler < T > handler ) throws TransportException { } public < T extends Streamable > void sendRequest ( final DiscoveryNode node , final String action , final Streamable message , final TransportRequestOptions options , final TransportResponseHandler < T > handler ) throws TransportException { } private long newRequestId ( ) { } public TransportAddress [ ] addressesFromString ( String address ) throws Exception { } public void registerHandler ( ActionTransportRequestHandler handler ) { } public void registerHandler ( String action , TransportRequestHandler handler ) { } public void removeHandler ( String action ) { } class Adapter implements TransportServiceAdapter { @ Override public void received ( long size ) { } @ Override public void sent ( long size ) { } @ Override public TransportRequestHandler handler ( String action ) { } @ Override public TransportResponseHandler remove ( long requestId ) { } @ Override public void raiseNodeConnected ( final DiscoveryNode node ) { <START_BUG> threadPool . execute ( new Runnable ( ) { <END_BUG> @ Override public void run ( ) { for ( TransportConnectionListener connectionListener : connectionListeners ) { connectionListener . onNodeConnected ( node ) ; } } } ) ; } @ Override public void raiseNodeDisconnected ( final DiscoveryNode node ) { } } class TimeoutTimerTask implements TimerTask { private final long requestId ; TimeoutTimerTask ( long requestId ) { } @ Override public void run ( Timeout timeout ) throws Exception { } } static class TimeoutInfoHolder { private final DiscoveryNode node ; private final String action ; TimeoutInfoHolder ( DiscoveryNode node , String action ) { } public DiscoveryNode node ( ) { } public String action ( ) { } } static class RequestHolder < T extends Streamable > { private final TransportResponseHandler < T > handler ; private final DiscoveryNode node ; private final String action ; private final Timeout timeout ; RequestHolder ( TransportResponseHandler < T > handler , DiscoveryNode node , String action , Timeout timeout ) { } public TransportResponseHandler < T > handler ( ) { } public DiscoveryNode node ( ) { } public String action ( ) { } public Timeout timeout ( ) { } } }
public class RestAnalyzeAction extends BaseRestHandler { @ Inject public RestAnalyzeAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { String text = request . param ( "text" ) ; if ( ( text == null ) && ( request . hasContent ( ) ) ) { text = request . content ( ) . toUtf8 ( ) ; } if ( text == null ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , new ElasticSearchIllegalArgumentException ( "text<seq2seq4repair_space>is<seq2seq4repair_space>missing" ) ) ) ; } catch ( IOException e1 ) { logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>response" , e1 ) ; } return ; } AnalyzeRequest analyzeRequest = new AnalyzeRequest ( request . param ( "index" ) , text ) ; analyzeRequest . listenerThreaded ( false ) ; analyzeRequest . preferLocal ( request . paramAsBoolean ( "prefer_local" , analyzeRequest . preferLocalShard ( ) ) ) ; analyzeRequest . analyzer ( request . param ( "analyzer" ) ) ; analyzeRequest . field ( request . param ( "field" ) ) ; analyzeRequest . tokenizer ( request . param ( "tokenizer" ) ) ; analyzeRequest . tokenFilters ( request . paramAsStringArray ( "token_filters" , request . paramAsStringArray ( "filters" , null ) ) ) ; client . admin ( ) . indices ( ) . analyze ( analyzeRequest , new org . elasticsearch . action . ActionListener < AnalyzeResponse > ( ) { @ Override public void onResponse ( AnalyzeResponse response ) { try { <START_BUG> XContentBuilder builder = restContentBuilder ( request , null ) ; <END_BUG> builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; } catch ( Throwable e ) { onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class UserViewActivity extends TabPagerActivity < UserPagerAdapter > implements OrganizationSelectionProvider { public static Intent createIntent ( User user ) { } @ Inject private AvatarLoader avatars ; @ InjectExtra ( Intents . EXTRA_USER ) private User user ; @ InjectView ( id . pb_loading ) private ProgressBar loadingBar ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } private void configurePager ( ) { } @ Override public User addListener ( OrganizationSelectionListener listener ) { } @ Override public OrganizationSelectionProvider removeListener ( OrganizationSelectionListener listener ) { } @ Override protected UserPagerAdapter createAdapter ( ) { <START_BUG> return new UserPagerAdapter ( getSupportFragmentManager ( ) , getResources ( ) ) ; <END_BUG> } @ Override protected int getContentView ( ) { } @ Override protected String getIcon ( int position ) { } }
public final class ClassReflection { public static Class forName ( String name ) throws ReflectionException { } public static String getSimpleName ( Class c ) { <START_BUG> return c . getName ( ) ; <END_BUG> } public static boolean isInstance ( Class c , Object obj ) { } public static boolean isAssignableFrom ( Class c1 , Class c2 ) { } public static boolean isMemberClass ( Class c ) { } public static boolean isStaticClass ( Class c ) { } public static < T > T newInstance ( Class < T > c ) throws ReflectionException { } public static Constructor [ ] getConstructors ( Class c ) { } public static Constructor getConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Constructor getDeclaredConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getMethods ( Class c ) { } public static Method getMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getDeclaredMethods ( Class c ) { } public static Method getDeclaredMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Field [ ] getFields ( Class c ) { } public static Field getField ( Class c , String name ) throws ReflectionException { } public static Field [ ] getDeclaredFields ( Class c ) { } public static Field getDeclaredField ( Class c , String name ) throws ReflectionException { } }
@ ThreadSafe public class MapperService extends AbstractIndexComponent implements Iterable < DocumentMapper > { public static final String DEFAULT_MAPPING = "_default_" ; private final boolean dynamic ; private volatile String defaultMappingSource ; private volatile ImmutableMap < String , DocumentMapper > mappers = ImmutableMap . of ( ) ; private final Object mutex = new Object ( ) ; private volatile ImmutableMap < String , FieldMappers > nameFieldMappers = ImmutableMap . of ( ) ; private volatile ImmutableMap < String , FieldMappers > indexNameFieldMappers = ImmutableMap . of ( ) ; private volatile ImmutableMap < String , FieldMappers > fullNameFieldMappers = ImmutableMap . of ( ) ; private final DocumentMapperParser documentParser ; private final MapperService . InternalFieldMapperListener fieldMapperListener = new MapperService . InternalFieldMapperListener ( ) ; private final MapperService . SmartIndexNameSearchAnalyzer searchAnalyzer ; @ Inject public MapperService ( Index index , @ IndexSettings Settings indexSettings , Environment environment , AnalysisService analysisService ) { } @ Override public UnmodifiableIterator < DocumentMapper > iterator ( ) { } public DocumentMapperParser documentMapperParser ( ) { } public void add ( String type , String mappingSource ) { } private void add ( DocumentMapper mapper ) { } public void remove ( String type ) { } public DocumentMapper parse ( String mappingType , String mappingSource ) throws MapperParsingException { } public boolean hasMapping ( String mappingType ) { } public DocumentMapper documentMapper ( String type ) { } public DocumentMapper documentMapperWithAutoCreate ( String type ) { DocumentMapper mapper = mappers . get ( type ) ; if ( mapper != null ) { return mapper ; } if ( ! ( dynamic ) ) { <START_BUG> return null ; <END_BUG> } synchronized ( mutex ) { mapper = mappers . get ( type ) ; if ( mapper != null ) { return mapper ; } add ( type , null ) ; return mappers . get ( type ) ; } } public Filter typesFilter ( String ... types ) { } public FieldMappers name ( String name ) { } public FieldMappers indexName ( String indexName ) { } public FieldMappers fullName ( String fullName ) { } public FieldMapper smartNameFieldMapper ( String smartName ) { } public Set < String > simpleMatchToIndexNames ( String pattern ) { } public FieldMappers smartNameFieldMappers ( String smartName ) { } public MapperService . SmartNameFieldMappers smartName ( String smartName ) { } public Analyzer searchAnalyzer ( ) { } public static class SmartNameFieldMappers { private final FieldMappers fieldMappers ; private final DocumentMapper docMapper ; public SmartNameFieldMappers ( FieldMappers fieldMappers , @ Nullable DocumentMapper docMapper ) { } public boolean hasMapper ( ) { } public FieldMapper mapper ( ) { } public FieldMappers fieldMappers ( ) { } public boolean hasDocMapper ( ) { } public DocumentMapper docMapper ( ) { } } class SmartIndexNameSearchAnalyzer extends Analyzer { private final Analyzer defaultAnalyzer ; SmartIndexNameSearchAnalyzer ( Analyzer defaultAnalyzer ) { } @ Override public int getPositionIncrementGap ( String fieldName ) { } @ Override public int getOffsetGap ( Fieldable field ) { } @ Override public TokenStream tokenStream ( String fieldName , Reader reader ) { } @ Override public TokenStream reusableTokenStream ( String fieldName , Reader reader ) throws IOException { } } private class InternalFieldMapperListener implements FieldMapperListener { @ Override public void fieldMapper ( FieldMapper fieldMapper ) { } } }
public class DumpMonitorService extends AbstractComponent { private final String dumpLocation ; private final DumpGenerator generator ; private final ClusterService clusterService ; private final Map < String , Settings > contSettings ; private final Map < String , DumpContributorFactory > contributors ; private final File workFile ; public DumpMonitorService ( ) { } @ Inject public DumpMonitorService ( Settings settings , Environment environment , @ Nullable ClusterService clusterService , @ Nullable Map < String , DumpContributorFactory > contributors ) { } public Result generateDump ( String cause , @ Nullable Map < String , Object > context ) throws DumpGenerationFailedException { } public Result generateDump ( String cause , @ Nullable Map < String , Object > context , String ... contributors ) throws DumpGenerationFailedException { } private Map < String , Object > fillContextMap ( Map < String , Object > context ) { if ( context == null ) { context = Maps . newHashMap ( ) ; } if ( ( clusterService ) != null ) { <START_BUG> context . put ( "localNode" , clusterService . state ( ) . nodes ( ) . localNode ( ) ) ; <END_BUG> } return context ; } }
public class AnimatedTiledMapTile implements TiledMapTile { private static long lastTiledMapRenderTime = 0 ; private int id ; private BlendMode blendMode = BlendMode . ALPHA ; private MapProperties properties ; private Array < StaticTiledMapTile > frameTiles ; private float animationInterval ; private long frameCount = 0 ; @ Override public int getId ( ) { } @ Override public void setId ( int id ) { } @ Override public BlendMode getBlendMode ( ) { } @ Override public void setBlendMode ( BlendMode blendMode ) { } @ Override public TextureRegion getTextureRegion ( ) { <START_BUG> long currentFrame = ( ( AnimatedTiledMapTile . lastTiledMapRenderTime ) / ( ( long ) ( animationInterval ) ) ) % ( frameCount ) ; <END_BUG> return frameTiles . get ( ( ( int ) ( currentFrame ) ) ) . getTextureRegion ( ) ; } @ Override public MapProperties getProperties ( ) { } public static void updateAnimationBaseTime ( ) { } public AnimatedTiledMapTile ( float interval , Array < StaticTiledMapTile > frameTiles ) { } }
public class XContentFactory { private static int GUESS_HEADER_LENGTH = 20 ; private static final XContent [ ] contents ; public static XContentBuilder jsonBuilder ( ) throws IOException { } public static XContentBuilder jsonBuilder ( OutputStream os ) throws IOException { } public static XContentBuilder safeJsonBuilder ( ) throws IOException { } public static XContentBuilder smileBuilder ( ) throws IOException { } public static XContentBuilder smileBuilder ( OutputStream os ) throws IOException { } public static XContentBuilder safeSmileBuilder ( ) throws IOException { } public static XContentBuilder contentBuilder ( XContentType type , OutputStream outputStream ) throws IOException { } public static XContentBuilder contentBuilder ( XContentType type ) throws IOException { } public static XContentBuilder unCachedContentBuilder ( XContentType type ) throws IOException { } public static XContent xContent ( XContentType type ) { } public static XContentType xContentType ( CharSequence content ) { } public static XContent xContent ( CharSequence content ) { } public static XContent xContent ( byte [ ] data ) { } public static XContent xContent ( byte [ ] data , int offset , int length ) { XContentType type = XContentFactory . xContentType ( data , offset , length ) ; if ( type == null ) { <START_BUG> throw new ElasticSearchParseException ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>derive<seq2seq4repair_space>xcontent<seq2seq4repair_space>from<seq2seq4repair_space>" + ( Arrays . toString ( data ) ) ) ) ; <END_BUG> } return XContentFactory . xContent ( type ) ; } public static XContentType xContentType ( byte [ ] data ) { } public static XContentType xContentType ( InputStream si ) throws IOException { } public static XContentType xContentType ( byte [ ] data , int offset , int length ) { } }
public class ChildrenQuery extends Query implements ScopePhase . CollectorPhase { private final SearchContext searchContext ; private final String parentType ; private final String childType ; private final Filter parentFilter ; private final ScoreType scoreType ; private final String scope ; private final Query childQuery ; private TObjectFloatHashMap < HashedBytesArray > uidToScore ; private TObjectIntHashMap < HashedBytesArray > uidToCount ; public ChildrenQuery ( SearchContext searchContext , String parentType , String childType , Filter parentFilter , String scope , Query childQuery , ScoreType scoreType ) { } private ChildrenQuery ( ChildrenQuery unProcessedQuery , Query rewrittenChildQuery ) { } @ Override public String toString ( String field ) { } @ Override public Query rewrite ( IndexReader reader ) throws IOException { } @ Override public void extractTerms ( Set < Term > terms ) { } @ Override public boolean requiresProcessing ( ) { } @ Override public Collector collector ( ) { } @ Override public void processCollector ( Collector collector ) { } @ Override public String scope ( ) { } @ Override public void clear ( ) { } @ Override public Query query ( ) { } @ Override public Weight createWeight ( IndexSearcher searcher ) throws IOException { } class ParentWeight extends Weight { final Weight childWeight ; public ParentWeight ( Weight childWeight ) { } @ Override public Explanation explain ( AtomicReaderContext context , int doc ) throws IOException { } @ Override public Query getQuery ( ) { } @ Override public float getValueForNormalization ( ) throws IOException { } @ Override public void normalize ( float norm , float topLevelBoost ) { } @ Override public Scorer scorer ( AtomicReaderContext context , boolean scoreDocsInOrder , boolean topScorer , Bits acceptDocs ) throws IOException { } } static class ParentScorer extends Scorer { final IdReaderTypeCache idTypeCache ; final TObjectFloatMap < HashedBytesArray > uidToScore ; final DocIdSetIterator parentsIterator ; int currentDocId = - 1 ; float currentScore ; ParentScorer ( Weight weight , IdReaderTypeCache idTypeCache , TObjectFloatMap < HashedBytesArray > uidToScore , DocIdSetIterator parentsIterator ) { } @ Override public float score ( ) throws IOException { } @ Override <START_BUG> public float freq ( ) throws IOException { <END_BUG> return 1 ; } @ Override public int docID ( ) { } @ Override public int nextDoc ( ) throws IOException { } @ Override public int advance ( int target ) throws IOException { } } static class AvgParentScorer extends ChildrenQuery . ParentScorer { final TObjectIntMap < HashedBytesArray > uidToCount ; HashedBytesArray currentUid ; AvgParentScorer ( Weight weight , IdReaderTypeCache idTypeCache , TObjectFloatMap < HashedBytesArray > uidToScore , TObjectIntMap < HashedBytesArray > uidToCount , DocIdSetIterator parentsIterator ) { } @ Override public int nextDoc ( ) throws IOException { } } static class ChildUidCollector extends NoopCollector { final TObjectFloatHashMap < HashedBytesArray > uidToScore ; final ScoreType scoreType ; final SearchContext searchContext ; final String childType ; Scorer scorer ; IdReaderTypeCache typeCache ; ChildUidCollector ( ScoreType scoreType , SearchContext searchContext , String childType , TObjectFloatHashMap < HashedBytesArray > uidToScore ) { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { } } static class AvgChildUidCollector extends ChildrenQuery . ChildUidCollector { final TObjectIntHashMap < HashedBytesArray > uidToCount ; AvgChildUidCollector ( ScoreType scoreType , SearchContext searchContext , String childType , TObjectFloatHashMap < HashedBytesArray > uidToScore , TObjectIntHashMap < HashedBytesArray > uidToCount ) { } @ Override public void collect ( int doc ) throws IOException { } } }
public class btCollisionDispatcher extends btDispatcher { private long swigCPtr ; protected btCollisionDispatcher ( final String className , long cPtr , boolean cMemoryOwn ) { } public btCollisionDispatcher ( long cPtr , boolean cMemoryOwn ) { } @ Override protected void reset ( long cPtr , boolean cMemoryOwn ) { } public static long getCPtr ( btCollisionDispatcher obj ) { } @ Override protected void finalize ( ) throws Throwable { } @ Override protected synchronized void delete ( ) { } public int getDispatcherFlags ( ) { } public void setDispatcherFlags ( int flags ) { } public void registerCollisionCreateFunc ( int proxyType0 , int proxyType1 , btCollisionAlgorithmCreateFunc createFunc ) { } public btPersistentManifold getManifoldByIndexInternal ( int index ) { } public btCollisionDispatcher ( btCollisionConfiguration collisionConfiguration ) { } public btCollisionAlgorithm findAlgorithm ( btCollisionObjectWrapper body0Wrap , btCollisionObjectWrapper body1Wrap , btPersistentManifold sharedManifold ) { } public btCollisionAlgorithm findAlgorithm ( btCollisionObjectWrapper body0Wrap , btCollisionObjectWrapper body1Wrap ) { } public void setNearCallback ( SWIGTYPE_p_f_r_btBroadphasePair_r_btCollisionDispatcher_r_q_const__btDispatcherInfo__void nearCallback ) { } public SWIGTYPE_p_f_r_btBroadphasePair_r_btCollisionDispatcher_r_q_const__btDispatcherInfo__void getNearCallback ( ) { } public static void defaultNearCallback ( btBroadphasePair collisionPair , btCollisionDispatcher dispatcher , btDispatcherInfo dispatchInfo ) { <START_BUG> CollisionJNI . btCollisionDispatcher_defaultNearCallback ( collisionPair , btCollisionDispatcher . getCPtr ( dispatcher ) , dispatcher , btDispatcherInfo . getCPtr ( dispatchInfo ) , dispatchInfo ) ; <END_BUG> } public btCollisionConfiguration getCollisionConfiguration ( ) { } public void setCollisionConfiguration ( btCollisionConfiguration config ) { } public btPoolAllocator getInternalManifoldPool ( ) { } public static final class DispatcherFlags { public static final int CD_STATIC_STATIC_REPORTED = 1 ; public static final int CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD = 2 ; public static final int CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION = 4 ; } }
@ AnalysisSettingsRequired public class HyphenationCompoundWordTokenFilterFactory extends AbstractCompoundWordTokenFilterFactory { private final HyphenationTree hyphenationTree ; @ Inject public HyphenationCompoundWordTokenFilterFactory ( Index index , @ IndexSettings Settings indexSettings , @ Assisted String name , @ Assisted Settings settings ) { } @ Override public TokenStream create ( TokenStream tokenStream ) { <START_BUG> return new org . apache . lucene . analysis . compound . HyphenationCompoundWordTokenFilter ( tokenStream , hyphenationTree , wordList , minWordSize , minSubwordSize , maxSubwordSize , onlyLongestMatch ) ; <END_BUG> } }
public class Pools { private static final ObjectMap < Class , ReflectionPool > typePools = new ObjectMap ( ) ; public static < T > Pool < T > get ( Class < T > type ) { } public static < T > T obtain ( Class < T > type ) { } public static void free ( Object object ) { } public static void freeAll ( Array objects ) { if ( objects == null ) throw new IllegalArgumentException ( "objects<seq2seq4repair_space>cannot<seq2seq4repair_space>be<seq2seq4repair_space>null." ) ; for ( int i = 0 , n = objects . size ; i < n ; i ++ ) { Object object = objects . get ( i ) ; if ( object == null ) continue ; ReflectionPool pool = Pools . typePools . get ( object . getClass ( ) ) ; if ( pool == null ) <START_BUG> return ; <END_BUG> pool . free ( object ) ; } } private Pools ( ) { } }
public class SharedLibraryLoader { public static boolean isWindows = System . getProperty ( "os.name" ) . contains ( "Windows" ) ; public static boolean isLinux = System . getProperty ( "os.name" ) . contains ( "Linux" ) ; public static boolean isMac = System . getProperty ( "os.name" ) . contains ( "Mac" ) ; public static boolean isIos = false ; public static boolean isAndroid = false ; public static boolean isARM = System . getProperty ( "os.arch" ) . startsWith ( "arm" ) ; public static boolean is64Bit = System . getProperty ( "os.arch" ) . equals ( "amd64" ) ; public static String abi = ( ( System . getProperty ( "sun.arch.abi" ) ) != null ) ? System . getProperty ( "sun.arch.abi" ) : "" ; private static final HashSet < String > loadedLibraries = new HashSet ( ) ; private String nativesJar ; public SharedLibraryLoader ( ) { } public SharedLibraryLoader ( String nativesJar ) { } public String crc ( InputStream input ) { } public String mapLibraryName ( String libraryName ) { if ( SharedLibraryLoader . isWindows ) return libraryName + ( SharedLibraryLoader . is64Bit ? "64.dll" : ".dll" ) ; if ( SharedLibraryLoader . isLinux ) return ( ( "lib" + libraryName ) + ( SharedLibraryLoader . isARM ? "arm" + ( SharedLibraryLoader . abi ) : "" ) ) + ( SharedLibraryLoader . is64Bit ? "64.so" : ".so" ) ; if ( SharedLibraryLoader . isMac ) <START_BUG> return ( "lib" + libraryName ) + ( SharedLibraryLoader . is64Bit ? "64.dylib" : ".dylib" ) ; <END_BUG> return libraryName ; } public synchronized void load ( String libraryName ) { } private InputStream readFile ( String path ) { } public File extractFile ( String sourcePath , String dirName ) throws IOException { } private File getExtractedFile ( String dirName , String fileName ) { } private boolean canWrite ( File file ) { } private File extractFile ( String sourcePath , String sourceCrc , File extractedFile ) throws IOException { } private void loadFile ( String sourcePath ) { } private Throwable loadFile ( String sourcePath , String sourceCrc , File extractedFile ) { } }
public class TransportSearchDfsQueryAndFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchDfsQueryAndFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , IndicesService indicesService , TransportSearchCache transportSearchCache , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < DfsSearchResult > { private final Collection < DfsSearchResult > dfsResults = searchCache . obtainDfsResults ( ) ; private final Map < SearchShardTarget , QueryFetchSearchResult > queryFetchResults = searchCache . obtainQueryFetchResults ( ) ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( Node node , InternalSearchRequest request , SearchServiceListener < DfsSearchResult > listener ) { } @ Override protected void processFirstPhaseResult ( ShardRouting shard , DfsSearchResult result ) { } @ Override protected void moveToSecondPhase ( ) { } private void executeSecondPhase ( final AtomicInteger counter , Node node , QuerySearchRequest querySearchRequest ) { } private void finishHim ( ) { try { innerFinishHim ( ) ; } catch ( Exception e ) { <START_BUG> listener . onFailure ( new ReduceSearchPhaseException ( "query_fetch" , "" , e ) ) ; <END_BUG> } } private void innerFinishHim ( ) { } } }
public class NodeClientHeadersTests extends AbstractClientHeadersTests { private static final ActionFilters EMPTY_FILTERS = new ActionFilters ( ImmutableSet . of ( ) ) ; private ThreadPool threadPool ; @ Before public void init ( ) { } @ After public void cleanup ( ) { } @ Override protected Client buildClient ( Settings headersSettings , GenericAction [ ] testedActions ) { } private static class Actions extends HashMap < GenericAction , TransportAction > { private Actions ( Settings settings , ThreadPool threadPool , GenericAction [ ] actions ) { } } private static class InternalTransportAction extends TransportAction { private InternalTransportAction ( Settings settings , String actionName , ThreadPool threadPool ) { } @ Override protected void doExecute ( ActionRequest request , ActionListener listener ) { <START_BUG> listener . onFailure ( new InternalException ( actionName , request . getHeaders ( ) ) ) ; <END_BUG> } } }
public final class LwjglInput implements Input { public static float keyRepeatInitialTime = 0.4F ; public static float keyRepeatTime = 0.1F ; List < LwjglInput . KeyEvent > keyEvents = new ArrayList < LwjglInput . KeyEvent > ( ) ; List < LwjglInput . TouchEvent > touchEvents = new ArrayList < LwjglInput . TouchEvent > ( ) ; boolean mousePressed = false ; int mouseX ; int mouseY ; int deltaX ; int deltaY ; int pressedKeys = 0 ; boolean justTouched = false ; Set < Integer > pressedButtons = new HashSet < Integer > ( ) ; InputProcessor processor ; char lastKeyCharPressed ; float keyRepeatTimer ; long currentEventTimeStamp ; Pool < LwjglInput . KeyEvent > usedKeyEvents = new Pool < LwjglInput . KeyEvent > ( 16 , 1000 ) { protected LwjglInput . KeyEvent newObject ( ) { } } ; Pool < LwjglInput . TouchEvent > usedTouchEvents = new Pool < LwjglInput . TouchEvent > ( 16 , 1000 ) { protected LwjglInput . TouchEvent newObject ( ) { } } ; public LwjglInput ( ) { } public float getAccelerometerX ( ) { } public float getAccelerometerY ( ) { } public float getAccelerometerZ ( ) { } public void getTextInput ( final TextInputListener listener , final String title , final String text ) { } public void getPlaceholderTextInput ( final TextInputListener listener , final String title , final String placeholder ) { } public int getX ( ) { } public int getY ( ) { } public boolean isAccelerometerAvailable ( ) { } public boolean isKeyPressed ( int key ) { } public boolean isTouched ( ) { } public int getX ( int pointer ) { } public int getY ( int pointer ) { } public boolean isTouched ( int pointer ) { } public boolean supportsMultitouch ( ) { } @ Override public void setOnscreenKeyboardVisible ( boolean visible ) { } @ Override public void setCatchBackKey ( boolean catchBack ) { } void processEvents ( ) { } public static int getGdxKeyCode ( int lwjglKeyCode ) { } public static int getLwjglKeyCode ( int gdxKeyCode ) { } public void update ( ) { } private int toGdxButton ( int button ) { } void updateMouse ( ) { } void updateKeyboard ( ) { } @ Override public void setInputProcessor ( InputProcessor processor ) { } @ Override public InputProcessor getInputProcessor ( ) { } @ Override public void vibrate ( int milliseconds ) { } @ Override public boolean justTouched ( ) { } private int toLwjglButton ( int button ) { } @ Override public boolean isButtonPressed ( int button ) { } @ Override public void vibrate ( long [ ] pattern , int repeat ) { } @ Override public void cancelVibrate ( ) { } @ Override public float getAzimuth ( ) { } @ Override public float getPitch ( ) { } @ Override public float getRoll ( ) { } @ Override public boolean isPeripheralAvailable ( Peripheral peripheral ) { } @ Override public int getRotation ( ) { } @ Override public Orientation getNativeOrientation ( ) { } @ Override public void setCursorCatched ( boolean catched ) { } @ Override public boolean isCursorCatched ( ) { } @ Override public int getDeltaX ( ) { } @ Override public int getDeltaX ( int pointer ) { } @ Override public int getDeltaY ( ) { } @ Override public int getDeltaY ( int pointer ) { } @ Override public void setCursorPosition ( int x , int y ) { <START_BUG> Mouse . setCursorPosition ( x , ( y - 1 ) ) ; <END_BUG> } @ Override public void setCursorImage ( Pixmap pixmap , int xHotspot , int yHotspot ) { } @ Override public void setCatchMenuKey ( boolean catchMenu ) { } @ Override public long getCurrentEventTime ( ) { } @ Override public void getRotationMatrix ( float [ ] matrix ) { } class KeyEvent { static final int KEY_DOWN = 0 ; static final int KEY_UP = 1 ; static final int KEY_TYPED = 2 ; long timeStamp ; int type ; int keyCode ; char keyChar ; } class TouchEvent { static final int TOUCH_DOWN = 0 ; static final int TOUCH_UP = 1 ; static final int TOUCH_DRAGGED = 2 ; static final int TOUCH_SCROLLED = 3 ; static final int TOUCH_MOVED = 4 ; long timeStamp ; int type ; int x ; int y ; int scrollAmount ; int button ; int pointer ; } }
public class ChildrenBuilder extends AggregationBuilder < ChildrenBuilder > { private String childType ; public ChildrenBuilder ( String name ) { } public ChildrenBuilder childType ( String childType ) { } @ Override protected XContentBuilder internalXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; if ( ( childType ) == null ) { <START_BUG> throw new org . elasticsearch . search . builder . SearchSourceBuilderException ( ( ( "child_type<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>set<seq2seq4repair_space>on<seq2seq4repair_space>children<seq2seq4repair_space>aggregation<seq2seq4repair_space>[" + ( name ) ) + "]" ) ) ; <END_BUG> } builder . field ( "type" , childType ) ; return builder . endObject ( ) ; } }
public class NestedBuilder extends AggregationBuilder < NestedBuilder > { private String path ; public NestedBuilder ( String name ) { } public NestedBuilder path ( String path ) { } @ Override protected XContentBuilder internalXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; if ( ( path ) == null ) { <START_BUG> throw new org . elasticsearch . search . builder . SearchSourceBuilderException ( ( ( "nested<seq2seq4repair_space>path<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>set<seq2seq4repair_space>on<seq2seq4repair_space>nested<seq2seq4repair_space>aggregation<seq2seq4repair_space>[" + ( getName ( ) ) ) + "]" ) ) ; <END_BUG> } builder . field ( "path" , path ) ; return builder . endObject ( ) ; } }
public class AssigneeDialog { private CollaboratorService service ; private Map < String , User > collaborators ; private final int requestCode ; private final DialogFragmentActivity activity ; private final IRepositoryIdProvider repository ; public AssigneeDialog ( final DialogFragmentActivity activity , final int requestCode , final IRepositoryIdProvider repository , final CollaboratorService service ) { } private void load ( final String selectedAssignee ) { new com . github . mobile . ui . ProgressDialogTask < java . util . List < User > > ( activity ) { @ Override public java . util . List < User > run ( ) throws Exception { java . util . List < User > users = service . getCollaborators ( repository ) ; Map < String , User > loadedCollaborators = new TreeMap < String , User > ( String . CASE_INSENSITIVE_ORDER ) ; for ( User user : users ) loadedCollaborators . put ( user . getLogin ( ) , user ) ; collaborators = loadedCollaborators ; return users ; } @ Override protected void onSuccess ( java . util . List < User > all ) throws Exception { super . onSuccess ( all ) ; show ( selectedAssignee ) ; } @ Override protected void onException ( Exception e ) throws RuntimeException { super . onException ( e ) ; <START_BUG> ToastUtils . show ( activity , e . getMessage ( ) ) ; <END_BUG> } @ Override public void execute ( ) { dismissProgress ( ) ; showIndeterminate ( loading_collaborators ) ; super . execute ( ) ; } } . execute ( ) ; } public User getCollaborator ( String login ) { } public void show ( String selectedAssignee ) { } }
public class TwoInstanceEmbeddedSearchTests extends AbstractNodesTests { private IndicesService indicesService ; private ClusterService clusterService ; private Map < String , SearchService > nodeToSearchService ; private SearchPhaseController searchPhaseController ; @ BeforeClass public void createNodeAndInitWithData ( ) throws Exception { } @ AfterClass public void closeServers ( ) { } @ Test public void testDfsQueryThenFetch ( ) throws Exception { } @ Test public void testDfsQueryThenFetchWithSort ( ) throws Exception { } @ Test public void testQueryAndFetch ( ) { } @ Test public void testSimpleFacets ( ) { } @ Test public void testSimpleFacetsTwice ( ) { } private InternalSearchRequest searchRequest ( ShardRouting shardRouting , SearchSourceBuilder builder ) { <START_BUG> return new InternalSearchRequest ( shardRouting , builder . buildAsBytes ( ) ) ; <END_BUG> } private void index ( Client client , String id , String nameValue , int age ) { } private String source ( String id , String nameValue , int age ) { } }
public class MergeSchedulerModule extends AbstractModule { public static class MergeSchedulerSettings { public static final String TYPE = "index.merge.scheduler.type" ; } private final Settings settings ; public MergeSchedulerModule ( Settings settings ) { } @ Override protected void configure ( ) { <START_BUG> bind ( MergeSchedulerProvider . class ) . to ( settings . getAsClass ( MergeSchedulerModule . MergeSchedulerSettings . TYPE , ConcurrentMergeSchedulerProvider . class ) ) . asEagerSingleton ( ) ; <END_BUG> } }
final class JoglPixmap implements Pixmap { BufferedImage pixmap ; Composite composite ; Color color = new Color ( 0 ) ; int strokeWidth = 1 ; JoglPixmap ( int width , int height , Pixmap . Format format ) { } JoglPixmap ( BufferedImage image ) { } private int getInternalFormat ( Pixmap . Format format ) { <START_BUG> if ( ( format == ( Format . RGBA4444 ) ) || ( format == ( Format . RGBA8888 ) ) ) <END_BUG> return BufferedImage . TYPE_4BYTE_ABGR ; else return BufferedImage . TYPE_BYTE_GRAY ; } @ Override public void drawCircle ( int x , int y , int radius ) { } @ Override public void drawLine ( int x , int y , int x2 , int y2 ) { } @ Override public void drawRectangle ( int x , int y , int width , int height ) { } @ Override public void fill ( ) { } @ Override public void fillCircle ( int x , int y , int radius ) { } @ Override public void fillRectangle ( int x , int y , int width , int height ) { } @ Override public Object getNativePixmap ( ) { } @ Override public void setColor ( float r , float g , float b , float a ) { } @ Override public void setStrokeWidth ( int width ) { } @ Override public int getPixel ( int x , int y ) { } @ Override public int getHeight ( ) { } @ Override public int getWidth ( ) { } @ Override public void drawPixmap ( Pixmap pixmap , int x , int y , int srcx , int srcy , int width , int height ) { } @ Override public void dispose ( ) { } @ Override public void getPixelRow ( int [ ] pixels , int y ) { } }
public class DragAndDropTest extends GdxTest { Stage stage ; public void create ( ) { } public void render ( ) { } public void resize ( int width , int height ) { <START_BUG> stage . setViewport ( width , height , true ) ; <END_BUG> } public void dispose ( ) { } }
public class FilesTest extends GdxTest { String message = "" ; boolean success ; BitmapFont font ; SpriteBatch batch ; @ Override public void create ( ) { } private void testClasspath ( ) throws IOException { } private void testInternal ( ) throws IOException { } private void testExternal ( ) throws IOException { } private void fail ( ) { } @ Override public void render ( ) { gl . glClear ( GL_COLOR_BUFFER_BIT ) ; batch . begin ( ) ; <START_BUG> font . drawMultiLine ( batch , message , 20 , ( ( graphics . getHeight ( ) ) - 20 ) , WHITE ) ; <END_BUG> batch . end ( ) ; } @ Override public boolean needsGL20 ( ) { } }
public class FilterListFragment extends ItemListFragment < IssueFilter > implements Comparator < IssueFilter > { @ Inject private AccountDataManager cache ; @ Inject private AvatarLoader avatars ; @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; <START_BUG> ListViewUtils . configure ( getActivity ( ) , getListView ( ) , true ) ; <END_BUG> setEmptyText ( getString ( no_filters ) ) ; } @ Override public Loader < List < IssueFilter > > onCreateLoader ( int id , Bundle args ) { } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public void onResume ( ) { } @ Override protected ItemListAdapter < IssueFilter , ? extends ItemView > createAdapter ( List < IssueFilter > items ) { } @ Override public int compare ( final IssueFilter lhs , final IssueFilter rhs ) { } }
public class FsChannelSimpleTranslogTests extends AbstractSimpleTranslogTests { @ Override protected Translog create ( ) { <START_BUG> return new FsTranslog ( shardId , EMPTY_SETTINGS , new File ( "work/fs-translog" ) , false ) ; <END_BUG> } @ AfterClass public void cleanup ( ) { } }
public abstract class AbstractSimpleTranslogTests { protected final ShardId shardId = new ShardId ( new Index ( "index" ) , 1 ) ; protected Translog translog ; @ BeforeMethod public void setUp ( ) { } @ AfterMethod public void tearDown ( ) { <START_BUG> translog . close ( true ) ; <END_BUG> } protected abstract Translog create ( ) { } @ Test public void testRead ( ) throws IOException { } @ Test public void testTransientTranslog ( ) { } @ Test public void testSimpleOperations ( ) { } @ Test public void testSnapshot ( ) { } @ Test public void testSnapshotWithNewTranslog ( ) { } @ Test public void testSnapshotWithSeekForward ( ) { } private Term newUid ( String id ) { } }
public class Scene2dTest extends GdxTest { Stage stage ; private FloatAction meow = new FloatAction ( 10 , 5 ) ; private NinePatch patch ; public void create ( ) { stage = new Stage ( ) ; input . setInputProcessor ( stage ) ; final TextureRegion region = new TextureRegion ( new Texture ( "data/badlogic.jpg" ) ) ; Actor actor = new Actor ( ) { public void draw ( SpriteBatch batch , float parentAlpha ) { Color color = getColor ( ) ; batch . setColor ( color . r , color . g , color . b , parentAlpha ) ; batch . draw ( region , getX ( ) , getY ( ) , getOriginX ( ) , getOriginY ( ) , getWidth ( ) , getHeight ( ) , getScaleX ( ) , getScaleY ( ) , getRotation ( ) ) ; } } ; actor . setBounds ( 15 , 15 , 100 , 100 ) ; actor . setOrigin ( 50 , 50 ) ; stage . addActor ( actor ) ; actor . addListener ( new ActorListener ( ) { public boolean touchDown ( ActorEvent event , float x , float y , int pointer , int button ) { System . out . println ( "down" ) ; return true ; } public void touchUp ( ActorEvent event , float x , float y , int pointer , int button ) { <START_BUG> System . out . println ( "up" ) ; <END_BUG> } } ) ; Skin skin = new Skin ( files . internal ( "data/uiskin.json" ) ) ; TextButtonStyle style = skin . getStyle ( TextButtonStyle . class ) ; style . up = new EmptyDrawable ( ) { ShapeRenderer renderer = new ShapeRenderer ( ) ; public void draw ( SpriteBatch batch , float x , float y , float width , float height ) { batch . end ( ) ; renderer . setProjectionMatrix ( batch . getProjectionMatrix ( ) ) ; renderer . setTransformMatrix ( batch . getTransformMatrix ( ) ) ; renderer . begin ( Line ) ; for ( int i = 0 ; i < 25 ; i ++ ) { renderer . setColor ( MathUtils . random ( 0.3F , 1 ) , MathUtils . random ( 0.3F , 1 ) , MathUtils . random ( 0.3F , 1 ) , 1 ) ; renderer . line ( MathUtils . random ( x , ( x + width ) ) , MathUtils . random ( y , ( y + height ) ) , MathUtils . random ( x , ( x + width ) ) , MathUtils . random ( y , ( y + height ) ) ) ; } renderer . end ( ) ; batch . begin ( ) ; } } ; final TextButton button = new TextButton ( "Fancy<seq2seq4repair_space>Background" , style ) ; button . addListener ( new ActorGestureListener ( ) { public void tap ( ActorEvent event , float x , float y , int count ) { System . out . println ( "tap" ) ; button . toFront ( ) ; } public boolean longPress ( Actor actor , float x , float y ) { button . toBack ( ) ; System . out . println ( "long<seq2seq4repair_space>press" ) ; return true ; } public void pan ( ActorEvent event , float x , float y , float deltaX , float deltaY ) { event . getTarget ( ) . translate ( deltaX , deltaY ) ; if ( deltaX < 0 ) System . out . println ( ( ( ( ( ( "panning<seq2seq4repair_space>" + deltaX ) + ",<seq2seq4repair_space>" ) + deltaY ) + "<seq2seq4repair_space>" ) + ( event . getTarget ( ) ) ) ) ; } } ) ; button . setPosition ( 50 , 50 ) ; stage . addActor ( button ) ; meow . setDuration ( 2 ) ; patch = skin . getPatch ( "default-round" ) ; } public void render ( ) { } public void resize ( int width , int height ) { } public boolean needsGL20 ( ) { } public void dispose ( ) { } }
public class ImportTest extends BaseBulletTest { btBulletWorldImporter importer ; Model model ; public class MyImporter extends btBulletWorldImporter { public MyImporter ( btDynamicsWorld world ) { } @ Override public btRigidBody createRigidBody ( boolean isDynamic , float mass , Matrix4 startTransform , btCollisionShape shape , String bodyName ) { } } @ Override public void create ( ) { } @ Override public boolean tap ( float x , float y , int count , int button ) { } @ Override public void dispose ( ) { super . dispose ( ) ; importer . deleteAllData ( ) ; <START_BUG> importer . delete ( ) ; <END_BUG> importer = null ; } }
public class TimerTest extends GdxTest { @ Override public void create ( ) { new Timer ( ) . scheduleTask ( new Task ( ) { @ Override public void run ( ) { app . log ( "TimerTest" , "ping" ) ; } <START_BUG> } , 0 , 1 ) ; <END_BUG> } }
public class RestUpdateSettingsAction extends BaseRestHandler { @ Inject public RestUpdateSettingsAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { UpdateSettingsRequest updateSettingsRequest = updateSettingsRequest ( splitIndices ( request . param ( "index" ) ) ) ; updateSettingsRequest . listenerThreaded ( false ) ; ImmutableSettings . Builder updateSettings = ImmutableSettings . settingsBuilder ( ) ; String bodySettingsStr = request . content ( ) . toUtf8 ( ) ; if ( Strings . hasText ( bodySettingsStr ) ) { try { Settings buildSettings = ImmutableSettings . settingsBuilder ( ) . loadFromSource ( bodySettingsStr ) . build ( ) ; for ( Map . Entry < String , String > entry : buildSettings . getAsMap ( ) . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( key . startsWith ( "settings." ) ) { key = key . substring ( "settings." . length ( ) ) ; } updateSettings . put ( key , value ) ; } } catch ( Exception e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , RestStatus . BAD_REQUEST , new SettingsException ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>parse<seq2seq4repair_space>index<seq2seq4repair_space>settings" , e ) ) ) ; } catch ( IOException e1 ) { logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>response" , e1 ) ; } return ; } } for ( Map . Entry < String , String > entry : request . params ( ) . entrySet ( ) ) { if ( entry . getKey ( ) . equals ( "pretty" ) ) { continue ; } updateSettings . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } updateSettingsRequest . settings ( updateSettings ) ; client . admin ( ) . indices ( ) . updateSettings ( updateSettingsRequest , new ActionListener < UpdateSettingsResponse > ( ) { @ Override public void onResponse ( UpdateSettingsResponse updateSettingsResponse ) { try { org . elasticsearch . common . xcontent . XContentBuilder builder = org . elasticsearch . rest . action . support . RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) . field ( "ok" , true ) . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class BulletEntity extends BaseEntity { private static final Matrix4 tmpM = new Matrix4 ( ) ; public BulletEntity . MotionState motionState ; public btCollisionObject body ; public BulletEntity ( final Model model , final btRigidBodyConstructionInfo bodyInfo , final float x , final float y , final float z ) { } public BulletEntity ( final Model model , final btRigidBodyConstructionInfo bodyInfo , final Matrix4 transform ) { } public BulletEntity ( final Model model , final btCollisionObject body , final float x , final float y , final float z ) { } public BulletEntity ( final Model model , final btCollisionObject body , final Matrix4 transform ) { } @ Override public void dispose ( ) { if ( ( motionState ) != null ) motionState . dispose ( ) ; if ( ( body ) != null ) <START_BUG> body . delete ( ) ; <END_BUG> motionState = null ; body = null ; } static class MotionState extends btMotionState implements Disposable { private final Matrix4 transform ; public MotionState ( final Matrix4 transform ) { } @ Override public void getWorldTransform ( final Matrix4 worldTrans ) { } @ Override public void setWorldTransform ( final Matrix4 worldTrans ) { } @ Override public void dispose ( ) { delete ( ) ; } } }
public class AcknowledgedRestResponseActionListener < T extends AcknowledgedResponse > extends AbstractRestResponseActionListener < T > { public AcknowledgedRestResponseActionListener ( RestRequest request , RestChannel channel , ESLogger logger ) { } @ Override public void onResponse ( T response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) . field ( AcknowledgedRestResponseActionListener . Fields . ACKNOWLEDGED , response . isAcknowledged ( ) ) ; addCustomFields ( builder , response ) ; builder . endObject ( ) ; <START_BUG> channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <END_BUG> } catch ( IOException e ) { AcknowledgedRestResponseActionListener . onFailure ( e ) ; } } protected void addCustomFields ( XContentBuilder builder , T response ) throws IOException { } static final class Fields { static final XContentBuilderString ACKNOWLEDGED = new XContentBuilderString ( "acknowledged" ) ; } }
public abstract class Streams { public static final int BUFFER_SIZE = 4096 ; public static int copy ( File in , File out ) throws IOException { } public static void copy ( byte [ ] in , File out ) throws IOException { } public static byte [ ] copyToByteArray ( File in ) throws IOException { } public static int copy ( InputStream in , OutputStream out ) throws IOException { } public static void copy ( byte [ ] in , OutputStream out ) throws IOException { } public static byte [ ] copyToByteArray ( InputStream in ) throws IOException { } public static int copy ( Reader in , Writer out ) throws IOException { } public static void copy ( String in , Writer out ) throws IOException { } public static String copyToString ( Reader in ) throws IOException { } public static String copyToStringFromClasspath ( ClassLoader classLoader , String path ) throws IOException { InputStream is = classLoader . getResourceAsStream ( path ) ; if ( is == null ) { throw new FileNotFoundException ( ( ( ( ( "Resource<seq2seq4repair_space>[" + path ) + "]<seq2seq4repair_space>not<seq2seq4repair_space>found<seq2seq4repair_space>in<seq2seq4repair_space>classpath<seq2seq4repair_space>with<seq2seq4repair_space>class<seq2seq4repair_space>loader<seq2seq4repair_space>[" ) + classLoader ) + "]" ) ) ; } <START_BUG> return Streams . copyToString ( new InputStreamReader ( is ) ) ; <END_BUG> } public static String copyToStringFromClasspath ( String path ) throws IOException { } public static byte [ ] copyToBytesFromClasspath ( String path ) throws IOException { } }
public class Button extends Table { private Button . ButtonStyle style ; ClickListener listener ; boolean isChecked ; ButtonGroup buttonGroup ; public Button ( Skin skin ) { } public Button ( Button . ButtonStyle style ) { } public Button ( TextureRegion region ) { } public Button ( TextureRegion regionUp , TextureRegion regionDown ) { } public Button ( TextureRegion regionUp , TextureRegion regionDown , TextureRegion regionChecked ) { } public Button ( NinePatch patch ) { } public Button ( NinePatch patchUp , NinePatch patchDown ) { } public Button ( NinePatch patchUp , NinePatch patchDown , NinePatch patchChecked ) { } public Button ( Actor child , Skin skin ) { } public Button ( Actor child , Button . ButtonStyle style ) { } public Button ( Button . ButtonStyle style , String name ) { } public void setChecked ( boolean isChecked ) { } public boolean isChecked ( ) { } public void setStyle ( Button . ButtonStyle style ) { if ( style == null ) throw new IllegalArgumentException ( "style<seq2seq4repair_space>cannot<seq2seq4repair_space>be<seq2seq4repair_space>null." ) ; this . style = style ; <START_BUG> setBackground ( ( isPressed ? style . down : style . up ) ) ; <END_BUG> invalidateHierarchy ( ) ; } public Button . ButtonStyle getStyle ( ) { } public void setClickListener ( ClickListener listener ) { } public void draw ( SpriteBatch batch , float parentAlpha ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMinWidth ( ) { } public float getMinHeight ( ) { } public static class ButtonStyle { public NinePatch down ; public NinePatch up ; public NinePatch checked ; public float pressedOffsetX ; public float pressedOffsetY ; public float unpressedOffsetX ; public float unpressedOffsetY ; public ButtonStyle ( ) { } public ButtonStyle ( NinePatch up , NinePatch down , NinePatch checked , float pressedOffsetX , float pressedOffsetY , float unpressedOffsetX , float unpressedOffsetY ) { } } }
public class RestClusterStateAction extends BaseRestHandler { private final SettingsFilter settingsFilter ; @ Inject public RestClusterStateAction ( Settings settings , Client client , RestController controller , SettingsFilter settingsFilter ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { final ClusterStateRequest clusterStateRequest = Requests . clusterStateRequest ( ) ; clusterStateRequest . listenerThreaded ( false ) ; clusterStateRequest . masterNodeTimeout ( request . paramAsTime ( "master_timeout" , clusterStateRequest . masterNodeTimeout ( ) ) ) ; clusterStateRequest . filterNodes ( request . paramAsBoolean ( "filter_nodes" , clusterStateRequest . filterNodes ( ) ) ) ; clusterStateRequest . filterRoutingTable ( request . paramAsBoolean ( "filter_routing_table" , clusterStateRequest . filterRoutingTable ( ) ) ) ; clusterStateRequest . filterMetaData ( request . paramAsBoolean ( "filter_metadata" , clusterStateRequest . filterMetaData ( ) ) ) ; clusterStateRequest . filterBlocks ( request . paramAsBoolean ( "filter_blocks" , clusterStateRequest . filterBlocks ( ) ) ) ; clusterStateRequest . filteredIndices ( RestActions . splitIndices ( request . param ( "filter_indices" , null ) ) ) ; clusterStateRequest . filteredIndexTemplates ( request . paramAsStringArray ( "filter_index_templates" , EMPTY_ARRAY ) ) ; clusterStateRequest . local ( request . paramAsBoolean ( "local" , clusterStateRequest . local ( ) ) ) ; client . admin ( ) . cluster ( ) . state ( clusterStateRequest , new org . elasticsearch . action . ActionListener < ClusterStateResponse > ( ) { @ Override public void onResponse ( ClusterStateResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; builder . field ( RestClusterStateAction . Fields . CLUSTER_NAME , response . getClusterName ( ) . value ( ) ) ; response . getState ( ) . settingsFilter ( settingsFilter ) . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>handle<seq2seq4repair_space>cluster<seq2seq4repair_space>state" , e ) ; } try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } static final class Fields { static final XContentBuilderString CLUSTER_NAME = new XContentBuilderString ( "cluster_name" ) ; } }
public class RestCreateIndexAction extends BaseRestHandler { @ Inject public RestCreateIndexAction ( Settings settings , Client client , RestController controller ) { } @ SuppressWarnings ( { "unchecked" } ) @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { CreateIndexRequest createIndexRequest = new CreateIndexRequest ( request . param ( "index" ) ) ; createIndexRequest . listenerThreaded ( false ) ; if ( request . hasContent ( ) ) { try { createIndexRequest . source ( request . content ( ) ) ; } catch ( Exception e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>response" , e1 ) ; } return ; } } createIndexRequest . timeout ( request . paramAsTime ( "timeout" , timeValueSeconds ( 10 ) ) ) ; client . admin ( ) . indices ( ) . create ( createIndexRequest , new org . elasticsearch . action . ActionListener < CreateIndexResponse > ( ) { @ Override public void onResponse ( CreateIndexResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) . field ( "ok" , true ) . field ( "acknowledged" , response . isAcknowledged ( ) ) . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public abstract class Camera { public final Vector3 position = new Vector3 ( ) ; public final Vector3 direction = new Vector3 ( 0 , 0 , ( - 1 ) ) ; public final Vector3 up = new Vector3 ( 0 , 1 , 0 ) ; public final Matrix4 projection = new Matrix4 ( ) ; public final Matrix4 view = new Matrix4 ( ) ; public final Matrix4 combined = new Matrix4 ( ) ; public final Matrix4 invProjectionView = new Matrix4 ( ) ; public float near = 1 ; public float far = 100 ; public float viewportWidth = 0 ; public float viewportHeight = 0 ; public final Frustum frustum = new Frustum ( ) ; private final Matrix4 tmpMat = new Matrix4 ( ) ; private final Vector3 tmpVec = new Vector3 ( ) ; public abstract void update ( ) { } public abstract void update ( boolean updateFrustum ) { } public void apply ( GL10 gl ) { } public void lookAt ( float x , float y , float z ) { } final Vector3 right = new Vector3 ( ) ; public void normalizeUp ( ) { } public void rotate ( float angle , float axisX , float axisY , float axisZ ) { } public void rotate ( Vector3 axis , float angle ) { } public void rotateAround ( Vector3 point , Vector3 axis , float angle ) { tmpVec . set ( point ) ; tmpVec . sub ( position ) ; translate ( tmpVec ) ; rotate ( axis , angle ) ; tmpVec . rotate ( axis , angle ) ; <START_BUG> translate ( ( - ( tmpVec . x ) ) , ( - ( tmpVec . y ) ) , ( - ( tmpVec . z ) ) ) ; <END_BUG> } public void translate ( float x , float y , float z ) { } public void translate ( Vector3 vec ) { } public void unproject ( Vector3 vec , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } public void unproject ( Vector3 vec ) { } public void project ( Vector3 vec ) { } public void project ( Vector3 vec , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } final Ray ray = new Ray ( new Vector3 ( ) , new Vector3 ( ) ) ; public Ray getPickRay ( float x , float y , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } public Ray getPickRay ( float x , float y ) { } }
public class Json { private static final boolean debug = false ; private JsonWriter writer ; private String typeName = "class" ; private boolean usePrototypes = true ; private OutputType outputType ; private final ObjectMap < Class , ObjectMap < String , Json . FieldMetadata > > typeToFields = new ObjectMap ( ) ; private final ObjectMap < String , Class > tagToClass = new ObjectMap ( ) ; private final ObjectMap < Class , String > classToTag = new ObjectMap ( ) ; private final ObjectMap < Class , Json . Serializer > classToSerializer = new ObjectMap ( ) ; private final ObjectMap < Class , Object [ ] > classToDefaultValues = new ObjectMap ( ) ; private Json . Serializer defaultSerializer ; private boolean ignoreUnknownFields ; public Json ( ) { } public Json ( OutputType outputType ) { } public void setIgnoreUnknownFields ( boolean ignoreUnknownFields ) { } public void setOutputType ( OutputType outputType ) { } public void addClassTag ( String tag , Class type ) { } public Class getClass ( String tag ) { } public String getTag ( Class type ) { } public void setTypeName ( String typeName ) { } public void setDefaultSerializer ( Json . Serializer defaultSerializer ) { } public < T > void setSerializer ( Class < T > type , Json . Serializer < T > serializer ) { } public < T > Json . Serializer < T > getSerializer ( Class < T > type ) { } public void setUsePrototypes ( boolean usePrototypes ) { } public void setElementType ( Class type , String fieldName , Class elementType ) { } private ObjectMap < String , Json . FieldMetadata > cacheFields ( Class type ) { } public String toJson ( Object object ) { } public String toJson ( Object object , Class knownType ) { } public String toJson ( Object object , Class knownType , Class elementType ) { } public void toJson ( Object object , FileHandle file ) { } public void toJson ( Object object , Class knownType , FileHandle file ) { } public void toJson ( Object object , Class knownType , Class elementType , FileHandle file ) { Writer writer = null ; try { <START_BUG> writer = file . writer ( false , "UTF-8" ) ; <END_BUG> toJson ( object , knownType , elementType , writer ) ; } catch ( Exception ex ) { throw new SerializationException ( ( "Error<seq2seq4repair_space>writing<seq2seq4repair_space>file:<seq2seq4repair_space>" + file ) , ex ) ; } finally { StreamUtils . closeQuietly ( writer ) ; } } public void toJson ( Object object , Writer writer ) { } public void toJson ( Object object , Class knownType , Writer writer ) { } public void toJson ( Object object , Class knownType , Class elementType , Writer writer ) { } public void setWriter ( Writer writer ) { } public JsonWriter getWriter ( ) { } public void writeFields ( Object object ) { } private Object [ ] getDefaultValues ( Class type ) { } public void writeField ( Object object , String name ) { } public void writeField ( Object object , String name , Class elementType ) { } public void writeField ( Object object , String fieldName , String jsonName ) { } public void writeField ( Object object , String fieldName , String jsonName , Class elementType ) { } public void writeValue ( String name , Object value ) { } public void writeValue ( String name , Object value , Class knownType ) { } public void writeValue ( String name , Object value , Class knownType , Class elementType ) { } public void writeValue ( Object value ) { } public void writeValue ( Object value , Class knownType ) { } public void writeValue ( Object value , Class knownType , Class elementType ) { } public void writeObjectStart ( String name ) { } public void writeObjectStart ( String name , Class actualType , Class knownType ) { } public void writeObjectStart ( ) { } public void writeObjectStart ( Class actualType , Class knownType ) { } public void writeObjectEnd ( ) { } public void writeArrayStart ( String name ) { } public void writeArrayStart ( ) { } public void writeArrayEnd ( ) { } public void writeType ( Class type ) { } public < T > T fromJson ( Class < T > type , Reader reader ) { } public < T > T fromJson ( Class < T > type , Class elementType , Reader reader ) { } public < T > T fromJson ( Class < T > type , InputStream input ) { } public < T > T fromJson ( Class < T > type , Class elementType , InputStream input ) { } public < T > T fromJson ( Class < T > type , FileHandle file ) { } public < T > T fromJson ( Class < T > type , Class elementType , FileHandle file ) { } public < T > T fromJson ( Class < T > type , char [ ] data , int offset , int length ) { } public < T > T fromJson ( Class < T > type , Class elementType , char [ ] data , int offset , int length ) { } public < T > T fromJson ( Class < T > type , String json ) { } public < T > T fromJson ( Class < T > type , Class elementType , String json ) { } public void readField ( Object object , String name , JsonValue jsonData ) { } public void readField ( Object object , String name , Class elementType , JsonValue jsonData ) { }
public class FloatArray { public float [ ] items ; public int size ; public boolean ordered ; public FloatArray ( ) { } public FloatArray ( int capacity ) { } public FloatArray ( boolean ordered , int capacity ) { } public FloatArray ( FloatArray array ) { } public FloatArray ( float [ ] array ) { } public FloatArray ( boolean ordered , float [ ] array , int startIndex , int count ) { } public void add ( float value ) { } public void addAll ( FloatArray array ) { } public void addAll ( FloatArray array , int offset , int length ) { } public void addAll ( float [ ] array ) { } public void addAll ( float [ ] array , int offset , int length ) { float [ ] items = this . items ; <START_BUG> int sizeNeeded = ( size ) + length ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public float get ( int index ) { } public void set ( int index , float value ) { } public void insert ( int index , float value ) { } public void swap ( int first , int second ) { } public boolean contains ( float value ) { } public int indexOf ( float value ) { } public int lastIndexOf ( char value ) { } public boolean removeValue ( float value ) { } public float removeIndex ( int index ) { } public boolean removeAll ( FloatArray array ) { } public float pop ( ) { } public float peek ( ) { } public float first ( ) { } public void clear ( ) { } public void shrink ( ) { } public float [ ] ensureCapacity ( int additionalCapacity ) { } protected float [ ] resize ( int newSize ) { } public void sort ( ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public float random ( ) { } public float [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class UidFieldMapper extends AbstractFieldMapper < Uid > implements InternalMapper , RootMapper { public static final String NAME = "_uid" . intern ( ) ; public static final String CONTENT_TYPE = "_uid" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = UidFieldMapper . NAME ; public static final FieldType FIELD_TYPE = new FieldType ( AbstractFieldMapper . Defaults . FIELD_TYPE ) ; public static final FieldType NESTED_FIELD_TYPE = new FieldType ( AbstractFieldMapper . Defaults . FIELD_TYPE ) ; } public static class Builder extends Mapper . Builder < UidFieldMapper . Builder , UidFieldMapper > { protected String indexName ; protected PostingsFormatProvider postingsFormat ; public Builder ( ) { } @ Override public UidFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private ThreadLocal < UidField > fieldCache = new ThreadLocal < UidField > ( ) { @ Override protected UidField initialValue ( ) { } } ; public UidFieldMapper ( ) { } protected UidFieldMapper ( String name ) { } protected UidFieldMapper ( String name , String indexName , PostingsFormatProvider postingsFormat ) { } @ Override public FieldType defaultFieldType ( ) { } @ Override public FieldDataType fieldDataType2 ( ) { <START_BUG> return new FieldDataType ( "string" ) ; <END_BUG> } @ Override protected String defaultPostingFormat ( ) { } @ Override public void preParse ( ParseContext context ) throws IOException { } @ Override public void postParse ( ParseContext context ) throws IOException { } @ Override public void parse ( ParseContext context ) throws IOException { } @ Override public void validate ( ParseContext context ) throws MapperParsingException { } @ Override public boolean includeInObject ( ) { } @ Override protected Field parseCreateField ( ParseContext context ) throws IOException { } @ Override public Uid value ( Object value ) { } public Term term ( String type , String id ) { } public Term term ( String uid ) { } @ Override public void close ( ) { } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public final class FloatMesh implements Mesh { private final int maxVertices ; private final int maxIndices ; private int vertexSize ; private int colorsOffset ; private int normalsOffset ; private int texCoordsOffset ; private int vertexSizeFloat ; private final int coordsSize ; private final int colorsSize ; private final int texCoordsSize ; private final boolean hasColors ; private final boolean hasNormals ; private final boolean hasTexCoords ; private final int numTexCoords ; private final float [ ] verticesArray ; private final FloatBuffer verticesBuffer ; private final short [ ] indicesArray ; private final ShortBuffer indicesBuffer ; public FloatMesh ( int maxVertices , int coordsSize , boolean hasColors , boolean hasNormals , boolean hasTexCoords , int numTexCoords , int texCoordSize , boolean hasIndices , int maxIndices ) { } public int getColorsOffset ( ) { } public int getNormalsOffset ( ) { } public int getTexCoordsOffset ( ) { } public int getCoordsSize ( ) { } public boolean hasColors ( ) { } public int getColorsSize ( ) { } public boolean hasNormals ( ) { } public boolean hasTexCoords ( ) { } public boolean hasIndices ( ) { } public int getTexCoordsSize ( ) { } public int getNumTexCoords ( ) { } public int getNumVertices ( ) { } public int getNumIndices ( ) { } public int getVertexSize ( ) { } public FloatBuffer getVerticesBuffer ( ) { } public float [ ] getVerticesArray ( ) { } public ShortBuffer getIndicesBuffer ( ) { } public short [ ] getIndicesArray ( ) { } public void setVertices ( float [ ] vertices ) { } public void setIndices ( short [ ] indices ) { } public void updateVertexBufferFromArray ( int numVertices ) { <START_BUG> verticesBuffer . position ( 0 ) ; <END_BUG> verticesBuffer . put ( verticesArray , 0 , ( ( numVertices * ( vertexSize ) ) / 4 ) ) ; verticesBuffer . flip ( ) ; } public void updateIndexBufferFromArray ( int numIndices ) { } public static void main ( String [ ] argv ) { } @ Override public int getMaximumVertices ( ) { } }
class AccountAuthenticator extends AbstractAccountAuthenticator { private Context context ; public AccountAuthenticator ( final Context context ) { } @ Override public Bundle addAccount ( final AccountAuthenticatorResponse response , final String accountType , final String authTokenType , String [ ] requiredFeatures , Bundle options ) throws NetworkErrorException { } @ Override public Bundle confirmCredentials ( AccountAuthenticatorResponse response , Account account , Bundle options ) { } @ Override public Bundle editProperties ( AccountAuthenticatorResponse response , String accountType ) { } @ Override public Bundle getAuthToken ( AccountAuthenticatorResponse response , Account account , String authTokenType , Bundle options ) throws NetworkErrorException { } @ Override public String getAuthTokenLabel ( String authTokenType ) { <START_BUG> if ( authTokenType . equals ( AccountConstants . ACCOUNT_TYPE ) ) <END_BUG> return authTokenType ; return null ; } @ Override public Bundle hasFeatures ( AccountAuthenticatorResponse response , Account account , String [ ] features ) throws NetworkErrorException { } @ Override public Bundle updateCredentials ( AccountAuthenticatorResponse response , Account account , String authTokenType , Bundle options ) { } }
public class RepoBrowseActivity extends RoboActivity { public static Intent createIntent ( Context context , User user ) { } private class RepoAdapter extends ArrayAdapter < Repository > { public RepoAdapter ( Repository [ ] objects ) { } @ Override public View getView ( int position , View convertView , ViewGroup parent ) { } } @ InjectView ( id . lv_repos ) private ListView repoList ; @ Inject private RepositoryService repoService ; private User user ; protected void onCreate ( Bundle savedInstanceState ) { } private void loadRepos ( ) { new roboguice . util . RoboAsyncTask < Repository [ ] > ( this ) { public Repository [ ] call ( ) throws Exception { java . util . List < Repository > repoList ; if ( ! ( "User" . equals ( user . getType ( ) ) ) ) repoList = repoService . getOrgRepositories ( user . getLogin ( ) ) ; else if ( user . getLogin ( ) . equals ( repoService . getClient ( ) . getUser ( ) ) ) repoList = repoService . getRepositories ( ) ; else repoList = repoService . getRepositories ( user . getLogin ( ) ) ; Repository [ ] repos = repoList . toArray ( new Repository [ repoList . size ( ) ] ) ; java . util . Arrays . sort ( repos , new java . util . Comparator < Repository > ( ) { public int compare ( Repository r1 , Repository r2 ) { <START_BUG> return r2 . getUpdatedAt ( ) . compareTo ( r1 . getUpdatedAt ( ) ) ; <END_BUG> } } ) ; return repos ; } protected void onSuccess ( Repository [ ] repos ) throws Exception { repoList . setAdapter ( new RepoBrowseActivity . RepoAdapter ( repos ) ) ; } } . execute ( ) ; } }
public class TransportFlushAction extends TransportBroadcastOperationAction < FlushRequest , FlushResponse , ShardFlushRequest , ShardFlushResponse > { @ Inject public TransportFlushAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected FlushRequest newRequest ( ) { } @ Override protected boolean ignoreNonActiveExceptions ( ) { } @ Override protected FlushResponse newResponse ( FlushRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardFlushRequest newShardRequest ( ) { } @ Override protected ShardFlushRequest newShardRequest ( ShardRouting shard , FlushRequest request ) { } @ Override protected ShardFlushResponse newShardResponse ( ) { } @ Override protected ShardFlushResponse shardOperation ( ShardFlushRequest request ) throws ElasticSearchException { IndexShard indexShard = indicesService . indexServiceSafe ( request . index ( ) ) . shardSafe ( request . shardId ( ) ) ; <START_BUG> indexShard . flush ( new Engine . Flush ( ) . refresh ( request . refresh ( ) ) ) ; <END_BUG> return new ShardFlushResponse ( request . index ( ) , request . shardId ( ) ) ; } @ Override protected GroupShardsIterator shards ( FlushRequest request , ClusterState clusterState ) { } }
public class LongArray { public long [ ] items ; public int size ; public boolean ordered ; public LongArray ( ) { } public LongArray ( int capacity ) { } public LongArray ( boolean ordered , int capacity ) { } public LongArray ( LongArray array ) { } public LongArray ( long [ ] array ) { } public LongArray ( boolean ordered , long [ ] array , int startIndex , int count ) { } public void add ( long value ) { } public void addAll ( LongArray array ) { } public void addAll ( LongArray array , int offset , int length ) { } public void addAll ( long [ ] array ) { } public void addAll ( long [ ] array , int offset , int length ) { long [ ] items = this . items ; <START_BUG> int sizeNeeded = ( ( size ) + length ) - offset ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public long get ( int index ) { } public void set ( int index , long value ) { } public void insert ( int index , long value ) { } public void swap ( int first , int second ) { } public boolean contains ( long value ) { } public int indexOf ( long value ) { } public int lastIndexOf ( char value ) { } public boolean removeValue ( long value ) { } public long removeIndex ( int index ) { } public boolean removeAll ( LongArray array ) { } public long pop ( ) { } public long peek ( ) { } public long first ( ) { } public void clear ( ) { } public void shrink ( ) { } public long [ ] ensureCapacity ( int additionalCapacity ) { } protected long [ ] resize ( int newSize ) { } public void sort ( ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public long random ( ) { } public long [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class XContentIndexQueryParser extends AbstractIndexComponent implements IndexQueryParser { public static final class Defaults { public static final String QUERY_PREFIX = "index.queryparser.query" ; public static final String FILTER_PREFIX = "index.queryparser.filter" ; } private ThreadLocal < ThreadLocals . CleanableValue < QueryParseContext > > cache = new ThreadLocal < ThreadLocals . CleanableValue < QueryParseContext > > ( ) { @ Override protected ThreadLocals . CleanableValue < QueryParseContext > initialValue ( ) { } } ; private final String name ; final ScriptService scriptService ; final MapperService mapperService ; final SimilarityService similarityService ; final IndexCache indexCache ; final IndexEngine indexEngine ; private final Map < String , XContentQueryParser > queryParsers ; private final Map < String , XContentFilterParser > filterParsers ; @ Inject public XContentIndexQueryParser ( Index index , @ IndexSettings Settings indexSettings , ScriptService scriptService , MapperService mapperService , IndexCache indexCache , IndexEngine indexEngine , @ Nullable SimilarityService similarityService , @ Nullable Map < String , XContentQueryParserFactory > namedQueryParsers , @ Nullable Map < String , XContentFilterParserFactory > namedFilterParsers , @ Assisted String name , @ Assisted @ Nullable Settings settings ) { } @ Override public String name ( ) { } public XContentQueryParser queryParser ( String name ) { } public XContentFilterParser filterParser ( String name ) { } @ Override public ParsedQuery parse ( QueryBuilder queryBuilder ) throws ElasticSearchException { } @ Override public ParsedQuery parse ( byte [ ] source ) throws ElasticSearchException { } @ Override public ParsedQuery parse ( byte [ ] source , int offset , int length ) throws ElasticSearchException { } @ Override public ParsedQuery parse ( String source ) throws QueryParsingException { } public ParsedQuery parse ( XContentParser parser ) { } public Filter parseInnerFilter ( XContentParser parser ) throws IOException { } public Query parseInnerQuery ( XContentParser parser ) throws IOException { } private ParsedQuery parse ( QueryParseContext parseContext , XContentParser parser ) throws IOException , QueryParsingException { parseContext . reset ( parser ) ; Query query = parseContext . parseInnerQuery ( ) ; <START_BUG> return new ParsedQuery ( query , parseContext . copyNamedFilters ( ) , parseContext . copyScopePhases ( ) ) ; <END_BUG> } private void add ( Map < String , XContentFilterParser > map , XContentFilterParser filterParser ) { } private void add ( Map < String , XContentQueryParser > map , XContentQueryParser queryParser ) { } }
public class ParticleEffectPool extends Pool < ParticleEffectPool . PooledEffect > { private final ParticleEffect effect ; public ParticleEffectPool ( ParticleEffect effect , int initialCapacity , int max ) { } protected ParticleEffectPool . PooledEffect newObject ( ) { } public ParticleEffectPool . PooledEffect obtain ( ) { ParticleEffectPool . PooledEffect effect = super . obtain ( ) ; <START_BUG> effect . reset ( ) ; <END_BUG> return effect ; } public class PooledEffect extends ParticleEffect { PooledEffect ( ParticleEffect effect ) { } public void free ( ) { } } }
public class AndroidMultiTouchHandler implements AndroidTouchHandler { public void onTouch ( MotionEvent event , AndroidInput input ) { } private void postTouchEvent ( AndroidInput input , int type , int x , int y , int pointer ) { synchronized ( input ) { TouchEvent event = input . freeTouchEvents . newObject ( ) ; <START_BUG> event . pointer = 0 ; <END_BUG> event . x = x ; event . y = y ; event . type = type ; input . touchEvents . add ( event ) ; } } public boolean supportsMultitouch ( AndroidApplication activity ) { } }
public class TransportTypesExistsAction extends TransportMasterNodeReadOperationAction < TypesExistsRequest , TypesExistsResponse > { @ Inject public TransportTypesExistsAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected TypesExistsRequest newRequest ( ) { } @ Override protected TypesExistsResponse newResponse ( ) { } @ Override protected ClusterBlockException checkBlock ( TypesExistsRequest request , ClusterState state ) { <START_BUG> return state . blocks ( ) . indicesBlockedException ( METADATA , state . metaData ( ) . concreteIndices ( request . indicesOptions ( ) , request . indices ( ) ) ) ; <END_BUG> } @ Override protected void masterOperation ( final TypesExistsRequest request , final ClusterState state , final ActionListener < TypesExistsResponse > listener ) throws ElasticsearchException { } }
public class PythonScriptEngineService extends AbstractComponent implements ScriptEngineService { private final PythonInterpreter interp ; @ Inject public PythonScriptEngineService ( Settings settings ) { } @ Override public String [ ] types ( ) { <START_BUG> return new String [ ] { "python" } ; <END_BUG> } @ Override public String [ ] extensions ( ) { } @ Override public Object compile ( String script ) { } @ Override public ExecutableScript executable ( Object compiledScript , Map < String , Object > vars ) { } @ Override public Object execute ( Object compiledScript , Map < String , Object > vars ) { } @ Override public Object unwrap ( Object value ) { } @ Override public void close ( ) { } public class PythonExecutableScript implements ExecutableScript { private final PyCode code ; private final PyStringMap pyVars ; public PythonExecutableScript ( PyCode code , Map < String , Object > vars ) { } @ Override public Object run ( ) { } @ Override public Object run ( Map < String , Object > vars ) { } @ Override public Object unwrap ( Object value ) { } } public static Object unwrapValue ( Object value ) { } }
public class Window extends Table { private Window . WindowStyle style ; private String title ; private BitmapFontCache titleCache ; boolean isMovable = true ; boolean isModal ; final Vector2 dragOffset = new Vector2 ( ) ; boolean dragging ; private int titleAlignment = Align . center ; public Window ( String title , Skin skin ) { } public Window ( String title , Skin skin , String styleName ) { } public Window ( String title , Window . WindowStyle style ) { } public void setStyle ( Window . WindowStyle style ) { } public Window . WindowStyle getStyle ( ) { } protected void drawBackground ( SpriteBatch batch , float parentAlpha ) { } public Actor hit ( float x , float y , boolean touchable ) { Actor hit = super . hit ( x , y , touchable ) ; <START_BUG> if ( ( hit == null ) && ( isModal ) ) <END_BUG> return this ; return hit ; } public void setTitle ( String title ) { } public String getTitle ( ) { } public void setTitleAlignment ( int titleAlignment ) { } public void setMovable ( boolean isMovable ) { } public void setModal ( boolean isModal ) { } public boolean isDragging ( ) { } public float getPrefWidth ( ) { } public static class WindowStyle { public Drawable background ; public BitmapFont titleFont ; public Color titleFontColor = new Color ( 1 , 1 , 1 , 1 ) ; public Drawable stageBackground ; public WindowStyle ( ) { } public WindowStyle ( BitmapFont titleFont , Color titleFontColor , Drawable background ) { } public WindowStyle ( Window . WindowStyle style ) { } } }
@ ClusterScope ( scope = Scope . TEST , numDataNodes = 0 , numClientNodes = 0 , transportClientRatio = 0 ) public class RecoveryPercolatorTests extends ElasticsearchIntegrationTest { @ Override protected int numberOfShards ( ) { } @ Override protected Settings nodeSettings ( int nodeOrdinal ) { <START_BUG> return builder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( "gateway.type" , "local" ) . build ( ) ; <END_BUG> } @ Test @ Slow public void testRestartNodePercolator1 ( ) throws Exception { } @ Test @ Slow public void testRestartNodePercolator2 ( ) throws Exception { } @ Test @ Slow @ TestLogging ( "index.percolator:TRACE,percolator:TRACE" ) public void testLoadingPercolateQueriesDuringCloseAndOpen ( ) throws Exception { } @ Test @ Slow public void testSinglePercolator_recovery ( ) throws Exception { } @ Test @ Slow public void testMultiPercolator_recovery ( ) throws Exception { } private void percolatorRecovery ( final boolean multiPercolate ) throws Exception { } }
public class OrgViewHolder implements ViewHolder < User > { private final AvatarHelper avatarHelper ; private final TextView nameText ; private final ImageView avatarView ; public OrgViewHolder ( final View view , final AvatarHelper avatarHelper ) { } @ Override <START_BUG> public void updateViewFor ( User user ) { <END_BUG> nameText . setText ( user . getLogin ( ) ) ; avatarView . setBackgroundDrawable ( null ) ; avatarHelper . bind ( avatarView , user ) ; } }
public abstract class BaseRestHandler extends AbstractComponent implements RestHandler { private static Set < String > usefulHeaders = Sets . newCopyOnWriteArraySet ( ) ; public static void addUsefulHeaders ( String ... headers ) { } static Set < String > usefulHeaders ( ) { } private final Client client ; protected BaseRestHandler ( Settings settings , Client client ) { } @ Override public final void handleRequest ( RestRequest request , RestChannel channel ) throws Exception { <START_BUG> handleRequest ( request , channel , ( ( BaseRestHandler . usefulHeaders . size ( ) ) == 0 ? client : new BaseRestHandler . HeadersAndContextCopyClient ( client , request , BaseRestHandler . usefulHeaders ) ) ) ; <END_BUG> } protected abstract void handleRequest ( RestRequest request , RestChannel channel , Client client ) throws Exception { } static final class HeadersAndContextCopyClient extends FilterClient { private final RestRequest restRequest ; private final BaseRestHandler . HeadersAndContextCopyClient . IndicesAdmin indicesAdmin ; private final BaseRestHandler . HeadersAndContextCopyClient . ClusterAdmin clusterAdmin ; private final Set < String > headers ; HeadersAndContextCopyClient ( Client in , RestRequest restRequest , Set < String > headers ) { } private static void copyHeadersAndContext ( ActionRequest actionRequest , RestRequest restRequest , Set < String > headers ) { } @ Override public < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder , Client > > ActionFuture < Response > execute ( Action < Request , Response , RequestBuilder , Client > action , Request request ) { } @ Override public < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder , Client > > void execute ( Action < Request , Response , RequestBuilder , Client > action , Request request , ActionListener < Response > listener ) { } @ Override public ClusterAdminClient cluster ( ) { } @ Override public IndicesAdminClient indices ( ) { } private static final class ClusterAdmin extends FilterClient . ClusterAdmin { private final RestRequest restRequest ; private final Set < String > headers ; private ClusterAdmin ( ClusterAdminClient in , RestRequest restRequest , Set < String > headers ) { } @ Override public < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder , ClusterAdminClient > > ActionFuture < Response > execute ( Action < Request , Response , RequestBuilder , ClusterAdminClient > action , Request request ) { } @ Override public < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder , ClusterAdminClient > > void execute ( Action < Request , Response , RequestBuilder , ClusterAdminClient > action , Request request , ActionListener < Response > listener ) { } } private final class IndicesAdmin extends FilterClient . IndicesAdmin { private final RestRequest restRequest ; private final Set < String > headers ; private IndicesAdmin ( IndicesAdminClient in , RestRequest restRequest , Set < String > headers ) { } @ Override public < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder , IndicesAdminClient > > ActionFuture < Response > execute ( Action < Request , Response , RequestBuilder , IndicesAdminClient > action , Request request ) { } @ Override public < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder , IndicesAdminClient > > void execute ( Action < Request , Response , RequestBuilder , IndicesAdminClient > action , Request request , ActionListener < Response > listener ) { } } } }
public class IssuesFragment extends ListLoadingFragment < Issue > { private static final String TAG = "IssuesF" ; @ Inject IssueService issueService ; @ Override protected ListAdapter adapterFor ( List < Issue > issues ) { } @ Override public Loader < List < Issue > > onCreateLoader ( int i , Bundle bundle ) { return new com . github . mobile . android . AsyncLoader < List < Issue > > ( getActivity ( ) ) { @ Override public List < Issue > loadInBackground ( ) { Log . i ( IssuesFragment . TAG , "started<seq2seq4repair_space>loadInBackground" ) ; try { <START_BUG> return issueService . getIssues ( "rtyley" , "agit" , Collections . < String , String > emptyMap ( ) ) ; <END_BUG> } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } ; } }
public final class DefaultTextureBinder implements TextureBinder { public static final int ROUNDROBIN = 0 ; public static final int WEIGHTED = 1 ; public static final int MAX_GLES_UNITS = 32 ; private final int offset ; private final int count ; private final int reuseWeight ; private final TextureDescriptor [ ] textures ; private final int [ ] weights ; private final int method ; private boolean reused ; private int reuseCount = 0 ; private int bindCount = 0 ; public DefaultTextureBinder ( final int method ) { } public DefaultTextureBinder ( final int method , final int offset ) { } public DefaultTextureBinder ( final int method , final int offset , final int count ) { } public DefaultTextureBinder ( final int method , final int offset , final int count , final int reuseWeight ) { } private static int getMaxTextureUnits ( ) { } @ Override public void begin ( ) { for ( int i = 0 ; i < ( count ) ; i ++ ) { <START_BUG> textures [ i ] . texture = null ; <END_BUG> if ( ( weights ) != null ) weights [ i ] = 0 ; } } @ Override public void end ( ) { } @ Override public final int bind ( final TextureDescriptor textureDesc ) { } private final int bindTexture ( final TextureDescriptor textureDesc , final boolean rebind ) { } private int currentTexture = 0 ; private final int bindTextureRoundRobin ( final Texture texture ) { } private final int bindTextureWeighted ( final Texture texture ) { } @ Override public final int getBindCount ( ) { } @ Override public final int getReuseCount ( ) { } @ Override public final void resetCounts ( ) { } }
public class OrganizationRepositories implements PersistableResource < Repository > { public interface Factory { OrganizationRepositories under ( User org ) { } } private final User org ; private final RepositoryService repos ; private final WatcherService watcher ; private final Provider < GitHubAccount > accountProvider ; @ Inject public OrganizationRepositories ( @ Assisted User orgs , RepositoryService repos , WatcherService watcher , Provider < GitHubAccount > accountProvider ) { } @ Override public Cursor getCursor ( SQLiteDatabase readableDatabase ) { } @ Override public Repository loadFrom ( Cursor cursor ) { } @ Override public void store ( SQLiteDatabase db , List < Repository > repos ) { } @ Override public List < Repository > request ( ) throws IOException { } private boolean isAuthenticatedUser ( ) { <START_BUG> return org . getLogin ( ) . equals ( accountProvider . get ( ) . username ) ; <END_BUG> } @ Override public String toString ( ) { } }
@ Ignore @ AbstractRandomizedTest . IntegrationTests public abstract class ElasticsearchIntegrationTest extends ElasticsearchTestCase { private static TestCluster GLOBAL_CLUSTER ; public static final String TESTS_CLIENT_RATIO = "tests.client.ratio" ; public static final String INDEX_SEED_SETTING = "index.tests.seed" ; private static TestCluster currentCluster ; private static final double TRANSPORT_CLIENT_RATIO = ElasticsearchIntegrationTest . transportClientRatio ( ) ; private static final Map < Class < ? > , TestCluster > clusters = new IdentityHashMap < Class < ? > , TestCluster > ( ) ; @ BeforeClass public static final void beforeClass ( ) throws Exception { } @ Before public final void before ( ) throws IOException { } public TestCluster buildAndPutCluster ( ElasticsearchIntegrationTest . Scope currentClusterScope , boolean createIfExists ) throws IOException { } private void clearClusters ( ) throws IOException { } @ After public final void after ( ) throws IOException { } public static TestCluster cluster ( ) { } public ClusterService clusterService ( ) { } public static Client client ( ) { } private static void randomIndexTemplate ( ) { } private static Builder setRandomNormsLoading ( ImmutableSettings . Builder builder ) { } private static Builder setRandomMerge ( Random random , ImmutableSettings . Builder builder ) { } public static Iterable < Client > clients ( ) { } protected static final int DEFAULT_MIN_NUM_SHARDS = 1 ; protected static final int DEFAULT_MAX_NUM_SHARDS = 10 ; protected int minimumNumberOfShards ( ) { } protected int maximumNumberOfShards ( ) { } protected int numberOfShards ( ) { } protected int minimumNumberOfReplicas ( ) { } protected int maximumNumberOfReplicas ( ) { } protected int numberOfReplicas ( ) { } public Settings indexSettings ( ) { } private static void ensureEstimatedStats ( ) { } public static void wipeIndices ( String ... indices ) { } public static void wipeTemplates ( String ... templates ) { } public static void wipeRepositories ( String ... repositories ) { } public final void createIndex ( String ... names ) { } public final CreateIndexRequestBuilder prepareCreate ( String index ) { } public final CreateIndexRequestBuilder prepareCreate ( String index , int numNodes ) { } public CreateIndexRequestBuilder prepareCreate ( String index , int numNodes , ImmutableSettings . Builder settingsBuilder ) { } private Builder getExcludeSettings ( String index , int num , ImmutableSettings . Builder builder ) { } public void allowNodes ( String index , int n ) { } public ClusterHealthStatus ensureGreen ( String ... indices ) { } public ClusterHealthStatus waitForRelocation ( ) { } public ClusterHealthStatus waitForRelocation ( ClusterHealthStatus status ) { } public ClusterHealthStatus ensureYellow ( String ... indices ) { } protected ClusterHealthStatus ensureSearchable ( String ... indices ) { } protected final IndexResponse index ( String index , String type , XContentBuilder source ) { } protected final IndexResponse index ( String index , String type , String id , Map < String , Object > source ) { } protected final GetResponse get ( String index , String type , String id ) { } protected final IndexResponse index ( String index , String type , String id , XContentBuilder source ) { } protected final IndexResponse index ( String index , String type , String id , Object ... source ) { } protected final RefreshResponse refresh ( ) { } protected final void flushAndRefresh ( ) { } protected final FlushResponse flush ( ) { } private FlushResponse flush ( boolean ignoreNotAllowed ) { } protected OptimizeResponse optimize ( ) { waitForRelocation ( ) ; <START_BUG> OptimizeResponse actionGet = ElasticsearchIntegrationTest . client ( ) . admin ( ) . indices ( ) . prepareOptimize ( ) . execute ( ) . actionGet ( ) ; <END_BUG> assertNoFailures ( actionGet ) ; return actionGet ; } protected boolean indexExists ( String index ) { } protected AdminClient admin ( ) { } public void indexRandom ( boolean forceRefresh , IndexRequestBuilder ... builders ) throws InterruptedException , ExecutionException { } public void indexRandom ( boolean forceRefresh , List < IndexRequestBuilder > builders ) throws InterruptedException , ExecutionException { } private static CountDownLatch newLatch ( List < CountDownLatch > latches ) { } private class LatchedActionListener < Response > implements ActionListener < Response > { private final CountDownLatch latch ; public LatchedActionListener ( CountDownLatch latch ) { } @ Override public final void onResponse ( Response response ) { } @ Override public final void onFailure ( Throwable t ) { } protected void addError ( Throwable t ) { } } private class PayloadLatchedActionListener < Response , T > extends ElasticsearchIntegrationTest . LatchedActionListener < Response > { private final CopyOnWriteArrayList < Tuple < T , Throwable > > errors ; private final T builder ; public PayloadLatchedActionListener ( T builder , CountDownLatch latch , CopyOnWriteArrayList < Tuple < T , Throwable > > errors ) { } protected void addError ( Throwable t ) { } } public void clearScroll ( String ... scrollIds ) { } public static enum Scope { GLOBAL , SUITE , TEST ; } private ElasticsearchIntegrationTest . ClusterScope getAnnotation ( Class < ? > clazz ) { } private ElasticsearchIntegrationTest . Scope getCurrentClusterScope ( ) { } private int getNumNodes ( ) { } private int getMinNumNodes ( ) { } private int getMaxNumNodes ( ) { } protected Settings nodeSettings ( int nodeOrdinal ) { } private TestCluster buildTestCluster ( ElasticsearchIntegrationTest . Scope scope ) { } @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE } ) public @ interface ClusterScope { ElasticsearchIntegrationTest . Scope scope ( ) default ElasticsearchIntegrationTest . Scope . GLOBAL ; int numNodes ( ) default - 1 ; int minNumNodes ( ) default TestCluster . DEFAULT_MIN_NUM_NODES ; int maxNumNodes ( ) default TestCluster . DEFAULT_MAX_NUM_NODES ; double transportClientRatio ( ) default - 1 ; } private static double transportClientRatio ( ) { } protected double getPerTestTransportClientRatio ( ) { } public static String randomNumericFieldDataFormat ( ) { } public static String randomBytesFieldDataFormat ( ) { }
public class DeleteByQueryRequest extends IndicesReplicationOperationRequest { private static final XContentType contentType = Requests . CONTENT_TYPE ; private byte [ ] querySource ; private int querySourceOffset ; private int querySourceLength ; private boolean querySourceUnsafe ; private String queryParserName ; private String [ ] types = Strings . EMPTY_ARRAY ; public DeleteByQueryRequest ( String ... indices ) { } public DeleteByQueryRequest ( ) { } @ Override public DeleteByQueryRequest listenerThreaded ( boolean threadedListener ) { } @ Override public ActionRequestValidationException validate ( ) { } public DeleteByQueryRequest indices ( String ... indices ) { } byte [ ] querySource ( ) { if ( ( querySourceUnsafe ) || ( ( querySourceOffset ) > 0 ) ) { <START_BUG> querySource = Arrays . copyOfRange ( querySource , querySourceOffset , querySourceLength ) ; <END_BUG> querySourceOffset = 0 ; querySourceUnsafe = false ; } return querySource ; } @ Required public DeleteByQueryRequest query ( QueryBuilder queryBuilder ) { } @ Required public DeleteByQueryRequest query ( String querySource ) { } @ Required public DeleteByQueryRequest query ( Map querySource ) { } @ Required public DeleteByQueryRequest query ( XContentBuilder builder ) { } @ Required public DeleteByQueryRequest query ( byte [ ] querySource ) { } @ Required public DeleteByQueryRequest query ( byte [ ] querySource , int offset , int length , boolean unsafe ) { } String queryParserName ( ) { } public DeleteByQueryRequest queryParserName ( String queryParserName ) { } String [ ] types ( ) { } public DeleteByQueryRequest types ( String ... types ) { } public DeleteByQueryRequest timeout ( TimeValue timeout ) { } public DeleteByQueryRequest timeout ( String timeout ) { } public DeleteByQueryRequest replicationType ( ReplicationType replicationType ) { } public DeleteByQueryRequest replicationType ( String replicationType ) { } public void readFrom ( StreamInput in ) throws IOException { } public void writeTo ( StreamOutput out ) throws IOException { } @ Override public String toString ( ) { } }
public abstract class AbstractIndexStore extends AbstractIndexComponent implements IndexStore { protected final IndexService indexService ; protected AbstractIndexStore ( Index index , @ IndexSettings Settings indexSettings , IndexService indexService ) { } @ Override public void deleteUnallocated ( ShardId shardId ) throws IOException { } @ Override public StoreFilesMetaData listStoreMetaData ( ShardId shardId ) throws IOException { InternalIndexShard indexShard = ( ( InternalIndexShard ) ( indexService . shard ( shardId . id ( ) ) ) ) ; if ( indexShard == null ) { return listUnallocatedStoreMetaData ( shardId ) ; } else { <START_BUG> return new StoreFilesMetaData ( true , shardId , indexShard . store ( ) . listWithMd5 ( ) ) ; <END_BUG> } } protected StoreFilesMetaData listUnallocatedStoreMetaData ( ShardId shardId ) throws IOException { } }
public class TransportNodesStatsAction extends TransportNodesOperationAction < NodesStatsRequest , NodesStatsResponse , TransportNodesStatsAction . NodeStatsRequest , NodeStats > { private final NodeService nodeService ; @ Inject public TransportNodesStatsAction ( Settings settings , ClusterName clusterName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , NodeService nodeService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected NodesStatsResponse newResponse ( NodesStatsRequest nodesInfoRequest , AtomicReferenceArray responses ) { } @ Override protected NodesStatsRequest newRequest ( ) { } @ Override protected TransportNodesStatsAction . NodeStatsRequest newNodeRequest ( ) { } @ Override protected TransportNodesStatsAction . NodeStatsRequest newNodeRequest ( String nodeId , NodesStatsRequest request ) { } @ Override protected NodeStats newNodeResponse ( ) { } @ Override protected NodeStats nodeOperation ( TransportNodesStatsAction . NodeStatsRequest nodeStatsRequest ) throws ElasticSearchException { NodesStatsRequest request = nodeStatsRequest . request ; <START_BUG> return nodeService . stats ( request . indices ( ) , request . os ( ) , request . process ( ) , request . jvm ( ) , request . network ( ) , request . transport ( ) , request . http ( ) ) ; <END_BUG> } @ Override protected boolean accumulateExceptions ( ) { } static class NodeStatsRequest extends NodeOperationRequest { NodesStatsRequest request ; NodeStatsRequest ( ) { } NodeStatsRequest ( String nodeId , NodesStatsRequest request ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class DefaultShaderProvider extends BaseShaderProvider { @ Override protected Shader createShader ( final Renderable renderable ) { app . log ( "DefaultShaderProvider" , "Creating<seq2seq4repair_space>new<seq2seq4repair_space>shader" ) ; if ( graphics . isGL20Available ( ) ) <START_BUG> return new com . badlogic . gdx . graphics . g3d . shaders . DefaultShader ( renderable . material , renderable . mesh . getVertexAttributes ( ) , ( ( renderable . lights ) != null ) , renderable . lights . directionalLights . size , renderable . lights . pointLights . size , 0 , ( ( renderable . bones ) == null ? 0 : 12 ) ) ; <END_BUG> return new GLES10Shader ( ) ; } }
@ ClusterScope ( scope = Scope . TEST , numDataNodes = 0 , numClientNodes = 0 ) public class SimpleThreadPoolTests extends ElasticsearchIntegrationTest { @ Override protected Settings nodeSettings ( int nodeOrdinal ) { <START_BUG> return ImmutableSettings . settingsBuilder ( ) . put ( "threadpool.search.type" , "cached" ) . put ( super . nodeSettings ( nodeOrdinal ) ) . build ( ) ; <END_BUG> } @ Test public void verifyThreadNames ( ) throws Exception { } @ Test ( timeout = 20000 ) public void testUpdatingThreadPoolSettings ( ) throws Exception { } private Map < String , Object > getPoolSettingsThroughJson ( ThreadPoolInfo info , String poolName ) throws IOException { } }
public class DoubleFieldDataTests extends AbstractNumericFieldDataTests { @ Override protected FieldDataType getFieldDataType ( ) { <START_BUG> return new FieldDataType ( "double" ) ; <END_BUG> } protected String one ( ) { } protected String two ( ) { } protected String three ( ) { } protected String four ( ) { } protected void add2SingleValuedDocumentsAndDeleteOneOfThem ( ) throws Exception { } @ Override protected void fillSingleValueAllSet ( ) throws Exception { } @ Override protected void fillSingleValueWithMissing ( ) throws Exception { } @ Override protected void fillMultiValueAllSet ( ) throws Exception { } @ Override protected void fillMultiValueWithMissing ( ) throws Exception { } protected void fillExtendedMvSet ( ) throws Exception { } }
public class TwoInstanceUnbalancedShardsEmbeddedSearchTests extends AbstractNodesTests { private IndicesService indicesService ; private ClusterService clusterService ; private Map < String , SearchService > nodeToSearchService ; private SearchPhaseController searchPhaseController ; @ BeforeClass public void createNodeAndInitWithData ( ) throws Exception { } @ AfterClass public void closeNodes ( ) { } @ Test public void testDfsQueryFetch ( ) throws Exception { } @ Test public void testDfsQueryFetchWithSort ( ) throws Exception { } @ Test public void testQueryFetchInOneGo ( ) { } @ Test public void testSimpleFacets ( ) { } @ Test public void testSimpleFacetsTwice ( ) { } private static InternalSearchRequest searchRequest ( ShardRouting shardRouting , SearchSourceBuilder builder ) { <START_BUG> return new InternalSearchRequest ( shardRouting , builder . buildAsBytes ( ) ) ; <END_BUG> } private void index ( Client client , String id , String nameValue , int age ) { } private String source ( String id , String nameValue , int age ) { } public static class UnevenOperationRoutingModule extends AbstractModule { @ Override protected void configure ( ) { } } public static class UnevenOperationRoutingStrategy extends PlainOperationRouting { @ Inject public UnevenOperationRoutingStrategy ( Index index , @ IndexSettings Settings indexSettings ) { } @ Override protected int hash ( String type , String id ) { } } }
public class BufferUtils { static Array < ByteBuffer > unsafeBuffers = new Array < ByteBuffer > ( ) ; static int allocatedUnsafe = 0 ; public static void copy ( float [ ] src , Buffer dst , int numFloats , int offset ) { } public static void copy ( byte [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( short [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( char [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( int [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( long [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( float [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( double [ ] src , int srcOffset , Buffer dst , int numElements ) { } public static void copy ( Buffer src , Buffer dst , int numElements ) { } private static int positionInBytes ( Buffer dst ) { } private static int bytesToElements ( Buffer dst , int bytes ) { } private static int elementsToBytes ( Buffer dst , int elements ) { } public static FloatBuffer newFloatBuffer ( int numFloats ) { } public static DoubleBuffer newDoubleBuffer ( int numDoubles ) { } public static ByteBuffer newByteBuffer ( int numBytes ) { } public static ShortBuffer newShortBuffer ( int numShorts ) { } public static CharBuffer newCharBuffer ( int numChars ) { } public static IntBuffer newIntBuffer ( int numInts ) { } public static LongBuffer newLongBuffer ( int numLongs ) { } public static void disposeUnsafeByteBuffer ( ByteBuffer buffer ) { } public static ByteBuffer newUnsafeByteBuffer ( int numBytes ) { } public static long getUnsafeByteBufferAddress ( ByteBuffer buffer ) { synchronized ( BufferUtils . unsafeBuffers ) { <START_BUG> if ( BufferUtils . unsafeBuffers . contains ( buffer , true ) ) <END_BUG> return 0 ; } return BufferUtils . getByteBufferAddress ( buffer ) ; } public static ByteBuffer newUnsafeByteBuffer ( ByteBuffer buffer ) { } public static int getAllocatedBytesUnsafe ( ) { } private static native void freeMemory ( ByteBuffer buffer ) { } private static native ByteBuffer newDisposableByteBuffer ( int numBytes ) { } private static native long getByteBufferAddress ( ByteBuffer buffer ) { } public static native void clear ( ByteBuffer buffer , int numBytes ) { } private static native void copyJni ( float [ ] src , Buffer dst , int numFloats , int offset ) { } private static native void copyJni ( byte [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( char [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( short [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( int [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( long [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( float [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( double [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } private static native void copyJni ( Buffer src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) { } }
public class LwjglGraphics implements Graphics { static int major ; static int minor ; GLCommon gl ; GL10 gl10 ; GL11 gl11 ; GL20 gl20 ; GLU glu ; float deltaTime = 0 ; long frameStart = 0 ; int frames = 0 ; int fps ; long lastTime = System . nanoTime ( ) ; Canvas canvas ; boolean vsync = false ; boolean resize = false ; LwjglApplicationConfiguration config ; BufferFormat bufferFormat = new BufferFormat ( 8 , 8 , 8 , 8 , 16 , 8 , 0 , false ) ; String extensions ; LwjglGraphics ( LwjglApplicationConfiguration config ) { } LwjglGraphics ( Canvas canvas , boolean useGL2IfAvailable ) { } LwjglGraphics ( Canvas canvas , LwjglApplicationConfiguration config ) { } public GL10 getGL10 ( ) { } public GL11 getGL11 ( ) { } public GL20 getGL20 ( ) { } public GLU getGLU ( ) { } public int getHeight ( ) { } public int getWidth ( ) { } public boolean isGL11Available ( ) { } public boolean isGL20Available ( ) { } public float getDeltaTime ( ) { } public float getRawDeltaTime ( ) { } public GraphicsType getType ( ) { } public int getFramesPerSecond ( ) { } @ Override public GLCommon getGLCommon ( ) { } void updateTime ( ) { } void setupDisplay ( ) throws LWJGLException { } private void createDisplayPixelFormat ( ) { } public void initiateGLInstances ( ) { } @ Override public float getPpiX ( ) { } @ Override public float getPpiY ( ) { } @ Override public float getPpcX ( ) { } @ Override public float getPpcY ( ) { } @ Override public float getDensity ( ) { } @ Override public boolean supportsDisplayModeChange ( ) { } private class LwjglDisplayMode extends DisplayMode { org . lwjgl . opengl . DisplayMode mode ; public LwjglDisplayMode ( int width , int height , int refreshRate , int bitsPerPixel , org . lwjgl . opengl . DisplayMode mode ) { } } @ Override public boolean setDisplayMode ( DisplayMode displayMode ) { } @ Override public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { } @ Override public DisplayMode [ ] getDisplayModes ( ) { } @ Override public DisplayMode getDesktopDisplayMode ( ) { } @ Override public void setTitle ( String title ) { } @ Override public BufferFormat getBufferFormat ( ) { } @ Override public void setVSync ( boolean vsync ) { } @ Override public boolean supportsExtension ( String extension ) { } public LwjglApplicationConfiguration getConfig ( ) { } volatile boolean isContinuous = true ; volatile boolean requestRendering = false ; @ Override public void setContinuousRendering ( boolean isContinuous ) { } @ Override public boolean isContinuousRendering ( ) { } @ Override public void requestRendering ( ) { } public boolean shouldRender ( ) { synchronized ( this ) { boolean rq = requestRendering ; requestRendering = false ; <START_BUG> return ( rq || ( isContinuous ) ) || ( Display . isDirty ( ) ) ; <END_BUG> } } @ Override public boolean isFullscreen ( ) { } }
public class PointLight implements Comparable { public final Vector3 position = new Vector3 ( ) ; public final Color color = new Color ( ) ; public float intensity ; protected float priority ; @ Override public int compareTo ( Object light ) { <START_BUG> return ( ( ( PointLight ) ( light ) ) . priority ) > ( this . priority ) ? - 1 : 1 ; <END_BUG> } }
public class GwtFileHandle extends FileHandle { public final Preloader preloader ; private final String file ; private final FileType type ; protected GwtFileHandle ( Preloader preloader , String fileName , FileType type ) { } public GwtFileHandle ( String path ) { } public String path ( ) { } public String name ( ) { } public String extension ( ) { } public String nameWithoutExtension ( ) { } public String pathWithoutExtension ( ) { } public FileType type ( ) { } public File file ( ) { } public InputStream read ( ) { } public BufferedInputStream read ( int bufferSize ) { } public Reader reader ( ) { } public Reader reader ( String charset ) { } public BufferedReader reader ( int bufferSize ) { } public BufferedReader reader ( int bufferSize , String charset ) { } public String readString ( ) { } public String readString ( String charset ) { } public byte [ ] readBytes ( ) { } public int readBytes ( byte [ ] bytes , int offset , int size ) { } public OutputStream write ( boolean append ) { } public void write ( InputStream input , boolean append ) { } public Writer writer ( boolean append ) { } public Writer writer ( boolean append , String charset ) { } public void writeString ( String string , boolean append ) { } public void writeString ( String string , boolean append , String charset ) { } public void writeBytes ( byte [ ] bytes , boolean append ) { } public void writeBytes ( byte [ ] bytes , int offset , int length , boolean append ) { } public FileHandle [ ] list ( ) { } public FileHandle [ ] list ( String suffix ) { } public boolean isDirectory ( ) { } public FileHandle child ( String name ) { <START_BUG> return new GwtFileHandle ( preloader , ( file . isEmpty ( ) ? "" : ( ( file ) + ( file . endsWith ( "/" ) ? "" : "/" ) ) + name ) , FileType . Internal ) ; <END_BUG> } public FileHandle parent ( ) { } public FileHandle sibling ( String name ) { } public void mkdirs ( ) { } public boolean exists ( ) { } public boolean delete ( ) { } public boolean deleteDirectory ( ) { } public void copyTo ( FileHandle dest ) { } public void moveTo ( FileHandle dest ) { } public long length ( ) { } public long lastModified ( ) { } public String toString ( ) { } }
public class PolygonSpriteBatch implements Batch { private Mesh mesh ; private final float [ ] vertices ; private final short [ ] triangles ; private int vertexIndex ; private int triangleIndex ; private Texture lastTexture ; private float invTexWidth = 0 ; private float invTexHeight = 0 ; private boolean drawing ; private final Matrix4 transformMatrix = new Matrix4 ( ) ; private final Matrix4 projectionMatrix = new Matrix4 ( ) ; private final Matrix4 combinedMatrix = new Matrix4 ( ) ; private boolean blendingDisabled ; private int blendSrcFunc = GL20 . GL_SRC_ALPHA ; private int blendDstFunc = GL20 . GL_ONE_MINUS_SRC_ALPHA ; private final ShaderProgram shader ; private ShaderProgram customShader ; private boolean ownsShader ; float color = WHITE . toFloatBits ( ) ; private Color tempColor = new Color ( 1 , 1 , 1 , 1 ) ; public int renderCalls = 0 ; public int totalRenderCalls = 0 ; public int maxTrianglesInBatch = 0 ; public PolygonSpriteBatch ( ) { } public PolygonSpriteBatch ( int size ) { } public PolygonSpriteBatch ( int size , ShaderProgram defaultShader ) { } public void begin ( ) { } public void end ( ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public void setColor ( float color ) { } public Color getColor ( ) { } public void draw ( PolygonRegion region , float x , float y ) { } public void draw ( PolygonRegion region , float x , float y , float width , float height ) { } public void draw ( PolygonRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation ) { } public void draw ( Texture texture , float [ ] polygonVertices , int verticesOffset , int verticesCount , short [ ] polygonTriangles , int trianglesOffset , int trianglesCount ) { } public void draw ( Texture texture , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { } public void draw ( Texture texture , float x , float y , float width , float height , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { } public void draw ( Texture texture , float x , float y , int srcX , int srcY , int srcWidth , int srcHeight ) { } public void draw ( Texture texture , float x , float y , float width , float height , float u , float v , float u2 , float v2 ) { } public void draw ( Texture texture , float x , float y ) { } public void draw ( Texture texture , float x , float y , float width , float height ) { } public void draw ( Texture texture , float [ ] spriteVertices , int offset , int count ) { } public void draw ( TextureRegion region , float x , float y ) { } public void draw ( TextureRegion region , float x , float y , float width , float height ) { } public void draw ( TextureRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation ) { } public void draw ( TextureRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation , boolean clockwise ) { } public void flush ( ) { } public void disableBlending ( ) { } public void enableBlending ( ) { } public void setBlendFunction ( int srcFunc , int dstFunc ) { } public int getBlendSrcFunc ( ) { } public int getBlendDstFunc ( ) { } public void dispose ( ) { } public Matrix4 getProjectionMatrix ( ) { } public Matrix4 getTransformMatrix ( ) { } public void setProjectionMatrix ( Matrix4 projection ) { } public void setTransformMatrix ( Matrix4 transform ) { } private void setupMatrices ( ) { } private void switchTexture ( Texture texture ) { } public void setShader ( ShaderProgram shader ) { } public boolean isBlendingEnabled ( ) { } public boolean isDrawing ( ) { <START_BUG> return false ; <END_BUG> } }
public abstract class TransportMasterNodeOperationAction < Request extends MasterNodeOperationRequest , Response extends ActionResponse > extends BaseAction < Request , Response > { protected final TransportService transportService ; protected final ClusterService clusterService ; protected final ThreadPool threadPool ; protected TransportMasterNodeOperationAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } protected abstract String transportAction ( ) { } protected abstract Request newRequest ( ) { } protected abstract Response newResponse ( ) { } protected abstract Response masterOperation ( Request request , ClusterState state ) throws ElasticSearchException { } protected void checkBlock ( Request request , ClusterState state ) { } protected void processBeforeDelegationToMaster ( Request request , ClusterState state ) { } @ Override protected void doExecute ( final Request request , final ActionListener < Response > listener ) { } private void innerExecute ( final Request request , final ActionListener < Response > listener , final boolean retrying ) { final ClusterState clusterState = clusterService . state ( ) ; final DiscoveryNodes nodes = clusterState . nodes ( ) ; if ( nodes . localNodeMaster ( ) ) { threadPool . execute ( new Runnable ( ) { @ Override public void run ( ) { try { checkBlock ( request , clusterState ) ; Response response = masterOperation ( request , clusterState ) ; listener . onResponse ( response ) ; } catch ( Exception e ) { listener . onFailure ( e ) ; } } } ) ; } else { if ( ( nodes . masterNode ( ) ) == null ) { if ( retrying ) { listener . onFailure ( new MasterNotDiscoveredException ( ) ) ; } else { clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { ClusterState clusterStateV2 = clusterService . state ( ) ; if ( ( clusterStateV2 . nodes ( ) . masterNodeId ( ) ) != null ) { clusterService . remove ( this ) ; innerExecute ( request , listener , true ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( new org . elasticsearch . node . NodeClosedException ( nodes . localNode ( ) ) ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; listener . onFailure ( new MasterNotDiscoveredException ( ) ) ; } @ Override public void clusterChanged ( ClusterChangedEvent event ) { if ( event . nodesDelta ( ) . masterNodeChanged ( ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , true ) ; } } } ) ; } return ; } processBeforeDelegationToMaster ( request , clusterState ) ; transportService . sendRequest ( nodes . masterNode ( ) , transportAction ( ) , request , new BaseTransportResponseHandler < Response > ( ) { @ Override public Response newInstance ( ) { return newResponse ( ) ; } @ Override public void handleResponse ( Response response ) { listener . onResponse ( response ) ; } @ Override public void handleException ( final RemoteTransportException exp ) { if ( ( exp . unwrapCause ( ) ) instanceof ConnectTransportException ) { clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { ClusterState clusterStateV2 = clusterService . state ( ) ; if ( ! ( clusterState . nodes ( ) . masterNodeId ( ) . equals ( clusterStateV2 . nodes ( ) . masterNodeId ( ) ) ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( new org . elasticsearch . node . NodeClosedException ( nodes . localNode ( ) ) ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; <START_BUG> listener . onFailure ( exp ) ; <END_BUG> } @ Override public void clusterChanged ( ClusterChangedEvent event ) { if ( event . nodesDelta ( ) . masterNodeChanged ( ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } } ) ; } else { listener . onFailure ( exp ) ; } } } ) ; } } private class TransportHandler extends BaseTransportRequestHandler < Request > { @ Override public Request newInstance ( ) { } @ Override public void messageReceived ( final Request request , final TransportChannel channel ) throws Exception { } } }
public abstract class AbstractRangeBuilder < B extends AbstractRangeBuilder < B > > extends ValuesSourceAggregationBuilder < B > { protected static class Range implements ToXContent { private String key ; private Object from ; private Object to ; public Range ( String key , Object from , Object to ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } } protected List < AbstractRangeBuilder . Range > ranges = Lists . newArrayList ( ) ; protected AbstractRangeBuilder ( String name , String type ) { } @ Override protected XContentBuilder doInternalXContent ( XContentBuilder builder , Params params ) throws IOException { if ( ranges . isEmpty ( ) ) { <START_BUG> throw new org . elasticsearch . search . builder . SearchSourceBuilderException ( ( ( "at<seq2seq4repair_space>least<seq2seq4repair_space>one<seq2seq4repair_space>range<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>defined<seq2seq4repair_space>for<seq2seq4repair_space>range<seq2seq4repair_space>aggregation<seq2seq4repair_space>[" + ( name ) ) + "]" ) ) ; <END_BUG> } builder . startArray ( "ranges" ) ; for ( AbstractRangeBuilder . Range range : ranges ) { range . toXContent ( builder , params ) ; } return builder . endArray ( ) ; } }
public class TransportAnalyzeAction extends TransportSingleCustomOperationAction < AnalyzeRequest , AnalyzeResponse > { private final IndicesService indicesService ; private final IndicesAnalysisService indicesAnalysisService ; @ Inject public TransportAnalyzeAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService , IndicesAnalysisService indicesAnalysisService , ActionFilters actionFilters ) { } @ Override protected String executor ( ) { } @ Override protected AnalyzeRequest newRequest ( ) { } @ Override protected AnalyzeResponse newResponse ( ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , AnalyzeRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , AnalyzeRequest request ) { if ( ( request . index ( ) ) != null ) { <START_BUG> request . index ( state . metaData ( ) . concreteSingleIndex ( request . index ( ) ) ) ; <END_BUG> return state . blocks ( ) . indexBlockedException ( READ , request . index ( ) ) ; } return null ; } @ Override protected ShardsIterator shards ( ClusterState state , AnalyzeRequest request ) { } @ Override protected AnalyzeResponse shardOperation ( AnalyzeRequest request , int shardId ) throws ElasticsearchException { } }
public class Skin implements Disposable { ObjectMap < Class , ObjectMap < String , Object > > resources = new ObjectMap ( ) ; TextureAtlas atlas ; public Skin ( ) { } public Skin ( FileHandle skinFile ) { } public Skin ( FileHandle skinFile , TextureAtlas atlas ) { } public Skin ( TextureAtlas atlas ) { } public void load ( FileHandle skinFile ) { } public void addRegions ( TextureAtlas atlas ) { } public void add ( String name , Object resource ) { } public void add ( String name , Object resource , Class type ) { } public < T > T get ( Class < T > type ) { } public < T > T get ( String name , Class < T > type ) { } public < T > T optional ( String name , Class < T > type ) { } public boolean has ( String name , Class type ) { } public < T > ObjectMap < String , T > getAll ( Class < T > type ) { } public Color getColor ( String name ) { } public BitmapFont getFont ( String name ) { } public TextureRegion getRegion ( String name ) { TextureRegion region = optional ( name , TextureRegion . class ) ; if ( region != null ) return region ; Texture texture = optional ( name , Texture . class ) ; if ( texture == null ) throw new GdxRuntimeException ( ( "No<seq2seq4repair_space>TextureRegion<seq2seq4repair_space>or<seq2seq4repair_space>Texture<seq2seq4repair_space>registered<seq2seq4repair_space>with<seq2seq4repair_space>name:<seq2seq4repair_space>" + name ) ) ; region = new TextureRegion ( texture ) ; <START_BUG> add ( name , region , TextureRegion . class ) ; <END_BUG> return region ; } public TiledDrawable getTiledDrawable ( String name ) { } public NinePatch getPatch ( String name ) { } public Sprite getSprite ( String name ) { } public Drawable getDrawable ( String name ) { } public String find ( Object resource ) { } public Drawable newDrawable ( String name ) { } public Drawable newDrawable ( String name , float r , float g , float b , float a ) { } public Drawable newDrawable ( String name , Color tint ) { } public Drawable newDrawable ( Drawable drawable ) { } public Drawable newDrawable ( Drawable drawable , float r , float g , float b , float a ) { } public Drawable newDrawable ( Drawable drawable , Color tint ) { } public void setEnabled ( Actor actor , boolean enabled ) { } public TextureAtlas getAtlas ( ) { } public void dispose ( ) { } protected Json getJsonLoader ( final FileHandle skinFile ) { } private static Method findMethod ( Class type , String name ) { } public static class TintedDrawable { public String name ; public Color color ; } }
public class TransportGatewaySnapshotAction extends TransportBroadcastOperationAction < GatewaySnapshotRequest , GatewaySnapshotResponse , ShardGatewaySnapshotRequest , ShardGatewaySnapshotResponse > { private final IndicesService indicesService ; @ Inject public TransportGatewaySnapshotAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected GatewaySnapshotRequest newRequest ( ) { } @ Override protected boolean ignoreNonActiveExceptions ( ) { } @ Override protected GatewaySnapshotResponse newResponse ( GatewaySnapshotRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardGatewaySnapshotRequest newShardRequest ( ) { } @ Override protected ShardGatewaySnapshotRequest newShardRequest ( ShardRouting shard , GatewaySnapshotRequest request ) { <START_BUG> return new ShardGatewaySnapshotRequest ( shard . index ( ) , shard . id ( ) ) ; <END_BUG> } @ Override protected ShardGatewaySnapshotResponse newShardResponse ( ) { } @ Override protected ShardGatewaySnapshotResponse shardOperation ( ShardGatewaySnapshotRequest request ) throws ElasticSearchException { } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , GatewaySnapshotRequest request , String [ ] concreteIndices ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , GatewaySnapshotRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , GatewaySnapshotRequest request , String [ ] concreteIndices ) { } }
public class PrimaryNotStartedActionException extends ElasticSearchException { public PrimaryNotStartedActionException ( ShardId shardId , String message ) { } private static String buildMessage ( ShardId shardId , String message ) { if ( shardId == null ) { return message ; } <START_BUG> return ( ( ( ( "[" + ( shardId . index ( ) ) ) + "][" ) + ( shardId . id ( ) ) ) + "]" ) + message ; <END_BUG> } }
public class IntArray { public int [ ] items ; public int size ; public boolean ordered ; public IntArray ( ) { } public IntArray ( int capacity ) { } public IntArray ( boolean ordered , int capacity ) { } public IntArray ( IntArray array ) { } public IntArray ( int [ ] array ) { } public IntArray ( boolean ordered , int [ ] array , int startIndex , int count ) { } public void add ( int value ) { } public void addAll ( IntArray array ) { } public void addAll ( IntArray array , int offset , int length ) { } public void addAll ( int [ ] array ) { } public void addAll ( int [ ] array , int offset , int length ) { int [ ] items = this . items ; <START_BUG> int sizeNeeded = ( size ) + length ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public int get ( int index ) { } public void set ( int index , int value ) { } public void insert ( int index , int value ) { } public void swap ( int first , int second ) { } public boolean contains ( int value ) { } public int indexOf ( int value ) { } public int lastIndexOf ( int value ) { } public boolean removeValue ( int value ) { } public int removeIndex ( int index ) { } public boolean removeAll ( IntArray array ) { } public int pop ( ) { } public int peek ( ) { } public int first ( ) { } public void clear ( ) { } public void shrink ( ) { } public int [ ] ensureCapacity ( int additionalCapacity ) { } protected int [ ] resize ( int newSize ) { } public void sort ( ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public int random ( ) { } public int [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class DeleteByQueryWrappingFilter extends Filter { private final Query query ; private IndexSearcher searcher ; private Weight weight ; public DeleteByQueryWrappingFilter ( Query query ) { } public final Query getQuery ( ) { } @ Override public DocIdSet getDocIdSet ( final AtomicReaderContext context , final Bits acceptDocs ) throws IOException { SearchContext searchContext = SearchContext . current ( ) ; if ( ( weight ) == null ) { assert ( searcher ) == null ; searcher = searchContext . searcher ( ) ; IndexReader indexReader = SearchContext . current ( ) . searcher ( ) . getIndexReader ( ) ; IndexReader multiReader = null ; try { if ( ! ( DeleteByQueryWrappingFilter . contains ( indexReader , context ) ) ) { multiReader = new org . apache . lucene . index . MultiReader ( new IndexReader [ ] { indexReader , context . reader ( ) } , false ) ; Similarity similarity = searcher . getSimilarity ( ) ; searcher = new IndexSearcher ( new org . apache . lucene . index . MultiReader ( indexReader , context . reader ( ) ) ) ; searcher . setSimilarity ( similarity ) ; } weight = searcher . createNormalizedWeight ( query ) ; } finally { if ( multiReader != null ) { multiReader . close ( ) ; } } } else { IndexReader indexReader = searcher . getIndexReader ( ) ; if ( ! ( DeleteByQueryWrappingFilter . contains ( indexReader , context ) ) ) { try ( IndexReader multiReader = new org . apache . lucene . index . MultiReader ( new IndexReader [ ] { indexReader , context . reader ( ) } , false ) ) { Similarity similarity = searcher . getSimilarity ( ) ; searcher = new IndexSearcher ( multiReader ) ; searcher . setSimilarity ( similarity ) ; weight = searcher . createNormalizedWeight ( query ) ; } } } return new DocIdSet ( ) { @ Override public DocIdSetIterator iterator ( ) throws IOException { <START_BUG> return weight . scorer ( context , true , false , acceptDocs ) ; <END_BUG> } @ Override public boolean isCacheable ( ) { return false ; } } ; } @ Override public String toString ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } static boolean contains ( IndexReader indexReader , AtomicReaderContext context ) { } }
@ ClusterScope ( numNodes = 0 , scope = Scope . TEST ) public class QuorumLocalGatewayTests extends AbstractIntegrationTest { @ Test @ Slow public void testChangeInitialShardsRecovery ( ) throws Exception { logger . info ( "--><seq2seq4repair_space>starting<seq2seq4repair_space>3<seq2seq4repair_space>nodes" ) ; final String [ ] nodes = new String [ 3 ] ; nodes [ 0 ] = cluster ( ) . startNode ( settingsBuilder ( ) . put ( "gateway.type" , "local" ) . put ( "index.number_of_shards" , 2 ) . put ( "index.number_of_replicas" , 2 ) . build ( ) ) ; nodes [ 1 ] = cluster ( ) . startNode ( settingsBuilder ( ) . put ( "gateway.type" , "local" ) . put ( "index.number_of_shards" , 2 ) . put ( "index.number_of_replicas" , 2 ) . build ( ) ) ; nodes [ 2 ] = cluster ( ) . startNode ( settingsBuilder ( ) . put ( "gateway.type" , "local" ) . put ( "index.number_of_shards" , 2 ) . put ( "index.number_of_replicas" , 2 ) . build ( ) ) ; logger . info ( "--><seq2seq4repair_space>indexing..." ) ; client ( ) . prepareIndex ( "test" , "type1" , "1" ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( "field" , "value1" ) . endObject ( ) ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . get ( ) ; client ( ) . prepareIndex ( "test" , "type1" , "2" ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( "field" , "value2" ) . endObject ( ) ) . get ( ) ; assertNoFailures ( client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . get ( ) ) ; logger . info ( "--><seq2seq4repair_space>running<seq2seq4repair_space>cluster_health<seq2seq4repair_space>(wait<seq2seq4repair_space>for<seq2seq4repair_space>the<seq2seq4repair_space>shards<seq2seq4repair_space>to<seq2seq4repair_space>startup)" ) ; ClusterHealthResponse clusterHealth = client ( ) . admin ( ) . cluster ( ) . health ( clusterHealthRequest ( ) . waitForGreenStatus ( ) . waitForActiveShards ( 6 ) ) . actionGet ( ) ; logger . info ( ( "--><seq2seq4repair_space>done<seq2seq4repair_space>cluster_health,<seq2seq4repair_space>status<seq2seq4repair_space>" + ( clusterHealth . getStatus ( ) ) ) ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( clusterHealth . getStatus ( ) , equalTo ( GREEN ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { assertHitCount ( client ( ) . prepareCount ( ) . setQuery ( matchAllQuery ( ) ) . get ( ) , 2L ) ; } final String nodeToRemove = nodes [ between ( 0 , 2 ) ] ; logger . info ( "--><seq2seq4repair_space>restarting<seq2seq4repair_space>2<seq2seq4repair_space>nodes<seq2seq4repair_space>--<seq2seq4repair_space>kill<seq2seq4repair_space>1" ) ; cluster ( ) . fullRestart ( new RestartCallback ( ) { @ Override public Settings onNodeStopped ( String nodeName ) throws Exception { return settingsBuilder ( ) . put ( "gateway.type" , "local" ) . build ( ) ; } @ Override public boolean doRestart ( String nodeName ) { return ! ( nodeToRemove . equals ( nodeName ) ) ; } } ) ; assertThat ( awaitBusy ( new Predicate < Object > ( ) { @ Override public boolean apply ( Object input ) { <START_BUG> ClusterStateResponse clusterStateResponse = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setMasterNodeTimeout ( "500ms" ) . get ( ) ; <END_BUG> return ! ( clusterStateResponse . getState ( ) . routingTable ( ) . index ( "test" ) . allPrimaryShardsActive ( ) ) ; } } , 30 , TimeUnit . SECONDS ) , equalTo ( true ) ) ; logger . info ( "--><seq2seq4repair_space>change<seq2seq4repair_space>the<seq2seq4repair_space>recovery.initial_shards<seq2seq4repair_space>setting,<seq2seq4repair_space>and<seq2seq4repair_space>make<seq2seq4repair_space>sure<seq2seq4repair_space>its<seq2seq4repair_space>recovered" ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( "test" ) . setSettings ( settingsBuilder ( ) . put ( "recovery.initial_shards" , 1 ) ) . get ( ) ; logger . info ( "--><seq2seq4repair_space>running<seq2seq4repair_space>cluster_health<seq2seq4repair_space>(wait<seq2seq4repair_space>for<seq2seq4repair_space>the<seq2seq4repair_space>shards<seq2seq4repair_space>to<seq2seq4repair_space>startup),<seq2seq4repair_space>4<seq2seq4repair_space>shards<seq2seq4repair_space>since<seq2seq4repair_space>we<seq2seq4repair_space>only<seq2seq4repair_space>have<seq2seq4repair_space>2<seq2seq4repair_space>nodes" ) ; clusterHealth = client ( ) . admin ( ) . cluster ( ) . health ( clusterHealthRequest ( ) . waitForYellowStatus ( ) . waitForActiveShards ( 4 ) ) . actionGet ( ) ; logger . info ( ( "--><seq2seq4repair_space>done<seq2seq4repair_space>cluster_health,<seq2seq4repair_space>status<seq2seq4repair_space>" + ( clusterHealth . getStatus ( ) ) ) ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( clusterHealth . getStatus ( ) , equalTo ( YELLOW ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { assertHitCount ( client ( ) . prepareCount ( ) . setQuery ( matchAllQuery ( ) ) . get ( ) , 2L ) ; } } @ Test @ Slow public void testQuorumRecovery ( ) throws Exception { } }
public class TransportCountAction extends TransportBroadcastOperationAction < CountRequest , CountResponse , ShardCountRequest , ShardCountResponse > { private final IndicesService indicesService ; @ Inject public TransportCountAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected CountRequest newRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ShardRouting shard , CountRequest request ) { } @ Override protected ShardCountResponse newShardResponse ( ) { } @ Override protected GroupShardsIterator shards ( CountRequest request , ClusterState clusterState ) { <START_BUG> return clusterService . operationRouting ( ) . searchShards ( clusterState , request . indices ( ) , request . queryHint ( ) ) ; <END_BUG> } @ Override protected void checkBlock ( CountRequest request , ClusterState state ) { } @ Override protected CountResponse newResponse ( CountRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardCountResponse shardOperation ( ShardCountRequest request ) throws ElasticSearchException { } }
public abstract class FieldMapperListener { public static class Aggregator extends FieldMapperListener { public final List < FieldMapper > mappers = new ArrayList < FieldMapper > ( ) ; @ Override public void fieldMapper ( FieldMapper fieldMapper ) { } } public abstract void fieldMapper ( FieldMapper fieldMapper ) { } <START_BUG> public void fieldMappers ( FieldMapper ... fieldMappers ) { <END_BUG> for ( FieldMapper mapper : fieldMappers ) { fieldMapper ( mapper ) ; } } }
public class TermsStatsStringFacetExecutor extends FacetExecutor { private final ComparatorType comparatorType ; final IndexFieldData keyIndexFieldData ; final IndexNumericFieldData valueIndexFieldData ; final SearchScript script ; private final int size ; private final int shardSize ; final V < ObjectObjectOpenHashMap < HashedBytesRef , InternalTermsStatsStringFacet . StringEntry > > entries ; long missing ; public TermsStatsStringFacetExecutor ( IndexFieldData keyIndexFieldData , IndexNumericFieldData valueIndexFieldData , SearchScript valueScript , int size , int shardSize , TermsStatsFacet . ComparatorType comparatorType , SearchContext context ) { } @ Override public TermsStatsStringFacetExecutor . Collector collector ( ) { } @ Override public InternalFacet buildFacet ( String facetName ) { } class Collector extends FacetExecutor . Collector { private final TermsStatsStringFacetExecutor . Aggregator aggregator ; private BytesValues keyValues ; public Collector ( ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { <START_BUG> keyValues = keyIndexFieldData . load ( context ) . getBytesValues ( true ) ; <END_BUG> if ( ( script ) != null ) { script . setNextReader ( context ) ; } else { aggregator . valueValues = valueIndexFieldData . load ( context ) . getDoubleValues ( ) ; } } @ Override public void collect ( int doc ) throws IOException { } @ Override public void postCollection ( ) { } } public static class Aggregator extends HashedAggregator { final ObjectObjectOpenHashMap < HashedBytesRef , InternalTermsStatsStringFacet . StringEntry > entries ; final HashedBytesRef spare = new HashedBytesRef ( ) ; int missing = 0 ; DoubleValues valueValues ; TermsStatsStringFacetExecutor . Aggregator . ValueAggregator valueAggregator = new TermsStatsStringFacetExecutor . Aggregator . ValueAggregator ( ) ; public Aggregator ( ObjectObjectOpenHashMap < HashedBytesRef , InternalTermsStatsStringFacet . StringEntry > entries ) { } @ Override public void onValue ( int docId , BytesRef value , int hashCode , BytesValues values ) { } public static class ValueAggregator extends DoubleFacetAggregatorBase { StringEntry stringEntry ; @ Override public void onValue ( int docId , double value ) { } } } public static class ScriptAggregator extends TermsStatsStringFacetExecutor . Aggregator { private final SearchScript script ; public ScriptAggregator ( ObjectObjectOpenHashMap < HashedBytesRef , InternalTermsStatsStringFacet . StringEntry > entries , SearchScript script ) { } @ Override public void onValue ( int docId , BytesRef value , int hashCode , BytesValues values ) { } } }
public class GroupRedBlackTree extends RedBlackTree { private long nextId ; private double [ ] centroids ; private long [ ] counts ; private int [ ] aggregatedSizes ; private long [ ] aggregatedCounts ; private long [ ] ids ; double tmpCentroid ; long tmpCount ; long tmpId ; public GroupRedBlackTree ( int capacity ) { } @ Override protected int compare ( int node ) { final double centroid = mean ( node ) ; int cmp = Double . compare ( tmpCentroid , centroid ) ; if ( cmp == 0 ) { <START_BUG> cmp = Longs . compare ( tmpId , ids [ node ] ) ; <END_BUG> } return cmp ; } @ Override protected void copy ( int node ) { } @ Override protected void merge ( int node ) { } @ Override protected void swap ( int node1 , int node2 ) { } @ Override protected int newNode ( ) { } private void fixAggregates ( int node ) { } private void fixCounts ( int node ) { } @ Override protected void rotateLeft ( int node ) { } @ Override protected void rotateRight ( int node ) { } @ Override protected void beforeRemoval ( int node ) { } @ Override protected void afterInsertion ( int node ) { } public double mean ( int node ) { } public long count ( int node ) { } public long id ( int node ) { } public void addGroup ( double centroid , long count , long id ) { } public void addGroup ( double centroid , long count ) { } public boolean removeGroup ( double centroid , int id ) { } public void updateGroup ( int node , double centroid , long count ) { } public int floorNode ( double centroid ) { } public int ceilingNode ( double centroid ) { } public void headSum ( int node , GroupRedBlackTree . SizeAndSum sizeAndSum ) { } public static class SizeAndSum { public int size ; public long sum ; } }
public class TermsDoubleFacetCollector extends AbstractFacetCollector { private final FieldDataCache fieldDataCache ; private final String indexFieldName ; private final ComparatorType comparatorType ; private final int size ; private final int numberOfShards ; private final FieldDataType fieldDataType ; private DoubleFieldData fieldData ; private final TermsDoubleFacetCollector . StaticAggregatorValueProc aggregator ; private final SearchScript script ; public TermsDoubleFacetCollector ( String facetName , String fieldName , int size , TermsFacet . ComparatorType comparatorType , boolean allTerms , SearchContext context , ImmutableSet < BytesRef > excluded , String scriptLang , String script , Map < String , Object > params ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { fieldData = ( ( DoubleFieldData ) ( fieldDataCache . cache ( fieldDataType , context . reader ( ) , indexFieldName ) ) ) ; if ( ( script ) != null ) { <START_BUG> script . setNextReader ( context . reader ( ) ) ; <END_BUG> } } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override public Facet facet ( ) { } public static class AggregatorValueProc extends TermsDoubleFacetCollector . StaticAggregatorValueProc { private final SearchScript script ; private final TDoubleHashSet excluded ; public AggregatorValueProc ( TDoubleIntHashMap facets , Set < BytesRef > excluded , SearchScript script ) { } @ Override public void onValue ( int docId , double value ) { } } public static class StaticAggregatorValueProc implements DoubleFieldData . ValueInDocProc , DoubleFieldData . ValueProc { private final TDoubleIntHashMap facets ; private int missing ; private int total ; public StaticAggregatorValueProc ( TDoubleIntHashMap facets ) { } @ Override public void onValue ( double value ) { } @ Override public void onValue ( int docId , double value ) { } @ Override public void onMissing ( int docId ) { } public final TDoubleIntHashMap facets ( ) { } public final int missing ( ) { } public int total ( ) { } } }
public class TransportFlushAction extends TransportBroadcastOperationAction < FlushRequest , FlushResponse , ShardFlushRequest , ShardFlushResponse > { private final IndicesService indicesService ; @ Inject public TransportFlushAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected FlushRequest newRequest ( ) { } @ Override protected FlushResponse newResponse ( FlushRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardFlushRequest newShardRequest ( ) { } @ Override protected ShardFlushRequest newShardRequest ( int numShards , ShardRouting shard , FlushRequest request ) { } @ Override protected ShardFlushResponse newShardResponse ( ) { } @ Override protected ShardFlushResponse shardOperation ( ShardFlushRequest request ) throws ElasticsearchException { } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , FlushRequest request , String [ ] concreteIndices ) { <START_BUG> return clusterState . routingTable ( ) . allActiveShardsGrouped ( concreteIndices , true ) ; <END_BUG> } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , FlushRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , FlushRequest countRequest , String [ ] concreteIndices ) { } }
public class ZenFaultDetectionTests extends ElasticsearchTestCase { protected ThreadPool threadPool ; protected static final Version version0 = Version . fromId ( 99 ) ; protected DiscoveryNode nodeA ; protected MockTransportService serviceA ; protected static final Version version1 = Version . fromId ( 199 ) ; protected DiscoveryNode nodeB ; protected MockTransportService serviceB ; @ Before public void setUp ( ) throws Exception { } @ After public void tearDown ( ) throws Exception { super . tearDown ( ) ; serviceA . close ( ) ; serviceB . close ( ) ; <START_BUG> threadPool . shutdown ( ) ; <END_BUG> } protected MockTransportService build ( Settings settings , Version version ) { } private DiscoveryNodes buildNodesForA ( boolean master ) { } private DiscoveryNodes buildNodesForB ( boolean master ) { } @ Test public void testNodesFaultDetectionConnectOnDisconnect ( ) throws InterruptedException { } @ Test public void testMasterFaultDetectionConnectOnDisconnect ( ) throws InterruptedException { } }
public class IndexCache extends AbstractIndexComponent implements ClusterStateListener , CloseableComponent { private final FilterCache filterCache ; private final QueryParserCache queryParserCache ; private final DocSetCache docSetCache ; private final FixedBitSetFilterCache fixedBitSetFilterCache ; private ClusterService clusterService ; @ Inject public IndexCache ( Index index , @ IndexSettings Settings indexSettings , FilterCache filterCache , QueryParserCache queryParserCache , DocSetCache docSetCache , FixedBitSetFilterCache fixedBitSetFilterCache ) { } @ Inject ( optional = true ) public void setClusterService ( @ Nullable ClusterService clusterService ) { } public FilterCache filter ( ) { } public DocSetCache docSet ( ) { } public QueryParserCache queryParserCache ( ) { } @ Override public void close ( ) throws ElasticsearchException { filterCache . close ( ) ; queryParserCache . close ( ) ; docSetCache . clear ( "close" ) ; <START_BUG> fixedBitSetFilterCache . clear ( "close" ) ; <END_BUG> if ( ( clusterService ) != null ) { clusterService . remove ( this ) ; } } public void clear ( String reason ) { } @ Override public void clusterChanged ( ClusterChangedEvent event ) { } }
public class CompletionSuggestSearchTests extends ElasticsearchIntegrationTest { private final String INDEX = RandomStrings . randomAsciiOfLength ( getRandom ( ) , 10 ) . toLowerCase ( Locale . ROOT ) ; private final String TYPE = RandomStrings . randomAsciiOfLength ( getRandom ( ) , 10 ) . toLowerCase ( Locale . ROOT ) ; private final String FIELD = RandomStrings . randomAsciiOfLength ( getRandom ( ) , 10 ) . toLowerCase ( Locale . ROOT ) ; @ Test public void testSimple ( ) throws Exception { } @ Test public void testSuggestFieldWithPercolateApi ( ) throws Exception { } @ Test public void testBasicPrefixSuggestion ( ) throws Exception { } @ Test public void testThatWeightsAreWorking ( ) throws Exception { } @ Test public void testThatWeightMustBeAnInteger ( ) throws Exception { } @ Test public void testThatInputCanBeAStringInsteadOfAnArray ( ) throws Exception { } @ Test public void testThatPayloadsAreArbitraryJsonObjects ( ) throws Exception { } @ Test public void testPayloadAsNumeric ( ) throws Exception { } @ Test public void testPayloadAsString ( ) throws Exception { } @ Test ( expected = MapperException . class ) public void testThatExceptionIsThrownWhenPayloadsAreDisabledButInIndexRequest ( ) throws Exception { } @ Test public void testDisabledPreserveSeperators ( ) throws Exception { } @ Test public void testEnabledPreserveSeperators ( ) throws Exception { } @ Test public void testThatMultipleInputsAreSupported ( ) throws Exception { } @ Test public void testThatShortSyntaxIsWorking ( ) throws Exception { } @ Test public void testThatDisablingPositionIncrementsWorkForStopwords ( ) throws Exception { } @ Test public void testThatSynonymsWork ( ) throws Exception { } @ Test public void testThatUpgradeToMultiFieldWorks ( ) throws Exception { } @ Test public void testThatFuzzySuggesterWorks ( ) throws Exception { } @ Test public void testThatFuzzySuggesterSupportsEditDistances ( ) throws Exception { } @ Test public void testThatFuzzySuggesterSupportsTranspositions ( ) throws Exception { } @ Test public void testThatFuzzySuggesterSupportsMinPrefixLength ( ) throws Exception { } @ Test public void testThatFuzzySuggesterSupportsNonPrefixLength ( ) throws Exception { } @ Test public void testThatStatsAreWorking ( ) throws Exception { } @ Test public void testThatSortingOnCompletionFieldReturnsUsefulException ( ) throws Exception { } @ Test public void testThatSuggestStopFilterWorks ( ) throws Exception { } @ Test ( expected = MapperParsingException . class ) public void testThatIndexingInvalidFieldsInCompletionFieldResultsInException ( ) throws Exception { } public void assertSuggestions ( String suggestion , String ... suggestions ) { } public void assertSuggestionsNotInOrder ( String suggestString , String ... suggestions ) { } private void assertSuggestions ( SuggestResponse suggestResponse , String name , String ... suggestions ) { } private void assertSuggestions ( SuggestResponse suggestResponse , boolean suggestionOrderStrict , String name , String ... suggestions ) { } private List < String > getNames ( Suggest . Suggestion . Entry < Suggest . Suggestion . Entry . Option > suggestEntry ) { } private void createIndexAndMapping ( ) throws IOException { } private void createIndexAndMappingAndSettings ( Settings . Builder settingsBuilder , String indexAnalyzer , String searchAnalyzer , boolean payloads , boolean preserveSeparators , boolean preservePositionIncrements ) throws IOException { } private void createIndexAndMapping ( String indexAnalyzer , String searchAnalyzer , boolean payloads , boolean preserveSeparators , boolean preservePositionIncrements ) throws IOException { } private Builder createDefaultSettings ( ) { int randomShardNumber = between ( 1 , 5 ) ; <START_BUG> int randomReplicaNumber = between ( 0 , ( ( cluster ( ) . numNodes ( ) ) - 1 ) ) ; <END_BUG> return settingsBuilder ( ) . put ( SETTING_NUMBER_OF_SHARDS , randomShardNumber ) . put ( SETTING_NUMBER_OF_REPLICAS , randomReplicaNumber ) ; } private void createData ( boolean optimize ) throws IOException , InterruptedException , ExecutionException { } @ Test public void testPrunedSegments ( ) throws IOException { } @ Test public void testMaxFieldLength ( ) throws IOException { } @ Test public void testVeryLongInput ( ) throws IOException { } @ Test ( expected = MapperParsingException . class ) public void testReservedChars ( ) throws IOException { } private static String replaceReservedChars ( String input , char replacement ) { } }
public class TransportSearchDfsQueryThenFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchDfsQueryThenFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportSearchCache transportSearchCache , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < DfsSearchResult > { private final Collection < DfsSearchResult > dfsResults = searchCache . obtainDfsResults ( ) ; private final Map < SearchShardTarget , QuerySearchResultProvider > queryResults = searchCache . obtainQueryResults ( ) ; private final Map < SearchShardTarget , FetchSearchResult > fetchResults = searchCache . obtainFetchResults ( ) ; private volatile Map < SearchShardTarget , ExtTIntArrayList > docIdsToLoad ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , InternalSearchRequest request , SearchServiceListener < DfsSearchResult > listener ) { } @ Override protected void processFirstPhaseResult ( ShardRouting shard , DfsSearchResult result ) { } @ Override protected void moveToSecondPhase ( ) { } private void executeQuery ( final DfsSearchResult dfsResult , final AtomicInteger counter , final QuerySearchRequest querySearchRequest , DiscoveryNode node ) { } private void executeFetchPhase ( ) { } private void innerExecuteFetchPhase ( ) { } private void executeFetch ( final SearchShardTarget shardTarget , final AtomicInteger counter , final FetchSearchRequest fetchSearchRequest , DiscoveryNode node ) { } private void finishHim ( ) { } private void innerFinishHim ( ) throws Exception { final InternalSearchResponse internalResponse = searchPhaseController . merge ( sortedShardList , queryResults , fetchResults ) ; String scrollId = null ; if ( ( request . scroll ( ) ) != null ) { <START_BUG> scrollId = TransportSearchHelper . buildScrollId ( request . searchType ( ) , dfsResults ) ; <END_BUG> } listener . onResponse ( new SearchResponse ( internalResponse , scrollId , expectedSuccessfulOps , successulOps . get ( ) , buildTookInMillis ( ) , buildShardFailures ( ) ) ) ; } } }
public class SinglePackedOrdinals implements Ordinals { private final Reader reader ; private final int numOrds ; private long size = - 1 ; public SinglePackedOrdinals ( PackedInts . Reader reader , int numOrds ) { } @ Override public Object getBackingStorage ( ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override public boolean isMultiValued ( ) { } @ Override public int getNumDocs ( ) { } @ Override public int getNumOrds ( ) { } @ Override public SinglePackedOrdinals . Docs ordinals ( ) { } public static class Docs implements Ordinals . Docs { private final SinglePackedOrdinals parent ; private final Reader reader ; private final IntArrayRef intsScratch = new IntArrayRef ( new int [ 1 ] ) ; private final SingleValueIter iter = new SingleValueIter ( ) ; public Docs ( SinglePackedOrdinals parent , PackedInts . Reader reader ) { } @ Override public Ordinals ordinals ( ) { } @ Override public int getNumDocs ( ) { } @ Override public int getNumOrds ( ) { } @ Override public boolean isMultiValued ( ) { } @ Override public int getOrd ( int docId ) { } @ Override public IntArrayRef getOrds ( int docId ) { int ordinal = ( ( int ) ( reader . get ( docId ) ) ) ; if ( ordinal == 0 ) return IntArrayRef . EMPTY ; <START_BUG> intsScratch . values [ 0 ] = docId ; <END_BUG> return intsScratch ; } @ Override public Iter getIter ( int docId ) { } @ Override public void forEachOrdinalInDoc ( int docId , OrdinalInDocProc proc ) { } } }
final class JoglAudio implements Audio , Runnable { private SourceDataLine line ; private final List < JoglAudio . JoglSoundBuffer > buffers = new ArrayList < JoglAudio . JoglSoundBuffer > ( ) ; private Thread thread ; private volatile boolean run = false ; class JoglSoundBuffer { private final float [ ] samples ; private final AudioFormat format ; private final float volume ; private int writtenSamples = 0 ; public JoglSoundBuffer ( JoglSound sound , float volume ) throws Exception { } public boolean writeSamples ( int numSamples , float [ ] buffer ) { } } JoglAudio ( ) { } @ Override public AudioDevice newAudioDevice ( boolean isMono ) { } @ Override public Music newMusic ( FileHandle file ) { try { JoglMusic music = new JoglMusic ( ( ( JoglFileHandle ) ( file ) ) ) ; return music ; <START_BUG> } catch ( Exception e ) { <END_BUG> throw new com . badlogic . gdx . utils . GdxRuntimeException ( ( ( "Couldn't<seq2seq4repair_space>create<seq2seq4repair_space>Music<seq2seq4repair_space>instance<seq2seq4repair_space>from<seq2seq4repair_space>file<seq2seq4repair_space>'" + file ) + "'" ) , e ) ; } } @ Override public Sound newSound ( FileHandle file ) { } protected void enqueueSound ( JoglSound sound , float volume ) { } @ Override public void run ( ) { } private void fillBuffer ( float [ ] buffer , byte [ ] bytes , int samplesToWrite ) { } @ Override public AudioRecorder newAudioRecoder ( int samplingRate , boolean isMono ) { } void dispose ( ) { } }
public class InternalFilterFacet extends InternalFacet implements FilterFacet { private static final BytesReference STREAM_TYPE = new org . elasticsearch . common . bytes . HashedBytesArray ( Strings . toUTF8Bytes ( "filter" ) ) ; public static void registerStreams ( ) { } static Stream STREAM = new Stream ( ) { @ Override public Facet readFacet ( StreamInput in ) throws IOException { } } ; @ Override public BytesReference streamType ( ) { } private long count ; InternalFilterFacet ( ) { } public InternalFilterFacet ( String name , long count ) { } @ Override public String getType ( ) { } public long getCount ( ) { } @ Override public Facet reduce ( ReduceContext context ) { List < Facet > facets = context . facets ( ) ; if ( ( facets . size ( ) ) == 1 ) { return facets . get ( 0 ) ; } <START_BUG> int count = 0 ; <END_BUG> for ( Facet facet : facets ) { count += ( ( FilterFacet ) ( facet ) ) . getCount ( ) ; } return new InternalFilterFacet ( getName ( ) , count ) ; } static final class Fields { static final XContentBuilderString _TYPE = new XContentBuilderString ( "_type" ) ; static final XContentBuilderString COUNT = new XContentBuilderString ( "count" ) ; } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } public static FilterFacet readFilterFacet ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public class PreBuiltAnalyzerProviderFactory implements AnalyzerProviderFactory { private final PreBuiltAnalyzerProvider analyzerProvider ; public PreBuiltAnalyzerProviderFactory ( String name , AnalyzerScope scope , Analyzer analyzer ) { } @ Override public AnalyzerProvider create ( String name , Settings settings ) { <START_BUG> Version indexVersion = settings . getAsVersion ( SETTING_VERSION_CREATED , CURRENT ) ; <END_BUG> if ( ! ( CURRENT . equals ( indexVersion ) ) ) { PreBuiltAnalyzers preBuiltAnalyzers = PreBuiltAnalyzers . getOrDefault ( name , null ) ; if ( preBuiltAnalyzers != null ) { Analyzer analyzer = preBuiltAnalyzers . getAnalyzer ( indexVersion ) ; return new PreBuiltAnalyzerProvider ( name , AnalyzerScope . INDICES , analyzer ) ; } } return analyzerProvider ; } public Analyzer analyzer ( ) { } }
public class TransportCountAction extends TransportBroadcastOperationAction < CountRequest , CountResponse , ShardCountRequest , ShardCountResponse > { private final IndicesService indicesService ; private final ScriptService scriptService ; @ Inject public TransportCountAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService , ScriptService scriptService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected CountRequest newRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ShardRouting shard , CountRequest request ) { } @ Override protected ShardCountResponse newShardResponse ( ) { } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , CountRequest request , String [ ] concreteIndices ) { Map < String , Set < String > > routingMap = clusterState . metaData ( ) . resolveSearchRouting ( request . routing ( ) , request . indices ( ) ) ; <START_BUG> return clusterService . operationRouting ( ) . searchShards ( clusterState , request . indices ( ) , concreteIndices , routingMap , null ) ; <END_BUG> } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , CountRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , CountRequest countRequest , String [ ] concreteIndices ) { } @ Override protected CountResponse newResponse ( CountRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardCountResponse shardOperation ( ShardCountRequest request ) throws ElasticSearchException { } }
public class RestAnalyzeAction extends BaseRestHandler { @ Inject public RestAnalyzeAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { String text = request . param ( "text" ) ; if ( ( text == null ) && ( request . hasContent ( ) ) ) { text = request . content ( ) . toUtf8 ( ) ; } if ( text == null ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , new ElasticSearchIllegalArgumentException ( "text<seq2seq4repair_space>is<seq2seq4repair_space>missing" ) ) ) ; } catch ( IOException e1 ) { logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>response" , e1 ) ; } return ; } AnalyzeRequest analyzeRequest = new AnalyzeRequest ( request . param ( "index" ) , text ) ; analyzeRequest . listenerThreaded ( false ) ; analyzeRequest . preferLocal ( request . paramAsBoolean ( "prefer_local" , analyzeRequest . preferLocalShard ( ) ) ) ; analyzeRequest . analyzer ( request . param ( "analyzer" ) ) ; analyzeRequest . field ( request . param ( "field" ) ) ; analyzeRequest . tokenizer ( request . param ( "tokenizer" ) ) ; analyzeRequest . tokenFilters ( request . paramAsStringArray ( "token_filters" , request . paramAsStringArray ( "filters" , null ) ) ) ; client . admin ( ) . indices ( ) . analyze ( analyzeRequest , new org . elasticsearch . action . ActionListener < AnalyzeResponse > ( ) { @ Override public void onResponse ( AnalyzeResponse response ) { try { XContentBuilder builder = restContentBuilder ( request , false ) ; builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class BinaryLoader { private final LoaderCallback < BinaryLoader . Blob > callback ; public BinaryLoader ( String url , LoaderCallback < BinaryLoader . Blob > callback ) { } private native void overrideMimeType ( XMLHttpRequest req , String mimeType ) { } public static final class Blob { final String data ; public Blob ( String data ) { } public int length ( ) { } public byte get ( int i ) { } private native byte get ( String s , int i ) { } public InputStream read ( ) { return new BinaryLoader . BlobInputStream ( this ) ; } } private static class BlobInputStream extends InputStream { BinaryLoader . Blob blob ; int pos ; public BlobInputStream ( BinaryLoader . Blob blob ) { } @ Override public int read ( ) throws IOException { if ( ( pos ) == ( blob . length ( ) ) ) return - 1 ; <START_BUG> return blob . get ( ( ( pos ) ++ ) ) ; <END_BUG> } } }
public class BulletEntity extends BaseEntity { private static final Matrix4 tmpM = new Matrix4 ( ) ; public BulletEntity . MotionState motionState ; public btCollisionObject body ; public BulletEntity ( final Model model , final btRigidBodyConstructionInfo bodyInfo , final float x , final float y , final float z ) { } public BulletEntity ( final Model model , final btRigidBodyConstructionInfo bodyInfo , final Matrix4 transform ) { } public BulletEntity ( final Model model , final btCollisionObject body , final float x , final float y , final float z ) { } public BulletEntity ( final Model model , final btCollisionObject body , final Matrix4 transform ) { } @ Override public void dispose ( ) { if ( ( motionState ) != null ) motionState . dispose ( ) ; if ( ( body ) != null ) <START_BUG> body . dispose ( ) ; <END_BUG> motionState = null ; body = null ; } static class MotionState extends btMotionState implements Disposable { private final Matrix4 transform ; public MotionState ( final Matrix4 transform ) { } @ Override public void getWorldTransform ( final Matrix4 worldTrans ) { } @ Override public void setWorldTransform ( final Matrix4 worldTrans ) { } @ Override public void dispose ( ) { delete ( ) ; } } }
public class IndicesFieldDataCacheListener implements IndexFieldDataCache . Listener { private final CircuitBreakerService circuitBreakerService ; @ Inject public IndicesFieldDataCacheListener ( CircuitBreakerService circuitBreakerService ) { } @ Override public void onLoad ( FieldMapper . Names fieldNames , FieldDataType fieldDataType , AtomicFieldData fieldData ) { } @ Override public void onUnload ( FieldMapper . Names fieldNames , FieldDataType fieldDataType , boolean wasEvicted , long sizeInBytes , @ Nullable AtomicFieldData fieldData ) { <START_BUG> assert sizeInBytes > 0 : ( "When<seq2seq4repair_space>reducing<seq2seq4repair_space>circuit<seq2seq4repair_space>breaker,<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>adjusted<seq2seq4repair_space>with<seq2seq4repair_space>a<seq2seq4repair_space>positive<seq2seq4repair_space>number<seq2seq4repair_space>and<seq2seq4repair_space>not<seq2seq4repair_space>[" + sizeInBytes ) + "]" ; <END_BUG> circuitBreakerService . getBreaker ( ) . addWithoutBreaking ( ( - sizeInBytes ) ) ; } }
public final class ClassReflection { public static Class forName ( String name ) throws ReflectionException { } public static String getSimpleName ( Class c ) { <START_BUG> return c . getSimpleName ( ) ; <END_BUG> } public static boolean isInstance ( Class c , Object obj ) { } public static boolean isAssignableFrom ( Class c1 , Class c2 ) { } public static boolean isMemberClass ( Class c ) { } public static boolean isStaticClass ( Class c ) { } public static < T > T newInstance ( Class < T > c ) throws ReflectionException { } public static Constructor [ ] getConstructors ( Class c ) { } public static Constructor getConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Constructor getDeclaredConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getMethods ( Class c ) { } public static Method getMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getDeclaredMethods ( Class c ) { } public static Method getDeclaredMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Field [ ] getFields ( Class c ) { } public static Field getField ( Class c , String name ) throws ReflectionException { } public static Field [ ] getDeclaredFields ( Class c ) { } public static Field getDeclaredField ( Class c , String name ) throws ReflectionException { } }
public final class WindowedMean { float [ ] values ; int added_values = 0 ; int last_value ; float mean = 0 ; boolean dirty = true ; public WindowedMean ( int window_size ) { } public boolean hasEnoughData ( ) { } public void clear ( ) { } public void addValue ( float value ) { } public float getMean ( ) { } public float getOldest ( ) { } public float getLatest ( ) { } public float standardDeviation ( ) { if ( ! ( hasEnoughData ( ) ) ) return 0 ; float mean = getMean ( ) ; float sum = 0 ; for ( int i = 0 ; i < ( values . length ) ; i ++ ) { sum += ( ( values [ i ] ) - mean ) * ( ( values [ i ] ) - mean ) ; } <START_BUG> return ( ( float ) ( Math . sqrt ( ( sum / ( values . length ) ) ) ) ) ; <END_BUG> } }
public class RobinEngine extends AbstractIndexShardComponent implements Engine , ScheduledRefreshableEngine { private volatile ByteSizeValue indexingBufferSize ; private final boolean compoundFormat ; private final int termIndexInterval ; private final int termIndexDivisor ; private final TimeValue refreshInterval ; private final ReadWriteLock rwl = new ReentrantReadWriteLock ( ) ; private final AtomicBoolean refreshMutex = new AtomicBoolean ( ) ; private final AtomicBoolean optimizeMutex = new AtomicBoolean ( ) ; private final Store store ; private final SnapshotDeletionPolicy deletionPolicy ; private final Translog translog ; private final MergePolicyProvider mergePolicyProvider ; private final MergeSchedulerProvider mergeScheduler ; private final AnalysisService analysisService ; private final SimilarityService similarityService ; private final BloomCache bloomCache ; private final boolean asyncLoadBloomFilter ; private IndexWriter indexWriter ; private volatile AcquirableResource < ReaderSearcherHolder > nrtResource ; private volatile boolean closed = false ; private volatile boolean dirty = false ; private volatile int disableFlushCounter = 0 ; private volatile Searcher postFlushSearcher ; private final AtomicBoolean flushing = new AtomicBoolean ( ) ; private final ConcurrentMap < String , RobinEngine . VersionValue > versionMap ; private final Object [ ] dirtyLocks ; @ Inject public RobinEngine ( ShardId shardId , @ IndexSettings Settings indexSettings , Store store , SnapshotDeletionPolicy deletionPolicy , Translog translog , MergePolicyProvider mergePolicyProvider , MergeSchedulerProvider mergeScheduler , AnalysisService analysisService , SimilarityService similarityService , BloomCache bloomCache ) throws EngineException { } @ Override public void updateIndexingBufferSize ( ByteSizeValue indexingBufferSize ) { } @ Override public void start ( ) throws EngineException { } @ Override public TimeValue refreshInterval ( ) { } @ Override public EngineException [ ] bulk ( Bulk bulk ) throws EngineException { } @ Override public void create ( Create create ) throws EngineException { } private void innerCreate ( Create create , IndexWriter writer ) throws IOException { } @ Override public void index ( Index index ) throws EngineException { } private void innerIndex ( Index index , IndexWriter writer ) throws IOException { } @ Override public void delete ( Delete delete ) throws EngineException { } private void innerDelete ( Delete delete , IndexWriter writer ) throws IOException { } @ Override public void delete ( DeleteByQuery delete ) throws EngineException { } @ Override public Searcher searcher ( ) throws EngineException { } @ Override public ByteSizeValue estimateFlushableMemorySize ( ) { rwl . readLock ( ) . lock ( ) ; try { long bytes = IndexWriters . estimateRamSize ( indexWriter ) ; <START_BUG> bytes += translog . estimateMemorySize ( ) . bytes ( ) ; <END_BUG> return new ByteSizeValue ( bytes ) ; } catch ( Exception e ) { return null ; } finally { rwl . readLock ( ) . unlock ( ) ; } } @ Override public void refresh ( Refresh refresh ) throws EngineException { } @ Override public void flush ( Flush flush ) throws EngineException { } @ Override public void optimize ( Optimize optimize ) throws EngineException { } @ Override public < T > T snapshot ( SnapshotHandler < T > snapshotHandler ) throws EngineException { } @ Override public void recover ( RecoveryHandler recoveryHandler ) throws EngineException { } @ Override public void close ( ) throws ElasticSearchException { } private Object dirtyLock ( Term uid ) { } private long loadCurrentVersionFromIndex ( Term uid ) { } private IndexWriter createWriter ( ) throws IOException { } private AcquirableResource < ReaderSearcherHolder > buildNrtResource ( IndexWriter indexWriter ) throws IOException { } private long newTransactionLogId ( ) throws IOException { } private static class RobinSearchResult implements Searcher { private final AcquirableResource < ReaderSearcherHolder > nrtHolder ; private RobinSearchResult ( AcquirableResource < ReaderSearcherHolder > nrtHolder ) { } @ Override public IndexReader reader ( ) { } @ Override public ExtendedIndexSearcher searcher ( ) { } @ Override public boolean release ( ) throws ElasticSearchException { } } static class VersionValue { private long version ; private final boolean delete ; VersionValue ( long version , boolean delete ) { } public long version ( ) { } public boolean delete ( ) { } } }
public final class AndroidLocklessInput implements SensorEventListener , OnKeyListener , OnTouchListener , Input { static class KeyEvent { static final int KEY_DOWN = 0 ; static final int KEY_UP = 1 ; static final int KEY_TYPED = 2 ; long timeStamp ; int type ; int keyCode ; char keyChar ; } static class TouchEvent { static final int TOUCH_DOWN = 0 ; static final int TOUCH_UP = 1 ; static final int TOUCH_DRAGGED = 2 ; long timeStamp ; int type ; int x ; int y ; int pointer ; } AtomicQueue < AndroidLocklessInput . KeyEvent > keyEvents = new AtomicQueue < AndroidLocklessInput . KeyEvent > ( 64 ) ; AtomicQueue < AndroidLocklessInput . KeyEvent > freeKeyEvents = new AtomicQueue < AndroidLocklessInput . KeyEvent > ( 64 ) ; AtomicQueue < AndroidLocklessInput . TouchEvent > touchEvents = new AtomicQueue < AndroidLocklessInput . TouchEvent > ( 64 ) ; AtomicQueue < AndroidLocklessInput . TouchEvent > freeTouchEvents = new AtomicQueue < AndroidLocklessInput . TouchEvent > ( 64 ) ; int [ ] touchX = new int [ 10 ] ; int [ ] touchY = new int [ 10 ] ; boolean [ ] touched = new boolean [ 10 ] ; final boolean hasMultitouch ; private HashSet < Integer > keys = new HashSet < Integer > ( ) ; private SensorManager manager ; public boolean accelerometerAvailable = false ; private final float [ ] accelerometerValues = new float [ 3 ] ; private String text = null ; private TextInputListener textListener = null ; private Handler handle ; final AndroidApplication app ; private final AndroidLocklessTouchHandler touchHandler ; private int sleepTime = 0 ; private boolean catchBack = false ; private Vibrator vibrator ; private final boolean compassAvailable ; private final float [ ] magneticFieldValues = new float [ 3 ] ; private float azimuth = 0 ; private float pitch = 0 ; private float roll = 0 ; private float inclination = 0 ; private boolean justTouched = false ; boolean keyboardAvailable ; private InputProcessor processor ; public AndroidLocklessInput ( AndroidApplication activity , View view , int sleepTime ) { } @ Override public float getAccelerometerX ( ) { } @ Override public float getAccelerometerY ( ) { } @ Override public float getAccelerometerZ ( ) { } @ Override public void getTextInput ( final TextInputListener listener , final String title , final String text ) { } @ Override public int getX ( ) { } @ Override public int getY ( ) { } @ Override public int getX ( int pointer ) { } @ Override public int getY ( int pointer ) { } public boolean isTouched ( int pointer ) { } @ Override public boolean isKeyPressed ( int key ) { } @ Override public boolean isTouched ( ) { } public void setInputProcessor ( InputProcessor processor ) { } @ Override public InputProcessor getInputProcessor ( ) { } void processEvents ( ) { } boolean requestFocus = true ; @ Override public boolean onTouch ( View view , MotionEvent event ) { } @ Override public boolean onKey ( View v , int keyCode , android . view . KeyEvent e ) { } @ Override public void onAccuracyChanged ( Sensor arg0 , int arg1 ) { } @ Override public void onSensorChanged ( SensorEvent event ) { } @ Override public void setOnscreenKeyboardVisible ( boolean visible ) { } @ Override public void setCatchBackKey ( boolean catchBack ) { } @ Override public void vibrate ( int milliseconds ) { } @ Override public void vibrate ( long [ ] pattern , int repeat ) { } @ Override public void cancelVibrate ( ) { } @ Override public boolean justTouched ( ) { } @ Override public boolean isButtonPressed ( int button ) { } final float [ ] R = new float [ 9 ] ; final float [ ] orientation = new float [ 3 ] ; private void updateOrientation ( ) { } @ Override public float getAzimuth ( ) { } @ Override public float getPitch ( ) { } @ Override public float getRoll ( ) { } @ Override public boolean isPeripheralAvailable ( Peripheral peripheral ) { if ( peripheral == ( Peripheral . Accelerometer ) ) return accelerometerAvailable ; if ( peripheral == ( Peripheral . Compass ) ) return compassAvailable ; if ( peripheral == ( Peripheral . HardwareKeyboard ) ) return keyboardAvailable ; if ( peripheral == ( Peripheral . OnscreenKeyboard ) ) return true ; if ( peripheral == ( Peripheral . Vibrator ) ) return ( vibrator ) != null ; if ( peripheral == ( Peripheral . MultitouchScreen ) ) <START_BUG> return ( touchHandler ) instanceof AndroidMultiTouchHandler ; <END_BUG> return false ; } }
public class BlobStoreSnapshot implements Snapshot { private final String name ; private final Version version ; private final SnapshotState state ; private final String reason ; private final ImmutableList < String > indices ; private final long startTime ; private final long endTime ; private final int totalShard ; private final int successfulShards ; private final ImmutableList < SnapshotShardFailure > shardFailures ; private BlobStoreSnapshot ( String name , ImmutableList < String > indices , SnapshotState state , String reason , Version version , long startTime , long endTime , int totalShard , int successfulShards , ImmutableList < SnapshotShardFailure > shardFailures ) { } @ Override public String name ( ) { } @ Override public SnapshotState state ( ) { } @ Override public String reason ( ) { } @ Override public Version version ( ) { } @ Override public ImmutableList < String > indices ( ) { } @ Override public long startTime ( ) { } @ Override public long endTime ( ) { } @ Override public int totalShard ( ) { } @ Override public int successfulShards ( ) { } @ Override public ImmutableList < SnapshotShardFailure > shardFailures ( ) { } public static BlobStoreSnapshot . Builder builder ( ) { } @ Override public int compareTo ( Snapshot o ) { <START_BUG> return Longs . compare ( startTime , ( ( BlobStoreSnapshot ) ( o ) ) . startTime ) ; <END_BUG> } public static class Builder { private String name ; private Version version = Version . CURRENT ; private SnapshotState state = SnapshotState . IN_PROGRESS ; private String reason ; private ImmutableList < String > indices ; private long startTime ; private long endTime ; private int totalShard ; private int successfulShards ; private ImmutableList < SnapshotShardFailure > shardFailures = ImmutableList . of ( ) ; public BlobStoreSnapshot . Builder snapshot ( BlobStoreSnapshot snapshot ) { } public BlobStoreSnapshot . Builder name ( String name ) { } public BlobStoreSnapshot . Builder indices ( Collection < String > indices ) { } public BlobStoreSnapshot . Builder indices ( String [ ] indices ) { } public BlobStoreSnapshot . Builder state ( SnapshotState state ) { } public BlobStoreSnapshot . Builder reason ( String reason ) { } public BlobStoreSnapshot . Builder success ( ) { } public BlobStoreSnapshot . Builder failed ( String reason ) { } public BlobStoreSnapshot . Builder version ( Version version ) { } public BlobStoreSnapshot . Builder startTime ( long startTime ) { } public BlobStoreSnapshot . Builder endTime ( long endTime ) { } public BlobStoreSnapshot . Builder totalShard ( int totalShard ) { } public BlobStoreSnapshot . Builder successfulShards ( int successfulShards ) { } public BlobStoreSnapshot . Builder shardFailures ( ImmutableList < SnapshotShardFailure > shardFailures ) { } public BlobStoreSnapshot . Builder failures ( int totalShard , ImmutableList < SnapshotShardFailure > shardFailures ) { } public BlobStoreSnapshot build ( ) { } static final class Fields { static final XContentBuilderString SNAPSHOT = new XContentBuilderString ( "snapshot" ) ; static final XContentBuilderString NAME = new XContentBuilderString ( "name" ) ; static final XContentBuilderString VERSION_ID = new XContentBuilderString ( "version_id" ) ; static final XContentBuilderString INDICES = new XContentBuilderString ( "indices" ) ; static final XContentBuilderString STATE = new XContentBuilderString ( "state" ) ; static final XContentBuilderString REASON = new XContentBuilderString ( "reason" ) ; static final XContentBuilderString START_TIME = new XContentBuilderString ( "start_time" ) ; static final XContentBuilderString END_TIME = new XContentBuilderString ( "end_time" ) ; static final XContentBuilderString TOTAL_SHARDS = new XContentBuilderString ( "total_shards" ) ; static final XContentBuilderString SUCCESSFUL_SHARDS = new XContentBuilderString ( "successful_shards" ) ; static final XContentBuilderString FAILURES = new XContentBuilderString ( "failures" ) ; } public static void toXContent ( BlobStoreSnapshot snapshot , XContentBuilder builder , ToXContent . Params params ) throws IOException { } public static BlobStoreSnapshot fromXContent ( XContentParser parser ) throws IOException { } } }
public class LocalTransport extends AbstractLifecycleComponent < Transport > implements Transport { private final ThreadPool threadPool ; private volatile TransportServiceAdapter transportServiceAdapter ; private volatile BoundTransportAddress boundAddress ; private volatile LocalTransportAddress localAddress ; private static final ConcurrentMap < TransportAddress , LocalTransport > transports = newConcurrentMap ( ) ; private static final AtomicLong transportAddressIdGenerator = new AtomicLong ( ) ; private final ConcurrentMap < DiscoveryNode , LocalTransport > connectedNodes = newConcurrentMap ( ) ; public LocalTransport ( ThreadPool threadPool ) { } @ Inject public LocalTransport ( Settings settings , ThreadPool threadPool ) { } @ Override public TransportAddress [ ] addressesFromString ( String address ) { } @ Override public boolean addressSupported ( Class < ? extends TransportAddress > address ) { } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } @ Override public void transportServiceAdapter ( TransportServiceAdapter transportServiceAdapter ) { } @ Override public BoundTransportAddress boundAddress ( ) { } @ Override public boolean nodeConnected ( DiscoveryNode node ) { } @ Override public void connectToNodeLight ( DiscoveryNode node ) throws ConnectTransportException { } @ Override public void connectToNode ( DiscoveryNode node ) throws ConnectTransportException { } @ Override public void disconnectFromNode ( DiscoveryNode node ) { } @ Override public long serverOpen ( ) { } @ Override public < T extends Streamable > void sendRequest ( final DiscoveryNode node , final long requestId , final String action , final Streamable message , TransportRequestOptions options ) throws IOException , TransportException { } ThreadPool threadPool ( ) { } void messageReceived ( byte [ ] data , String action , LocalTransport sourceTransport , @ Nullable final Long sendRequestId ) { } private void handleRequest ( StreamInput stream , long requestId , LocalTransport sourceTransport ) throws Exception { } private void handleResponse ( StreamInput buffer , final TransportResponseHandler handler ) { } private void handlerResponseError ( StreamInput buffer , final TransportResponseHandler handler ) { Throwable error ; try { <START_BUG> ThrowableObjectInputStream ois = new ThrowableObjectInputStream ( buffer ) ; <END_BUG> error = ( ( Throwable ) ( ois . readObject ( ) ) ) ; } catch ( Exception e ) { error = new TransportSerializationException ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>deserialize<seq2seq4repair_space>exception<seq2seq4repair_space>response<seq2seq4repair_space>from<seq2seq4repair_space>stream" , e ) ; } handleException ( handler , error ) ; } private void handleException ( final TransportResponseHandler handler , Throwable error ) { } }
public class RestNodesStatsAction extends BaseRestHandler { @ Inject public RestNodesStatsAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } void executeNodeStats ( final RestRequest request , final RestChannel channel , final NodesStatsRequest nodesStatsRequest ) { nodesStatsRequest . listenerThreaded ( false ) ; client . admin ( ) . cluster ( ) . nodesStats ( nodesStatsRequest , new org . elasticsearch . action . ActionListener < NodesStatsResponse > ( ) { @ Override public void onResponse ( NodesStatsResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } class RestIndicesHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestOsHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestProcessHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestJvmHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestThreadPoolHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestNetworkHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestFsHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestTransportHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } class RestHttpHandler implements RestHandler { @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { } } }
public static final int V_0_18_2_ID = 180299 ; public static final Version V_0_18_2 = new Version ( Version . V_0_18_2_ID , false ) ; public static final int V_0_18_3_ID = 180399 ; public static final Version V_0_18_3 = new Version ( Version . V_0_18_3_ID , false ) ; public static final int V_0_18_4_ID = 180499 ; public static final Version V_0_18_4 = new Version ( Version . V_0_18_4_ID , false ) ; public static final int V_0_18_5_ID = 180599 ; public static final Version V_0_18_5 = new Version ( Version . V_0_18_5_ID , false ) ; public static final int V_0_18_6_ID = 180699 ; public static final Version V_0_18_6 = new Version ( Version . V_0_18_6_ID , false ) ; public static final int V_0_18_7_ID = 180799 ; public static final Version V_0_18_7 = new Version ( Version . V_0_18_7_ID , false ) ; public static final int V_0_18_8_ID = 180899 ; public static final Version V_0_18_8 = new Version ( Version . V_0_18_8_ID , false ) ; public static final int V_0_19_0_RC1_ID = 190051 ; public static final Version V_0_19_0_RC1 = new Version ( Version . V_0_19_0_RC1_ID , false ) ; public static final int V_0_19_0_RC2_ID = 190052 ; public static final Version V_0_19_0_RC2 = new Version ( Version . V_0_19_0_RC2_ID , false ) ; public static final int V_0_19_0_RC3_ID = 190053 ; public static final Version V_0_19_0_RC3 = new Version ( Version . V_0_19_0_RC3_ID , false ) ; public static final int V_0_19_0_ID = 190099 ; public static final Version V_0_19_0 = new Version ( Version . V_0_19_0_ID , false ) ; public static final int V_0_19_1_ID = 190199 ; public static final Version V_0_19_1 = new Version ( Version . V_0_19_1_ID , false ) ; public static final int V_0_19_2_ID = 190299 ; public static final Version V_0_19_2 = new Version ( Version . V_0_19_2_ID , false ) ; public static final int V_0_19_3_ID = 190399 ; public static final Version V_0_19_3 = new Version ( Version . V_0_19_3_ID , false ) ; public static final int V_0_19_4_ID = 190499 ; public static final Version V_0_19_4 = new Version ( Version . V_0_19_4_ID , false ) ; public static final int V_0_19_5_ID = 190599 ; public static final Version V_0_19_5 = new Version ( Version . V_0_19_5_ID , false ) ; public static final int V_0_19_6_ID = 190699 ; public static final Version V_0_19_6 = new Version ( Version . V_0_19_6_ID , false ) ; public static final int V_0_19_7_ID = 190799 ; public static final Version V_0_19_7 = new Version ( Version . V_0_19_7_ID , false ) ; public static final int V_0_19_8_ID = 190899 ; public static final Version V_0_19_8 = new Version ( Version . V_0_19_8_ID , false ) ; public static final int V_0_19_9_ID = 190999 ; public static final Version V_0_19_9 = new Version ( Version . V_0_19_9_ID , false ) ; public static final int V_0_19_10_ID = 191099 ; public static final Version V_0_19_10 = new Version ( Version . V_0_19_10_ID , false ) ; public static final int V_0_19_11_ID = 191199 ; public static final Version V_0_19_11 = new Version ( Version . V_0_19_11_ID , false ) ; public static final int V_0_19_12_ID = 191299 ; public static final Version V_0_19_12 = new Version ( Version . V_0_19_12_ID , false ) ; public static final int V_0_19_13_ID = 191399 ; public static final Version V_0_19_13 = new Version ( Version . V_0_19_13_ID , false ) ; public static final int V_0_20_0_RC1_ID = 200051 ; public static final Version V_0_20_0_RC1 = new Version ( Version . V_0_20_0_RC1_ID , false ) ; public static final int V_0_20_0_ID = 200099 ; public static final Version V_0_20_0 = new Version ( Version . V_0_20_0_ID , false ) ; public static final int V_0_20_1_ID = 200199 ; public static final Version V_0_20_1 = new Version ( Version . V_0_20_1_ID , false ) ; public static final int V_0_20_2_ID = 200299 ; public static final Version V_0_20_2 = new Version ( Version . V_0_20_2_ID , false ) ; public static final int V_0_20_3_ID = 200399 ; public static final Version V_0_20_3 = new Version ( Version . V_0_20_3_ID , false ) ; public static final int V_0_20_4_ID = 200499 ; public static final Version V_0_20_4 = new Version ( Version . V_0_20_4_ID , false ) ; public static final int V_0_20_5_ID = 200599 ; public static final Version V_0_20_5 = new Version ( Version . V_0_20_5_ID , false ) ; public static final int V_0_21_0_Beta1_ID = 210001 ; public static final Version V_0_21_0_Beta1 = new Version ( Version . V_0_21_0_Beta1_ID , true ) ; public static final Version CURRENT = Version . V_0_21_0_Beta1 ; public static Version readVersion ( StreamInput in ) throws IOException { } public static Version fromId ( int id ) { } public static void writeVersion ( Version version , StreamOutput out ) throws IOException { } public final int id ; public final byte major ; public final byte minor ; public final byte revision ; public final byte build ; public final Boolean snapshot ; Version ( int id , @ Nullable Boolean snapshot ) { } public boolean snapshot ( ) { } public boolean after ( Version version ) { } public boolean onOrAfter ( Version version ) { } public boolean before ( Version version ) { } public boolean onOrBefore ( Version version ) { } public String number ( ) { } public static void main ( String [ ] args ) { <START_BUG> System . out . println ( ( ( ( "ElasticSearch<seq2seq4repair_space>Version:<seq2seq4repair_space>" + ( Version . CURRENT ) ) + ",<seq2seq4repair_space>JVM:<seq2seq4repair_space>" ) + ( JvmInfo . jvmInfo ( ) . vmVersion ( ) ) ) ) ; <END_BUG> } @ Override public String toString ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } }
public class CircularFloatBuffer { private final float [ ] buffer ; private int writePosition ; private int readPosition ; private int available ; public final int size ; public CircularFloatBuffer ( int size ) { } public void write ( float [ ] data , int offset , int count ) { } public void combine ( float [ ] data , int offset , int count ) { } public int read ( float [ ] data , int offset , int count ) { } public int skip ( int count ) { <START_BUG> int total = count = Math . min ( available , count ) ; <END_BUG> available -= total ; readPosition = ( ( readPosition ) + total ) % ( buffer . length ) ; return total ; } public void clear ( ) { } public void setWritePosition ( int writePosition ) { } public int getWritePosition ( ) { } public void setReadPosition ( int readPosition ) { } public int getReadPosition ( ) { } public int getAvailable ( ) { } private void dump ( ) { } private static void combine ( float [ ] src , int srcPos , float [ ] dest , int destPos , int length ) { } }
public class BulkRequestTests extends ElasticsearchTestCase { @ Test public void testSimpleBulk1 ( ) throws Exception { } @ Test public void testSimpleBulk2 ( ) throws Exception { } @ Test public void testSimpleBulk3 ( ) throws Exception { } @ Test public void testSimpleBulk4 ( ) throws Exception { } @ Test public void testBulkAllowExplicitIndex ( ) throws Exception { String bulkAction = copyToStringFromClasspath ( "/org/elasticsearch/action/bulk/simple-bulk.json" ) ; try { new BulkRequest ( ) . add ( new BytesArray ( bulkAction . getBytes ( Charsets . UTF_8 ) ) , true , null , null , false ) ; <START_BUG> assert false ; <END_BUG> } catch ( Exception e ) { } bulkAction = copyToStringFromClasspath ( "/org/elasticsearch/action/bulk/simple-bulk5.json" ) ; new BulkRequest ( ) . add ( new BytesArray ( bulkAction . getBytes ( Charsets . UTF_8 ) ) , true , "test" , null , false ) ; } }
public class CharArray { public char [ ] items ; public int size ; public boolean ordered ; public CharArray ( ) { } public CharArray ( int capacity ) { } public CharArray ( boolean ordered , int capacity ) { } public CharArray ( CharArray array ) { } public CharArray ( char [ ] array ) { } public CharArray ( boolean ordered , char [ ] array , int startIndex , int count ) { } public void add ( char value ) { } public void addAll ( CharArray array ) { } public void addAll ( CharArray array , int offset , int length ) { } public void addAll ( char [ ] array ) { } public void addAll ( char [ ] array , int offset , int length ) { char [ ] items = this . items ; <START_BUG> int sizeNeeded = ( ( size ) + length ) - offset ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public char get ( int index ) { } public void set ( int index , char value ) { } public void insert ( int index , char value ) { } public void swap ( int first , int second ) { } public boolean contains ( char value ) { } public int indexOf ( char value ) { } public int lastIndexOf ( char value ) { } public boolean removeValue ( char value ) { } public char removeIndex ( int index ) { } public boolean removeAll ( CharArray array ) { } public char pop ( ) { } public char peek ( ) { } public char first ( ) { } public void clear ( ) { } public void shrink ( ) { } public char [ ] ensureCapacity ( int additionalCapacity ) { } protected char [ ] resize ( int newSize ) { } public void sort ( ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public char random ( ) { } public char [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class DummyCircuitBreakerService implements CircuitBreakerService { private final ESLogger logger = Loggers . getLogger ( DummyCircuitBreakerService . class ) ; private final MemoryCircuitBreaker breaker = new MemoryCircuitBreaker ( new ByteSizeValue ( Long . MAX_VALUE ) , 0.0 , logger ) ; public DummyCircuitBreakerService ( ) { } @ Override public MemoryCircuitBreaker getBreaker ( ) { } @ Override public FieldDataBreakerStats stats ( ) { <START_BUG> return new FieldDataBreakerStats ( ( - 1 ) , ( - 1 ) , 0 ) ; <END_BUG> } }
public class LwjglAWTCanvas implements Application { final LwjglGraphics graphics ; final OpenALAudio audio ; final LwjglFiles files ; final LwjglAWTInput input ; final LwjglNet net ; final ApplicationListener listener ; final AWTGLCanvas canvas ; final List < Runnable > runnables = new ArrayList ( ) ; final List < Runnable > executedRunnables = new ArrayList ( ) ; final Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; boolean running = true ; int lastWidth ; int lastHeight ; int logLevel = LOG_INFO ; private Cursor cursor ; public LwjglAWTCanvas ( ApplicationListener listener , boolean useGL2 ) { } public LwjglAWTCanvas ( ApplicationListener listener , boolean useGL2 , LwjglAWTCanvas sharedContextCanvas ) { } protected void setDisplayMode ( int width , int height ) { } protected void setTitle ( String title ) { } @ Override public ApplicationListener getApplicationListener ( ) { } public Canvas getCanvas ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Files getFiles ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Input getInput ( ) { } @ Override public Net getNet ( ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { } void setGlobals ( ) { } void create ( ) { } void render ( ) { } protected void start ( ) { } protected void resize ( int width , int height ) { } protected void stopped ( ) { } public void stop ( ) { } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } Map < String , Preferences > preferences = new HashMap < String , Preferences > ( ) ; @ Override public Preferences getPreferences ( String name ) { if ( preferences . containsKey ( name ) ) { return preferences . get ( name ) ; } else { <START_BUG> Preferences prefs = new LwjglPreferences ( name , ".prefs/" ) ; <END_BUG> preferences . put ( name , prefs ) ; return prefs ; } } @ Override public Clipboard getClipboard ( ) { } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } public void log ( String tag , String message ) { } @ Override public void log ( String tag , String message , Throwable exception ) { } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public int getLogLevel ( ) { } @ Override public void exit ( ) { } public void makeCurrent ( ) { } public boolean isCurrent ( ) { } public void setCursor ( Cursor cursor ) { } @ Override public void addLifecycleListener ( LifecycleListener listener ) { } @ Override public void removeLifecycleListener ( LifecycleListener listener ) { } }
public class SearchContext implements Releasable { private final long id ; private final SearchShardTarget shardTarget ; private final Searcher engineSearcher ; private final IndexService indexService ; private final ContextIndexSearcher searcher ; private final DfsSearchResult dfsResult ; private final QuerySearchResult queryResult ; private final FetchSearchResult fetchResult ; private final TimeValue timeout ; private float queryBoost = 1.0F ; private Scroll scroll ; private boolean explain ; private String [ ] fieldNames ; private int from = - 1 ; private int size = - 1 ; private String [ ] types ; private Sort sort ; private String queryParserName ; private Query query ; private int [ ] docIdsToLoad ; private SearchContextFacets facets ; private SearchContextHighlight highlight ; private boolean queryRewritten ; private volatile TimeValue keepAlive ; private volatile long lastAccessTime ; private volatile Timeout keepAliveTimeout ; public SearchContext ( long id , SearchShardTarget shardTarget , TimeValue timeout , String [ ] types , Engine . Searcher engineSearcher , IndexService indexService ) { } @ Override public boolean release ( ) throws ElasticSearchException { } public long id ( ) { } public SearchShardTarget shardTarget ( ) { } public String [ ] types ( ) { } public float queryBoost ( ) { } public SearchContext queryBoost ( float queryBoost ) { } public Scroll scroll ( ) { } public SearchContext scroll ( Scroll scroll ) { } public SearchContextFacets facets ( ) { } public SearchContext facets ( SearchContextFacets facets ) { } public SearchContextHighlight highlight ( ) { } public void highlight ( SearchContextHighlight highlight ) { } public ContextIndexSearcher searcher ( ) { } public IndexQueryParser queryParser ( ) throws IndexQueryParserMissingException { } public MapperService mapperService ( ) { } public IndexQueryParserService queryParserService ( ) { } public SimilarityService similarityService ( ) { } public FilterCache filterCache ( ) { <START_BUG> return indexService . filterCache ( ) ; <END_BUG> } public TimeValue timeout ( ) { } public SearchContext sort ( Sort sort ) { } public Sort sort ( ) { } public String queryParserName ( ) { } public SearchContext queryParserName ( String queryParserName ) { } public SearchContext query ( Query query ) { } public Query query ( ) { } public int from ( ) { } public SearchContext from ( int from ) { } public int size ( ) { } public SearchContext size ( int size ) { } public String [ ] fieldNames ( ) { } public SearchContext fieldNames ( String [ ] fieldNames ) { } public boolean explain ( ) { } public void explain ( boolean explain ) { } public SearchContext rewriteQuery ( ) throws IOException { } public int [ ] docIdsToLoad ( ) { } public SearchContext docIdsToLoad ( int [ ] docIdsToLoad ) { } public void accessed ( long accessTime ) { } public long lastAccessTime ( ) { } public TimeValue keepAlive ( ) { } public void keepAlive ( TimeValue keepAlive ) { } public void keepAliveTimeout ( Timeout keepAliveTimeout ) { } public DfsSearchResult dfsResult ( ) { } public QuerySearchResult queryResult ( ) { } public FetchSearchResult fetchResult ( ) { } }
public class DoubleTermsAggregator extends LongTermsAggregator { public DoubleTermsAggregator ( String name , AggregatorFactories factories , ValuesSource . Numeric valuesSource , @ Nullable ValueFormat format , long estimatedBucketCount , Terms . Order order , BucketCountThresholds bucketCountThresholds , AggregationContext aggregationContext , Aggregator parent , SubAggCollectionMode collectionMode , boolean showTermDocCountError , IncludeExclude . LongFilter longFilter ) { } @ Override protected SortedNumericDocValues getValues ( Numeric valuesSource ) { } @ Override public DoubleTerms buildAggregation ( long owningBucketOrdinal ) { } @ Override public DoubleTerms buildEmptyAggregation ( ) { } private static Bucket convertToDouble ( InternalTerms . Bucket bucket ) { final long term = bucket . getKeyAsNumber ( ) . longValue ( ) ; final double value = NumericUtils . sortableLongToDouble ( term ) ; <START_BUG> return new DoubleTerms . Bucket ( value , bucket . docCount , bucket . aggregations , bucket . showDocCountError , bucket . docCountError ) ; <END_BUG> } private static DoubleTerms convertToDouble ( LongTerms terms ) { } }
public class JsonShortFieldMapper extends JsonNumberFieldMapper < Short > { public static final String JSON_TYPE = "short" ; public static class Defaults extends JsonNumberFieldMapper . Defaults { public static final Short NULL_VALUE = null ; } public static class Builder extends JsonNumberFieldMapper . Builder < JsonShortFieldMapper . Builder , JsonShortFieldMapper > { protected Short nullValue = JsonShortFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public JsonShortFieldMapper . Builder nullValue ( short nullValue ) { } @ Override public JsonShortFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements JsonTypeParser { @ Override public JsonMapper . Builder parse ( String name , JsonNode node , ParserContext parserContext ) throws MapperParsingException { } } private final Short nullValue ; private final String nullValueAsString ; protected JsonShortFieldMapper ( Names names , int precisionStep , Field . Index index , Field . Store store , float boost , boolean omitNorms , boolean omitTermFreqAndPositions , Short nullValue ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Short value ( Fieldable field ) { byte [ ] value = field . getBinaryValue ( ) ; if ( value == null ) { <START_BUG> return Short . MIN_VALUE ; <END_BUG> } return Numbers . bytesToShort ( value ) ; } @ Override public String indexedValue ( String value ) { } @ Override public String indexedValue ( Short value ) { } @ Override public Object valueFromTerm ( String term ) { } @ Override public Object valueFromString ( String text ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override protected Field parseCreateField ( JsonParseContext jsonContext ) throws IOException { } @ Override public int sortType ( ) { } @ Override protected String jsonType ( ) { } @ Override protected void doJsonBody ( JsonBuilder builder ) throws IOException { } }
public class RestIndicesExistsAction extends BaseRestHandler { private final SettingsFilter settingsFilter ; @ Inject public RestIndicesExistsAction ( Settings settings , Client client , RestController controller , SettingsFilter settingsFilter ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { IndicesExistsRequest indicesExistsRequest = new IndicesExistsRequest ( splitIndices ( request . param ( "index" ) ) ) ; indicesExistsRequest . listenerThreaded ( false ) ; client . admin ( ) . indices ( ) . exists ( indicesExistsRequest , new org . elasticsearch . action . ActionListener < IndicesExistsResponse > ( ) { @ Override public void onResponse ( IndicesExistsResponse response ) { try { if ( response . isExists ( ) ) { channel . sendResponse ( new StringRestResponse ( RestStatus . OK ) ) ; } else { channel . sendResponse ( new StringRestResponse ( RestStatus . NOT_FOUND ) ) ; } <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new StringRestResponse ( ExceptionsHelper . status ( e ) ) ) ; } catch ( Exception e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public abstract class Camera { public final Vector3 position = new Vector3 ( ) ; public final Vector3 direction = new Vector3 ( 0 , 0 , ( - 1 ) ) ; public final Vector3 up = new Vector3 ( 0 , 1 , 0 ) ; public final Matrix4 projection = new Matrix4 ( ) ; public final Matrix4 view = new Matrix4 ( ) ; public final Matrix4 combined = new Matrix4 ( ) ; public final Matrix4 invProjectionView = new Matrix4 ( ) ; public float near = 1 ; public float far = 100 ; public float viewportWidth = 0 ; public float viewportHeight = 0 ; public final Frustum frustum = new Frustum ( ) ; private final Matrix4 tmpMat = new Matrix4 ( ) ; private final Vector3 tmpVec = new Vector3 ( ) ; public abstract void update ( ) { } public abstract void update ( boolean updateFrustum ) { } public void apply ( GL10 gl ) { } public void lookAt ( float x , float y , float z ) { } final Vector3 right = new Vector3 ( ) ; public void normalizeUp ( ) { } public void rotate ( float angle , float axisX , float axisY , float axisZ ) { } public void rotate ( Vector3 axis , float angle ) { } public void rotateAround ( Vector3 point , Vector3 axis , float angle ) { tmpVec . set ( point ) ; tmpVec . sub ( position ) ; translate ( tmpVec ) ; rotate ( axis , angle ) ; tmpVec . rotate ( axis , angle ) ; <START_BUG> translate ( tmpVec . mul ( ( - 1 ) ) ) ; <END_BUG> } public void translate ( float x , float y , float z ) { } public void translate ( Vector3 vec ) { } public void unproject ( Vector3 vec , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } public void unproject ( Vector3 vec ) { } public void project ( Vector3 vec ) { } public void project ( Vector3 vec , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } final Ray ray = new Ray ( new Vector3 ( ) , new Vector3 ( ) ) ; public Ray getPickRay ( float x , float y , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } public Ray getPickRay ( float x , float y ) { } }
public class ElasticsearchAssertions { public static void assertAcked ( AcknowledgedRequestBuilder < ? , ? , ? > builder ) { } public static void assertNoTimeout ( ClusterHealthRequestBuilder requestBuilder ) { } public static void assertNoTimeout ( ClusterHealthResponse response ) { <START_BUG> assertThat ( "ClusterHealthResponse<seq2seq4repair_space>has<seq2seq4repair_space>timed<seq2seq4repair_space>out" , response . isTimedOut ( ) , is ( false ) ) ; <END_BUG> } public static void assertAcked ( AcknowledgedResponse response ) { } public static void assertAcked ( DeleteIndexRequestBuilder builder ) { } public static void assertAcked ( DeleteIndexResponse response ) { } public static String formatShardStatus ( BroadcastOperationResponse response ) { } public static String formatShardStatus ( SearchResponse response ) { } public static void assertHitCount ( SearchResponse searchResponse , long expectedHitCount ) { } public static void assertSearchHits ( SearchResponse searchResponse , String ... ids ) { } public static void assertOrderedSearchHits ( SearchResponse searchResponse , String ... ids ) { } public static void assertHitCount ( CountResponse countResponse , long expectedHitCount ) { } public static void assertMatchCount ( PercolateResponse percolateResponse , long expectedHitCount ) { } public static void assertExists ( GetResponse response ) { } public static void assertFirstHit ( SearchResponse searchResponse , Matcher < SearchHit > matcher ) { } public static void assertSecondHit ( SearchResponse searchResponse , Matcher < SearchHit > matcher ) { } public static void assertThirdHit ( SearchResponse searchResponse , Matcher < SearchHit > matcher ) { } public static void assertSearchHit ( SearchResponse searchResponse , int number , Matcher < SearchHit > matcher ) { } public static void assertNoFailures ( SearchResponse searchResponse ) { } public static void assertFailures ( SearchResponse searchResponse ) { } public static void assertFailures ( SearchRequestBuilder searchRequestBuilder , RestStatus restStatus , Matcher < String > reasonMatcher ) { } public static void assertNoFailures ( BroadcastOperationResponse response ) { } public static void assertAllSuccessful ( BroadcastOperationResponse response ) { } public static void assertAllSuccessful ( SearchResponse response ) { } public static void assertSearchHit ( SearchHit searchHit , Matcher < SearchHit > matcher ) { } public static void assertHighlight ( SearchResponse resp , int hit , String field , int fragment , Matcher < String > matcher ) { } public static void assertHighlight ( SearchResponse resp , int hit , String field , int fragment , int totalFragments , Matcher < String > matcher ) { } public static void assertHighlight ( SearchHit hit , String field , int fragment , Matcher < String > matcher ) { } public static void assertHighlight ( SearchHit hit , String field , int fragment , int totalFragments , Matcher < String > matcher ) { } private static void assertHighlight ( SearchResponse resp , int hit , String field , int fragment , Matcher < Integer > fragmentsMatcher , Matcher < String > matcher ) { } private static void assertHighlight ( SearchHit hit , String field , int fragment , Matcher < Integer > fragmentsMatcher , Matcher < String > matcher ) { } public static void assertNotHighlighted ( SearchResponse resp , int hit , String field ) { } public static void assertSuggestionSize ( Suggest searchSuggest , int entry , int size , String key ) { } public static void assertSuggestion ( Suggest searchSuggest , int entry , int ord , String key , String text ) { } public static void assertSuggestion ( Suggest searchSuggest , int entry , String key , String ... text ) { } public static void assertSuggestion ( Suggest searchSuggest , int entry , String key , int size , String ... text ) { } public static Matcher < SearchHit > hasId ( final String id ) { } public static Matcher < SearchHit > hasType ( final String type ) { } public static Matcher < SearchHit > hasIndex ( final String index ) { } public static Matcher < SearchHit > hasScore ( final float score ) { } public static < T extends Query > T assertBooleanSubQuery ( Query query , Class < T > subqueryType , int i ) { } public static < E extends Throwable > void assertThrows ( ActionRequestBuilder < ? , ? , ? > builder , Class < E > exceptionClass ) { } public static < E extends Throwable > void assertThrows ( ActionRequestBuilder < ? , ? , ? > builder , Class < E > exceptionClass , String extraInfo ) { } public static < E extends Throwable > void assertThrows ( ActionFuture future , Class < E > exceptionClass ) { } public static < E extends Throwable > void assertThrows ( ActionFuture future , Class < E > exceptionClass , String extraInfo ) { } private static BytesReference serialize ( Version version , Streamable streamable ) throws IOException { } public static void assertVersionSerializable ( Streamable streamable ) { } public static void assertVersionSerializable ( Version version , Streamable streamable ) { } private static Streamable tryCreateNewInstance ( Streamable streamable ) throws IllegalAccessException , InstantiationException , NoSuchMethodException , InvocationTargetException { } public static SearchResponse assertSearchResponse ( SearchRequestBuilder request ) { } public static SearchResponse assertSearchResponse ( SearchResponse response ) { } public static void assertAllSearchersClosed ( ) { } public static void assertAllFilesClosed ( ) { } }
@ ClusterScope ( scope = Scope . SUITE , numDataNodes = 3 ) public class ScriptFieldTests extends ElasticsearchIntegrationTest { @ Override protected Settings nodeSettings ( int nodeOrdinal ) { <START_BUG> return settingsBuilder ( ) . put ( "plugin.types" , ScriptFieldTests . CustomScriptPlugin . class . getName ( ) ) . put ( super . nodeSettings ( nodeOrdinal ) ) . build ( ) ; <END_BUG> } static int [ ] intArray = new int [ ] { Integer . MAX_VALUE , Integer . MIN_VALUE , 3 } ; static long [ ] longArray = new long [ ] { Long . MAX_VALUE , Long . MIN_VALUE , 9223372036854775807L } ; static float [ ] floatArray = new float [ ] { Float . MAX_VALUE , Float . MIN_VALUE , 3.3F } ; static double [ ] doubleArray = new double [ ] { Double . MAX_VALUE , Double . MIN_VALUE , 3.3 } ; public void testNativeScript ( ) throws InterruptedException , ExecutionException { } static class IntArrayScriptFactory implements NativeScriptFactory { @ Override public ExecutableScript newScript ( @ Nullable Map < String , Object > params ) { } } static class IntScript extends AbstractSearchScript { @ Override public Object run ( ) { } } static class LongArrayScriptFactory implements NativeScriptFactory { @ Override public ExecutableScript newScript ( @ Nullable Map < String , Object > params ) { } } static class LongScript extends AbstractSearchScript { @ Override public Object run ( ) { } } static class FloatArrayScriptFactory implements NativeScriptFactory { @ Override public ExecutableScript newScript ( @ Nullable Map < String , Object > params ) { } } static class FloatScript extends AbstractSearchScript { @ Override public Object run ( ) { } } static class DoubleArrayScriptFactory implements NativeScriptFactory { @ Override public ExecutableScript newScript ( @ Nullable Map < String , Object > params ) { } } static class DoubleScript extends AbstractSearchScript { @ Override public Object run ( ) { } } public static class CustomScriptPlugin extends AbstractPlugin { @ Override public String name ( ) { } @ Override public String description ( ) { } public void onModule ( ScriptModule scriptModule ) { } } }
public class TransportDeleteWarmerAction extends TransportMasterNodeOperationAction < DeleteWarmerRequest , DeleteWarmerResponse > { @ Inject public TransportDeleteWarmerAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected DeleteWarmerRequest newRequest ( ) { } @ Override protected DeleteWarmerResponse newResponse ( ) { } @ Override protected void doExecute ( DeleteWarmerRequest request , ActionListener < DeleteWarmerResponse > listener ) { <START_BUG> request . indices ( clusterService . state ( ) . metaData ( ) . concreteIndices ( request . indices ( ) , request . indicesOptions ( ) ) ) ; <END_BUG> super . doExecute ( request , listener ) ; } @ Override protected ClusterBlockException checkBlock ( DeleteWarmerRequest request , ClusterState state ) { } @ Override protected void masterOperation ( final DeleteWarmerRequest request , final ClusterState state , final ActionListener < DeleteWarmerResponse > listener ) throws ElasticsearchException { } }
public class IndicesClusterStateService extends AbstractLifecycleComponent < IndicesClusterStateService > implements ClusterStateListener { private final IndicesService indicesService ; private final ClusterService clusterService ; private final ThreadPool threadPool ; private final RecoveryTarget recoveryTarget ; private final ShardStateAction shardStateAction ; private final NodeIndexDeletedAction nodeIndexDeletedAction ; private final NodeMappingRefreshAction nodeMappingRefreshAction ; private final ConcurrentMap < Tuple < String , String > , Boolean > seenMappings = ConcurrentCollections . newConcurrentMap ( ) ; private final ConcurrentMap < ShardId , IndicesClusterStateService . FailedShard > failedShards = ConcurrentCollections . newConcurrentMap ( ) ; static class FailedShard { public final long version ; public final long timestamp ; FailedShard ( long version ) { } } private final Object mutex = new Object ( ) ; private final IndicesClusterStateService . FailedEngineHandler failedEngineHandler = new IndicesClusterStateService . FailedEngineHandler ( ) ; private final boolean sendRefreshMapping ; private final AtomicLong recoveryIdGenerator = new AtomicLong ( ) ; @ Inject public IndicesClusterStateService ( Settings settings , IndicesService indicesService , ClusterService clusterService , ThreadPool threadPool , RecoveryTarget recoveryTarget , ShardStateAction shardStateAction , NodeIndexDeletedAction nodeIndexDeletedAction , NodeMappingRefreshAction nodeMappingRefreshAction ) { } @ Override protected void doStart ( ) throws ElasticsearchException { } @ Override protected void doStop ( ) throws ElasticsearchException { } @ Override protected void doClose ( ) throws ElasticsearchException { } @ Override public void clusterChanged ( final ClusterChangedEvent event ) { } private void sendIndexLifecycleEvents ( final ClusterChangedEvent event ) { } private void cleanMismatchedIndexUUIDs ( final ClusterChangedEvent event ) { } private void applyCleanedIndices ( final ClusterChangedEvent event ) { } private void applyDeletedIndices ( final ClusterChangedEvent event ) { } private void applyDeletedShards ( final ClusterChangedEvent event ) { } private void applyNewIndices ( final ClusterChangedEvent event ) { } private void applySettings ( ClusterChangedEvent event ) { } private void applyMappings ( ClusterChangedEvent event ) { } private boolean processMapping ( String index , MapperService mapperService , String mappingType , CompressedString mappingSource ) { } private boolean aliasesChanged ( ClusterChangedEvent event ) { } private void applyAliases ( ClusterChangedEvent event ) { } private void processAliases ( String index , ObjectContainer < AliasMetaData > aliases , IndexAliasesService indexAliasesService ) { } private void applyNewOrUpdatedShards ( final ClusterChangedEvent event ) throws ElasticsearchException { } private void cleanFailedShards ( final ClusterChangedEvent event ) { } private void applyInitializingShard ( final RoutingTable routingTable , final DiscoveryNodes nodes , final IndexMetaData indexMetaData , final IndexShardRoutingTable indexShardRouting , final ShardRouting shardRouting ) throws ElasticsearchException { } private class PeerRecoveryListener implements RecoveryTarget . RecoveryListener { private final StartRecoveryRequest request ; private final ShardRouting shardRouting ; private final IndexService indexService ; private final IndexMetaData indexMetaData ; private PeerRecoveryListener ( StartRecoveryRequest request , ShardRouting shardRouting , IndexService indexService , IndexMetaData indexMetaData ) { } @ Override public void onRecoveryDone ( ) { } @ Override public void onRetryRecovery ( TimeValue retryAfter , RecoveryStatus recoveryStatus ) { <START_BUG> recoveryTarget . retryRecovery ( request , recoveryStatus , this ) ; <END_BUG> } @ Override public void onIgnoreRecovery ( boolean removeShard , String reason ) { } @ Override public void onRecoveryFailure ( RecoveryFailedException e , boolean sendShardFailure ) { } } private void handleRecoveryFailure ( IndexService indexService , IndexMetaData indexMetaData , ShardRouting shardRouting , boolean sendShardFailure , Throwable failure ) { } private void removeIndex ( String index , String reason ) { } private class FailedEngineHandler implements Engine . FailedEngineListener { @ Override public void onFailedEngine ( final ShardId shardId , final String reason , @ Nullable final Throwable failure ) { } } }
public class TransportPutMappingAction extends TransportMasterNodeOperationAction < PutMappingRequest , PutMappingResponse > { private final MetaDataService metaDataService ; @ Inject public TransportPutMappingAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , MetaDataService metaDataService ) { } @ Override protected String transportAction ( ) { } @ Override protected PutMappingRequest newRequest ( ) { } @ Override protected PutMappingResponse newResponse ( ) { } @ Override protected PutMappingResponse masterOperation ( PutMappingRequest request ) throws ElasticSearchException { ClusterState clusterState = clusterService . state ( ) ; request . indices ( clusterState . metaData ( ) . concreteIndices ( request . indices ( ) ) ) ; final String [ ] indices = request . indices ( ) ; <START_BUG> MetaDataService . PutMappingResult result = metaDataService . putMapping ( indices , request . type ( ) , request . mappingSource ( ) , request . ignoreConflicts ( ) , request . timeout ( ) ) ; <END_BUG> return new PutMappingResponse ( result . acknowledged ( ) ) ; } }
public class IndexerModule extends AbstractModule implements SpawnModules { private IndexerName indexerName ; private final Settings globalSettings ; private final Map < String , Object > settings ; public IndexerModule ( IndexerName indexerName , Map < String , Object > settings , Settings globalSettings ) { } @ Override public Iterable < ? extends Module > spawnModules ( ) { } @ Override protected void configure ( ) { <START_BUG> bind ( Map . class ) . annotatedWith ( IndexerSettings . class ) . toInstance ( settings ) ; <END_BUG> } private Class < ? extends Module > loadTypeModule ( String type , String prefixPackage , String suffixClassName ) { } }
public class TransportCountAction extends TransportBroadcastOperationAction < CountRequest , CountResponse , ShardCountRequest , ShardCountResponse > { private final IndicesService indicesService ; @ Inject public TransportCountAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected CountRequest newRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ShardRouting shard , CountRequest request ) { } @ Override protected ShardCountResponse newShardResponse ( ) { } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , CountRequest request , String [ ] concreteIndices ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , CountRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , CountRequest countRequest , String [ ] concreteIndices ) { } @ Override protected CountResponse newResponse ( CountRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardCountResponse shardOperation ( ShardCountRequest request ) throws ElasticSearchException { IndexShard indexShard = indicesService . indexServiceSafe ( request . index ( ) ) . shardSafe ( request . shardId ( ) ) ; <START_BUG> long count = indexShard . count ( request . minScore ( ) , request . querySource ( ) , request . querySourceOffset ( ) , request . querySourceLength ( ) , request . filteringAliases ( ) , request . types ( ) ) ; <END_BUG> return new ShardCountResponse ( request . index ( ) , request . shardId ( ) , count ) ; } }
public class SingleInstanceEmbeddedSearchTests extends AbstractNodesTests { private SearchService searchService ; private SearchPhaseController searchPhaseController ; @ BeforeClass public void createNodeAndInitWithData ( ) throws Exception { } @ AfterClass public void closeNode ( ) { } @ Test public void testDirectDfs ( ) throws Exception { } @ Test public void testDirectQuery ( ) throws Exception { } @ Test public void testDirectFetch ( ) throws Exception { } @ Test public void testQueryThenFetch ( ) throws Exception { } @ Test public void testQueryAndFetch ( ) throws Exception { } @ Test public void testDfsQueryThenFetch ( ) throws Exception { } @ Test public void testSimpleQueryFacets ( ) throws Exception { } @ Test public void testQueryFetchKeepAliveTimeout ( ) throws Exception { } private InternalSearchRequest searchRequest ( SearchSourceBuilder builder ) { <START_BUG> return new InternalSearchRequest ( "test" , 0 ) . source ( builder . buildAsBytes ( ) ) ; <END_BUG> } private void index ( Client client , String id , String nameValue , int age ) { } private String source ( String id , String nameValue , int age ) { } }
public class InternalDateHistogram extends InternalHistogram < InternalDateHistogram . Bucket > implements DateHistogram { static final Type TYPE = new Type ( "date_histogram" , "dhisto" ) ; static final InternalDateHistogram . Factory FACTORY = new InternalDateHistogram . Factory ( ) ; private static final Stream STREAM = new AggregationStreams . Stream ( ) { @ Override public InternalDateHistogram readResult ( StreamInput in ) throws IOException { } } ; public static void registerStream ( ) { } static class Bucket extends InternalHistogram . Bucket implements DateHistogram . Bucket { private final ValueFormatter formatter ; Bucket ( long key , long docCount , InternalAggregations aggregations , ValueFormatter formatter ) { } @ Override public String getKey ( ) { } @ Override public DateTime getKeyAsDate ( ) { } @ Override public String toString ( ) { } } static class Factory extends InternalHistogram . Factory < InternalDateHistogram . Bucket > { private Factory ( ) { } @ Override public String type ( ) { } @ Override public InternalDateHistogram create ( String name , List < InternalDateHistogram . Bucket > buckets , InternalOrder order , long minDocCount , EmptyBucketInfo emptyBucketInfo , ValueFormatter formatter , boolean keyed ) { } @ Override public InternalDateHistogram . Bucket createBucket ( long key , long docCount , InternalAggregations aggregations , ValueFormatter formatter ) { } } private ObjectObjectOpenHashMap < String , InternalDateHistogram . Bucket > bucketsMap ; InternalDateHistogram ( ) { } InternalDateHistogram ( String name , List < InternalDateHistogram . Bucket > buckets , InternalOrder order , long minDocCount , EmptyBucketInfo emptyBucketInfo , ValueFormatter formatter , boolean keyed ) { } @ Override public Type type ( ) { } @ Override public InternalDateHistogram . Bucket getBucketByKey ( String key ) { try { long time = Long . parseLong ( key ) ; return super . getBucketByKey ( time ) ; } catch ( NumberFormatException nfe ) { } if ( ( bucketsMap ) == null ) { <START_BUG> bucketsMap = new ObjectObjectOpenHashMap < String , InternalDateHistogram . Bucket > ( ) ; <END_BUG> for ( InternalDateHistogram . Bucket bucket : buckets ) { bucketsMap . put ( bucket . getKey ( ) , bucket ) ; } } return bucketsMap . get ( key ) ; } @ Override public DateHistogram . Bucket getBucketByKey ( DateTime key ) { } @ Override protected InternalDateHistogram . Bucket createBucket ( long key , long docCount , InternalAggregations aggregations , ValueFormatter formatter ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } }
public class DoubleFieldsFunctionDataComparator extends FieldComparator { public static ExtendedFieldComparatorSource comparatorSource ( SearchScript script ) { } private static class InnerSource extends FieldDataType . ExtendedFieldComparatorSource { private final SearchScript script ; private InnerSource ( SearchScript script ) { } @ Override public FieldComparator newComparator ( String fieldname , int numHits , int sortPos , boolean reversed ) throws IOException { } @ Override <START_BUG> public int reducedType ( ) { <END_BUG> return SortField . DOUBLE ; } } private final SearchScript script ; private final double [ ] values ; private double bottom ; public DoubleFieldsFunctionDataComparator ( int numHits , SearchScript script ) { } @ Override public void setNextReader ( IndexReader reader , int docBase ) throws IOException { } @ Override public void setScorer ( Scorer scorer ) { } @ Override public int compare ( int slot1 , int slot2 ) { } @ Override public int compareBottom ( int doc ) { } @ Override public void copy ( int slot , int doc ) { } @ Override public void setBottom ( final int bottom ) { } @ Override public Comparable value ( int slot ) { } }
public abstract class AbstractConcurrentMapFieldDataCache extends AbstractIndexComponent implements FieldDataCache { private final ConcurrentMap < Object , ConcurrentMap < String , FieldData > > cache ; private final Object creationMutex = new Object ( ) ; protected AbstractConcurrentMapFieldDataCache ( Index index , @ IndexSettings Settings indexSettings , ConcurrentMap < Object , ConcurrentMap < String , FieldData > > cache ) { } @ Override public void close ( ) throws ElasticSearchException { } @ Override public void clear ( ) { } @ Override public void clear ( IndexReader reader ) { } @ Override public void clearUnreferenced ( ) { } @ Override public FieldData cache ( FieldData . Type type , IndexReader reader , String fieldName ) throws IOException { <START_BUG> return cache ( type . fieldDataClass , reader , fieldName ) ; <END_BUG> } @ Override public < T extends FieldData > T cache ( Class < T > type , IndexReader reader , String fieldName ) throws IOException { } }
public class PointSpriteParticleBatch extends BufferedParticleBatch < PointSpriteControllerRenderData > { private static boolean pointSpritesEnabled = false ; protected static final Vector3 TMP_V1 = new Vector3 ( ) ; protected static final int sizeAndRotationUsage = 1 << 9 ; protected static final VertexAttributes CPU_ATTRIBUTES = new VertexAttributes ( new VertexAttribute ( Usage . Position , 3 , ShaderProgram . POSITION_ATTRIBUTE ) , new VertexAttribute ( Usage . Color , 4 , ShaderProgram . COLOR_ATTRIBUTE ) , new VertexAttribute ( Usage . TextureCoordinates , 4 , "a_region" ) , new VertexAttribute ( PointSpriteParticleBatch . sizeAndRotationUsage , 3 , "a_sizeAndRotation" ) ) ; protected static final int CPU_VERTEX_SIZE = ( ( short ) ( ( PointSpriteParticleBatch . CPU_ATTRIBUTES . vertexSize ) / 4 ) ) ; protected static final int CPU_POSITION_OFFSET = ( ( short ) ( ( PointSpriteParticleBatch . CPU_ATTRIBUTES . findByUsage ( Position ) . offset ) / 4 ) ) ; protected static final int CPU_COLOR_OFFSET = ( ( short ) ( ( PointSpriteParticleBatch . CPU_ATTRIBUTES . findByUsage ( Color ) . offset ) / 4 ) ) ; protected static final int CPU_REGION_OFFSET = ( ( short ) ( ( PointSpriteParticleBatch . CPU_ATTRIBUTES . findByUsage ( TextureCoordinates ) . offset ) / 4 ) ) ; protected static final int CPU_SIZE_AND_ROTATION_OFFSET = ( ( short ) ( ( PointSpriteParticleBatch . CPU_ATTRIBUTES . findByUsage ( PointSpriteParticleBatch . sizeAndRotationUsage ) . offset ) / 4 ) ) ; private static void enablePointSprites ( ) { } private float [ ] vertices ; Renderable renderable ; public PointSpriteParticleBatch ( ) { } public PointSpriteParticleBatch ( int capacity ) { } @ Override protected void allocParticlesData ( int capacity ) { } protected void allocRenderable ( ) { renderable = new Renderable ( ) ; renderable . primitiveType = GL20 . GL_POINTS ; renderable . meshPartOffset = 0 ; <START_BUG> renderable . material = new com . badlogic . gdx . graphics . g3d . Material ( new com . badlogic . gdx . graphics . g3d . attributes . BlendingAttribute ( GL20 . GL_ONE , GL20 . GL_ONE_MINUS_SRC_ALPHA , 1.0F ) , new com . badlogic . gdx . graphics . g3d . attributes . DepthTestAttribute ( GL20 . GL_LEQUAL , false ) , TextureAttribute . createDiffuse ( null ) ) ; <END_BUG> } public void setTexture ( Texture texture ) { } public Texture getTexture ( ) { } @ Override protected void flush ( int [ ] offsets ) { } @ Override public void getRenderables ( Array < Renderable > renderables , Pool < Renderable > pool ) { } @ Override public void save ( AssetManager manager , ResourceData resources ) { } @ Override public void load ( AssetManager manager , ResourceData resources ) { } }
public class IssuesFragment extends PagedItemFragment < Issue > { @ Inject private AccountDataManager cache ; @ Inject private IssueService service ; @ Inject private IssueStore store ; @ InjectExtra ( value = Intents . EXTRA_ISSUE_FILTER , optional = true ) private IssueFilter filter ; @ InjectExtra ( Intents . EXTRA_REPOSITORY ) private Repository repository ; private View filterHeader ; private TextView state ; private ImageView assigneeAvatar ; private View assigneeArea ; private TextView assignee ; private TextView labels ; private TextView milestone ; @ Inject private AvatarLoader avatars ; @ Override public void onCreate ( Bundle savedInstanceState ) { } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { } @ Override protected void configureList ( Activity activity , ListView listView ) { super . configureList ( activity , listView ) ; <START_BUG> getListAdapter ( ) . addHeader ( filterHeader , null , false ) ; <END_BUG> } private void updateFilterSummary ( ) { } @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public void onCreateOptionsMenu ( Menu optionsMenu , MenuInflater inflater ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } @ Override protected ResourcePager < Issue > createPager ( ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected int getErrorMessage ( Exception exception ) { } @ Override protected SingleTypeAdapter < Issue > createAdapter ( List < Issue > items ) { } }
public interface CacheKeyFilter { public static class Key { private final byte [ ] bytes ; private final int hashCode ; public Key ( byte [ ] bytes ) { } public Key ( String str ) { } public byte [ ] bytes ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } } public static class Wrapper extends Filter implements CacheKeyFilter { private final Filter filter ; private final CacheKeyFilter . Key key ; public Wrapper ( Filter filter , CacheKeyFilter . Key key ) { } @ Override public CacheKeyFilter . Key cacheKey ( ) { return key ; } public Filter wrappedFilter ( ) { } @ Override public DocIdSet getDocIdSet ( AtomicReaderContext context , Bits acceptDocs ) throws IOException { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } @ Override public String toString ( ) { } } <START_BUG> CacheKeyFilter . Key cacheKey ( ) ; <END_BUG> }
public class DocumentActionsTests extends ElasticsearchIntegrationTest { protected void createIndex ( ) { <START_BUG> wipeIndices ( getConcreteIndexName ( ) ) ; <END_BUG> createIndex ( getConcreteIndexName ( ) ) ; } protected String getConcreteIndexName ( ) { } @ Test public void testIndexActions ( ) throws Exception { } @ Test public void testBulk ( ) throws Exception { } private XContentBuilder source ( String id , String nameValue ) throws IOException { } }
public abstract class TransportMasterNodeOperationAction < Request extends MasterNodeOperationRequest , Response extends ActionResponse > extends TransportAction < Request , Response > { protected final TransportService transportService ; protected final ClusterService clusterService ; final String transportAction ; final String executor ; protected TransportMasterNodeOperationAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } protected abstract String transportAction ( ) { } protected abstract String executor ( ) { } protected abstract Request newRequest ( ) { } protected abstract Response newResponse ( ) { } protected abstract void masterOperation ( Request request , ClusterState state , ActionListener < Response > listener ) throws ElasticSearchException { } protected boolean localExecute ( Request request ) { } protected ClusterBlockException checkBlock ( Request request , ClusterState state ) { } protected void processBeforeDelegationToMaster ( Request request , ClusterState state ) { } @ Override public void execute ( Request request , ActionListener < Response > listener ) { } @ Override protected void doExecute ( final Request request , final ActionListener < Response > listener ) { } private void innerExecute ( final Request request , final ActionListener < Response > listener , final boolean retrying ) { final ClusterState clusterState = clusterService . state ( ) ; final DiscoveryNodes nodes = clusterState . nodes ( ) ; if ( ( nodes . localNodeMaster ( ) ) || ( localExecute ( request ) ) ) { final ClusterBlockException blockException = checkBlock ( request , clusterState ) ; if ( blockException != null ) { if ( ! ( blockException . retryable ( ) ) ) { listener . onFailure ( blockException ) ; return ; } clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { ClusterBlockException blockException = checkBlock ( request , clusterService . state ( ) ) ; if ( ( blockException == null ) || ( ! ( blockException . retryable ( ) ) ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( blockException ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; listener . onFailure ( blockException ) ; } @ Override public void clusterChanged ( ClusterChangedEvent event ) { ClusterBlockException blockException = checkBlock ( request , event . state ( ) ) ; if ( ( blockException == null ) || ( ! ( blockException . retryable ( ) ) ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } } ) ; } else { threadPool . executor ( executor ) . execute ( new Runnable ( ) { @ Override public void run ( ) { try { <START_BUG> masterOperation ( request , clusterState , listener ) ; <END_BUG> } catch ( Throwable e ) { listener . onFailure ( e ) ; } } } ) ; } } else { if ( ( nodes . masterNode ( ) ) == null ) { if ( retrying ) { listener . onFailure ( new MasterNotDiscoveredException ( ) ) ; } else { clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { ClusterState clusterStateV2 = clusterService . state ( ) ; if ( ( clusterStateV2 . nodes ( ) . masterNodeId ( ) ) != null ) { clusterService . remove ( this ) ; innerExecute ( request , listener , true ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( new org . elasticsearch . node . NodeClosedException ( nodes . localNode ( ) ) ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; listener . onFailure ( new MasterNotDiscoveredException ( ( ( "waited<seq2seq4repair_space>for<seq2seq4repair_space>[" + timeout ) + "]" ) ) ) ; } @ Override public void clusterChanged ( ClusterChangedEvent event ) { if ( event . nodesDelta ( ) . masterNodeChanged ( ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , true ) ; } } } ) ; } return ; } processBeforeDelegationToMaster ( request , clusterState ) ; transportService . sendRequest ( nodes . masterNode ( ) , transportAction , request , new BaseTransportResponseHandler < Response > ( ) { @ Override public Response newInstance ( ) { return newResponse ( ) ; } @ Override public void handleResponse ( Response response ) { listener . onResponse ( response ) ; } @ Override public String executor ( ) { return Names . SAME ; } @ Override public void handleException ( final TransportException exp ) { if ( ( exp . unwrapCause ( ) ) instanceof ConnectTransportException ) { clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { ClusterState clusterStateV2 = clusterService . state ( ) ; if ( ! ( clusterState . nodes ( ) . masterNodeId ( ) . equals ( clusterStateV2 . nodes ( ) . masterNodeId ( ) ) ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( new org . elasticsearch . node . NodeClosedException ( nodes . localNode ( ) ) ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; listener . onFailure ( new MasterNotDiscoveredException ( ) ) ; }
public class MinAggregator extends MetricsAggregator . SingleValue { private final NumericValuesSource valuesSource ; private DoubleValues values ; private DoubleArray mins ; public MinAggregator ( String name , long estimatedBucketsCount , NumericValuesSource valuesSource , AggregationContext context , Aggregator parent ) { } @ Override public boolean shouldCollect ( ) { } @ Override public void setNextReader ( AtomicReaderContext reader ) { } @ Override public void collect ( int doc , long owningBucketOrdinal ) throws IOException { } @ Override public double metric ( long owningBucketOrd ) { <START_BUG> return mins . get ( owningBucketOrd ) ; <END_BUG> } @ Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) { } @ Override public InternalAggregation buildEmptyAggregation ( ) { } public static class Factory extends ValueSourceAggregatorFactory . LeafOnly < NumericValuesSource > { public Factory ( String name , ValuesSourceConfig < NumericValuesSource > valuesSourceConfig ) { } @ Override protected Aggregator createUnmapped ( AggregationContext aggregationContext , Aggregator parent ) { } @ Override protected Aggregator create ( NumericValuesSource valuesSource , long expectedBucketsCount , AggregationContext aggregationContext , Aggregator parent ) { } } @ Override public void doRelease ( ) { } }
public class InternalSearchResponse implements Streamable , ToXContent { public static InternalSearchResponse empty ( ) { <START_BUG> return new InternalSearchResponse ( new InternalSearchHits ( new InternalSearchHit [ 0 ] , 0 , 0 ) , null , null , null , false ) ; <END_BUG> } private InternalSearchHits hits ; private InternalFacets facets ; private InternalAggregations aggregations ; private Suggest suggest ; private boolean timedOut ; private InternalSearchResponse ( ) { } public InternalSearchResponse ( InternalSearchHits hits , InternalFacets facets , InternalAggregations aggregations , Suggest suggest , boolean timedOut ) { } public boolean timedOut ( ) { } public SearchHits hits ( ) { } public Facets facets ( ) { } public Aggregations aggregations ( ) { } public Suggest suggest ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } public static InternalSearchResponse readInternalSearchResponse ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public class TextButton extends Button { private final Label label ; private TextButton . TextButtonStyle style ; public TextButton ( Skin skin ) { } public TextButton ( String text , Skin skin ) { } public TextButton ( String text , TextButton . TextButtonStyle style ) { } public TextButton ( String text , TextButton . TextButtonStyle style , String name ) { } public void setStyle ( ButtonStyle style ) { } public TextButton . TextButtonStyle getStyle ( ) { } public void draw ( SpriteBatch batch , float parentAlpha ) { } public Label getLabel ( ) { } public Cell getLabelCell ( ) { } public void setText ( String text ) { } <START_BUG> public String getText ( ) { <END_BUG> return label . getText ( ) ; } public static class TextButtonStyle extends ButtonStyle { public BitmapFont font ; public Color fontColor ; public Color downFontColor ; public Color checkedFontColor ; public TextButtonStyle ( ) { } public TextButtonStyle ( NinePatch down , NinePatch up , NinePatch checked , float pressedOffsetX , float pressedOffsetY , float unpressedOffsetX , float unpressedOffsetY , BitmapFont font , Color fontColor , Color downFontColor , Color checkedFontColor ) { } } }
public class StoreFileMetaData implements Streamable { private String name ; private long length ; private String checksum ; private Version writtenBy ; private BytesRef hash ; private StoreFileMetaData ( ) { } public StoreFileMetaData ( String name , long length ) { } public StoreFileMetaData ( String name , long length , String checksum ) { } public StoreFileMetaData ( String name , long length , String checksum , Version writtenBy ) { } public StoreFileMetaData ( String name , long length , String checksum , Version writtenBy , BytesRef hash ) { } public String name ( ) { } public long length ( ) { } @ Nullable public String checksum ( ) { } public boolean isSame ( StoreFileMetaData other ) { } public static StoreFileMetaData readStoreFileMetaData ( StreamInput in ) throws IOException { } @ Override public String toString ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( name ) ; out . writeVLong ( length ) ; out . writeOptionalString ( checksum ) ; if ( out . getVersion ( ) . onOrAfter ( V_1_3_0 ) ) { <START_BUG> out . writeOptionalString ( ( ( writtenBy ) == null ? null : writtenBy . name ( ) ) ) ; <END_BUG> } if ( out . getVersion ( ) . onOrAfter ( V_1_4_0 ) ) { out . writeBytesRef ( hash ) ; } } public Version writtenBy ( ) { } public boolean hasLegacyChecksum ( ) { } public BytesRef hash ( ) { } }
public class IOSGraphics extends iPhoneOSGameView implements Graphics { IOSApplication app ; IOSGLES20 gl20 ; int width ; int height ; long lastFrameTime ; float deltaTime ; long framesStart ; int frames ; int fps ; public IOSGraphics ( RectangleF bounds , IOSApplication app ) { } @ Override protected void ConfigureLayer ( CAEAGLLayer layer ) { } @ Override protected void OnLoad ( EventArgs arg0 ) { } @ Override protected void OnRenderFrame ( FrameEventArgs arg0 ) { } @ Override protected void OnResize ( EventArgs arg0 ) { } @ ExportAttribute . Annotation ( "layerClass" ) static Class LayerClass ( ) { } @ Override public boolean isGL11Available ( ) { } @ Override public boolean isGL20Available ( ) { } @ Override public GLCommon getGLCommon ( ) { } @ Override public GL10 getGL10 ( ) { } @ Override public GL11 getGL11 ( ) { } @ Override public GL20 getGL20 ( ) { } @ Override public GLU getGLU ( ) { } @ Override public int getWidth ( ) { } @ Override public int getHeight ( ) { } @ Override public float getDeltaTime ( ) { } @ Override public float getRawDeltaTime ( ) { } @ Override public int getFramesPerSecond ( ) { } @ Override public GraphicsType getType ( ) { <START_BUG> return null ; <END_BUG> } @ Override public float getPpiX ( ) { } @ Override public float getPpiY ( ) { } @ Override public float getPpcX ( ) { } @ Override public float getPpcY ( ) { } @ Override public float getDensity ( ) { } @ Override public boolean supportsDisplayModeChange ( ) { } @ Override public DisplayMode [ ] getDisplayModes ( ) { } @ Override public DisplayMode getDesktopDisplayMode ( ) { } @ Override public boolean setDisplayMode ( DisplayMode displayMode ) { } @ Override public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { } @ Override public void setTitle ( String title ) { } @ Override public void setIcon ( Pixmap [ ] pixmaps ) { } @ Override public void setVSync ( boolean vsync ) { } @ Override public BufferFormat getBufferFormat ( ) { } @ Override public boolean supportsExtension ( String extension ) { } @ Override public void setContinuousRendering ( boolean isContinuous ) { } @ Override public boolean isContinuousRendering ( ) { } @ Override public void requestRendering ( ) { } @ Override public boolean isFullscreen ( ) { } }
public class TWL implements InputProcessor { private final GdxRenderer renderer ; private final GUI gui ; private boolean mouseDown ; private boolean ignoreMouse ; private boolean lastPressConsumed ; public Widget root ; public TWL ( SpriteBatch batch , String themeFile , FileType fileType , Widget widget ) { } public TWL ( SpriteBatch batch , String themeFile , FileType fileType ) { } public GUI getGUI ( ) { } public void setWidget ( Widget widget ) { } public void clear ( ) { } public void render ( ) { } public boolean keyDown ( int keycode ) { } public boolean keyUp ( int keycode ) { } public boolean keyTyped ( char character ) { } public boolean touchDown ( int x , int y , int pointer , int button ) { } public boolean touchUp ( int x , int y , int pointer , int button ) { mouseDown = false ; if ( ignoreMouse ) { ignoreMouse = false ; return false ; } <START_BUG> boolean handled = gui . handleMouse ( x , y , 0 , false ) ; <END_BUG> if ( ( app . getType ( ) ) == ( ApplicationType . Android ) ) { gui . handleMouse ( ( - 9999 ) , ( - 9999 ) , ( - 1 ) , false ) ; } return handled ; } public boolean touchDragged ( int x , int y , int pointer ) { } public boolean touchMoved ( int x , int y ) { } public boolean scrolled ( int amount ) { } public void dispose ( ) { } public static int getTwlKeyCode ( int gdxKeyCode ) { } public static URL getThemeURL ( String themeFile , final FileType fileType ) throws MalformedURLException { } }
public class QuerySearchResult extends TransportResponse implements QuerySearchResultProvider { private long id ; private SearchShardTarget shardTarget ; private int from ; private int size ; private TopDocs topDocs ; private InternalFacets facets ; private Suggest suggest ; private boolean searchTimedOut ; public QuerySearchResult ( ) { } public QuerySearchResult ( long id , SearchShardTarget shardTarget ) { } @ Override public boolean includeFetch ( ) { } @ Override public QuerySearchResult queryResult ( ) { } public long id ( ) { } public SearchShardTarget shardTarget ( ) { } @ Override public void shardTarget ( SearchShardTarget shardTarget ) { } public void searchTimedOut ( boolean searchTimedOut ) { } public boolean searchTimedOut ( ) { } public TopDocs topDocs ( ) { } public void topDocs ( TopDocs topDocs ) { } public Facets facets ( ) { } public void facets ( InternalFacets facets ) { } public Suggest suggest ( ) { } public void suggest ( Suggest suggest ) { } public int from ( ) { } public QuerySearchResult from ( int from ) { } public int size ( ) { } public QuerySearchResult size ( int size ) { } public static QuerySearchResult readQuerySearchResult ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; id = in . readLong ( ) ; from = in . readVInt ( ) ; size = in . readVInt ( ) ; topDocs = readTopDocs ( in ) ; if ( in . readBoolean ( ) ) { facets = InternalFacets . readFacets ( in ) ; } if ( in . readBoolean ( ) ) { <START_BUG> suggest = Suggest . readSuggest ( in ) ; <END_BUG> } searchTimedOut = in . readBoolean ( ) ; } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
final class LwjglGL11 extends LwjglGL10 implements GL11 { private IntBuffer tempInt ; private FloatBuffer tempFloat ; public LwjglGL11 ( ) { } private IntBuffer toBuffer ( int n , int [ ] src , int offset ) { } private IntBuffer toBuffer ( int [ ] src , int offset ) { } private FloatBuffer toBuffer ( float [ ] src , int offset ) { } public void glBindBuffer ( int target , int buffer ) { } public void glBufferData ( int target , int size , Buffer data , int usage ) { } public void glBufferSubData ( int target , int offset , int size , Buffer data ) { } public void glClipPlanef ( int plane , float [ ] equation , int offset ) { } public void glClipPlanef ( int plane , FloatBuffer equation ) { } public void glColor4ub ( byte red , byte green , byte blue , byte alpha ) { } public void glDeleteBuffers ( int n , int [ ] buffers , int offset ) { } public void glDeleteBuffers ( int n , IntBuffer buffers ) { } public void glGenBuffers ( int n , int [ ] buffers , int offset ) { for ( int i = offset ; i < ( offset + n ) ; i ++ ) <START_BUG> buffers [ i ] = GL15 . glGenBuffers ( ) ; <END_BUG> } public void glGenBuffers ( int n , IntBuffer buffers ) { } public void glGetBooleanv ( int pname , boolean [ ] params , int offset ) { } public void glGetBooleanv ( int pname , IntBuffer params ) { } public void glGetBufferParameteriv ( int target , int pname , int [ ] params , int offset ) { } public void glGetBufferParameteriv ( int target , int pname , IntBuffer params ) { } public void glGetClipPlanef ( int pname , float [ ] eqn , int offset ) { } public void glGetClipPlanef ( int pname , FloatBuffer eqn ) { } public void glGetFixedv ( int pname , int [ ] params , int offset ) { } public void glGetFixedv ( int pname , IntBuffer params ) { } public void glGetFloatv ( int pname , float [ ] params , int offset ) { } public void glGetFloatv ( int pname , FloatBuffer params ) { } public void glGetLightfv ( int light , int pname , float [ ] params , int offset ) { } public void glGetLightfv ( int light , int pname , FloatBuffer params ) { } public void glGetLightxv ( int light , int pname , int [ ] params , int offset ) { } public void glGetLightxv ( int light , int pname , IntBuffer params ) { } public void glGetMaterialfv ( int face , int pname , float [ ] params , int offset ) { } public void glGetMaterialfv ( int face , int pname , FloatBuffer params ) { } public void glGetMaterialxv ( int face , int pname , int [ ] params , int offset ) { } public void glGetMaterialxv ( int face , int pname , IntBuffer params ) { } public void glGetPointerv ( int pname , Buffer [ ] params ) { } public void glGetTexEnviv ( int env , int pname , int [ ] params , int offset ) { } public void glGetTexEnviv ( int env , int pname , IntBuffer params ) { } public void glGetTexEnvxv ( int env , int pname , int [ ] params , int offset ) { } public void glGetTexEnvxv ( int env , int pname , IntBuffer params ) { } public void glGetTexParameterfv ( int target , int pname , float [ ] params , int offset ) { } public void glGetTexParameterfv ( int target , int pname , FloatBuffer params ) { } public void glGetTexParameteriv ( int target , int pname , int [ ] params , int offset ) { } public void glGetTexParameteriv ( int target , int pname , IntBuffer params ) { } public void glGetTexParameterxv ( int target , int pname , int [ ] params , int offset ) { } public void glGetTexParameterxv ( int target , int pname , IntBuffer params ) { } public boolean glIsBuffer ( int buffer ) { } public boolean glIsEnabled ( int cap ) { } public boolean glIsTexture ( int texture ) { } public void glPointParameterf ( int pname , float param ) { } public void glPointParameterfv ( int pname , float [ ] params , int offset ) { } public void glPointParameterfv ( int pname , FloatBuffer params ) { } public void glPointSizePointerOES ( int type , int stride , Buffer pointer ) { } public void glTexEnvi ( int target , int pname , int param ) { } public void glTexEnviv ( int target , int pname , int [ ] params , int offset ) { } public void glTexEnviv ( int target , int pname , IntBuffer params ) { } public void glTexParameterfv ( int target , int pname , float [ ] params , int offset ) { } public void glTexParameterfv ( int target , int pname , FloatBuffer params ) { } public void glTexParameteri ( int target , int pname , int param ) { } public void glTexParameteriv ( int target , int pname , int [ ] params , int offset ) { } public void glTexParameteriv ( int target , int pname , IntBuffer params ) { } public void glColorPointer ( int size , int type , int stride , int pointer ) { } public void glNormalPointer ( int type , int stride , int pointer ) { } public void glTexCoordPointer ( int size , int type , int stride , int pointer ) { }
public class ScriptGeoDistanceFacetCollector extends GeoDistanceFacetCollector { private final SearchScript script ; private ScriptGeoDistanceFacetCollector . Aggregator scriptAggregator ; public ScriptGeoDistanceFacetCollector ( String facetName , String fieldName , double lat , double lon , DistanceUnit unit , GeoDistance geoDistance , GeoDistanceFacet [ ] entries , SearchContext context , String scriptLang , String script , Map < String , Object > params ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { super . doSetNextReader ( context ) ; <START_BUG> script . setNextReader ( context . reader ( ) ) ; <END_BUG> } @ Override protected void doCollect ( int doc ) throws IOException { } public static class Aggregator implements GeoPointFieldData . ValueInDocProc { private final FixedSourceDistance fixedSourceDistance ; private final Entry [ ] entries ; double scriptValue ; public Aggregator ( GeoDistance . FixedSourceDistance fixedSourceDistance , GeoDistanceFacet [ ] entries ) { } @ Override public void onValue ( int docId , double lat , double lon ) { } } }
public class TransportSearchDfsQueryAndFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchDfsQueryAndFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportSearchCache transportSearchCache , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < DfsSearchResult > { private final Collection < DfsSearchResult > dfsResults = searchCache . obtainDfsResults ( ) ; private final Map < SearchShardTarget , QueryFetchSearchResult > queryFetchResults = searchCache . obtainQueryFetchResults ( ) ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , InternalSearchRequest request , SearchServiceListener < DfsSearchResult > listener ) { } @ Override protected void processFirstPhaseResult ( ShardRouting shard , DfsSearchResult result ) { } @ Override protected void moveToSecondPhase ( ) { } private void executeSecondPhase ( final DfsSearchResult dfsResult , final AtomicInteger counter , DiscoveryNode node , final QuerySearchRequest querySearchRequest ) { } private void finishHim ( ) { } private void innerFinishHim ( ) { sortedShardList = searchPhaseController . sortDocs ( queryFetchResults . values ( ) ) ; final InternalSearchResponse internalResponse = searchPhaseController . merge ( sortedShardList , queryFetchResults , queryFetchResults ) ; String scrollId = null ; if ( ( request . scroll ( ) ) != null ) { scrollId = buildScrollId ( request . searchType ( ) , dfsResults ) ; } <START_BUG> invokeListener ( new SearchResponse ( internalResponse , scrollId , expectedSuccessfulOps , successulOps . get ( ) , buildShardFailures ( ) ) ) ; <END_BUG> } } }
public class ClusterBlock implements Serializable , Streamable , ToXContent { private int id ; private String description ; private ClusterBlockLevel [ ] levels ; private ClusterBlock ( ) { } public ClusterBlock ( int id , String description , ClusterBlockLevel ... levels ) { } public int id ( ) { } public String description ( ) { } public ClusterBlockLevel [ ] levels ( ) { <START_BUG> return this . levels ( ) ; <END_BUG> } public boolean contains ( ClusterBlockLevel level ) { } @ Override public void toXContent ( XContentBuilder builder , Params params ) throws IOException { } public static ClusterBlock readClusterBlock ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } public String toString ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } }
public class TransportSearchQueryThenFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchQueryThenFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < QuerySearchResult > { final AtomicArray < FetchSearchResult > fetchResults ; final AtomicArray < ExtTIntArrayList > docIdsToLoad ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , ShardSearchRequest request , SearchServiceListener < QuerySearchResult > listener ) { } @ Override protected void moveToSecondPhase ( ) { } void executeFetch ( final int shardIndex , final SearchShardTarget shardTarget , final AtomicInteger counter , final FetchSearchRequest fetchSearchRequest , DiscoveryNode node ) { searchService . sendExecuteFetch ( node , fetchSearchRequest , new SearchServiceListener < FetchSearchResult > ( ) { @ Override public void onResult ( FetchSearchResult result ) { result . shardTarget ( shardTarget ) ; fetchResults . set ( shardIndex , result ) ; if ( ( counter . decrementAndGet ( ) ) == 0 ) { finishHim ( ) ; } } @ Override public void onFailure ( Throwable t ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "[{}]<seq2seq4repair_space>Failed<seq2seq4repair_space>to<seq2seq4repair_space>execute<seq2seq4repair_space>fetch<seq2seq4repair_space>phase" , t , fetchSearchRequest . id ( ) ) ; } <START_BUG> TransportSearchQueryThenFetchAction . AsyncAction . this . addShardFailure ( shardIndex , t ) ; <END_BUG> successulOps . decrementAndGet ( ) ; if ( ( counter . decrementAndGet ( ) ) == 0 ) { finishHim ( ) ; } } } ) ; } void finishHim ( ) { } void innerFinishHim ( ) throws Exception { } } }
public class EmptyScorer extends Scorer { public EmptyScorer ( Weight weight ) { } @ Override public float score ( ) throws IOException { } @ Override <START_BUG> public float freq ( ) throws IOException { <END_BUG> return 0 ; } @ Override public int docID ( ) { } @ Override public int nextDoc ( ) throws IOException { } @ Override public int advance ( int target ) throws IOException { } }
public class OrthographicCamera extends Camera { public float zoom = 1 ; public OrthographicCamera ( ) { } public OrthographicCamera ( float viewportWidth , float viewportHeight ) { } public OrthographicCamera ( float viewportWidth , float viewportHeight , float diamondAngle ) { } public void findDirectionForIsoView ( float targetAngle , float epsilon , int maxIterations ) { } private float calculateAngle ( float a ) { } private Vector3 calculateDirection ( float angle ) { } private final Vector3 tmp = new Vector3 ( ) ; @ Override public void update ( ) { } @ Override public void update ( boolean updateFrustum ) { } public void setToOrtho ( boolean yDown ) { } public void setToOrtho ( boolean yDown , float viewportWidth , float viewportHeight ) { if ( yDown ) { up . set ( 0 , ( - 1 ) , 0 ) ; direction . set ( 0 , 0 , 1 ) ; } <START_BUG> position . set ( ( viewportWidth / 2.0F ) , ( viewportHeight / 2.0F ) , 0 ) ; <END_BUG> this . viewportWidth = viewportWidth ; this . viewportHeight = viewportHeight ; update ( ) ; } public void rotate ( float angle ) { } public void translate ( float x , float y ) { } public void translate ( Vector2 vec ) { } }
public class LwjglCanvas implements Application { LwjglGraphics graphics ; OpenALAudio audio ; LwjglFiles files ; LwjglInput input ; LwjglNet net ; ApplicationListener listener ; Canvas canvas ; final List < Runnable > runnables = new ArrayList ( ) ; final List < Runnable > executedRunnables = new ArrayList ( ) ; final Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; boolean running = true ; int logLevel = LOG_INFO ; Cursor cursor ; public LwjglCanvas ( ApplicationListener listener , boolean useGL2 ) { } public LwjglCanvas ( ApplicationListener listener , LwjglApplicationConfiguration config ) { } private void initialize ( ApplicationListener listener , LwjglApplicationConfiguration config ) { } protected void setDisplayMode ( int width , int height ) { } protected void setTitle ( String title ) { } @ Override public ApplicationListener getApplicationListener ( ) { } public Canvas getCanvas ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Files getFiles ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Input getInput ( ) { } @ Override public Net getNet ( ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { } void create ( ) { } protected int getFrameRate ( ) { int frameRate = ( Display . isActive ( ) ) ? graphics . config . foregroundFPS : graphics . config . backgroundFPS ; if ( frameRate == ( - 1 ) ) frameRate = 10 ; if ( frameRate == 0 ) frameRate = graphics . config . backgroundFPS ; if ( frameRate == 0 ) frameRate = 30 ; <START_BUG> return 0 ; <END_BUG> } protected void exception ( Throwable ex ) { } protected void start ( ) { } protected void resize ( int width , int height ) { } protected void stopped ( ) { } public void stop ( ) { } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } Map < String , Preferences > preferences = new HashMap < String , Preferences > ( ) ; @ Override public Preferences getPreferences ( String name ) { } @ Override public Clipboard getClipboard ( ) { } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } public void log ( String tag , String message ) { } @ Override public void log ( String tag , String message , Exception exception ) { } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public void exit ( ) { } public void setCursor ( Cursor cursor ) { } @ Override public void addLifecycleListener ( LifecycleListener listener ) { } @ Override public void removeLifecycleListener ( LifecycleListener listener ) { } }
public class UnicodeFont { private static final int DISPLAY_LIST_CACHE_SIZE = 200 ; private static final int MAX_GLYPH_CODE = 1114111 ; private static final int PAGE_SIZE = 512 ; private static final int PAGES = ( UnicodeFont . MAX_GLYPH_CODE ) / ( UnicodeFont . PAGE_SIZE ) ; private Font font ; private FontMetrics metrics ; private String ttfFileRef ; private int ascent ; private int descent ; private int leading ; private int spaceWidth ; private final Glyph [ ] [ ] glyphs = new Glyph [ UnicodeFont . PAGES ] [ ] ; private final List glyphPages = new ArrayList ( ) ; private final List queuedGlyphs = new ArrayList ( 256 ) ; private final List effects = new ArrayList ( ) ; private int paddingTop ; private int paddingLeft ; private int paddingBottom ; private int paddingRight ; private int paddingAdvanceX ; private int paddingAdvanceY ; private Glyph missingGlyph ; private int glyphPageWidth = 512 ; private int glyphPageHeight = 512 ; private final UnicodeFont . DisplayList emptyDisplayList = new UnicodeFont . DisplayList ( ) ; private boolean nativeRendering ; private boolean displayListCaching = true ; private int baseDisplayListID = - 1 ; int eldestDisplayListID ; private final LinkedHashMap displayLists = new LinkedHashMap ( UnicodeFont . DISPLAY_LIST_CACHE_SIZE , 1 , true ) { protected boolean removeEldestEntry ( Map . Entry eldest ) { } } ; public UnicodeFont ( String ttfFileRef , String hieroFileRef ) { } public UnicodeFont ( String ttfFileRef , HieroSettings settings ) { } public UnicodeFont ( String ttfFileRef , int size , boolean bold , boolean italic ) { } public UnicodeFont ( Font font , String hieroFileRef ) { } public UnicodeFont ( Font font , HieroSettings settings ) { } public UnicodeFont ( Font font ) { } public UnicodeFont ( Font font , int size , boolean bold , boolean italic ) { } private void initializeFont ( Font baseFont , int size , boolean bold , boolean italic ) { } private void loadSettings ( HieroSettings settings ) { } public void addGlyphs ( int startCodePoint , int endCodePoint ) { } public void addGlyphs ( String text ) { } public void addAsciiGlyphs ( ) { } public void addNeheGlyphs ( ) { } public boolean loadGlyphs ( ) { } public boolean loadGlyphs ( int maxGlyphsToLoad ) { } public void clearGlyphs ( ) { } public void destroy ( ) { } public UnicodeFont . DisplayList drawDisplayList ( float x , float y , String text , Color color , int startIndex , int endIndex ) { } public void drawString ( float x , float y , String text , Color color , int startIndex , int endIndex ) { } public void drawString ( float x , float y , String text ) { } public void drawString ( float x , float y , String text , Color col ) { } private Glyph getGlyph ( int glyphCode , int codePoint , Rectangle bounds , GlyphVector vector , int index ) { } private Rectangle getGlyphBounds ( GlyphVector vector , int index , int codePoint ) { } public int getSpaceWidth ( ) { } public int getWidth ( String text ) { } public int getHeight ( String text ) { } public int getYOffset ( String text ) { } public Font getFont ( ) { } public int getPaddingTop ( ) { } public void setPaddingTop ( int paddingTop ) { } public int getPaddingLeft ( ) { } public void setPaddingLeft ( int paddingLeft ) { } public int getPaddingBottom ( ) { } public void setPaddingBottom ( int paddingBottom ) { } public int getPaddingRight ( ) { } public void setPaddingRight ( int paddingRight ) { } public int getPaddingAdvanceX ( ) { } public void setPaddingAdvanceX ( int paddingAdvanceX ) { } public int getPaddingAdvanceY ( ) { } public void setPaddingAdvanceY ( int paddingAdvanceY ) { } public int getLineHeight ( ) { } public int getAscent ( ) { } public int getDescent ( ) { } public int getLeading ( ) { } public int getGlyphPageWidth ( ) { } public void setGlyphPageWidth ( int glyphPageWidth ) { } public int getGlyphPageHeight ( ) { } public void setGlyphPageHeight ( int glyphPageHeight ) { } public List getGlyphPages ( ) { } public List getEffects ( ) { } public boolean isCaching ( ) { } public void setDisplayListCaching ( boolean displayListCaching ) { } public void setNativeRendering ( boolean nativeRendering ) { } public boolean getNativeRendering ( ) { } public String getFontFile ( ) { } private static Font createFont ( String ttfFileRef ) { try { <START_BUG> return Font . createFont ( Font . TRUETYPE_FONT , files . readFile ( ttfFileRef , Absolute ) ) ; <END_BUG> } catch ( FontFormatException ex ) { throw new GdxRuntimeException ( ( "Invalid<seq2seq4repair_space>font:<seq2seq4repair_space>" + ttfFileRef ) , ex ) ; } catch ( IOException ex ) { throw new GdxRuntimeException ( ( "Error<seq2seq4repair_space>reading<seq2seq4repair_space>font:<seq2seq4repair_space>" + ttfFileRef ) , ex ) ; } } private static final Comparator heightComparator = new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { } } ; public class DisplayList { boolean invalid ; int id ; Short yOffset ; public short width ; public short height ; public Object userData ; DisplayList ( ) { } } }
public class LogByteSizeMergePolicyProvider extends AbstractIndexShardComponent implements MergePolicyProvider < LogByteSizeMergePolicy > { private final IndexSettingsService indexSettingsService ; private volatile boolean compoundFormat ; private volatile ByteSizeValue minMergeSize ; private volatile ByteSizeValue maxMergeSize ; private volatile int mergeFactor ; private volatile int maxMergeDocs ; private final boolean calibrateSizeByDeletes ; private boolean asyncMerge ; private final Set < LogByteSizeMergePolicyProvider . CustomLogByteSizeMergePolicy > policies = new CopyOnWriteArraySet < LogByteSizeMergePolicyProvider . CustomLogByteSizeMergePolicy > ( ) ; private final LogByteSizeMergePolicyProvider . ApplySettings applySettings = new LogByteSizeMergePolicyProvider . ApplySettings ( ) ; @ Inject public LogByteSizeMergePolicyProvider ( Store store , IndexSettingsService indexSettingsService ) { } @ Override public LogByteSizeMergePolicy newMergePolicy ( ) { LogByteSizeMergePolicyProvider . CustomLogByteSizeMergePolicy mergePolicy ; if ( asyncMerge ) { <START_BUG> mergePolicy = new LogByteSizeMergePolicyProvider . CustomLogByteSizeMergePolicy ( this ) ; <END_BUG> } else { mergePolicy = new LogByteSizeMergePolicyProvider . CustomLogByteSizeMergePolicy ( this ) ; } mergePolicy . setMinMergeMB ( minMergeSize . mbFrac ( ) ) ; mergePolicy . setMaxMergeMB ( maxMergeSize . mbFrac ( ) ) ; mergePolicy . setMergeFactor ( mergeFactor ) ; mergePolicy . setMaxMergeDocs ( maxMergeDocs ) ; mergePolicy . setCalibrateSizeByDeletes ( calibrateSizeByDeletes ) ; mergePolicy . setUseCompoundFile ( compoundFormat ) ; policies . add ( mergePolicy ) ; return mergePolicy ; } @ Override public void close ( boolean delete ) throws ElasticSearchException { } class ApplySettings implements IndexSettingsService . Listener { @ Override public void onRefreshSettings ( Settings settings ) { } } public static class CustomLogByteSizeMergePolicy extends LogByteSizeMergePolicy { private final LogByteSizeMergePolicyProvider provider ; public CustomLogByteSizeMergePolicy ( LogByteSizeMergePolicyProvider provider ) { } @ Override public void close ( ) { } } public static class EnableMergeLogByteSizeMergePolicy extends LogByteSizeMergePolicyProvider . CustomLogByteSizeMergePolicy implements EnableMergePolicy { private final ThreadLocal < Boolean > enableMerge = new ThreadLocal < Boolean > ( ) { @ Override protected Boolean initialValue ( ) { } } ; public EnableMergeLogByteSizeMergePolicy ( LogByteSizeMergePolicyProvider provider ) { } @ Override public void enableMerge ( ) { } @ Override public void disableMerge ( ) { } @ Override public boolean isMergeEnabled ( ) { } @ Override public void close ( ) { } @ Override public MergeSpecification findMerges ( SegmentInfos infos ) throws IOException { } @ Override public MergeSpecification findMergesToExpungeDeletes ( SegmentInfos segmentInfos ) throws IOException , CorruptIndexException { } @ Override public MergeSpecification findMergesForOptimize ( SegmentInfos infos , int maxNumSegments , Set < SegmentInfo > segmentsToOptimize ) throws IOException { } } }
public class XContentMapValues { public static List < Object > extractRawValues ( String path , Map < String , Object > map ) { } @ SuppressWarnings ( { "unchecked" } ) private static void extractRawValues ( List values , Map < String , Object > part , String [ ] pathElements , int index ) { } @ SuppressWarnings ( { "unchecked" } ) private static void extractRawValues ( List values , List < Object > part , String [ ] pathElements , int index ) { } public static Object extractValue ( String path , Map < String , Object > map ) { } @ SuppressWarnings ( { "unchecked" } ) private static Object extractValue ( String [ ] pathElements , int index , Object currentValue ) { } public static Map < String , Object > filter ( Map < String , Object > map , String [ ] includes , String [ ] excludes ) { Map < String , Object > result = Maps . newHashMap ( ) ; <START_BUG> XContentMapValues . filter ( map , result , includes , excludes , new StringBuilder ( ) ) ; <END_BUG> return result ; } private static void filter ( Map < String , Object > map , Map < String , Object > into , String [ ] includes , String [ ] excludes , StringBuilder sb ) { } private static void filter ( List < Object > from , List < Object > to , String [ ] includes , String [ ] excludes , StringBuilder sb ) { } public static boolean isObject ( Object node ) { } public static boolean isArray ( Object node ) { } public static String nodeStringValue ( Object node , String defaultValue ) { } public static float nodeFloatValue ( Object node , float defaultValue ) { } public static float nodeFloatValue ( Object node ) { } public static double nodeDoubleValue ( Object node , double defaultValue ) { } public static double nodeDoubleValue ( Object node ) { } public static int nodeIntegerValue ( Object node ) { } public static int nodeIntegerValue ( Object node , int defaultValue ) { } public static short nodeShortValue ( Object node , short defaultValue ) { } public static short nodeShortValue ( Object node ) { } public static byte nodeByteValue ( Object node , byte defaultValue ) { } public static byte nodeByteValue ( Object node ) { } public static long nodeLongValue ( Object node , long defaultValue ) { } public static long nodeLongValue ( Object node ) { } public static boolean nodeBooleanValue ( Object node , boolean defaultValue ) { } public static boolean nodeBooleanValue ( Object node ) { } public static TimeValue nodeTimeValue ( Object node , TimeValue defaultValue ) { } public static TimeValue nodeTimeValue ( Object node ) { } }
public class BoostScoreFunction implements ScoreFunction { private final float boost ; public BoostScoreFunction ( float boost ) { } public float getBoost ( ) { } @ Override public void setNextReader ( AtomicReaderContext context ) { } @ Override public float score ( int docId , float subQueryScore ) { } @ Override <START_BUG> public float factor ( int docId ) { <END_BUG> return boost ; } @ Override public Explanation explainScore ( int docId , Explanation subQueryExpl ) { } @ Override public Explanation explainFactor ( int docId ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } }
public class GLES10Shader implements Shader { private Camera camera ; private RenderContext context ; private Matrix4 currentTransform ; private Material currentMaterial ; private Texture currentTexture0 ; private Mesh currentMesh ; public static int defaultCullFace = GL10 . GL_BACK ; public GLES10Shader ( ) { } @ Override public void init ( ) { } @ Override public boolean canRender ( final Renderable renderable ) { } @ Override public int compareTo ( Shader other ) { } @ Override public boolean equals ( Object obj ) { } public boolean equals ( GLES10Shader obj ) { } @ Override public void begin ( final Camera camera , final RenderContext context ) { this . context = context ; this . camera = camera ; <START_BUG> context . setDepthTest ( GL_LEQUAL , 0 , 1 , true ) ; <END_BUG> gl10 . glMatrixMode ( GL_PROJECTION ) ; gl10 . glLoadMatrixf ( camera . combined . val , 0 ) ; gl10 . glMatrixMode ( GL_MODELVIEW ) ; } private final float [ ] lightVal = new float [ ] { 0 , 0 , 0 , 0 } ; private final float [ ] zeroVal4 = new float [ ] { 0 , 0 , 0 , 0 } ; private final float [ ] oneVal4 = new float [ ] { 1 , 1 , 1 , 1 } ; private void bindLights ( Lights lights ) { } private static final float [ ] getValues ( final float [ ] out , final float v0 , final float v1 , final float v2 , final float v3 ) { } private static final float [ ] getValues ( final float [ ] out , final Color color ) { } @ Override public void render ( final Renderable renderable ) { } @ Override public void end ( ) { } @ Override public void dispose ( ) { } }
public class HttpImageGetter implements ImageGetter { private static class LoadingImageGetter implements ImageGetter { private final Drawable image ; private LoadingImageGetter ( final Context context , final int size ) { } @ Override public Drawable getDrawable ( String source ) { } } private static boolean containsImages ( final String html ) { <START_BUG> return ( html . indexOf ( "<img" ) ) != ( - 1 ) ; <END_BUG> } private final HttpImageGetter . LoadingImageGetter loading ; private final Context context ; private final File dir ; private final int width ; private final Map < Object , CharSequence > rawHtmlCache = new HashMap < Object , CharSequence > ( ) ; private final Map < Object , CharSequence > fullHtmlCache = new HashMap < Object , CharSequence > ( ) ; private final ContentsService service ; @ Inject public HttpImageGetter ( Context context , ContentsService service ) { } private HttpImageGetter show ( final TextView view , final CharSequence html ) { } private HttpImageGetter hide ( final TextView view ) { } public HttpImageGetter encode ( final Object id , final String html ) { } public HttpImageGetter bind ( final TextView view , final String html , final Object id ) { } private Drawable requestRepositoryImage ( final String source ) throws IOException { } @ Override public Drawable getDrawable ( final String source ) { } }
public void glBlendFunc ( int sfactor , int dfactor ) { } public void glBlendFuncSeparate ( int srcRGB , int dstRGB , int srcAlpha , int dstAlpha ) { } public void glBufferData ( int target , int size , Buffer data , int usage ) { } public void glBufferSubData ( int target , int offset , int size , Buffer data ) { } public int glCheckFramebufferStatus ( int target ) { } public void glClear ( int mask ) { } public void glClearColor ( float red , float green , float blue , float alpha ) { } public void glClearDepthf ( float depth ) { } public void glClearStencil ( int s ) { } public void glColorMask ( boolean red , boolean green , boolean blue , boolean alpha ) { } public void glCompileShader ( int shader ) { } public void glCompressedTexImage2D ( int target , int level , int internalformat , int width , int height , int border , int imageSize , Buffer data ) { } public void glCompressedTexSubImage2D ( int target , int level , int xoffset , int yoffset , int width , int height , int format , int imageSize , Buffer data ) { } public void glCopyTexImage2D ( int target , int level , int internalformat , int x , int y , int width , int height , int border ) { } public void glCopyTexSubImage2D ( int target , int level , int xoffset , int yoffset , int x , int y , int width , int height ) { } public int glCreateProgram ( ) { } public int glCreateShader ( int type ) { } public void glCullFace ( int mode ) { } public void glDeleteBuffers ( int n , IntBuffer buffers ) { } public void glDeleteFramebuffers ( int n , IntBuffer framebuffers ) { } public void glDeleteProgram ( int program ) { } public void glDeleteRenderbuffers ( int n , IntBuffer renderbuffers ) { } public void glDeleteShader ( int shader ) { } public void glDeleteTextures ( int n , IntBuffer textures ) { } public void glDepthFunc ( int func ) { } public void glDepthMask ( boolean flag ) { } public void glDepthRangef ( float zNear , float zFar ) { } public void glDetachShader ( int program , int shader ) { } public void glDisable ( int cap ) { } public void glDisableVertexAttribArray ( int index ) { } public void glDrawArrays ( int mode , int first , int count ) { } public void glDrawElements ( int mode , int count , int type , Buffer indices ) { } public void glEnable ( int cap ) { } public void glEnableVertexAttribArray ( int index ) { } public void glFinish ( ) { } public void glFlush ( ) { } public void glFramebufferRenderbuffer ( int target , int attachment , int renderbuffertarget , int renderbuffer ) { } public void glFramebufferTexture2D ( int target , int attachment , int textarget , int texture , int level ) { } public void glFrontFace ( int mode ) { } public void glGenBuffers ( int n , IntBuffer buffers ) { } public void glGenFramebuffers ( int n , IntBuffer framebuffers ) { } public void glGenRenderbuffers ( int n , IntBuffer renderbuffers ) { } public void glGenTextures ( int n , IntBuffer textures ) { } public void glGenerateMipmap ( int target ) { } public String glGetActiveAttrib ( int program , int index , IntBuffer size , Buffer type ) { } public String glGetActiveUniform ( int program , int index , IntBuffer size , Buffer type ) { IntBuffer typeTmp = BufferUtils . createIntBuffer ( 2 ) ; String name = org . lwjgl . opengl . GL20 . glGetActiveUniform ( program , index , 256 , typeTmp ) ; size . put ( typeTmp . get ( 0 ) ) ; if ( type instanceof IntBuffer ) <START_BUG> ( ( IntBuffer ) ( type ) ) . put ( typeTmp . get ( 1 ) ) ; <END_BUG> return name ; } public void glGetAttachedShaders ( int program , int maxcount , Buffer count , IntBuffer shaders ) { } public int glGetAttribLocation ( int program , String name ) { } public void glGetBooleanv ( int pname , Buffer params ) { } public void glGetBufferParameteriv ( int target , int pname , IntBuffer params ) { } public int glGetError ( ) { } public void glGetFloatv ( int pname , FloatBuffer params ) { } public void glGetFramebufferAttachmentParameteriv ( int target , int attachment , int pname , IntBuffer params ) { } public void glGetIntegerv ( int pname , IntBuffer params ) { } public String glGetProgramInfoLog ( int program ) { } public void glGetProgramiv ( int program , int pname , IntBuffer params ) { } public void glGetRenderbufferParameteriv ( int target , int pname , IntBuffer params ) { } public String glGetShaderInfoLog ( int shader ) { } public void glGetShaderPrecisionFormat ( int shadertype , int precisiontype , IntBuffer range , IntBuffer precision ) { } public void glGetShaderiv ( int shader , int pname , IntBuffer params ) { } public String glGetString ( int name ) { } public void glGetTexParameterfv ( int target , int pname , FloatBuffer params ) { } public void glGetTexParameteriv ( int target , int pname , IntBuffer params ) { } public int glGetUniformLocation ( int program , String name ) { } public void glGetUniformfv ( int program , int location , FloatBuffer params ) { } public void glGetUniformiv ( int program , int location , IntBuffer params ) { } public void glGetVertexAttribPointerv ( int index , int pname , Buffer pointer ) { } public void glGetVertexAttribfv ( int index , int pname , FloatBuffer params ) { }
protected final ClusterService clusterService ; final String transportAction ; final String executor ; protected TransportMasterNodeOperationAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } protected abstract String transportAction ( ) { } protected abstract String executor ( ) { } protected abstract Request newRequest ( ) { } protected abstract Response newResponse ( ) { } protected abstract Response masterOperation ( Request request , ClusterState state ) throws ElasticSearchException { } protected boolean localExecute ( Request request ) { } protected ClusterBlockException checkBlock ( Request request , ClusterState state ) { } protected void processBeforeDelegationToMaster ( Request request , ClusterState state ) { } @ Override protected void doExecute ( final Request request , final ActionListener < Response > listener ) { } private void innerExecute ( final Request request , final ActionListener < Response > listener , final boolean retrying ) { final ClusterState clusterState = clusterService . state ( ) ; final DiscoveryNodes nodes = clusterState . nodes ( ) ; if ( ( nodes . localNodeMaster ( ) ) || ( localExecute ( request ) ) ) { final ClusterBlockException blockException = checkBlock ( request , clusterState ) ; if ( blockException != null ) { if ( ! ( blockException . retryable ( ) ) ) { listener . onFailure ( blockException ) ; return ; } clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { ClusterBlockException blockException = checkBlock ( request , clusterService . state ( ) ) ; if ( ( blockException == null ) || ( ! ( blockException . retryable ( ) ) ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( blockException ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; listener . onFailure ( blockException ) ; } @ Override public void clusterChanged ( ClusterChangedEvent event ) { ClusterBlockException blockException = checkBlock ( request , event . state ( ) ) ; if ( ( blockException == null ) || ( ! ( blockException . retryable ( ) ) ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } } ) ; } else { threadPool . executor ( executor ) . execute ( new Runnable ( ) { @ Override public void run ( ) { try { Response response = masterOperation ( request , clusterState ) ; listener . onResponse ( response ) ; } catch ( Exception e ) { listener . onFailure ( e ) ; } } } ) ; } } else { if ( ( nodes . masterNode ( ) ) == null ) { if ( retrying ) { listener . onFailure ( new MasterNotDiscoveredException ( ) ) ; } else { clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { ClusterState clusterStateV2 = clusterService . state ( ) ; if ( ( clusterStateV2 . nodes ( ) . masterNodeId ( ) ) != null ) { clusterService . remove ( this ) ; innerExecute ( request , listener , true ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( new org . elasticsearch . node . NodeClosedException ( nodes . localNode ( ) ) ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; <START_BUG> listener . onFailure ( new MasterNotDiscoveredException ( ) ) ; <END_BUG> } @ Override public void clusterChanged ( ClusterChangedEvent event ) { if ( event . nodesDelta ( ) . masterNodeChanged ( ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , true ) ; } } } ) ; } return ; } processBeforeDelegationToMaster ( request , clusterState ) ; transportService . sendRequest ( nodes . masterNode ( ) , transportAction , request , new BaseTransportResponseHandler < Response > ( ) { @ Override public Response newInstance ( ) { return newResponse ( ) ; } @ Override public void handleResponse ( Response response ) { listener . onResponse ( response ) ; } @ Override public String executor ( ) { return Names . SAME ; } @ Override public void handleException ( final TransportException exp ) { if ( ( exp . unwrapCause ( ) ) instanceof ConnectTransportException ) { clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { ClusterState clusterStateV2 = clusterService . state ( ) ; if ( ! ( clusterState . nodes ( ) . masterNodeId ( ) . equals ( clusterStateV2 . nodes ( ) . masterNodeId ( ) ) ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( new org . elasticsearch . node . NodeClosedException ( nodes . localNode ( ) ) ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; listener . onFailure ( new MasterNotDiscoveredException ( ) ) ; } @ Override public void clusterChanged ( ClusterChangedEvent event ) { if ( event . nodesDelta ( ) . masterNodeChanged ( ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ;
public class RefDialogFragment extends SingleChoiceDialogFragment { private static class RefListAdapter extends SingleTypeAdapter < Reference > { private final int selected ; public RefListAdapter ( LayoutInflater inflater , Reference [ ] refs , int selected ) { } @ Override public long getItemId ( int position ) { } @ Override protected int [ ] getChildViewIds ( ) { } @ Override protected View initialize ( View view ) { view = super . initialize ( view ) ; <START_BUG> TypefaceUtils . setOcticons ( textView ( view , 0 ) ) ; <END_BUG> return view ; } @ Override protected void update ( int position , Reference item ) { } } public static Reference getSelected ( Bundle arguments ) { } public static void show ( final DialogFragmentActivity activity , final int requestCode , final String title , final String message , ArrayList < Reference > choices , final int selectedChoice ) { } @ Override public Dialog onCreateDialog ( final Bundle savedInstanceState ) { } @ SuppressWarnings ( "unchecked" ) private ArrayList < Reference > getChoices ( ) { } @ Override public void onClick ( DialogInterface dialog , int which ) { } }
public class Button extends Table implements Disableable { private Button . ButtonStyle style ; boolean isChecked ; boolean isDisabled ; ButtonGroup buttonGroup ; private ClickListener clickListener ; public Button ( Skin skin ) { } public Button ( Skin skin , String styleName ) { } public Button ( Actor child , Skin skin , String styleName ) { } public Button ( Actor child , Button . ButtonStyle style ) { } public Button ( Button . ButtonStyle style ) { } public Button ( ) { } private void initialize ( ) { } public Button ( Drawable up ) { } public Button ( Drawable up , Drawable down ) { } public Button ( Drawable up , Drawable down , Drawable checked ) { } public Button ( Actor child , Skin skin ) { } public void setChecked ( boolean isChecked ) { } public void toggle ( ) { } public boolean isChecked ( ) { } public boolean isPressed ( ) { <START_BUG> return clickListener . isVisualPressed ( ) ; <END_BUG> } public boolean isOver ( ) { } public ClickListener getClickListener ( ) { } public boolean isDisabled ( ) { } public void setDisabled ( boolean isDisabled ) { } public void setStyle ( Button . ButtonStyle style ) { } public Button . ButtonStyle getStyle ( ) { } public void draw ( Batch batch , float parentAlpha ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMinWidth ( ) { } public float getMinHeight ( ) { } public static class ButtonStyle { public Drawable up ; public Drawable down ; public Drawable over ; public Drawable checked ; public Drawable checkedOver ; public Drawable disabled ; public float pressedOffsetX ; public float pressedOffsetY ; public float unpressedOffsetX ; public float unpressedOffsetY ; public ButtonStyle ( ) { } public ButtonStyle ( Drawable up , Drawable down , Drawable checked ) { } public ButtonStyle ( Button . ButtonStyle style ) { } } }
; Skin skin ; Stage stage ; SpriteBatch batch ; Texture texture1 ; Texture texture2 ; Actor root ; Label fpsLabel ; @ Override public void create ( ) { batch = new SpriteBatch ( ) ; skin = new Skin ( files . internal ( "data/uiskin.json" ) ) ; texture1 = new Texture ( files . internal ( "data/badlogicsmall.jpg" ) ) ; texture2 = new Texture ( files . internal ( "data/badlogic.jpg" ) ) ; TextureRegion image = new TextureRegion ( texture1 ) ; TextureRegion imageFlipped = new TextureRegion ( image ) ; imageFlipped . flip ( true , true ) ; TextureRegion image2 = new TextureRegion ( texture2 ) ; stage = new Stage ( graphics . getWidth ( ) , graphics . getHeight ( ) , false ) ; input . setInputProcessor ( stage ) ; ImageButtonStyle style = new ImageButtonStyle ( skin . get ( ButtonStyle . class ) ) ; style . imageUp = new com . badlogic . gdx . scenes . scene2d . utils . TextureRegionDrawable ( image ) ; style . imageDown = new com . badlogic . gdx . scenes . scene2d . utils . TextureRegionDrawable ( imageFlipped ) ; ImageButton iconButton = new ImageButton ( style ) ; Button buttonMulti = new com . badlogic . gdx . scenes . scene2d . ui . TextButton ( "Multi\nLine\nToggle" , skin , "toggle" ) ; Button imgButton = new Button ( new Image ( image ) , skin ) ; Button imgToggleButton = new Button ( new Image ( image ) , skin , "toggle" ) ; Label myLabel = new Label ( "this<seq2seq4repair_space>is<seq2seq4repair_space>some<seq2seq4repair_space>text." , skin ) ; myLabel . setWrap ( true ) ; Table t = new Table ( ) ; t . row ( ) ; t . add ( myLabel ) ; t . layout ( ) ; CheckBox checkBox = new CheckBox ( "Check<seq2seq4repair_space>me" , skin ) ; final Slider slider = new Slider ( 0 , 10 , 1 , false , skin ) ; TextField textfield = new TextField ( "" , skin ) ; textfield . setMessageText ( "Click<seq2seq4repair_space>here!" ) ; SelectBox dropdown = new SelectBox ( new String [ ] { "Android" , "Windows" , "Linux" , "OSX" } , skin ) ; Image imageActor = new Image ( image2 ) ; ScrollPane scrollPane = new ScrollPane ( imageActor ) ; List list = new List ( listEntries , skin ) ; ScrollPane scrollPane2 = new ScrollPane ( list , skin ) ; scrollPane2 . setFlickScroll ( false ) ; SplitPane splitPane = new SplitPane ( scrollPane , scrollPane2 , false , skin , "default-horizontal" ) ; fpsLabel = new Label ( "fps:" , skin ) ; final Label passwordLabel = new Label ( "Textfield<seq2seq4repair_space>in<seq2seq4repair_space>password<seq2seq4repair_space>mode:<seq2seq4repair_space>" , skin ) ; final TextField passwordTextField = new TextField ( "" , skin ) ; passwordTextField . setMessageText ( "password" ) ; passwordTextField . setPasswordCharacter ( '*' ) ; passwordTextField . setPasswordMode ( true ) ; Window window = new Window ( "Dialog" , skin ) ; window . setPosition ( 0 , 0 ) ; window . defaults ( ) . spaceBottom ( 10 ) ; window . row ( ) . fill ( ) . expandX ( ) ; window . add ( iconButton ) ; window . add ( buttonMulti ) ; window . add ( imgButton ) ; window . add ( imgToggleButton ) ; window . row ( ) ; window . add ( checkBox ) ; window . add ( slider ) . minWidth ( 100 ) . fillX ( ) . colspan ( 3 ) ; window . row ( ) ; window . add ( dropdown ) ; window . add ( textfield ) . minWidth ( 100 ) . expandX ( ) . fillX ( ) . colspan ( 3 ) ; window . row ( ) ; window . add ( splitPane ) . fill ( ) . expand ( ) . colspan ( 4 ) . maxHeight ( 200 ) ; window . row ( ) ; window . add ( passwordLabel ) . colspan ( 2 ) ; window . add ( passwordTextField ) . minWidth ( 100 ) . expandX ( ) . fillX ( ) . colspan ( 2 ) ; window . row ( ) ; window . add ( fpsLabel ) . colspan ( 4 ) ; window . pack ( ) ; stage . addActor ( window ) ; textfield . setTextFieldListener ( new TextFieldListener ( ) { public void keyTyped ( TextField textField , char key ) { if ( key == '\n' ) textField . getOnscreenKeyboard ( ) . show ( false ) ; } } ) ; slider . addListener ( new ChangeListener ( ) { public void changed ( ChangeEvent event , Actor actor ) { app . log ( "UITest" , ( "slider:<seq2seq4repair_space>" + ( slider . getValue ( ) ) ) ) ; } } ) ; iconButton . addListener ( new ChangeListener ( ) { public void changed ( ChangeEvent event , Actor actor ) { new com . badlogic . gdx . scenes . scene2d . ui . Dialog ( "Some<seq2seq4repair_space>Dialog" , skin , "dialog" ) { protected void clicked ( Object object ) { System . out . println ( ( "Chosen:<seq2seq4repair_space>" + object ) ) ; } <START_BUG> } . text ( "Are<seq2seq4repair_space>you<seq2seq4repair_space>enjoying<seq2seq4repair_space>this<seq2seq4repair_space>demo?" ) . button ( "Yes" , true ) . button ( "No" , false ) . key ( ENTER , true ) . key ( ESCAPE , false ) . show ( stage , 0.4F ) ; <END_BUG> } } ) ; } @ Override public void render ( ) { } @ Override public void resize ( int width , int height ) { } @ Override public void dispose ( ) { } }
public class Sequence implements Action { static final Pool < Sequence > pool = new Pool < Sequence > ( new com . badlogic . gdx . utils . Pool . PoolObjectFactory < Sequence > ( ) { @ Override public Sequence createObject ( ) { } } , 100 ) ; protected final List < Action > actions = new ArrayList < Action > ( ) ; protected Actor target ; protected int currAction = 0 ; public static Sequence $ ( Action ... actions ) { } @ Override public void setTarget ( Actor actor ) { } @ Override public void act ( float delta ) { } @ Override public boolean isDone ( ) { <START_BUG> return ( currAction ) == ( actions . size ( ) ) ; <END_BUG> } @ Override public void finish ( ) { } @ Override public Action copy ( ) { } }
public final class LoggerInfoStream extends InfoStream { private final ESLogger logger ; public LoggerInfoStream ( Settings settings , ShardId shardId ) { } public void message ( String component , String message ) { <START_BUG> logger . trace ( "{}<seq2seq4repair_space>{}:<seq2seq4repair_space>{}" , Thread . currentThread ( ) . getName ( ) , component , message ) ; <END_BUG> } public boolean isEnabled ( String component ) { } @ Override public void close ( ) { } }
public class CountdownEventAction < T extends Event > extends EventAction < T > { int count ; int current ; public CountdownEventAction ( Class < ? extends T > eventClass , int count ) { } public boolean handle ( T event ) { ( current ) ++ ; <START_BUG> return ( current ) > ( count ) ; <END_BUG> } }
public abstract class Camera { public final Vector3 position = new Vector3 ( ) ; public final Vector3 direction = new Vector3 ( 0 , 0 , ( - 1 ) ) ; public final Vector3 up = new Vector3 ( 0 , 1 , 0 ) ; public final Matrix4 projection = new Matrix4 ( ) ; public final Matrix4 view = new Matrix4 ( ) ; public final Matrix4 combined = new Matrix4 ( ) ; public final Matrix4 invProjectionView = new Matrix4 ( ) ; public float near = 1 ; public float far = 100 ; public float viewportWidth = 0 ; public float viewportHeight = 0 ; public final Frustum frustum = new Frustum ( ) ; private final Matrix4 tmpMat = new Matrix4 ( ) ; private final Vector3 tmpVec = new Vector3 ( ) ; public abstract void update ( ) { } public abstract void update ( boolean updateFrustum ) { } public void apply ( GL10 gl ) { } public void lookAt ( float x , float y , float z ) { } final Vector3 right = new Vector3 ( ) ; public void normalizeUp ( ) { } public void rotate ( float angle , float axisX , float axisY , float axisZ ) { } public void rotate ( Vector3 axis , float angle ) { } public void rotateAround ( Vector3 point , Vector3 axis , float angle ) { tmpVec . set ( point ) ; tmpVec . sub ( position ) ; translate ( tmpVec ) ; rotate ( axis , angle ) ; tmpVec . rotate ( axis , angle ) ; <START_BUG> translate ( tmpVec . set ( ( - ( tmpVec . x ) ) , ( - ( tmpVec . y ) ) , ( - ( tmpVec . z ) ) ) ) ; <END_BUG> } public void translate ( float x , float y , float z ) { } public void translate ( Vector3 vec ) { } public void unproject ( Vector3 vec , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } public void unproject ( Vector3 vec ) { } public void project ( Vector3 vec ) { } public void project ( Vector3 vec , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } final Ray ray = new Ray ( new Vector3 ( ) , new Vector3 ( ) ) ; public Ray getPickRay ( float x , float y , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { } public Ray getPickRay ( float x , float y ) { } }
public interface IndexShard extends IndexShardComponent { ShardIndexingService indexingService ( ) { } ShardGetService getService ( ) { } ShardSearchService searchService ( ) { } ShardIndexWarmerService warmerService ( ) { } ShardFilterCache filterCache ( ) { } ShardIdCache idCache ( ) { } ShardFieldData fieldData ( ) { } ShardRouting routingEntry ( ) { } DocsStats docStats ( ) { } StoreStats storeStats ( ) { } IndexingStats indexingStats ( String ... types ) { } SearchStats searchStats ( String ... groups ) { } GetStats getStats ( ) { } MergeStats mergeStats ( ) { } SegmentsStats segmentStats ( ) { } RefreshStats refreshStats ( ) { } FlushStats flushStats ( ) { } WarmerStats warmerStats ( ) { } FilterCacheStats filterCacheStats ( ) { } IdCacheStats idCacheStats ( ) { } FieldDataStats fieldDataStats ( String ... fields ) { } CompletionStats completionStats ( String ... fields ) { } PercolatorQueriesRegistry percolateRegistry ( ) { } ShardPercolateService shardPercolateService ( ) { } ShardTermVectorService termVectorService ( ) { } MapperService mapperService ( ) { } IndexFieldDataService indexFieldDataService ( ) { } IndexService indexService ( ) { } IndexShardState state ( ) { } Create prepareCreate ( SourceToParse source ) throws ElasticSearchException { } ParsedDocument create ( Engine . Create create ) throws ElasticSearchException { } Index prepareIndex ( SourceToParse source ) throws ElasticSearchException { } ParsedDocument index ( Engine . Index index ) throws ElasticSearchException { } Delete prepareDelete ( String type , String id , long version ) throws ElasticSearchException { } void delete ( Engine . Delete delete ) throws ElasticSearchException { } <START_BUG> DeleteByQuery prepareDeleteByQuery ( BytesReference querySource , @ Nullable <END_BUG> String [ ] filteringAliases , String ... types ) throws ElasticSearchException ; void deleteByQuery ( Engine . DeleteByQuery deleteByQuery ) throws ElasticSearchException { } GetResult get ( Engine . Get get ) throws ElasticSearchException { } void refresh ( Engine . Refresh refresh ) throws ElasticSearchException { } void flush ( Engine . Flush flush ) throws ElasticSearchException { } void optimize ( Engine . Optimize optimize ) throws ElasticSearchException { } < T > T snapshot ( Engine . SnapshotHandler < T > snapshotHandler ) throws EngineException { } SnapshotIndexCommit snapshotIndex ( ) throws EngineException { } void recover ( Engine . RecoveryHandler recoveryHandler ) throws EngineException { } Searcher acquireSearcher ( String source ) { } Searcher acquireSearcher ( String source , IndexShard . Mode mode ) { } public boolean ignoreRecoveryAttempt ( ) { } void readAllowed ( ) throws IllegalIndexShardStateException { } void readAllowed ( IndexShard . Mode mode ) throws IllegalIndexShardStateException { } public enum Mode { READ , WRITE ; } }
public class GetIndexTemplatesRequest extends MasterNodeOperationRequest < GetIndexTemplatesRequest > { private String [ ] names ; public GetIndexTemplatesRequest ( ) { } public GetIndexTemplatesRequest ( String ... names ) { } @ Override public ActionRequestValidationException validate ( ) { } public GetIndexTemplatesRequest names ( String ... names ) { } public String [ ] names ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; if ( out . getVersion ( ) . onOrAfter ( V_0_90_4 ) ) { out . writeStringArray ( names ) ; } else { <START_BUG> out . writeString ( names [ 0 ] ) ; <END_BUG> } } }
public class TransportBroadcastPingAction extends TransportBroadcastOperationAction < BroadcastPingRequest , BroadcastPingResponse , BroadcastShardPingRequest , BroadcastShardPingResponse > { @ Inject public TransportBroadcastPingAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected BroadcastPingRequest newRequest ( ) { } @ Override protected GroupShardsIterator shards ( BroadcastPingRequest request , ClusterState clusterState ) { <START_BUG> return indicesService . searchShards ( clusterState , request . indices ( ) , request . queryHint ( ) ) ; <END_BUG> } @ Override protected BroadcastPingResponse newResponse ( BroadcastPingRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected BroadcastShardPingRequest newShardRequest ( ) { } @ Override protected BroadcastShardPingRequest newShardRequest ( ShardRouting shard , BroadcastPingRequest request ) { } @ Override protected BroadcastShardPingResponse newShardResponse ( ) { } @ Override protected BroadcastShardPingResponse shardOperation ( BroadcastShardPingRequest broadcastShardPingRequest ) throws ElasticSearchException { } }
public class TransportSearchDfsQueryAndFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchDfsQueryAndFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportSearchCache transportSearchCache , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < DfsSearchResult > { private final Collection < DfsSearchResult > dfsResults = searchCache . obtainDfsResults ( ) ; private final Map < SearchShardTarget , QueryFetchSearchResult > queryFetchResults = searchCache . obtainQueryFetchResults ( ) ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , InternalSearchRequest request , SearchServiceListener < DfsSearchResult > listener ) { } @ Override protected void processFirstPhaseResult ( ShardRouting shard , DfsSearchResult result ) { } @ Override protected void moveToSecondPhase ( ) { } void executeSecondPhase ( final DfsSearchResult dfsResult , final AtomicInteger counter , DiscoveryNode node , final QuerySearchRequest querySearchRequest ) { searchService . sendExecuteFetch ( node , querySearchRequest , new SearchServiceListener < QueryFetchSearchResult > ( ) { @ Override public void onResult ( QueryFetchSearchResult result ) { result . shardTarget ( dfsResult . shardTarget ( ) ) ; queryFetchResults . put ( result . shardTarget ( ) , result ) ; if ( ( counter . decrementAndGet ( ) ) == 0 ) { finishHim ( ) ; } } @ Override public void onFailure ( Throwable t ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "[{}]<seq2seq4repair_space>Failed<seq2seq4repair_space>to<seq2seq4repair_space>execute<seq2seq4repair_space>query<seq2seq4repair_space>phase" , t , querySearchRequest . id ( ) ) ; } <START_BUG> TransportSearchDfsQueryAndFetchAction . AsyncAction . this . shardFailures . add ( new ShardSearchFailure ( t ) ) ; <END_BUG> successulOps . decrementAndGet ( ) ; if ( ( counter . decrementAndGet ( ) ) == 0 ) { finishHim ( ) ; } } } ) ; } void finishHim ( ) { } void innerFinishHim ( ) throws Exception { } } }
public class TextAreaTest implements RenderListener { GUI gui ; public void surfaceCreated ( ) { } public void render ( ) { } public void surfaceChanged ( int width , int height ) { <START_BUG> gui . setSize ( ) ; <END_BUG> } public void dispose ( ) { } }
public abstract class Streams { public static final int BUFFER_SIZE = 1024 * 8 ; public static long copy ( File in , File out ) throws IOException { } public static void copy ( byte [ ] in , File out ) throws IOException { } public static byte [ ] copyToByteArray ( File in ) throws IOException { } public static long copy ( InputStream in , OutputStream out ) throws IOException { } public static long copy ( InputStream in , OutputStream out , byte [ ] buffer ) throws IOException { } public static void copy ( byte [ ] in , OutputStream out ) throws IOException { } public static byte [ ] copyToByteArray ( InputStream in ) throws IOException { CachedStreamOutput . Entry cachedEntry = CachedStreamOutput . popEntry ( ) ; try { BytesStreamOutput out = cachedEntry . bytes ( ) ; Streams . copy ( in , out ) ; <START_BUG> return out . copiedByteArray ( ) ; <END_BUG> } finally { CachedStreamOutput . pushEntry ( cachedEntry ) ; } } public static int copy ( Reader in , Writer out ) throws IOException { } public static void copy ( String in , Writer out ) throws IOException { } public static String copyToString ( Reader in ) throws IOException { } public static String copyToStringFromClasspath ( ClassLoader classLoader , String path ) throws IOException { } public static String copyToStringFromClasspath ( String path ) throws IOException { } public static byte [ ] copyToBytesFromClasspath ( String path ) throws IOException { } }
public class IndexFieldMapper extends AbstractFieldMapper < String > implements org . elasticsearch . index . mapper . IndexFieldMapper { public static final String CONTENT_TYPE = "_index" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = org . elasticsearch . index . mapper . IndexFieldMapper . NAME ; public static final String INDEX_NAME = org . elasticsearch . index . mapper . IndexFieldMapper . NAME ; public static final Index INDEX = Index . NOT_ANALYZED ; public static final Store STORE = Store . NO ; public static final boolean OMIT_NORMS = true ; public static final boolean OMIT_TERM_FREQ_AND_POSITIONS = true ; public static final boolean ENABLED = false ; } public static class Builder extends AbstractFieldMapper . Builder < IndexFieldMapper . Builder , IndexFieldMapper > { private boolean enabled = IndexFieldMapper . Defaults . ENABLED ; public Builder ( ) { } public IndexFieldMapper . Builder enabled ( boolean enabled ) { } @ Override public IndexFieldMapper build ( BuilderContext context ) { } } private final boolean enabled ; protected IndexFieldMapper ( ) { } protected IndexFieldMapper ( String name , String indexName ) { } public IndexFieldMapper ( String name , String indexName , Field . Store store , Field . TermVector termVector , float boost , boolean omitNorms , boolean omitTermFreqAndPositions , boolean enabled ) { } @ Override public boolean enabled ( ) { } @ Override public String value ( Document document ) { } @ Override public String value ( Fieldable field ) { } @ Override public String valueFromString ( String value ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } @ Override public Term term ( String value ) { <START_BUG> return new Term ( names . indexName ( ) , value ) ; <END_BUG> } @ Override protected Field parseCreateField ( ParseContext context ) throws IOException { } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( XContentMapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public class SharedLibraryLoader { public static boolean isWindows = System . getProperty ( "os.name" ) . contains ( "Windows" ) ; public static boolean isLinux = System . getProperty ( "os.name" ) . contains ( "Linux" ) ; public static boolean isMac = System . getProperty ( "os.name" ) . contains ( "Mac" ) ; public static boolean isIos = false ; public static boolean isAndroid = false ; public static boolean isARM = System . getProperty ( "os.arch" ) . startsWith ( "arm" ) ; public static boolean is64Bit = System . getProperty ( "os.arch" ) . equals ( "amd64" ) ; public static String abi = ( ( System . getProperty ( "sun.arch.abi" ) ) != null ) ? System . getProperty ( "sun.arch.abi" ) : "" ; private static final HashSet < String > loadedLibraries = new HashSet ( ) ; private String nativesJar ; public SharedLibraryLoader ( ) { } public SharedLibraryLoader ( String nativesJar ) { } public String crc ( InputStream input ) { } public String mapLibraryName ( String libraryName ) { if ( SharedLibraryLoader . isWindows ) return libraryName + ( SharedLibraryLoader . is64Bit ? "64.dll" : ".dll" ) ; if ( SharedLibraryLoader . isLinux ) return ( ( "lib" + libraryName ) + ( SharedLibraryLoader . isARM ? "arm" + ( SharedLibraryLoader . abi ) : "" ) ) + ( SharedLibraryLoader . is64Bit ? "64.so" : ".so" ) ; if ( SharedLibraryLoader . isMac ) <START_BUG> return ( "lib" + libraryName ) + ".dylib" ; <END_BUG> return libraryName ; } public synchronized void load ( String libraryName ) { } private InputStream readFile ( String path ) { } public File extractFile ( String sourcePath , String dirName ) throws IOException { } private File getExtractedFile ( String dirName , String fileName ) { } private boolean canWrite ( File file ) { } private File extractFile ( String sourcePath , String sourceCrc , File extractedFile ) throws IOException { } private void loadFile ( String sourcePath ) { } private Throwable loadFile ( String sourcePath , String sourceCrc , File extractedFile ) { } }
public class ConstraintsTest extends BaseBulletTest { final Array < btTypedConstraint > constraints = new Array < btTypedConstraint > ( ) ; @ Override public void create ( ) { } @ Override public void dispose ( ) { for ( int i = 0 ; i < ( constraints . size ) ; i ++ ) { ( ( btDynamicsWorld ) ( collisionWorld ) ) . removeConstraint ( constraints . get ( i ) ) ; <START_BUG> constraints . get ( i ) . dispose ( ) ; <END_BUG> } constraints . clear ( ) ; super . dispose ( ) ; } @ Override public boolean tap ( float x , float y , int count , int button ) { } }
public class JoglDebugStarter { public static void main ( String [ ] argv ) { <START_BUG> new com . badlogic . gdx . backends . jogl . JoglApplication ( new com . badlogic . gdx . tests . SimpleAnimationTest ( ) , "Debug<seq2seq4repair_space>Test" , 480 , 320 , false ) ; <END_BUG> } }
public class GameScreen extends CubocScreen { Map map ; MapRenderer renderer ; OnscreenControlRenderer controlRenderer ; public GameScreen ( Game game ) { } @ Override public void show ( ) { } @ Override public void render ( float delta ) { } @ Override public void hide ( ) { <START_BUG> System . out . println ( "dispose<seq2seq4repair_space>game<seq2seq4repair_space>screen" ) ; <END_BUG> renderer . dispose ( ) ; controlRenderer . dispose ( ) ; } }
public abstract class PagedUserFragment extends PagedItemFragment < User > { @ Inject protected AvatarLoader avatars ; @ Inject protected UserService service ; @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; <START_BUG> ListViewUtils . configure ( getActivity ( ) , getListView ( ) , true ) ; <END_BUG> } @ Override protected ItemListAdapter < User , ? extends ItemView > createAdapter ( List < User > items ) { } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } }
public class GdxInvadersAndroid extends AndroidApplication { @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setRequestedOrientation ( SCREEN_ORIENTATION_LANDSCAPE ) ; AndroidApplicationConfiguration config = new AndroidApplicationConfiguration ( ) ; config . useWakelock = true ; <START_BUG> config . useGL20 = false ; <END_BUG> initialize ( new GdxInvaders ( ) , config ) ; } }
public class EsExecutors { <START_BUG> public static EsThreadPoolExecutor newSinglePrioritizingThreadExecutor ( ThreadFactory threadFactory ) { <END_BUG> return new PrioritizedEsThreadPoolExecutor ( 1 , 1 , 0L , TimeUnit . MILLISECONDS , threadFactory ) ; } public static EsThreadPoolExecutor newScalingExecutorService ( int min , int max , long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory ) { } public static EsThreadPoolExecutor newBlockingExecutorService ( int min , int max , long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory , int capacity , long waitTime , TimeUnit waitTimeUnit ) { } public static String threadName ( Settings settings , String namePrefix ) { } public static ThreadFactory daemonThreadFactory ( Settings settings , String namePrefix ) { } public static ThreadFactory daemonThreadFactory ( String namePrefix ) { } static class EsThreadFactory implements ThreadFactory { final ThreadGroup group ; final AtomicInteger threadNumber = new AtomicInteger ( 1 ) ; final String namePrefix ; public EsThreadFactory ( String namePrefix ) { } @ Override public Thread newThread ( Runnable r ) { } } private EsExecutors ( ) { } static class ExecutorScalingQueue < E > extends LinkedTransferQueue < E > { ThreadPoolExecutor executor ; public ExecutorScalingQueue ( ) { } @ Override public boolean offer ( E e ) { } } static class ExecutorBlockingQueue < E > extends ArrayBlockingQueue < E > { ThreadPoolExecutor executor ; ExecutorBlockingQueue ( int capacity ) { } @ Override public boolean offer ( E o ) { } } static class ForceQueuePolicy implements RejectedExecutionHandler { public void rejectedExecution ( Runnable r , ThreadPoolExecutor executor ) { } } static class TimedBlockingPolicy implements XRejectedExecutionHandler { private final CounterMetric rejected = new CounterMetric ( ) ; private final long waitTime ; public TimedBlockingPolicy ( long waitTime ) { } public void rejectedExecution ( Runnable r , ThreadPoolExecutor executor ) { } @ Override public long rejected ( ) { } } }
public class TableLayoutTest extends GdxTest { Stage stage ; public void create ( ) { } public void render ( ) { } public void resize ( int width , int height ) { <START_BUG> stage . getViewport ( ) . update ( width , height ) ; <END_BUG> } public void dispose ( ) { } }
public class Scene2dTest extends GdxTest { Stage stage ; private FloatAction meow = new FloatAction ( 10 , 5 ) ; private TiledDrawable patch ; public void create ( ) { stage = new Stage ( ) ; input . setInputProcessor ( stage ) ; final TextureRegion region = new TextureRegion ( new Texture ( "data/badlogic.jpg" ) ) ; final Actor actor = new Actor ( ) { public void draw ( SpriteBatch batch , float parentAlpha ) { Color color = getColor ( ) ; batch . setColor ( color . r , color . g , color . b , parentAlpha ) ; batch . draw ( region , getX ( ) , getY ( ) , getOriginX ( ) , getOriginY ( ) , getWidth ( ) , getHeight ( ) , getScaleX ( ) , getScaleY ( ) , getRotation ( ) ) ; } } ; actor . setBounds ( 15 , 15 , 100 , 100 ) ; actor . setOrigin ( 50 , 50 ) ; stage . addActor ( actor ) ; actor . addListener ( new InputListener ( ) { public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { System . out . println ( "down" ) ; return true ; } public void touchUp ( InputEvent event , float x , float y , int pointer , int button ) { System . out . println ( ( "up<seq2seq4repair_space>" + ( event . getTarget ( ) ) ) ) ; } } ) ; Skin skin = new Skin ( files . internal ( "data/uiskin.json" ) ) ; VerticalGroup g = new VerticalGroup ( ) ; g . setPosition ( 100 , 100 ) ; g . setReverse ( true ) ; stage . addActor ( g ) ; for ( int i = 0 ; i < 10 ; i ++ ) { g . addActor ( new TextButton ( ( "button<seq2seq4repair_space>" + i ) , skin ) ) ; } g . pack ( ) ; final TextButton button = new TextButton ( "Fancy<seq2seq4repair_space>Background" , skin ) ; button . addListener ( new ActorGestureListener ( ) { public boolean longPress ( Actor actor , float x , float y ) { System . out . println ( ( ( ( "long<seq2seq4repair_space>press<seq2seq4repair_space>" + x ) + ",<seq2seq4repair_space>" ) + y ) ) ; return true ; } <START_BUG> public void fling ( InputEvent event , float velocityX , float velocityY , int pointer , int button ) { <END_BUG> System . out . println ( ( ( ( "fling<seq2seq4repair_space>" + velocityX ) + ",<seq2seq4repair_space>" ) + velocityY ) ) ; } public void zoom ( InputEvent event , float initialDistance , float distance ) { System . out . println ( ( ( ( "zoom<seq2seq4repair_space>" + initialDistance ) + ",<seq2seq4repair_space>" ) + distance ) ) ; } public void pan ( InputEvent event , float x , float y , float deltaX , float deltaY ) { event . getListenerActor ( ) . translate ( deltaX , deltaY ) ; if ( deltaX < 0 ) System . out . println ( ( ( ( ( ( "panning<seq2seq4repair_space>" + deltaX ) + ",<seq2seq4repair_space>" ) + deltaY ) + "<seq2seq4repair_space>" ) + ( event . getTarget ( ) ) ) ) ; } } ) ; button . setPosition ( 50 , 50 ) ; stage . addActor ( button ) ; meow . setDuration ( 2 ) ; actor . addAction ( forever ( sequence ( moveBy ( 50 , 0 , 2 ) , moveBy ( ( - 50 ) , 0 , 2 ) , run ( new Runnable ( ) { public void run ( ) { actor . setZIndex ( 0 ) ; } } ) ) ) ) ; patch = new TiledDrawable ( skin . getRegion ( "default-round" ) ) ; Window window = new Window ( "Moo" , skin ) ; Label lbl = new Label ( "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJ" , skin ) ; lbl . setWrap ( true ) ; window . row ( ) ; window . add ( lbl ) . width ( 400 ) ; window . pack ( ) ; window . pack ( ) ; stage . addActor ( window ) ; } public void render ( ) { } public void resize ( int width , int height ) { } public boolean needsGL20 ( ) { } public void dispose ( ) { } }
public class KinematicBodyTest extends GdxTest { @ Override public boolean needsGL20 ( ) { } OrthographicCamera cam ; World world ; Box2DDebugRenderer renderer ; public void create ( ) { } public void render ( ) { gl . glClear ( GL_COLOR_BUFFER_BIT ) ; world . step ( Math . min ( 0.032F , graphics . getDeltaTime ( ) ) , 3 , 4 ) ; cam . update ( ) ; cam . apply ( gl10 ) ; <START_BUG> renderer . render ( world ) ; <END_BUG> } }
public class SoftBodyTest extends BaseBulletTest { btSoftBodyWorldInfo worldInfo ; btSoftBody softBody ; Texture texture ; Mesh mesh ; Model model ; ModelInstance instance ; Matrix4 tmpM = new Matrix4 ( ) ; @ Override public BulletWorld createWorld ( ) { } @ Override public void create ( ) { } @ Override public void dispose ( ) { } @ Override protected void renderWorld ( ) { softBody . getVertices ( mesh . getVerticesBuffer ( ) , softBody . getNodeCount ( ) , mesh . getVertexSize ( ) , 0 ) ; softBody . getWorldTransform ( instance . transform ) ; modelBatch . begin ( camera ) ; world . render ( modelBatch , lights ) ; <START_BUG> modelBatch . render ( instance , lights ) ; <END_BUG> modelBatch . end ( ) ; } @ Override public boolean tap ( float x , float y , int count , int button ) { } }
public class NestedAggregator extends SingleBucketAggregator implements ReaderContextAware { private final String nestedPath ; private final Aggregator parentAggregator ; private Filter parentFilter ; private final Filter childFilter ; private Bits childDocs ; private FixedBitSet parentDocs ; public NestedAggregator ( String name , AggregatorFactories factories , String nestedPath , AggregationContext aggregationContext , Aggregator parentAggregator ) { } @ Override public void setNextReader ( AtomicReaderContext reader ) { } @ Override public void collect ( int parentDoc , long bucketOrd ) throws IOException { if ( ( parentDoc == 0 ) || ( ( parentDocs ) == null ) ) { return ; } int prevParentDoc = parentDocs . prevSetBit ( ( parentDoc - 1 ) ) ; int numChildren = 0 ; for ( int i = parentDoc - 1 ; i > prevParentDoc ; i -- ) { if ( childDocs . get ( i ) ) { ++ numChildren ; collectBucketNoCounts ( i , bucketOrd ) ; } } <START_BUG> incrementBucketDocCount ( numChildren , bucketOrd ) ; <END_BUG> } @ Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) { } @ Override public InternalAggregation buildEmptyAggregation ( ) { } public String getNestedPath ( ) { } static NestedAggregator findClosestNestedAggregator ( Aggregator parent ) { } public static class Factory extends AggregatorFactory { private final String path ; public Factory ( String name , String path ) { } @ Override public Aggregator create ( AggregationContext context , Aggregator parent , long expectedBucketsCount ) { } } }
public class JvmMonitorService extends AbstractLifecycleComponent < JvmMonitorService > { private final ThreadPool threadPool ; private final DumpMonitorService dumpMonitorService ; private final boolean enabled ; private final TimeValue interval ; private final TimeValue gcCollectionWarning ; private volatile ScheduledFuture scheduledFuture ; @ Inject public JvmMonitorService ( Settings settings , ThreadPool threadPool , DumpMonitorService dumpMonitorService ) { } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } private class JvmMonitor implements Runnable { private JvmStats . JvmStats lastJvmStats = jvmStats ( ) ; private final Set < DeadlockAnalyzer . DeadlockAnalyzer . Deadlock > lastSeenDeadlocks = new HashSet < DeadlockAnalyzer . DeadlockAnalyzer . Deadlock > ( ) ; public JvmMonitor ( ) { } @ Override public void run ( ) { } private void monitorLongGc ( ) { JvmStats . JvmStats currentJvmStats = jvmStats ( ) ; <START_BUG> long collectionTime = ( currentJvmStats . gcCollectionTime ( ) . millis ( ) ) - ( lastJvmStats . gcCollectionTime ( ) . millis ( ) ) ; <END_BUG> if ( collectionTime > ( gcCollectionWarning . millis ( ) ) ) { logger . warn ( ( ( ( ( "Long<seq2seq4repair_space>GC<seq2seq4repair_space>collection<seq2seq4repair_space>occurred,<seq2seq4repair_space>took<seq2seq4repair_space>[" + ( new TimeValue ( collectionTime ) ) ) + "],<seq2seq4repair_space>breached<seq2seq4repair_space>threshold<seq2seq4repair_space>[" ) + ( gcCollectionWarning ) ) + "]" ) ) ; } lastJvmStats = currentJvmStats ; } private void monitorDeadlock ( ) { } } }
public class RestSearchAction extends BaseRestHandler { public static final Pattern fieldsPattern ; @ Inject public RestSearchAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { SearchRequest searchRequest ; try { searchRequest = parseSearchRequest ( request ) ; searchRequest . listenerThreaded ( false ) ; SearchOperationThreading operationThreading = SearchOperationThreading . fromString ( request . param ( "operationThreading" ) , SINGLE_THREAD ) ; if ( operationThreading == ( SearchOperationThreading . NO_THREADS ) ) { operationThreading = SearchOperationThreading . SINGLE_THREAD ; } searchRequest . operationThreading ( operationThreading ) ; } catch ( Exception e ) { try { channel . sendResponse ( new JsonRestResponse ( request , BAD_REQUEST , JsonBuilder . jsonBuilder ( ) . startObject ( ) . field ( "error" , e . getMessage ( ) ) . endObject ( ) ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } return ; } client . execSearch ( searchRequest , new org . elasticsearch . action . ActionListener < SearchResponse > ( ) { @ Override public void onResponse ( SearchResponse result ) { try { JsonBuilder builder = RestJsonBuilder . cached ( request ) ; builder . startObject ( ) ; <START_BUG> result . toJson ( builder ) ; <END_BUG> builder . endObject ( ) ; channel . sendResponse ( new JsonRestResponse ( request , OK , builder ) ) ; } catch ( Exception e ) { onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new JsonThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } private SearchRequest parseSearchRequest ( RestRequest request ) { } private String parseSearchSource ( RestRequest request ) { } }
public class GistFragment extends RoboSherlockFragment implements OnItemClickListener { private static final int REQUEST_CODE_COMMENT = 1 ; private String gistId ; private List < Comment > comments ; private Gist gist ; @ InjectView ( id . list ) private ListView list ; @ Inject private GistStore store ; @ Inject private ContextScopedProvider < GistService > service ; private View headerView ; private GistHeaderViewHolder headerHolder ; private View loadingView ; private RefreshAnimation refreshAnimation = new RefreshAnimation ( ) ; private boolean starred ; private boolean loadFinished ; @ Inject private AvatarHelper avatarHelper ; @ Inject private ContextScopedProvider < GistService > gistServiceProvider ; private Executor executor = Executors . newFixedThreadPool ( 1 ) ; private List < View > fileHeaders = Lists . newArrayList ( ) ; @ SuppressWarnings ( "unchecked" ) public void onCreate ( Bundle savedInstanceState ) { } public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View root = inflater . inflate ( gist_view , null ) ; headerView = inflater . inflate ( gist_header , null ) ; <START_BUG> headerHolder = new GistHeaderViewHolder ( headerView , avatarHelper ) ; <END_BUG> loadingView = inflater . inflate ( comment_load_item , null ) ; return root ; } public void onActivityCreated ( Bundle savedInstanceState ) { } private boolean isOwner ( ) { } @ Override public void onCreateOptionsMenu ( Menu options , MenuInflater inflater ) { } @ Override public void onPrepareOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } private void starGist ( ) { } private void unstarGist ( ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } private void createComment ( final String comment ) { } private void updateFiles ( Gist gist ) { } private void updateList ( Gist gist , List < Comment > comments ) { } @ SuppressWarnings ( "unchecked" ) private ViewHoldingListAdapter < Comment > getRootAdapter ( ) { } private void refreshGist ( ) { } public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { } }
public class PlainShardsIterator implements ShardsIterator { private final List < ShardRouting > shards ; private final int size ; private final int index ; private final int limit ; private volatile int counter ; public PlainShardsIterator ( List < ShardRouting > shards ) { } public PlainShardsIterator ( List < ShardRouting > shards , int index ) { } @ Override public ShardsIterator reset ( ) { } @ Override public int remaining ( ) { } @ Override public ShardRouting firstOrNull ( ) { if ( ( size ) == 0 ) { return null ; } <START_BUG> return shards . get ( ( ( ( index ) + 1 ) % ( size ) ) ) ; <END_BUG> } @ Override public ShardRouting nextOrNull ( ) { } @ Override public int size ( ) { } @ Override public int sizeActive ( ) { } @ Override public int assignedReplicasIncludingRelocating ( ) { } @ Override public Iterable < ShardRouting > asUnordered ( ) { } }
public class IntroScreen extends CubocScreen { TextureRegion intro ; SpriteBatch batch ; float time = 0 ; public IntroScreen ( Game game ) { } @ Override public void show ( ) { } @ Override public void render ( float delta ) { } @ Override public void hide ( ) { <START_BUG> System . out . println ( "dispose<seq2seq4repair_space>intro" ) ; <END_BUG> batch . dispose ( ) ; intro . getTexture ( ) . dispose ( ) ; } }
public class TransportTypesExistsAction extends TransportMasterNodeReadOperationAction < TypesExistsRequest , TypesExistsResponse > { @ Inject public TransportTypesExistsAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected TypesExistsRequest newRequest ( ) { } @ Override protected TypesExistsResponse newResponse ( ) { } @ Override protected ClusterBlockException checkBlock ( TypesExistsRequest request , ClusterState state ) { <START_BUG> return state . blocks ( ) . indicesBlockedException ( METADATA , request . indices ( ) ) ; <END_BUG> } @ Override protected void masterOperation ( final TypesExistsRequest request , final ClusterState state , final ActionListener < TypesExistsResponse > listener ) throws ElasticsearchException { } }
public class ClusterState { private final long version ; private final RoutingTable routingTable ; private final DiscoveryNodes nodes ; private final MetaData metaData ; private final ClusterBlocks blocks ; private final AllocationExplanation allocationExplanation ; private volatile RoutingNodes routingNodes ; public ClusterState ( long version , ClusterState state ) { } public ClusterState ( long version , MetaData metaData , RoutingTable routingTable , DiscoveryNodes nodes , ClusterBlocks blocks , AllocationExplanation allocationExplanation ) { } public long version ( ) { } public long getVersion ( ) { } public DiscoveryNodes nodes ( ) { } public DiscoveryNodes getNodes ( ) { } public MetaData metaData ( ) { } public MetaData getMetaData ( ) { } public RoutingTable routingTable ( ) { } public RoutingTable getRoutingTable ( ) { } public RoutingNodes routingNodes ( ) { } public RoutingNodes getRoutingNodes ( ) { } public ClusterBlocks blocks ( ) { } public ClusterBlocks getBlocks ( ) { } public AllocationExplanation allocationExplanation ( ) { } public AllocationExplanation getAllocationExplanation ( ) { } public RoutingNodes readOnlyRoutingNodes ( ) { } public static ClusterState . Builder builder ( ) { } public static ClusterState . Builder newClusterStateBuilder ( ) { } public static class Builder { private long version = 0 ; private MetaData metaData = MetaData . EMPTY_META_DATA ; private RoutingTable routingTable = RoutingTable . EMPTY_ROUTING_TABLE ; private DiscoveryNodes nodes = DiscoveryNodes . EMPTY_NODES ; private ClusterBlocks blocks = ClusterBlocks . EMPTY_CLUSTER_BLOCK ; private AllocationExplanation allocationExplanation = AllocationExplanation . EMPTY ; public ClusterState . Builder nodes ( DiscoveryNodes . Builder nodesBuilder ) { } public ClusterState . Builder nodes ( DiscoveryNodes nodes ) { } public ClusterState . Builder routingTable ( RoutingTable . Builder routingTable ) { } public ClusterState . Builder routingResult ( RoutingAllocation . Result routingResult ) { } public ClusterState . Builder routingTable ( RoutingTable routingTable ) { } public ClusterState . Builder metaData ( MetaData . Builder metaDataBuilder ) { } public ClusterState . Builder metaData ( MetaData metaData ) { } public ClusterState . Builder blocks ( ClusterBlocks . Builder blocksBuilder ) { } public ClusterState . Builder blocks ( ClusterBlocks block ) { } public ClusterState . Builder allocationExplanation ( AllocationExplanation allocationExplanation ) { } public ClusterState . Builder version ( long version ) { } public ClusterState . Builder state ( ClusterState state ) { } public ClusterState build ( ) { } public static byte [ ] toBytes ( ClusterState state ) throws IOException { CachedStreamOutput . Entry cachedEntry = CachedStreamOutput . popEntry ( ) ; try { BytesStreamOutput os = cachedEntry . bytes ( ) ; ClusterState . Builder . writeTo ( state , os ) ; <START_BUG> return os . copiedByteArray ( ) ; <END_BUG> } finally { CachedStreamOutput . pushEntry ( cachedEntry ) ; } } public static ClusterState fromBytes ( byte [ ] data , DiscoveryNode localNode ) throws IOException { } public static void writeTo ( ClusterState state , StreamOutput out ) throws IOException { } public static ClusterState readFrom ( StreamInput in , @ Nullable DiscoveryNode localNode ) throws IOException { } } }
public class TransportOpenIndexAction extends TransportMasterNodeOperationAction < OpenIndexRequest , OpenIndexResponse > { private final MetaDataIndexStateService indexStateService ; @ Inject public TransportOpenIndexAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , MetaDataIndexStateService indexStateService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected OpenIndexRequest newRequest ( ) { } @ Override protected OpenIndexResponse newResponse ( ) { } @ Override protected void doExecute ( OpenIndexRequest request , ActionListener < OpenIndexResponse > listener ) { <START_BUG> request . indices ( clusterService . state ( ) . metaData ( ) . concreteIndices ( request . indices ( ) , request . ignoreIndices ( ) , false ) ) ; <END_BUG> super . doExecute ( request , listener ) ; } @ Override protected ClusterBlockException checkBlock ( OpenIndexRequest request , ClusterState state ) { } @ Override protected void masterOperation ( final OpenIndexRequest request , final ClusterState state , final ActionListener < OpenIndexResponse > listener ) throws ElasticSearchException { } }
public class BlendingAttribute extends Attribute { public static final String Alias = "blended" ; public static final long Type = register ( BlendingAttribute . Alias ) ; public static final boolean is ( final long mask ) { } public boolean blended ; public int sourceFunction ; public int destFunction ; public float opacity = 1.0F ; public BlendingAttribute ( ) { } public BlendingAttribute ( final boolean blended , final int sourceFunc , final int destFunc , final float opacity ) { } public BlendingAttribute ( final int sourceFunc , final int destFunc , final float opacity ) { } public BlendingAttribute ( final int sourceFunc , final int destFunc ) { } public BlendingAttribute ( final boolean blended , final float opacity ) { } public BlendingAttribute ( final float opacity ) { } public BlendingAttribute ( final BlendingAttribute copyFrom ) { } @ Override public BlendingAttribute copy ( ) { } @ Override public int hashCode ( ) { <START_BUG> int result = ( ( int ) ( type ) ) ; <END_BUG> result = ( 947 * result ) + ( blended ? 1 : 0 ) ; result = ( 947 * result ) + ( sourceFunction ) ; result = ( 947 * result ) + ( destFunction ) ; result = ( 947 * result ) + ( NumberUtils . floatToRawIntBits ( opacity ) ) ; return result ; } }
public class BoundingBox implements Serializable { private static final long serialVersionUID = - 1286036817192127343L ; private static final Vector3 tmpVector = new Vector3 ( ) ; public final Vector3 min = new Vector3 ( ) ; public final Vector3 max = new Vector3 ( ) ; private final Vector3 cnt = new Vector3 ( ) ; private final Vector3 dim = new Vector3 ( ) ; @ Deprecated private Vector3 [ ] corners ; @ Deprecated public Vector3 getCenter ( ) { } public Vector3 getCenter ( Vector3 out ) { <START_BUG> return cnt ; <END_BUG> } public float getCenterX ( ) { } public float getCenterY ( ) { } public float getCenterZ ( ) { } @ Deprecated protected void updateCorners ( ) { } @ Deprecated public Vector3 [ ] getCorners ( ) { } public Vector3 getCorner000 ( final Vector3 out ) { } public Vector3 getCorner001 ( final Vector3 out ) { } public Vector3 getCorner010 ( final Vector3 out ) { } public Vector3 getCorner011 ( final Vector3 out ) { } public Vector3 getCorner100 ( final Vector3 out ) { } public Vector3 getCorner101 ( final Vector3 out ) { } public Vector3 getCorner110 ( final Vector3 out ) { } public Vector3 getCorner111 ( final Vector3 out ) { } @ Deprecated public Vector3 getDimensions ( ) { } public Vector3 getDimensions ( final Vector3 out ) { } public float getWidth ( ) { } public float getHeight ( ) { } public float getDepth ( ) { } @ Deprecated public Vector3 getMin ( ) { } public Vector3 getMin ( final Vector3 out ) { } @ Deprecated public Vector3 getMax ( ) { } public Vector3 getMax ( final Vector3 out ) { } public BoundingBox ( ) { } public BoundingBox ( BoundingBox bounds ) { } public BoundingBox ( Vector3 minimum , Vector3 maximum ) { } public BoundingBox set ( BoundingBox bounds ) { } public BoundingBox set ( Vector3 minimum , Vector3 maximum ) { } public BoundingBox set ( Vector3 [ ] points ) { } public BoundingBox set ( List < Vector3 > points ) { } public BoundingBox inf ( ) { } public BoundingBox ext ( Vector3 point ) { } public BoundingBox clr ( ) { } public boolean isValid ( ) { } public BoundingBox ext ( BoundingBox a_bounds ) { } public BoundingBox ext ( BoundingBox bounds , Matrix4 transform ) { } public BoundingBox mul ( Matrix4 transform ) { } public boolean contains ( BoundingBox b ) { } public boolean intersects ( BoundingBox b ) { } public boolean contains ( Vector3 v ) { } @ Override public String toString ( ) { } public BoundingBox ext ( float x , float y , float z ) { } static final float min ( final float a , final float b ) { } static final float max ( final float a , final float b ) { } }
public class Rectangle implements Serializable { public static final Rectangle tmp = new Rectangle ( ) ; public static final Rectangle tmp2 = new Rectangle ( ) ; private static final long serialVersionUID = 5733252015138115702L ; public float x ; public float y ; public float width ; public float height ; public Rectangle ( ) { } public Rectangle ( float x , float y , float width , float height ) { } public Rectangle ( Rectangle rect ) { } public Rectangle set ( float x , float y , float width , float height ) { } public float getX ( ) { } public Rectangle setX ( float x ) { } public float getY ( ) { } public Rectangle setY ( float y ) { } public float getWidth ( ) { } public Rectangle setWidth ( float width ) { } public float getHeight ( ) { } public Rectangle setHeight ( float height ) { } public Vector2 getPosition ( Vector2 position ) { } public Rectangle setPosition ( Vector2 position ) { } public Rectangle setPosition ( float x , float y ) { } public Rectangle setSize ( float width , float height ) { } public Rectangle setSize ( float sizeXY ) { } public Vector2 getSize ( Vector2 size ) { } public boolean contains ( float x , float y ) { } public boolean contains ( Vector2 point ) { } public boolean contains ( Rectangle rectangle ) { } public boolean overlaps ( Rectangle r ) { } public Rectangle set ( Rectangle rect ) { } public Rectangle merge ( Rectangle rect ) { } public Rectangle merge ( float x , float y ) { } public Rectangle merge ( Vector2 vec ) { } public Rectangle merge ( Vector2 [ ] vecs ) { } public float getAspectRatio ( ) { } public Vector2 getCenter ( Vector2 vector ) { } public Rectangle setCenter ( float x , float y ) { } public Rectangle setCenter ( Vector2 position ) { } public Rectangle fitOutside ( Rectangle rect ) { } public Rectangle fitInside ( Rectangle rect ) { } public String toString ( ) { } public float area ( ) { } public float perimeter ( ) { <START_BUG> return ( 2 * ( this . width ) ) * ( this . height ) ; <END_BUG> } public int hashCode ( ) { } public boolean equals ( Object obj ) { } }
public abstract class TransportClusterInfoAction < Request extends ClusterInfoRequest , Response extends ActionResponse > extends TransportMasterNodeReadOperationAction < Request , Response > { public TransportClusterInfoAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } @ Override protected String executor ( ) { } @ Override protected final void masterOperation ( final Request request , final ClusterState state , final ActionListener < Response > listener ) throws ElasticsearchException { <START_BUG> String [ ] concreteIndices = state . metaData ( ) . concreteIndices ( request . indices ( ) , request . indicesOptions ( ) ) ; <END_BUG> request . indices ( concreteIndices ) ; doMasterOperation ( request , state , listener ) ; } protected abstract void doMasterOperation ( Request request , ClusterState state , final ActionListener < Response > listener ) throws ElasticsearchException { } }
public class Body { protected final long addr ; private final float [ ] tmp = new float [ 4 ] ; private final World world ; private ArrayList < Fixture > fixtures = new ArrayList < Fixture > ( 2 ) ; protected ArrayList < JointEdge > joints = new ArrayList < JointEdge > ( 2 ) ; private Object userData ; protected Body ( World world , long addr ) { } public Fixture createFixture ( FixtureDef def ) { } private native long jniCreateFixture ( long addr , long shapeAddr , float friction , float restitution , float density , boolean isSensor , short filterCategoryBits , short filterMaskBits , short filterGroupIndex ) { } public Fixture createFixture ( Shape shape , float density ) { } private native long jniCreateFixture ( long addr , long shapeAddr , float density ) { } public void destroyFixture ( Fixture fixture ) { } private native void jniDestroyFixture ( long addr , long fixtureAddr ) { } public void setTransform ( Vector2 position , float angle ) { } private native void jniSetTransform ( long addr , float positionX , float positionY , float angle ) { } private final Transform transform = new Transform ( ) ; public Transform getTransform ( ) { } private native void jniGetTransform ( long addr , float [ ] vals ) { } private final Vector2 position = new Vector2 ( ) ; public Vector2 getPosition ( ) { } private native void jniGetPosition ( long addr , float [ ] position ) { } public float getAngle ( ) { } private native float jniGetAngle ( long addr ) { } private final Vector2 worldCenter = new Vector2 ( ) ; public Vector2 getWorldCenter ( ) { } private native void jniGetWorldCenter ( long addr , float [ ] worldCenter ) { } private final Vector2 localCenter = new Vector2 ( ) ; public Vector2 getLocalCenter ( ) { } private native void jniGetLocalCenter ( long addr , float [ ] localCenter ) { } public void setLinearVelocity ( Vector2 v ) { } private native void jniSetLinearVelocity ( long addr , float x , float y ) { } private final Vector2 linearVelocity = new Vector2 ( ) ; public Vector2 getLinearVelocity ( ) { } private native void jniGetLinearVelocity ( long addr , float [ ] tmpLinearVelocity ) { } public void setAngularVelocity ( float omega ) { } private native void jniSetAngularVelocity ( long addr , float omega ) { } public float getAngularVelocity ( ) { } private native float jniGetAngularVelocity ( long addr ) { } public void applyForce ( Vector2 force , Vector2 point ) { } private native void jniApplyForce ( long addr , float forceX , float forceY , float pointX , float pointY ) { } public void applyTorque ( float torque ) { } private native void jniApplyTorque ( long addr , float torque ) { } public void applyLinearImpulse ( Vector2 impulse , Vector2 point ) { } private native void jniApplyLinearImpulse ( long addr , float impulseX , float impulseY , float pointX , float pointY ) { } public void applyAngularImpulse ( float impulse ) { } private native void jniApplyAngularImpulse ( long addr , float impulse ) { } public float getMass ( ) { } private native float jniGetMass ( long addr ) { } public float getInertia ( ) { } private native float jniGetInertia ( long addr ) { } private final MassData massData = new MassData ( ) ; public MassData getMassData ( ) { jniGetMassData ( addr , tmp ) ; massData . mass = tmp [ 0 ] ; massData . center . x = tmp [ 1 ] ; massData . center . y = tmp [ 2 ] ; massData . I = tmp [ 3 ] ; <START_BUG> return null ; <END_BUG> } private native void jniGetMassData ( long addr , float [ ] massData ) { } public void setMassData ( MassData data ) { } private native void jniSetMassData ( long addr , float mass , float centerX , float centerY , float I ) { } public void resetMassData ( ) { } private native void jniResetMassData ( long addr ) { } private final Vector2 localPoint = new Vector2 ( ) ; public Vector2 getWorldPoint ( Vector2 localPoint ) { } private native void jniGetWorldPoint ( long addr , float localPointX , float localPointY , float [ ] worldPoint ) { } private final Vector2 worldVector = new Vector2 ( ) ; public Vector2 getWorldVector ( Vector2 localVector ) { } private native void jniGetWorldVector ( long addr , float localVectorX , float localVectorY , float [ ] worldVector ) { } public final Vector2 localPoint2 = new Vector2 ( ) ; public Vector2 getLocalPoint ( Vector2 worldPoint ) { } private native void jniGetLocalPoint ( long addr , float worldPointX , float worldPointY , float [ ] localPoint ) { } public final Vector2 localVector = new Vector2 ( ) ; public Vector2 getLocalVector ( Vector2 worldVector ) { } private native void jniGetLocalVector ( long addr , float worldVectorX , float worldVectorY , float [ ] worldVector ) { } public final Vector2 linVelWorld = new Vector2 ( ) ; public Vector2 getLinearVelocityFromWorldPoint ( Vector2 worldPoint ) { } private native void jniGetLinearVelocityFromWorldPoint ( long addr , float worldPointX , float worldPointY , float [ ] linVelWorld ) { } public final Vector2 linVelLoc = new Vector2 ( ) ; public Vector2 getLinearVelocityFromLocalPoint ( Vector2 localPoint ) { } private native void jniGetLinearVelocityFromLocalPoint ( long addr , float localPointX , float localPointY , float [ ] linVelLoc ) { } public float getLinearDamping ( ) { } private native float jniGetLinearDamping ( long add ) { } public void setLinearDamping ( float linearDamping ) { } private native void jniSetLinearDamping ( long addr , float linearDamping ) { }
public class MapperTestUtils { public static DocumentMapperParser newParser ( ) { <START_BUG> return new DocumentMapperParser ( new Index ( "test" ) , MapperTestUtils . newAnalysisService ( ) , new org . elasticsearch . index . codec . postingsformat . PostingsFormatService ( new Index ( "test" ) ) , new org . elasticsearch . index . codec . docvaluesformat . DocValuesFormatService ( new Index ( "test" ) ) , MapperTestUtils . newSimilarityLookupService ( ) ) ; <END_BUG> } public static DocumentMapperParser newParser ( Settings indexSettings ) { } public static MapperService newMapperService ( ) { } public static MapperService newMapperService ( Index index , Settings indexSettings ) { } public static AnalysisService newAnalysisService ( ) { } public static AnalysisService newAnalysisService ( Settings indexSettings ) { } public static SimilarityLookupService newSimilarityLookupService ( ) { } }
public abstract class TransportInstanceSingleOperationAction < Request extends InstanceShardOperationRequest , Response extends ActionResponse > extends TransportAction < Request , Response > { protected final ClusterService clusterService ; protected final TransportService transportService ; final String executor ; protected TransportInstanceSingleOperationAction ( Settings settings , String actionName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , ActionFilters actionFilters ) { } @ Override protected void doExecute ( Request request , ActionListener < Response > listener ) { } protected abstract String executor ( ) { } protected abstract void shardOperation ( Request request , ActionListener < Response > listener ) throws ElasticsearchException { } protected abstract Request newRequest ( ) { } protected abstract Response newResponse ( ) { } protected abstract ClusterBlockException checkGlobalBlock ( ClusterState state , Request request ) { } protected abstract ClusterBlockException checkRequestBlock ( ClusterState state , Request request ) { } protected boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) { <START_BUG> request . index ( state . metaData ( ) . concreteSingleIndex ( request . index ( ) ) ) ; <END_BUG> return true ; } protected boolean retryOnFailure ( Throwable e ) { } protected TransportRequestOptions transportOptions ( ) { } protected abstract ShardIterator shards ( ClusterState clusterState , Request request ) throws ElasticsearchException { } class AsyncSingleAction { private final ActionListener < Response > listener ; private final Request request ; private ShardIterator shardIt ; private DiscoveryNodes nodes ; private final AtomicBoolean operationStarted = new AtomicBoolean ( ) ; private volatile ClusterStateObserver observer ; private AsyncSingleAction ( Request request , ActionListener < Response > listener ) { } public void start ( ) { } protected boolean doStart ( ) throws ElasticsearchException { } void retry ( @ Nullable final Throwable failure ) { } } class TransportHandler extends BaseTransportRequestHandler < Request > { @ Override public Request newInstance ( ) { } @ Override public String executor ( ) { } @ Override public void messageReceived ( Request request , final TransportChannel channel ) throws Exception { } } }
@ AnalysisSettingsRequired public class DictionaryCompoundWordTokenFilterFactory extends AbstractCompoundWordTokenFilterFactory { @ Inject public DictionaryCompoundWordTokenFilterFactory ( Index index , @ IndexSettings Settings indexSettings , @ Assisted String name , @ Assisted Settings settings ) { } @ Override public TokenStream create ( TokenStream tokenStream ) { <START_BUG> return new org . apache . lucene . analysis . compound . DictionaryCompoundWordTokenFilter ( tokenStream , wordList , minWordSize , minSubwordSize , maxSubwordSize , onlyLongestMatch ) ; <END_BUG> } }
public class LineJoint extends Joint { public LineJoint ( World world , long addr ) { } public float getJointTranslation ( ) { } private native float jniGetJointTranslation ( long addr ) { } public float getJointSpeed ( ) { } private native float jniGetJointSpeed ( long addr ) { } public boolean isLimitEnabled ( ) { } private native boolean jniIsLimitEnabled ( long addr ) { } public void enableLimit ( boolean flag ) { } private native void jniEnableLimit ( long addr , boolean flag ) { } public float getLowerLimit ( ) { } private native float jniGetLowerLimit ( long addr ) { } public float getUpperLimit ( ) { } private native float jniGetUpperLimit ( long addr ) { } public void setLimits ( float lower , float upper ) { } private native void jniSetLimits ( long addr , float lower , float upper ) { } public boolean isMotorEnabled ( ) { } private native boolean jniIsMotorEnabled ( long addr ) { } public void enableMotor ( boolean flag ) { } <START_BUG> private native boolean jniEnableMotor ( long addr , boolean flag ) ; <END_BUG> public void setMotorSpeed ( float speed ) { } private native void jniSetMotorSpeed ( long addr , float speed ) { } public float getMotorSpeed ( ) { } private native float jniGetMotorSpeed ( long addr ) { } public void setMaxMotorForce ( float force ) { } private native void jniSetMaxMotorForce ( long addr , float force ) { } public float getMaxMotorForce ( ) { } private native float jniGetMaxMotorForce ( long addr ) { } public float getMotorForce ( ) { } private native float jniGetMotorForce ( long addr ) { } }
public class ScriptRangeFacetCollector extends AbstractFacetCollector { private final SearchScript keyScript ; private final SearchScript valueScript ; private final Entry [ ] entries ; public ScriptRangeFacetCollector ( String facetName , String scriptLang , String keyScript , String valueScript , Map < String , Object > params , RangeFacet [ ] entries , SearchContext context ) { } @ Override protected void doSetNextReader ( IndexReader reader , int docBase ) throws IOException { } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override public Facet facet ( ) { <START_BUG> return new InternalRangeFacet ( facetName , "_na" , "_na" , entries ) ; <END_BUG> } }
public class IOSMusic implements Music { private final OALAudioTrack track ; OnCompletionListener onCompletionListener ; public IOSMusic ( OALAudioTrack track ) { } @ Override public void play ( ) { } @ Override public void pause ( ) { } @ Override public void stop ( ) { } @ Override public boolean isPlaying ( ) { } @ Override public void setLooping ( boolean isLooping ) { } @ Override public boolean isLooping ( ) { } @ Override public void setVolume ( float volume ) { } public void setPosition ( float position ) { } @ Override public float getPosition ( ) { <START_BUG> return ( ( float ) ( track . getCurrentTime ( ) ) ) ; <END_BUG> } @ Override public void dispose ( ) { } @ Override public float getVolume ( ) { } @ Override public void setPan ( float pan , float volume ) { } @ Override public void setOnCompletionListener ( OnCompletionListener listener ) { } }
public class WidgetGroup extends Group implements Layout { private boolean needsLayout = true ; private boolean fillParent ; private boolean layoutEnabled = true ; public float getMinWidth ( ) { } public float getMinHeight ( ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMaxWidth ( ) { } public float getMaxHeight ( ) { } public void setLayoutEnabled ( boolean enabled ) { } private void setLayoutEnabled ( Group parent , boolean enabled ) { } public void validate ( ) { } public boolean needsLayout ( ) { } public void invalidate ( ) { } public void invalidateHierarchy ( ) { } protected void childrenChanged ( ) { } public void pack ( ) { } public void setFillParent ( boolean fillParent ) { } public void layout ( ) { } public void draw ( SpriteBatch batch , float parentAlpha ) { validate ( ) ; <START_BUG> super . drawChildren ( batch , parentAlpha ) ; <END_BUG> } }
public class GameLoop extends InvadersScreen implements SimulationListener { private final Simulation simulation ; private final Renderer renderer ; private final Sound explosion ; private final Sound shot ; public GameLoop ( ) { } @ Override public void dispose ( ) { } @ Override public boolean isDone ( ) { } @ Override public void draw ( float delta ) { <START_BUG> graphics . getGL10 ( ) . glClear ( ( ( GL10 . GL_COLOR_BUFFER_BIT ) | ( GL10 . GL_DEPTH_BUFFER_BIT ) ) ) ; <END_BUG> renderer . render ( simulation , delta ) ; } @ Override public void update ( float delta ) { } @ Override public void explosion ( ) { } @ Override public void shot ( ) { } }
public class LZFEncoder { private LZFEncoder ( ) { } public static byte [ ] encode ( byte [ ] data ) throws IOException { } public static byte [ ] encode ( byte [ ] data , int length ) throws IOException { <START_BUG> ChunkEncoder enc = new ChunkEncoder ( length ) ; <END_BUG> byte [ ] result = LZFEncoder . encode ( enc , data , length ) ; enc . close ( ) ; return result ; } public static byte [ ] encode ( ChunkEncoder enc , byte [ ] data , int length ) throws IOException { } }
@ ClusterScope ( scope = Scope . TEST , numNodes = 0 ) public class ShardsAllocatorModuleTests extends ElasticsearchIntegrationTest { public void testLoadDefaultShardsAllocator ( ) { } public void testLoadByShortKeyShardsAllocator ( ) { } public void testLoadByClassNameShardsAllocator ( ) { } private void assertAllocatorInstance ( Settings settings , Class < ? extends ShardsAllocator > clazz ) { <START_BUG> while ( ( cluster ( ) . size ( ) ) != 0 ) { <END_BUG> cluster ( ) . stopRandomNode ( ) ; } cluster ( ) . startNode ( settings ) ; ShardsAllocator instance = cluster ( ) . getInstance ( ShardsAllocator . class ) ; assertThat ( instance , instanceOf ( clazz ) ) ; } }
public class GistsActivity extends RoboFragmentActivity implements OnItemClickListener { private static final int REQUEST_CREATE = 1 ; private static final int REQUEST_VIEW = ( GistsActivity . REQUEST_CREATE ) + 1 ; @ Inject private Context context ; @ Inject private ContextScopedProvider < GistService > serviceProvider ; private GistsFragment gists ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( layout . gists ) ; <START_BUG> setTitle ( getString ( gists_title ) ) ; <END_BUG> gists = ( ( GistsFragment ) ( getSupportFragmentManager ( ) . findFragmentById ( list ) ) ) ; if ( ( gists ) == null ) { gists = new GistsFragment ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . add ( list , gists ) . commit ( ) ; } gists . setClickListener ( this ) ; } private void randomGist ( ) { } private void openGist ( ) { } @ Override public boolean onCreateOptionsMenu ( Menu options ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } public void onItemClick ( AdapterView < ? > list , View view , int position , long id ) { } }
public class FiltersFunctionScoreQuery extends Query { public static class FilterFunction { public final Filter filter ; public final ScoreFunction function ; public FilterFunction ( Filter filter , ScoreFunction function ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } } public static enum ScoreMode { First , Avg , Max , Total , Min , Multiply ; } Query subQuery ; final FiltersFunctionScoreQuery . FilterFunction [ ] filterFunctions ; final FiltersFunctionScoreQuery . ScoreMode scoreMode ; final float maxBoost ; public FiltersFunctionScoreQuery ( Query subQuery , FiltersFunctionScoreQuery . ScoreMode scoreMode , FiltersFunctionScoreQuery . FilterFunction [ ] filterFunctions , float maxBoost ) { } public Query getSubQuery ( ) { } public FiltersFunctionScoreQuery . FilterFunction [ ] getFilterFunctions ( ) { } @ Override public Query rewrite ( IndexReader reader ) throws IOException { } @ Override public void extractTerms ( Set < Term > terms ) { } @ Override public Weight createWeight ( IndexSearcher searcher ) throws IOException { } class CustomBoostFactorWeight extends Weight { final Weight subQueryWeight ; final Bits [ ] docSets ; public CustomBoostFactorWeight ( Weight subQueryWeight , int filterFunctionLength ) throws IOException { } public Query getQuery ( ) { } @ Override public float getValueForNormalization ( ) throws IOException { } @ Override public void normalize ( float norm , float topLevelBoost ) { } @ Override public Scorer scorer ( AtomicReaderContext context , boolean scoreDocsInOrder , boolean topScorer , Bits acceptDocs ) throws IOException { } @ Override public Explanation explain ( AtomicReaderContext context , int doc ) throws IOException { } } static class CustomBoostFactorScorer extends Scorer { private final float subQueryBoost ; private final Scorer scorer ; private final FiltersFunctionScoreQuery . FilterFunction [ ] filterFunctions ; private final FiltersFunctionScoreQuery . ScoreMode scoreMode ; private final float maxBoost ; private final Bits [ ] docSets ; private CustomBoostFactorScorer ( FiltersFunctionScoreQuery . CustomBoostFactorWeight w , Scorer scorer , FiltersFunctionScoreQuery . ScoreMode scoreMode , FiltersFunctionScoreQuery . FilterFunction [ ] filterFunctions , float maxBoost , Bits [ ] docSets ) throws IOException { } @ Override public int docID ( ) { } @ Override public int advance ( int target ) throws IOException { } @ Override public int nextDoc ( ) throws IOException { } @ Override public float score ( ) throws IOException { } @ Override <START_BUG> public float freq ( ) throws IOException { <END_BUG> return scorer . freq ( ) ; } } public String toString ( String field ) { } public boolean equals ( Object o ) { } public int hashCode ( ) { } }
public class TransportSearchScrollQueryThenFetchAction extends AbstractComponent { private final ThreadPool threadPool ; private final ClusterService clusterService ; private final SearchServiceTransportAction searchService ; private final SearchPhaseController searchPhaseController ; private final TransportSearchCache searchCache ; @ Inject public TransportSearchScrollQueryThenFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportSearchCache searchCache , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } public void execute ( SearchScrollRequest request , ParsedScrollId scrollId , ActionListener < SearchResponse > listener ) { } private class AsyncAction { private final SearchScrollRequest request ; private final ActionListener < SearchResponse > listener ; private final ParsedScrollId scrollId ; private final DiscoveryNodes nodes ; protected volatile Queue < ShardSearchFailure > shardFailures ; private final Map < SearchShardTarget , QuerySearchResultProvider > queryResults = searchCache . obtainQueryResults ( ) ; private final Map < SearchShardTarget , FetchSearchResult > fetchResults = searchCache . obtainFetchResults ( ) ; private volatile ShardDoc [ ] sortedShardList ; private final AtomicInteger successfulOps ; private final long startTime = System . currentTimeMillis ( ) ; private AsyncAction ( SearchScrollRequest request , ParsedScrollId scrollId , ActionListener < SearchResponse > listener ) { } protected final ShardSearchFailure [ ] buildShardFailures ( ) { } protected final void addShardFailure ( ShardSearchFailure failure ) { } public void start ( ) { } private void executeQueryPhase ( final AtomicInteger counter , DiscoveryNode node , final long searchId ) { } private void executeFetchPhase ( ) { } private void finishHim ( ) { try { innerFinishHim ( ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> listener . onFailure ( new ReduceSearchPhaseException ( "fetch" , "" , e , buildShardFailures ( ) ) ) ; } } private void innerFinishHim ( ) { } } }
public class IntAttribute extends Attribute { public static final String CullFaceAlias = "cullface" ; public static final long CullFace = register ( IntAttribute . CullFaceAlias ) ; public static IntAttribute createCullFace ( int value ) { } public int value ; public IntAttribute ( long type ) { } public IntAttribute ( long type , int value ) { } @ Override public Attribute copy ( ) { } @ Override public int hashCode ( ) { <START_BUG> int result = ( ( int ) ( type ) ) ; <END_BUG> result = ( 983 * result ) + ( value ) ; return result ; } }
public class AndroidLiveWallpaper implements Application { protected AndroidLiveWallpaperService service ; protected AndroidGraphicsLiveWallpaper graphics ; protected AndroidInput input ; protected AndroidAudio audio ; protected AndroidFiles files ; protected AndroidNet net ; protected ApplicationListener listener ; protected boolean firstResume = true ; protected final Array < Runnable > runnables = new Array < Runnable > ( ) ; protected final Array < Runnable > executedRunnables = new Array < Runnable > ( ) ; protected final Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; protected int logLevel = LOG_INFO ; public AndroidLiveWallpaper ( AndroidLiveWallpaperService service ) { } public void initialize ( ApplicationListener listener , AndroidApplicationConfiguration config ) { } public void onPause ( ) { } public void onResume ( ) { } public void onDestroy ( ) { } public WindowManager getWindowManager ( ) { } public AndroidLiveWallpaperService getService ( ) { } public ApplicationListener getListener ( ) { } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public Audio getAudio ( ) { } @ Override public Files getFiles ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Input getInput ( ) { } @ Override public Net getNet ( ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { <START_BUG> return VERSION . SDK_INT ; <END_BUG> } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } @ Override public Preferences getPreferences ( String name ) { } AndroidClipboard clipboard ; @ Override public Clipboard getClipboard ( ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } @ Override public void log ( String tag , String message ) { } @ Override public void log ( String tag , String message , Throwable exception ) { } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public int getLogLevel ( ) { } @ Override public void exit ( ) { } @ Override public void addLifecycleListener ( LifecycleListener listener ) { } @ Override public void removeLifecycleListener ( LifecycleListener listener ) { } @ Override public ApplicationListener getApplicationListener ( ) { } }
public class Bits { long [ ] bits = new long [ ] { 0 } ; public boolean get ( int index ) { } public void set ( int index ) { } public void flip ( int index ) { } private void checkCapacity ( int len ) { <START_BUG> if ( len >= ( bits . length ) ) { <END_BUG> long [ ] newBits = new long [ len + 1 ] ; System . arraycopy ( bits , 0 , newBits , 0 , bits . length ) ; bits = newBits ; } } public void clear ( int index ) { } public void clear ( ) { } public int numBits ( ) { } }
public class Array < T > implements Iterable < T > { public T [ ] items ; public int size ; public boolean ordered ; private Array . ArrayIterator iterator ; public Array ( ) { } public Array ( int capacity ) { } public Array ( boolean ordered , int capacity ) { } public Array ( boolean ordered , int capacity , Class < T > arrayType ) { } public Array ( Class < T > arrayType ) { } public Array ( Array array ) { } public Array ( T [ ] array ) { } public Array ( boolean ordered , T [ ] array ) { } public void add ( T value ) { } public void addAll ( Array array ) { } public void addAll ( Array array , int offset , int length ) { } public void addAll ( T [ ] array ) { } public void addAll ( T [ ] array , int offset , int length ) { } public T get ( int index ) { } public void set ( int index , T value ) { } public void insert ( int index , T value ) { } public boolean contains ( T value , boolean identity ) { } public int indexOf ( T value , boolean identity ) { } public boolean removeValue ( T value , boolean identity ) { } public T removeIndex ( int index ) { } public T pop ( ) { } public T peek ( ) { } public void clear ( ) { } public void shrink ( ) { } public T [ ] ensureCapacity ( int additionalCapacity ) { } protected T [ ] resize ( int newSize ) { } public void sort ( ) { } public void sort ( Comparator < T > comparator ) { } public void reverse ( ) { } public void shuffle ( ) { } public Iterator < T > iterator ( ) { } public void truncate ( int newSize ) { if ( ( size ) <= newSize ) return ; <START_BUG> for ( int i = size ; i < newSize ; i ++ ) <END_BUG> items [ i ] = null ; size = newSize ; } public T [ ] toArray ( ) { } public < V > V [ ] toArray ( Class < V > type ) { } public String toString ( ) { } public static class ArrayIterator < T > implements Iterator < T > { private final Array < T > array ; int index ; public ArrayIterator ( Array < T > array ) { } public boolean hasNext ( ) { } public T next ( ) { } public void remove ( ) { } public void reset ( ) { } } public static class ArrayIterable < T > implements Iterable < T > { private Array . ArrayIterator < T > iterator ; public ArrayIterable ( Array < T > array ) { } @ Override public Iterator < T > iterator ( ) { } } }
public class TransportNodesStatsAction extends TransportNodesOperationAction < NodesStatsRequest , NodesStatsResponse , TransportNodesStatsAction . NodeStatsRequest , NodeStats > { private final MonitorService monitorService ; @ Inject public TransportNodesStatsAction ( Settings settings , ClusterName clusterName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , MonitorService monitorService ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportNodeAction ( ) { } @ Override protected NodesStatsResponse newResponse ( NodesStatsRequest nodesInfoRequest , AtomicReferenceArray responses ) { } @ Override protected NodesStatsRequest newRequest ( ) { } @ Override protected TransportNodesStatsAction . NodeStatsRequest newNodeRequest ( ) { } @ Override protected TransportNodesStatsAction . NodeStatsRequest newNodeRequest ( String nodeId , NodesStatsRequest request ) { } @ Override protected NodeStats newNodeResponse ( ) { } @ Override protected NodeStats nodeOperation ( TransportNodesStatsAction . NodeStatsRequest request ) throws ElasticSearchException { <START_BUG> return new NodeStats ( clusterService . state ( ) . nodes ( ) . localNode ( ) , monitorService . osService ( ) . stats ( ) , monitorService . processService ( ) . stats ( ) , monitorService . jvmService ( ) . stats ( ) , monitorService . networkService ( ) . stats ( ) , threadPool . stats ( ) ) ; <END_BUG> } @ Override protected boolean accumulateExceptions ( ) { } protected static class NodeStatsRequest extends NodeOperationRequest { private NodeStatsRequest ( ) { } private NodeStatsRequest ( String nodeId ) { } } }
public class TransportFlushAction extends TransportBroadcastOperationAction < FlushRequest , FlushResponse , ShardFlushRequest , ShardFlushResponse > { private final IndicesService indicesService ; @ Inject public TransportFlushAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected FlushRequest newRequest ( ) { } @ Override protected boolean ignoreNonActiveExceptions ( ) { } @ Override protected FlushResponse newResponse ( FlushRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardFlushRequest newShardRequest ( ) { } @ Override protected ShardFlushRequest newShardRequest ( ShardRouting shard , FlushRequest request ) { } @ Override protected ShardFlushResponse newShardResponse ( ) { } @ Override protected ShardFlushResponse shardOperation ( ShardFlushRequest request ) throws ElasticSearchException { } @ Override protected GroupShardsIterator shards ( FlushRequest request , String [ ] concreteIndices , ClusterState clusterState ) { <START_BUG> return clusterState . routingTable ( ) . allShardsGrouped ( concreteIndices ) ; <END_BUG> } }
public class Node { public String id ; public Node parent ; public final Array < Node > children = new Array < Node > ( 2 ) ; public boolean isAnimated ; public final Vector3 translation = new Vector3 ( ) ; public final Quaternion rotation = new Quaternion ( 0 , 0 , 0 , 1 ) ; public final Vector3 scale = new Vector3 ( 1 , 1 , 1 ) ; public final Matrix4 localTransform = new Matrix4 ( ) ; public final Matrix4 globalTransform = new Matrix4 ( ) ; public Array < NodePart > parts = new Array < NodePart > ( 2 ) ; public Matrix4 calculateLocalTransform ( ) { if ( ! ( isAnimated ) ) <START_BUG> localTransform . idt ( ) . translate ( translation ) . rotate ( rotation ) . scale ( scale . x , scale . y , scale . z ) ; <END_BUG> return localTransform ; } public Matrix4 calculateWorldTransform ( ) { } public void calculateTransforms ( boolean recursive ) { } public void calculateBoneTransforms ( boolean recursive ) { } public BoundingBox calculateBoundingBox ( final BoundingBox out ) { } public BoundingBox calculateBoundingBox ( final BoundingBox out , boolean transform ) { } public BoundingBox extendBoundingBox ( final BoundingBox out ) { } public BoundingBox extendBoundingBox ( final BoundingBox out , boolean transform ) { } public Node getChild ( final String id , boolean recursive , boolean ignoreCase ) { } public static Node getNode ( final Array < Node > nodes , final String id , boolean recursive , boolean ignoreCase ) { } }
public class TransportBroadcastPingAction extends TransportBroadcastOperationAction < BroadcastPingRequest , BroadcastPingResponse , BroadcastShardPingRequest , BroadcastShardPingResponse > { @ Inject public TransportBroadcastPingAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected BroadcastPingRequest newRequest ( ) { } @ Override protected GroupShardsIterator shards ( BroadcastPingRequest request , String [ ] concreteIndices , ClusterState clusterState ) { <START_BUG> return clusterService . operationRouting ( ) . searchShards ( clusterState , concreteIndices , request . queryHint ( ) , null , null ) ; <END_BUG> } @ Override protected BroadcastPingResponse newResponse ( BroadcastPingRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected BroadcastShardPingRequest newShardRequest ( ) { } @ Override protected BroadcastShardPingRequest newShardRequest ( ShardRouting shard , BroadcastPingRequest request ) { } @ Override protected BroadcastShardPingResponse newShardResponse ( ) { } @ Override protected BroadcastShardPingResponse shardOperation ( BroadcastShardPingRequest broadcastShardPingRequest ) throws ElasticSearchException { } }
public class ObjectSet < T > implements Iterable < T > { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; public int size ; T [ ] keyTable ; int capacity ; int stashSize ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private ObjectSet . SetIterator iterator1 ; private ObjectSet . SetIterator iterator2 ; public ObjectSet ( ) { } public ObjectSet ( int initialCapacity ) { } public ObjectSet ( int initialCapacity , float loadFactor ) { } public ObjectSet ( ObjectSet set ) { } public boolean add ( T key ) { } public void addAll ( Array < ? extends T > array ) { } public void addAll ( Array < ? extends T > array , int offset , int length ) { } public void addAll ( T ... array ) { } public void addAll ( T [ ] array , int offset , int length ) { } public void addAll ( ObjectSet < T > set ) { } private void addResize ( T key ) { } private void push ( T insertKey , int index1 , T key1 , int index2 , T key2 , int index3 , T key3 ) { } private void addStash ( T key ) { } public boolean remove ( T key ) { } boolean removeStash ( T key ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean contains ( T key ) { } private boolean containsKeyStash ( T key ) { } public T first ( ) { T [ ] keyTable = this . keyTable ; <START_BUG> for ( int i = 0 , n = ( capacity ) + ( stashSize ) ; i < n ; ) <END_BUG> if ( ( keyTable [ i ] ) != null ) return keyTable [ i ] ; throw new IllegalStateException ( "IntSet<seq2seq4repair_space>is<seq2seq4repair_space>empty." ) ; } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public String toString ( String separator ) { } public ObjectSet . SetIterator < T > iterator ( ) { } public static < T > ObjectSet < T > with ( T ... array ) { } public static class SetIterator < K > implements Iterable < K > , Iterator < K > { public boolean hasNext ; final ObjectSet < K > set ; int nextIndex ; int currentIndex ; boolean valid = true ; public SetIterator ( ObjectSet < K > set ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { } public boolean hasNext ( ) { } public K next ( ) { } public Iterator < K > iterator ( ) { } public Array < K > toArray ( ) { } } }
public class OrganizationLoader extends AuthenticatedUserLoader < List < User > > { private static final String TAG = "OrganizationLoader" ; private final Provider < UserComparator > userComparatorProvider ; private final AccountDataManager accountDataManager ; @ Inject public OrganizationLoader ( Activity activity , AccountDataManager accountDataManager , Provider < UserComparator > userComparatorProvider ) { } @ Override protected List < User > getAccountFailureData ( ) { } @ Override public List < User > load ( final Account account ) { List < User > orgs ; try { <START_BUG> orgs = accountDataManager . getOrgs ( ) ; <END_BUG> } catch ( final IOException e ) { Log . e ( OrganizationLoader . TAG , "Exception<seq2seq4repair_space>loading<seq2seq4repair_space>organizations" , e ) ; ToastUtils . show ( activity , e , error_orgs_load ) ; return Collections . emptyList ( ) ; } Collections . sort ( orgs , userComparatorProvider . get ( ) ) ; return orgs ; } }
public class ContactAddedListenerByValue { private long swigCPtr ; protected boolean swigCMemOwn ; protected ContactAddedListenerByValue ( long cPtr , boolean cMemoryOwn ) { } public static long getCPtr ( ContactAddedListenerByValue obj ) { } protected void finalize ( ) { } public synchronized void delete ( ) { } protected void swigDirectorDisconnect ( ) { } public void swigReleaseOwnership ( ) { } public void swigTakeOwnership ( ) { } public boolean onContactAdded ( btManifoldPoint cp , int userValue0 , int partId0 , int index0 , boolean match0 , int userValue1 , int partId1 , int index1 , boolean match1 ) { <START_BUG> return gdxBulletJNI . ContactAddedListenerByValue_onContactAdded ( swigCPtr , this , btManifoldPoint . getCPtr ( cp ) , cp , userValue0 , partId0 , index0 , match0 , userValue1 , partId1 , index1 , match1 ) ; <END_BUG> } public ContactAddedListenerByValue ( ) { } }
public class CubocDesktop { public static void main ( String [ ] argv ) { <START_BUG> new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new Cubocy ( ) , "Cubocy" , 480 , 320 , true ) ; <END_BUG> app . setLogLevel ( LOG_DEBUG ) ; } }
public abstract class Viewport { private Camera camera ; private float worldWidth ; private float worldHeight ; private int screenX ; private int screenY ; private int screenWidth ; private int screenHeight ; private final Vector3 tmp = new Vector3 ( ) ; public void apply ( ) { } public void apply ( boolean centerCamera ) { } public final void update ( int screenWidth , int screenHeight ) { } public void update ( int screenWidth , int screenHeight , boolean centerCamera ) { } public Vector2 unproject ( Vector2 screenCoords ) { } public Vector2 project ( Vector2 worldCoords ) { } public Vector3 unproject ( Vector3 screenCoords ) { } public Vector3 project ( Vector3 worldCoords ) { } public Ray getPickRay ( float screenX , float screenY ) { <START_BUG> return camera . getPickRay ( screenX , screenY , this . screenX , this . screenY , screenWidth , screenHeight ) ; <END_BUG> } public void calculateScissors ( Matrix4 batchTransform , Rectangle area , Rectangle scissor ) { } public Vector2 toScreenCoordinates ( Vector2 worldCoords , Matrix4 transformMatrix ) { } public Camera getCamera ( ) { } public void setCamera ( Camera camera ) { } public float getWorldWidth ( ) { } public void setWorldWidth ( float worldWidth ) { } public float getWorldHeight ( ) { } public void setWorldHeight ( float worldHeight ) { } public void setWorldSize ( float worldWidth , float worldHeight ) { } public int getScreenX ( ) { } public void setScreenX ( int screenX ) { } public int getScreenY ( ) { } public void setScreenY ( int screenY ) { } public int getScreenWidth ( ) { } public void setScreenWidth ( int screenWidth ) { } public int getScreenHeight ( ) { } public void setScreenHeight ( int screenHeight ) { } public void setScreenPosition ( int screenX , int screenY ) { } public void setScreenSize ( int screenWidth , int screenHeight ) { } public void setScreenBounds ( int screenX , int screenY , int screenWidth , int screenHeight ) { } public int getLeftGutterWidth ( ) { } public int getRightGutterX ( ) { } public int getRightGutterWidth ( ) { } public int getBottomGutterHeight ( ) { } public int getTopGutterY ( ) { } public int getTopGutterHeight ( ) { } }
public class RepositoryNewsFragment extends NewsFragment { @ InjectExtra ( Intents . EXTRA_REPOSITORY ) private Repository repo ; @ Override protected ResourcePager < Event > createPager ( ) { } @ Override protected void viewRepository ( Repository repository ) { } @ Override protected void viewIssue ( Issue issue ) { <START_BUG> startActivity ( IssuesViewActivity . createIntent ( Collections . singletonList ( issue ) , repo , 0 ) ) ; <END_BUG> } }
public class TransportSearchDfsQueryAndFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchDfsQueryAndFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportSearchCache transportSearchCache , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < DfsSearchResult > { private final Collection < DfsSearchResult > dfsResults = searchCache . obtainDfsResults ( ) ; private final Map < SearchShardTarget , QueryFetchSearchResult > queryFetchResults = searchCache . obtainQueryFetchResults ( ) ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , InternalSearchRequest request , SearchServiceListener < DfsSearchResult > listener ) { } @ Override protected void processFirstPhaseResult ( ShardRouting shard , DfsSearchResult result ) { } @ Override protected void moveToSecondPhase ( ) { } private void executeSecondPhase ( final DfsSearchResult dfsResult , final AtomicInteger counter , DiscoveryNode node , final QuerySearchRequest querySearchRequest ) { } private void finishHim ( ) { } private void innerFinishHim ( ) throws Exception { sortedShardList = searchPhaseController . sortDocs ( queryFetchResults . values ( ) ) ; final InternalSearchResponse internalResponse = searchPhaseController . merge ( sortedShardList , queryFetchResults , queryFetchResults ) ; String scrollId = null ; if ( ( request . scroll ( ) ) != null ) { <START_BUG> scrollId = buildScrollId ( request . searchType ( ) , dfsResults ) ; <END_BUG> } listener . onResponse ( new SearchResponse ( internalResponse , scrollId , expectedSuccessfulOps , successulOps . get ( ) , buildTookInMillis ( ) , buildShardFailures ( ) ) ) ; } } }
public class TransportGetAction extends TransportShardSingleOperationAction < GetRequest , GetResponse > { private final IndicesService indicesService ; private final ScriptService scriptService ; private final boolean realtime ; @ Inject public TransportGetAction ( Settings settings , ClusterService clusterService , TransportService transportService , IndicesService indicesService , ScriptService scriptService , ThreadPool threadPool ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected void checkBlock ( GetRequest request , ClusterState state ) { } @ Override protected ShardIterator shards ( ClusterState clusterState , GetRequest request ) { <START_BUG> return clusterService . operationRouting ( ) . indexShards ( clusterService . state ( ) , request . index ( ) , request . type ( ) , request . id ( ) , request . routing ( ) ) ; <END_BUG> } @ Override protected void doExecute ( GetRequest request , ActionListener < GetResponse > listener ) { } @ Override protected GetResponse shardOperation ( GetRequest request , int shardId ) throws ElasticSearchException { } private FieldSelector buildFieldSelectors ( DocumentMapper docMapper , String ... fields ) { } private byte [ ] extractSource ( Document doc , DocumentMapper documentMapper ) { } private DocIdAndVersion loadCurrentVersionFromIndex ( BloomCache bloomCache , Engine . Searcher searcher , Term uid ) { } @ Override protected GetRequest newRequest ( ) { } @ Override protected GetResponse newResponse ( ) { } }
public class AtomicQueue < T > { private final AtomicInteger writeIndex = new AtomicInteger ( ) ; private final AtomicInteger readIndex = new AtomicInteger ( ) ; private final AtomicReferenceArray < T > queue ; public AtomicQueue ( int capacity ) { } private int next ( int idx ) { <START_BUG> return ( idx + 1 ) % ( queue . length ( ) ) ; <END_BUG> } public boolean put ( T value ) { } public T poll ( ) { } }
public class Cell < T extends Actor > implements Poolable { Value minWidth ; Value minHeight ; Value prefWidth ; Value prefHeight ; Value maxWidth ; Value maxHeight ; Value spaceTop ; Value spaceLeft ; Value spaceBottom ; Value spaceRight ; Value padTop ; Value padLeft ; Value padBottom ; Value padRight ; Float fillX ; Float fillY ; Integer align ; Integer expandX ; Integer expandY ; Integer colspan ; Boolean uniformX ; Boolean uniformY ; Actor actor ; float actorX ; float actorY ; float actorWidth ; float actorHeight ; private Table table ; boolean endRow ; int column ; int row ; int cellAboveIndex = - 1 ; float computedPadTop ; float computedPadLeft ; float computedPadBottom ; float computedPadRight ; public void setLayout ( Table table ) { } void set ( Cell defaults ) { } void merge ( Cell cell ) { } public < A extends Actor > Cell < A > setActor ( A newActor ) { } public T getActor ( ) { } public boolean hasActor ( ) { } public Cell < T > size ( Value size ) { } public Cell < T > size ( Value width , Value height ) { } public Cell < T > size ( float size ) { } public Cell < T > size ( float width , float height ) { } public Cell < T > width ( Value width ) { } public Cell < T > width ( float width ) { } public Cell < T > height ( Value height ) { } public Cell < T > height ( float height ) { } public Cell < T > minSize ( Value size ) { } public Cell < T > minSize ( Value width , Value height ) { } public Cell < T > minWidth ( Value minWidth ) { } public Cell < T > minHeight ( Value minHeight ) { } public Cell < T > minSize ( float size ) { } public Cell < T > minSize ( float width , float height ) { } public Cell < T > minWidth ( float minWidth ) { } public Cell < T > minHeight ( float minHeight ) { } public Cell < T > prefSize ( Value size ) { } public Cell < T > prefSize ( Value width , Value height ) { } public Cell < T > prefWidth ( Value prefWidth ) { } public Cell < T > prefHeight ( Value prefHeight ) { } public Cell < T > prefSize ( float width , float height ) { <START_BUG> prefSize ( new Fixed ( width ) , new Fixed ( height ) ) ; <END_BUG> return this ; } public Cell < T > prefSize ( float size ) { } public Cell < T > prefWidth ( float prefWidth ) { } public Cell < T > prefHeight ( float prefHeight ) { } public Cell < T > maxSize ( Value size ) { } public Cell < T > maxSize ( Value width , Value height ) { } public Cell < T > maxWidth ( Value maxWidth ) { } public Cell < T > maxHeight ( Value maxHeight ) { } public Cell < T > maxSize ( float size ) { } public Cell < T > maxSize ( float width , float height ) { } public Cell < T > maxWidth ( float maxWidth ) { } public Cell < T > maxHeight ( float maxHeight ) { } public Cell < T > space ( Value space ) { } public Cell < T > space ( Value top , Value left , Value bottom , Value right ) { } public Cell < T > spaceTop ( Value spaceTop ) { } public Cell < T > spaceLeft ( Value spaceLeft ) { } public Cell < T > spaceBottom ( Value spaceBottom ) { } public Cell < T > spaceRight ( Value spaceRight ) { } public Cell < T > space ( float space ) { } public Cell < T > space ( float top , float left , float bottom , float right ) { } public Cell < T > spaceTop ( float spaceTop ) { } public Cell < T > spaceLeft ( float spaceLeft ) { } public Cell < T > spaceBottom ( float spaceBottom ) { } public Cell < T > spaceRight ( float spaceRight ) { } public Cell < T > pad ( Value pad ) { } public Cell < T > pad ( Value top , Value left , Value bottom , Value right ) { } public Cell < T > padTop ( Value padTop ) { } public Cell < T > padLeft ( Value padLeft ) { } public Cell < T > padBottom ( Value padBottom ) { } public Cell < T > padRight ( Value padRight ) { } public Cell < T > pad ( float pad ) { } public Cell < T > pad ( float top , float left , float bottom , float right ) { } public Cell < T > padTop ( float padTop ) { } public Cell < T > padLeft ( float padLeft ) { } public Cell < T > padBottom ( float padBottom ) { } public Cell < T > padRight ( float padRight ) { } public Cell < T > fill ( ) { } public Cell < T > fillX ( ) { } public Cell < T > fillY ( ) { } public Cell < T > fill ( Float x , Float y ) { } public Cell < T > fill ( boolean x , boolean y ) { }
public class Touchpad extends Widget { private Touchpad . TouchpadStyle style ; boolean touched ; private float deadzoneRadius ; private final Circle padBounds = new Circle ( 0 , 0 , 0 ) ; private final Circle deadzoneBounds = new Circle ( 0 , 0 , 0 ) ; private final Vector2 knobPosition = new Vector2 ( ) ; private final Vector2 knobPercent = new Vector2 ( ) ; public Touchpad ( float deadzoneRadius , Skin skin ) { } public Touchpad ( float deadzoneRadius , Skin skin , String styleName ) { } public Touchpad ( float deadzoneRadius , Touchpad . TouchpadStyle style ) { } void calculatePositionAndValue ( float x , float y , boolean isTouchUp ) { } public void setStyle ( Touchpad . TouchpadStyle style ) { } public Touchpad . TouchpadStyle getStyle ( ) { } @ Override <START_BUG> public Actor hit ( float x , float y , boolean touchable ) { <END_BUG> return padBounds . contains ( x , y ) ? this : null ; } @ Override public void layout ( ) { } @ Override public void draw ( SpriteBatch batch , float parentAlpha ) { } @ Override public float getPrefWidth ( ) { } @ Override public float getPrefHeight ( ) { } public boolean isTouched ( ) { } public void setDeadzone ( float deadzoneRadius ) { } public float getKnobX ( ) { } public float getKnobY ( ) { } public float getKnobPercentX ( ) { } public float getKnobPercentY ( ) { } public static class TouchpadStyle { public Drawable background ; public Drawable knob ; public TouchpadStyle ( ) { } public TouchpadStyle ( Drawable background , Drawable knob ) { } public TouchpadStyle ( Touchpad . TouchpadStyle style ) { } } }
public class IndexersModule extends AbstractModule { private final Settings settings ; public IndexersModule ( Settings settings ) { } @ Override protected void configure ( ) { <START_BUG> bind ( String . class ) . annotatedWith ( IndexerIndexName . class ) . toInstance ( settings . get ( "indexer.index_name" , "indexer" ) ) ; <END_BUG> bind ( IndexersService . class ) . asEagerSingleton ( ) ; bind ( IndexerClusterService . class ) . asEagerSingleton ( ) ; bind ( IndexersRouter . class ) . asEagerSingleton ( ) ; bind ( IndexerManager . class ) . asEagerSingleton ( ) ; } }
public class ClusterState { private final long version ; private final RoutingTable routingTable ; private final DiscoveryNodes nodes ; private final MetaData metaData ; private final ClusterBlocks blocks ; private final AllocationExplanation allocationExplanation ; private volatile RoutingNodes routingNodes ; public ClusterState ( long version , ClusterState state ) { } public ClusterState ( long version , MetaData metaData , RoutingTable routingTable , DiscoveryNodes nodes , ClusterBlocks blocks , AllocationExplanation allocationExplanation ) { } public long version ( ) { } public long getVersion ( ) { } public DiscoveryNodes nodes ( ) { } public DiscoveryNodes getNodes ( ) { } public MetaData metaData ( ) { } public MetaData getMetaData ( ) { } public RoutingTable routingTable ( ) { } public RoutingTable getRoutingTable ( ) { } public RoutingNodes routingNodes ( ) { } public RoutingNodes getRoutingNodes ( ) { } public ClusterBlocks blocks ( ) { } public ClusterBlocks getBlocks ( ) { } public AllocationExplanation allocationExplanation ( ) { } public AllocationExplanation getAllocationExplanation ( ) { } public RoutingNodes readOnlyRoutingNodes ( ) { } public static ClusterState . Builder builder ( ) { } public static ClusterState . Builder newClusterStateBuilder ( ) { } public static class Builder { private long version = 0 ; private MetaData metaData = MetaData . EMPTY_META_DATA ; private RoutingTable routingTable = RoutingTable . EMPTY_ROUTING_TABLE ; private DiscoveryNodes nodes = DiscoveryNodes . EMPTY_NODES ; private ClusterBlocks blocks = ClusterBlocks . EMPTY_CLUSTER_BLOCK ; private AllocationExplanation allocationExplanation = AllocationExplanation . EMPTY ; public ClusterState . Builder nodes ( DiscoveryNodes . Builder nodesBuilder ) { } public ClusterState . Builder nodes ( DiscoveryNodes nodes ) { } public ClusterState . Builder routingTable ( RoutingTable . Builder routingTable ) { } public ClusterState . Builder routingResult ( RoutingAllocation . Result routingResult ) { } public ClusterState . Builder routingTable ( RoutingTable routingTable ) { } public ClusterState . Builder metaData ( MetaData . Builder metaDataBuilder ) { } public ClusterState . Builder metaData ( MetaData metaData ) { } public ClusterState . Builder blocks ( ClusterBlocks . Builder blocksBuilder ) { } public ClusterState . Builder blocks ( ClusterBlocks block ) { } public ClusterState . Builder allocationExplanation ( AllocationExplanation allocationExplanation ) { } public ClusterState . Builder version ( long version ) { } public ClusterState . Builder state ( ClusterState state ) { } public ClusterState build ( ) { } public static byte [ ] toBytes ( ClusterState state ) throws IOException { } public static ClusterState fromBytes ( byte [ ] data , DiscoveryNode localNode ) throws IOException { <START_BUG> return ClusterState . Builder . readFrom ( new BytesStreamInput ( data ) , localNode ) ; <END_BUG> } public static void writeTo ( ClusterState state , StreamOutput out ) throws IOException { } public static ClusterState readFrom ( StreamInput in , @ Nullable DiscoveryNode localNode ) throws IOException { } } }
public class JsonReader implements BaseJsonReader { public JsonValue parse ( String json ) { } public JsonValue parse ( Reader reader ) { } @ Override public JsonValue parse ( InputStream input ) { } @ Override public JsonValue parse ( FileHandle file ) { try { <START_BUG> return parse ( file . read ( ) ) ; <END_BUG> } catch ( Exception ex ) { throw new SerializationException ( ( "Error<seq2seq4repair_space>parsing<seq2seq4repair_space>file:<seq2seq4repair_space>" + file ) , ex ) ; } } public JsonValue parse ( char [ ] data , int offset , int length ) { } private static byte [ ] init__json_actions_0 ( ) { } private static final byte [ ] _json_actions = JsonReader . init__json_actions_0 ( ) ; private static short [ ] init__json_key_offsets_0 ( ) { } private static final short [ ] _json_key_offsets = JsonReader . init__json_key_offsets_0 ( ) ; private static char [ ] init__json_trans_keys_0 ( ) { } private static final char [ ] _json_trans_keys = JsonReader . init__json_trans_keys_0 ( ) ; private static byte [ ] init__json_single_lengths_0 ( ) { } private static final byte [ ] _json_single_lengths = JsonReader . init__json_single_lengths_0 ( ) ; private static byte [ ] init__json_range_lengths_0 ( ) { } private static final byte [ ] _json_range_lengths = JsonReader . init__json_range_lengths_0 ( ) ; private static short [ ] init__json_index_offsets_0 ( ) { } private static final short [ ] _json_index_offsets = JsonReader . init__json_index_offsets_0 ( ) ; private static byte [ ] init__json_trans_targs_0 ( ) { } private static final byte [ ] _json_trans_targs = JsonReader . init__json_trans_targs_0 ( ) ; private static byte [ ] init__json_trans_actions_0 ( ) { } private static final byte [ ] _json_trans_actions = JsonReader . init__json_trans_actions_0 ( ) ; private static byte [ ] init__json_eof_actions_0 ( ) { } private static final byte [ ] _json_eof_actions = JsonReader . init__json_eof_actions_0 ( ) ; static final int json_start = 1 ; static final int json_first_final = 72 ; static final int json_error = 0 ; static final int json_en_object = 8 ; static final int json_en_array = 46 ; static final int json_en_main = 1 ; private final Array < JsonValue > elements = new Array ( 8 ) ; private final Array < JsonValue > lastChild = new Array ( 8 ) ; private JsonValue root ; private JsonValue current ; private void addChild ( String name , JsonValue child ) { } protected void startObject ( String name ) { } protected void startArray ( String name ) { } protected void pop ( ) { } protected void string ( String name , String value ) { } protected void number ( String name , double value ) { } protected void number ( String name , long value ) { } protected void bool ( String name , boolean value ) { } private String unescape ( String value ) { } }
public class SignificantLongTerms extends InternalSignificantTerms { public static final Type TYPE = new Type ( "significant_terms" , "siglterms" ) ; public static Stream STREAM = new AggregationStreams . Stream ( ) { @ Override public SignificantLongTerms readResult ( StreamInput in ) throws IOException { } } ; public static void registerStreams ( ) { } static class Bucket extends InternalSignificantTerms . Bucket { long term ; public Bucket ( long subsetDf , long subsetSize , long supersetDf , long supersetSize , long term , InternalAggregations aggregations ) { } @ Override public Text getKeyAsText ( ) { } @ Override public Number getKeyAsNumber ( ) { } @ Override int compareTerm ( SignificantTerms . Bucket other ) { <START_BUG> return Longs . compare ( term , other . getKeyAsNumber ( ) . longValue ( ) ) ; <END_BUG> } @ Override public String getKey ( ) { } } private ValueFormatter valueFormatter ; SignificantLongTerms ( ) { } public SignificantLongTerms ( long subsetSize , long supersetSize , String name , ValueFormatter valueFormatter , int requiredSize , long minDocCount , Collection < InternalSignificantTerms . Bucket > buckets ) { } @ Override public Type type ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class NettyTransport extends AbstractLifecycleComponent < Transport > implements Transport { private final NetworkService networkService ; final int workerCount ; final boolean blockingServer ; final boolean blockingClient ; final String port ; final String bindHost ; final String publishHost ; final boolean compress ; final TimeValue connectTimeout ; final Boolean tcpNoDelay ; final Boolean tcpKeepAlive ; final Boolean reuseAddress ; final ByteSizeValue tcpSendBufferSize ; final ByteSizeValue tcpReceiveBufferSize ; private final ThreadPool threadPool ; private volatile OpenChannelsHandler serverOpenChannels ; private volatile ClientBootstrap clientBootstrap ; private volatile ServerBootstrap serverBootstrap ; final ConcurrentMap < DiscoveryNode , Channel > connectedNodes = newConcurrentMap ( ) ; private volatile Channel serverChannel ; private volatile TransportServiceAdapter transportServiceAdapter ; private volatile BoundTransportAddress boundAddress ; public NettyTransport ( ThreadPool threadPool ) { } public NettyTransport ( Settings settings , ThreadPool threadPool ) { } @ Inject public NettyTransport ( Settings settings , ThreadPool threadPool , NetworkService networkService ) { } public Settings settings ( ) { } @ Override public void transportServiceAdapter ( TransportServiceAdapter service ) { } TransportServiceAdapter transportServiceAdapter ( ) { } ThreadPool threadPool ( ) { } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } @ Override public TransportAddress [ ] addressesFromString ( String address ) throws Exception { } @ Override public boolean addressSupported ( Class < ? extends TransportAddress > address ) { } @ Override public BoundTransportAddress boundAddress ( ) { } void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception { } TransportAddress wrapAddress ( SocketAddress socketAddress ) { } @ Override public < T extends Streamable > void sendRequest ( final DiscoveryNode node , final long requestId , final String action , final Streamable message , TransportRequestOptions options ) throws IOException , TransportException { Channel targetChannel = nodeChannel ( node ) ; if ( compress ) { <START_BUG> options . withCompress ( ) ; <END_BUG> } byte [ ] data = TransportStreams . buildRequest ( requestId , action , message , options ) ; ChannelBuffer buffer = ChannelBuffers . wrappedBuffer ( data ) ; ChannelFuture channelFuture = targetChannel . write ( buffer ) ; } @ Override public boolean nodeConnected ( DiscoveryNode node ) { } @ Override public void connectToNode ( DiscoveryNode node ) { } @ Override public void disconnectFromNode ( DiscoveryNode node ) { } private Channel nodeChannel ( DiscoveryNode node ) throws ConnectTransportException { } private void closeChannel ( Channel channel ) { } private class ChannelCloseListener implements ChannelFutureListener { private final DiscoveryNode node ; private ChannelCloseListener ( DiscoveryNode node ) { } @ Override public void operationComplete ( ChannelFuture future ) throws Exception { } } }
public class AudioTools { public static native void convertToFloat ( ShortBuffer source , FloatBuffer target , int numSamples ) { } public static native void convertToShort ( FloatBuffer source , ShortBuffer target , int numSamples ) { } public static native void convertToMonoShort ( ShortBuffer source , ShortBuffer target , int numSamples ) { } public static native void convertToMonoFloat ( FloatBuffer source , FloatBuffer target , int numSamples ) { } public static native float spectralFlux ( FloatBuffer spectrumA , FloatBuffer spectrumB , int numSamples ) { } public static FloatBuffer allocateFloatBuffer ( int numSamples , int numChannels ) { } public static ShortBuffer allocateShortBuffer ( int numSamples , int numChannels ) { } public static void toShort ( byte [ ] src , int offsetSrc , short [ ] dst , int offsetDst , int numBytes ) { } public static void toFloat ( byte [ ] src , int offsetSrc , float [ ] dst , int offsetDst , int numBytes ) { } public static void toFloat ( short [ ] src , int offsetSrc , float [ ] dst , int offsetDst , int numBytes ) { float scale = 1.0F / ( Short . MAX_VALUE ) ; for ( int i = offsetSrc , ii = offsetDst ; i < numBytes ; i ++ , ii ++ ) <START_BUG> dst [ i ] = ( src [ ii ] ) * scale ; <END_BUG> } public static short [ ] generate ( int samplingRate , int frequency , int numSamples ) { } public static short [ ] generate ( int samplingRate , int frequency , float length ) { } public static float [ ] generateFloat ( int samplingRate , int frequency , int numSamples ) { } public static float [ ] generateFloat ( int samplingRate , int frequency , float length ) { } }
public class TextField extends Widget { private static final char BACKSPACE = 8 ; private static final char ENTER_DESKTOP = '\r' ; private static final char ENTER_ANDROID = '\n' ; private static final char TAB = '\t' ; private static final char DELETE = 127 ; private static final char BULLET = 149 ; TextField . TextFieldStyle style ; String text ; String messageText ; private CharSequence displayText ; int cursor ; private Clipboard clipboard ; TextField . TextFieldListener listener ; TextField . TextFieldFilter filter ; TextField . OnscreenKeyboard keyboard = new TextField . DefaultOnscreenKeyboard ( ) ; private boolean passwordMode ; private StringBuilder passwordBuffer ; private final Rectangle fieldBounds = new Rectangle ( ) ; private final TextBounds textBounds = new TextBounds ( ) ; private final Rectangle scissor = new Rectangle ( ) ; float renderOffset ; float textOffset ; private int visibleTextStart ; private int visibleTextEnd ; private final FloatArray glyphAdvances = new FloatArray ( ) ; final FloatArray glyphPositions = new FloatArray ( ) ; boolean cursorOn = true ; private float blinkTime = 0.42F ; long lastBlink ; boolean hasSelection ; int selectionStart ; private float selectionX ; private float selectionWidth ; private char passwordCharacter = TextField . BULLET ; public TextField ( String text , Skin skin ) { } public TextField ( String text , Skin skin , String styleName ) { } public TextField ( String text , TextField . TextFieldStyle style ) { } private void initialize ( ) { addListener ( new InputListener ( ) { public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { <START_BUG> if ( pointer != 0 ) <END_BUG> return false ; Stage stage = getStage ( ) ; if ( stage != null ) stage . setKeyboardFocus ( TextField . this ) ; keyboard . show ( true ) ; clearSelection ( ) ; setCursorPosition ( x ) ; selectionStart = cursor ; return true ; } public void touchDragged ( InputEvent event , float x , float y , int pointer ) { lastBlink = 0 ; cursorOn = false ; setCursorPosition ( x ) ; hasSelection = true ; } private void setCursorPosition ( float x ) { lastBlink = 0 ; cursorOn = false ; x -= renderOffset ; for ( int i = 0 ; i < ( glyphPositions . size ) ; i ++ ) { if ( ( glyphPositions . items [ i ] ) > x ) { cursor = Math . max ( 0 , ( i - 1 ) ) ; return ; } } cursor = Math . max ( 0 , ( ( glyphPositions . size ) - 1 ) ) ; } public boolean keyDown ( InputEvent event , int keycode ) { final BitmapFont font = style . font ; Stage stage = getStage ( ) ; if ( ( stage != null ) && ( ( stage . getKeyboardFocus ( ) ) == ( TextField . this ) ) ) { if ( ( input . isKeyPressed ( CONTROL_LEFT ) ) || ( input . isKeyPressed ( CONTROL_RIGHT ) ) ) { if ( keycode == ( Keys . V ) ) paste ( ) ; if ( ( keycode == ( Keys . C ) ) || ( keycode == ( Keys . INSERT ) ) ) copy ( ) ; } else if ( ( input . isKeyPressed ( SHIFT_LEFT ) ) || ( input . isKeyPressed ( SHIFT_RIGHT ) ) ) { if ( keycode == ( Keys . INSERT ) ) paste ( ) ; if ( keycode == ( Keys . FORWARD_DEL ) ) { if ( hasSelection ) { copy ( ) ; delete ( ) ; } } if ( keycode == ( Keys . LEFT ) ) { if ( ! ( hasSelection ) ) { selectionStart = cursor ; hasSelection = true ; } ( cursor ) -- ; } if ( keycode == ( Keys . RIGHT ) ) { if ( ! ( hasSelection ) ) { selectionStart = cursor ; hasSelection = true ; } ( cursor ) ++ ; } if ( keycode == ( Keys . HOME ) ) { if ( ! ( hasSelection ) ) { selectionStart = cursor ; hasSelection = true ; } cursor = 0 ; } if ( keycode == ( Keys . END ) ) { if ( ! ( hasSelection ) ) { selectionStart = cursor ; hasSelection = true ; } cursor = text . length ( ) ; } cursor = Math . max ( 0 , cursor ) ; cursor = Math . min ( text . length ( ) , cursor ) ; } else { if ( keycode == ( Keys . LEFT ) ) { ( cursor ) -- ; clearSelection ( ) ; } if ( keycode == ( Keys . RIGHT ) ) { ( cursor ) ++ ; clearSelection ( ) ; } if ( keycode == ( Keys . HOME ) ) { cursor = 0 ; clearSelection ( ) ; } if ( keycode == ( Keys . END ) ) { cursor = text . length ( ) ; clearSelection ( ) ; } cursor = Math . max ( 0 , cursor ) ; cursor = Math . min ( text . length ( ) , cursor ) ; } return true ; } return false ; } public boolean keyUp ( InputEvent event , int keycode ) { return true ; } public boolean keyTyped ( InputEvent event , char character ) { final BitmapFont font = style . font ; Stage stage = getStage ( ) ;
public class TribeTests extends ElasticsearchIntegrationTest { private static InternalTestCluster cluster2 ; private Node tribeNode ; private Client tribeClient ; @ BeforeClass public static void setupSecondCluster ( ) throws Exception { ElasticsearchIntegrationTest . beforeClass ( ) ; <START_BUG> TribeTests . cluster2 = new InternalTestCluster ( randomLong ( ) , 2 , 2 , Strings . randomBase64UUID ( getRandom ( ) ) , 0 , false ) ; <END_BUG> TribeTests . cluster2 . beforeTest ( getRandom ( ) , 0.1 ) ; TribeTests . cluster2 . ensureAtLeastNumDataNodes ( 2 ) ; } @ AfterClass public static void tearDownSecondCluster ( ) { } @ After public void tearDownTribeNode ( ) throws IOException { } private void setupTribeNode ( Settings settings ) { } @ Test public void testGlobalReadWriteBlocks ( ) throws Exception { } @ Test public void testIndexWriteBlocks ( ) throws Exception { } @ Test public void testOnConflictDrop ( ) throws Exception { } @ Test public void testOnConflictPrefer ( ) throws Exception { } private void testOnConflictPrefer ( String tribe ) throws Exception { } @ Test public void testTribeOnOneCluster ( ) throws Exception { } private void awaitIndicesInClusterState ( final String ... indices ) throws Exception { } private void awaitSameNodeCounts ( ) throws Exception { } private int countDataNodesForTribe ( String tribeName , DiscoveryNodes nodes ) { } }
public class RestPercolateAction extends BaseRestHandler { @ Inject public RestPercolateAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { PercolateRequest percolateRequest = new PercolateRequest ( request . param ( "index" ) , request . param ( "type" ) ) ; percolateRequest . listenerThreaded ( false ) ; percolateRequest . source ( request . content ( ) , request . contentUnsafe ( ) ) ; percolateRequest . listenerThreaded ( false ) ; percolateRequest . operationThreaded ( true ) ; percolateRequest . preferLocal ( request . paramAsBoolean ( "prefer_local" , percolateRequest . preferLocalShard ( ) ) ) ; client . percolate ( percolateRequest , new org . elasticsearch . action . ActionListener < PercolateResponse > ( ) { @ Override public void onResponse ( PercolateResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; builder . field ( RestPercolateAction . Fields . OK , true ) ; builder . startArray ( RestPercolateAction . Fields . MATCHES ) ; for ( String match : response ) { builder . value ( match ) ; } builder . endArray ( ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } static final class Fields { static final XContentBuilderString OK = new XContentBuilderString ( "ok" ) ; static final XContentBuilderString MATCHES = new XContentBuilderString ( "matches" ) ; } }
public class ContextIndexSearcher extends ExtendedIndexSearcher { private SearchContext searchContext ; private CachedDfSource dfSource ; private List < Collector > collectors ; private List < Collector > globalCollectors ; private boolean useGlobalCollectors = false ; public ContextIndexSearcher ( SearchContext searchContext , Engine . Searcher searcher ) { } public void dfSource ( CachedDfSource dfSource ) { } public void addCollector ( Collector collector ) { } public List < Collector > collectors ( ) { } public void addGlobalCollector ( Collector collector ) { } public List < Collector > globalCollectors ( ) { } public void useGlobalCollectors ( boolean useGlobalCollectors ) { } @ Override public Query rewrite ( Query original ) throws IOException { <START_BUG> if ( ( original == ( searchContext . query ( ) ) ) || ( original == ( searchContext . originalQuery ( ) ) ) ) { <END_BUG> if ( searchContext . queryRewritten ( ) ) { return searchContext . query ( ) ; } Query rewriteQuery = super . rewrite ( original ) ; searchContext . updateRewriteQuery ( rewriteQuery ) ; return rewriteQuery ; } else { return super . rewrite ( original ) ; } } @ Override protected Weight createWeight ( Query query ) throws IOException { } @ Override public void search ( Weight weight , Filter filter , Collector collector ) throws IOException { } }
public class FunctionScoreQuery extends Query { Query subQuery ; final ScoreFunction function ; public FunctionScoreQuery ( Query subQuery , ScoreFunction function ) { } public Query getSubQuery ( ) { } public ScoreFunction getFunction ( ) { } @ Override public Query rewrite ( IndexReader reader ) throws IOException { } @ Override public void extractTerms ( Set < Term > terms ) { } @ Override public Weight createWeight ( IndexSearcher searcher ) throws IOException { } class CustomBoostFactorWeight extends Weight { final Weight subQueryWeight ; public CustomBoostFactorWeight ( Weight subQueryWeight ) throws IOException { } public Query getQuery ( ) { } @ Override public float getValueForNormalization ( ) throws IOException { } @ Override public void normalize ( float norm , float topLevelBoost ) { } @ Override public Scorer scorer ( AtomicReaderContext context , boolean scoreDocsInOrder , boolean topScorer , Bits acceptDocs ) throws IOException { <START_BUG> Scorer subQueryScorer = subQueryWeight . scorer ( context , scoreDocsInOrder , topScorer , acceptDocs ) ; <END_BUG> if ( subQueryScorer == null ) { return null ; } function . setNextReader ( context ) ; return new FunctionScoreQuery . CustomBoostFactorScorer ( this , subQueryScorer , function ) ; } @ Override public Explanation explain ( AtomicReaderContext context , int doc ) throws IOException { } } static class CustomBoostFactorScorer extends Scorer { private final float subQueryBoost ; private final Scorer scorer ; private final ScoreFunction function ; private CustomBoostFactorScorer ( FunctionScoreQuery . CustomBoostFactorWeight w , Scorer scorer , ScoreFunction function ) throws IOException { } @ Override public int docID ( ) { } @ Override public int advance ( int target ) throws IOException { } @ Override public int nextDoc ( ) throws IOException { } @ Override public float score ( ) throws IOException { } @ Override public float freq ( ) throws IOException { } } public String toString ( String field ) { } public boolean equals ( Object o ) { } public int hashCode ( ) { } }
public class ClusterRerouteRequestBuilder extends MasterNodeOperationRequestBuilder < ClusterRerouteRequest , ClusterRerouteResponse , ClusterRerouteRequestBuilder > { public ClusterRerouteRequestBuilder ( ClusterAdminClient clusterClient ) { } public ClusterRerouteRequestBuilder add ( AllocationCommand ... commands ) { } public ClusterRerouteRequestBuilder setDryRun ( boolean dryRun ) { } public ClusterRerouteRequestBuilder setSource ( BytesReference source ) throws Exception { <START_BUG> request . source ( source ) ; <END_BUG> return this ; } @ Override protected void doExecute ( ActionListener < ClusterRerouteResponse > listener ) { } }
public class AndroidSingleTouchHandler implements AndroidTouchHandler { public void onTouch ( MotionEvent event , AndroidInput input ) { } private void postTouchEvent ( AndroidInput input , int type , int x , int y , int pointer ) { long timeStamp = System . nanoTime ( ) ; synchronized ( input ) { <START_BUG> TouchEvent event = input . usedTouchEvents . add ( ) ; <END_BUG> event . timeStamp = timeStamp ; event . pointer = 0 ; event . x = x ; event . y = y ; event . type = type ; input . touchEvents . add ( event ) ; } } }
public abstract class Box2DTest implements InputListener , RenderListener { protected OrthographicCamera camera ; protected Box2DDebugRenderer renderer ; protected World world ; protected Body groundBody ; protected MouseJoint mouseJoint = null ; protected Body hitBody = null ; protected abstract void createWorld ( World world ) { } protected Vector2 tmp = new Vector2 ( ) ; @ Override public void render ( Application app ) { <START_BUG> world . step ( ( 1 / 60.0F ) , 8 , 3 ) ; <END_BUG> GL10 gl = app . getGraphics ( ) . getGL10 ( ) ; gl . glClear ( GL_COLOR_BUFFER_BIT ) ; camera . setMatrices ( ) ; renderer . render ( world ) ; } @ Override public void surfaceChanged ( Application app , int width , int height ) { } @ Override public void surfaceCreated ( Application app ) { } @ Override public void dispose ( Application app ) { } @ Override public boolean keyDown ( int keycode ) { } @ Override public boolean keyTyped ( char character ) { } @ Override public boolean keyUp ( int keycode ) { } Vector2 testPoint = new Vector2 ( ) ; QueryCallback callback = new QueryCallback ( ) { @ Override public boolean reportFixture ( Fixture fixture ) { } } ; @ Override public boolean touchDown ( int x , int y , int pointer ) { } Vector2 target = new Vector2 ( ) ; @ Override public boolean touchDragged ( int x , int y , int pointer ) { } @ Override public boolean touchUp ( int x , int y , int pointer ) { } }
public class LifeCycleTest extends GdxTest { @ Override public void dispose ( ) { } @ Override public void pause ( ) { } @ Override public void resume ( ) { } @ Override public void render ( ) { } @ Override public void create ( ) { } @ Override public void resize ( int width , int height ) { <START_BUG> app . log ( "Test" , ( ( "Thread=" + ( Thread . currentThread ( ) . getId ( ) ) ) + ",<seq2seq4repair_space>app<seq2seq4repair_space>resized" ) ) ; <END_BUG> } @ Override public boolean needsGL20 ( ) { } }
public class FileDescriptor { public enum FileType { Classpath , Absolute ; } protected File file ; protected FileDescriptor . FileType type ; protected FileDescriptor ( ) { } public FileDescriptor ( String fileName ) { } public FileDescriptor ( File file ) { } protected FileDescriptor ( String fileName , FileDescriptor . FileType type ) { } protected FileDescriptor ( File file , FileDescriptor . FileType type ) { } public String path ( ) { <START_BUG> return file . getPath ( ) ; <END_BUG> } public String name ( ) { } public String extension ( ) { } public String nameWithoutExtension ( ) { } public FileDescriptor . FileType type ( ) { } public File file ( ) { } public InputStream read ( ) { } public Reader reader ( ) { } public Reader reader ( String charset ) { } public BufferedReader reader ( int bufferSize ) { } public BufferedReader reader ( int bufferSize , String charset ) { } public String readString ( ) { } public String readString ( String charset ) { } public byte [ ] readBytes ( ) { } public int readBytes ( byte [ ] bytes , int offset , int size ) { } public OutputStream write ( boolean append ) { } public void write ( InputStream input , boolean append ) { } public Writer writer ( boolean append ) { } public Writer writer ( boolean append , String charset ) { } public void writeString ( String string , boolean append ) { } public void writeString ( String string , boolean append , String charset ) { } public void writeBytes ( byte [ ] bytes , boolean append ) { } public FileDescriptor [ ] list ( ) { } public FileDescriptor [ ] list ( String suffix ) { } public boolean isDirectory ( ) { } public FileDescriptor child ( String name ) { } public FileDescriptor parent ( ) { } public boolean mkdirs ( ) { } public boolean exists ( ) { } public boolean delete ( ) { } public boolean deleteDirectory ( ) { } public void copyTo ( FileDescriptor dest ) { } public void moveTo ( FileDescriptor dest ) { } public long length ( ) { } public long lastModified ( ) { } public String toString ( ) { } public static FileDescriptor tempFile ( String prefix ) { } public static FileDescriptor tempDirectory ( String prefix ) { } private static boolean deleteDirectory ( File file ) { } private static void copyFile ( FileDescriptor source , FileDescriptor dest ) { } private static void copyDirectory ( FileDescriptor sourceDir , FileDescriptor destDir ) { } }
public class ViewportTest3 extends GdxTest { Array < Viewport > viewports = new Array ( ) ; Viewport viewport ; private PerspectiveCamera camera ; public Environment environment ; public DirectionalLight shadowLight ; public ModelBuilder modelBuilder ; public ModelBatch modelBatch ; public ModelInstance boxInstance ; public void create ( ) { } public void render ( ) { } public void resize ( int width , int height ) { <START_BUG> System . out . println ( viewport ) ; <END_BUG> viewport . update ( width , height ) ; } }
public class ContactProcessedListenerByObject { private long swigCPtr ; protected boolean swigCMemOwn ; protected ContactProcessedListenerByObject ( long cPtr , boolean cMemoryOwn ) { } public static long getCPtr ( ContactProcessedListenerByObject obj ) { } protected void finalize ( ) { } public synchronized void delete ( ) { } protected void swigDirectorDisconnect ( ) { } public void swigReleaseOwnership ( ) { } public void swigTakeOwnership ( ) { } public void onContactProcessed ( btManifoldPoint cp , btCollisionObject colObj0 , boolean match0 , btCollisionObject colObj1 , boolean match1 ) { <START_BUG> gdxBulletJNI . ContactProcessedListenerByObject_onContactProcessed ( swigCPtr , this , btManifoldPoint . getCPtr ( cp ) , cp , btCollisionObject . getCPtr ( colObj0 ) , colObj0 , match0 , btCollisionObject . getCPtr ( colObj1 ) , colObj1 , match1 ) ; <END_BUG> } public ContactProcessedListenerByObject ( ) { } }
public class LinearDecayFunctionParser extends DecayFunctionParser { public static final String [ ] NAMES = new String [ ] { "linear" } ; @ Override public String [ ] getNames ( ) { } static final DecayFunction decayFunction = new LinearDecayFunctionParser . LinearDecayScoreFunction ( ) ; @ Override public DecayFunction getDecayFunction ( ) { } static final class LinearDecayScoreFunction implements DecayFunction { @ Override public double evaluate ( double value , double scale ) { <START_BUG> return Math . max ( 0.0 , ( ( scale - ( Math . abs ( value ) ) ) / scale ) ) ; <END_BUG> } @ Override public Explanation explainFunction ( String valueExpl , double value , double scale ) { } @ Override public double processScale ( double scale , double value ) { } } }
public class SearchSourceBuilder implements ToXContent { public static SearchSourceBuilder searchSource ( ) { } public static HighlightBuilder highlight ( ) { } private QueryBuilder queryBuilder ; private BytesReference queryBinary ; private FilterBuilder filterBuilder ; private BytesReference filterBinary ; private int from = - 1 ; private int size = - 1 ; private Boolean explain ; private Boolean version ; private List < SortBuilder > sorts ; private boolean trackScores = false ; private Float minScore ; private long timeoutInMillis = - 1 ; private List < String > fieldNames ; private List < SearchSourceBuilder . ScriptField > scriptFields ; private List < SearchSourceBuilder . PartialField > partialFields ; private List < FacetBuilder > facets ; private BytesReference facetsBinary ; private HighlightBuilder highlightBuilder ; private SuggestBuilder suggestBuilder ; private RescoreBuilder rescoreBuilder ; private TObjectFloatHashMap < String > indexBoost = null ; private String [ ] stats ; public SearchSourceBuilder ( ) { } public SearchSourceBuilder query ( QueryBuilder query ) { } public SearchSourceBuilder query ( byte [ ] queryBinary ) { } public SearchSourceBuilder query ( byte [ ] queryBinary , int queryBinaryOffset , int queryBinaryLength ) { } public SearchSourceBuilder query ( BytesReference queryBinary ) { } public SearchSourceBuilder query ( String queryString ) { } public SearchSourceBuilder query ( XContentBuilder query ) { } public SearchSourceBuilder query ( Map query ) { } public SearchSourceBuilder filter ( FilterBuilder filter ) { } public SearchSourceBuilder filter ( String filterString ) { } public SearchSourceBuilder filter ( byte [ ] filter ) { } public SearchSourceBuilder filter ( byte [ ] filterBinary , int filterBinaryOffset , int filterBinaryLength ) { } public SearchSourceBuilder filter ( BytesReference filterBinary ) { } public SearchSourceBuilder filter ( XContentBuilder filter ) { } public SearchSourceBuilder filter ( Map filter ) { } public SearchSourceBuilder from ( int from ) { } public SearchSourceBuilder size ( int size ) { } public SearchSourceBuilder minScore ( float minScore ) { } public SearchSourceBuilder explain ( Boolean explain ) { } public SearchSourceBuilder version ( Boolean version ) { } public SearchSourceBuilder timeout ( TimeValue timeout ) { } public SearchSourceBuilder timeout ( String timeout ) { } public SearchSourceBuilder sort ( String name , SortOrder order ) { } public SearchSourceBuilder sort ( String name ) { } public SearchSourceBuilder sort ( SortBuilder sort ) { } public SearchSourceBuilder trackScores ( boolean trackScores ) { } public SearchSourceBuilder facet ( FacetBuilder facet ) { } public SearchSourceBuilder facets ( byte [ ] facetsBinary ) { } public SearchSourceBuilder facets ( byte [ ] facetsBinary , int facetBinaryOffset , int facetBinaryLength ) { } public SearchSourceBuilder facets ( BytesReference facetsBinary ) { } public SearchSourceBuilder facets ( XContentBuilder facets ) { } public SearchSourceBuilder facets ( Map facets ) { } public HighlightBuilder highlighter ( ) { } public SearchSourceBuilder highlight ( HighlightBuilder highlightBuilder ) { } public SuggestBuilder suggest ( ) { if ( ( suggestBuilder ) == null ) { <START_BUG> suggestBuilder = new SuggestBuilder ( ) ; <END_BUG> } return suggestBuilder ; } public RescoreBuilder rescore ( ) { } public SearchSourceBuilder noFields ( ) { } public SearchSourceBuilder fields ( List < String > fields ) { } public SearchSourceBuilder fields ( String ... fields ) { } public SearchSourceBuilder field ( String name ) { } public SearchSourceBuilder scriptField ( String name , String script ) { } public SearchSourceBuilder scriptField ( String name , String script , Map < String , Object > params ) { } public SearchSourceBuilder scriptField ( String name , String lang , String script , Map < String , Object > params ) { } public SearchSourceBuilder partialField ( String name , @ Nullable String include , @ Nullable String exclude ) { } public SearchSourceBuilder partialField ( String name , @ Nullable String [ ] includes , @ Nullable String [ ] excludes ) { } public SearchSourceBuilder indexBoost ( String index , float indexBoost ) { } public SearchSourceBuilder stats ( String ... statsGroups ) { } @ Override public String toString ( ) { } public BytesReference buildAsBytes ( ) throws SearchSourceBuilderException { } public BytesReference buildAsBytes ( XContentType contentType ) throws SearchSourceBuilderException { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } private static class ScriptField { private final String fieldName ; private final String script ; private final String lang ; private final Map < String , Object > params ; private ScriptField ( String fieldName , String lang , String script , Map < String , Object > params ) { } public String fieldName ( ) { } public String script ( ) { } public String lang ( ) { } public Map < String , Object > params ( ) { } } private static class PartialField { private final String name ; private final String [ ] includes ; private final String [ ] excludes ; private PartialField ( String name , String [ ] includes , String [ ] excludes ) { } private PartialField ( String name , String include , String exclude ) { } public String name ( ) { } public String [ ] includes ( ) { } public String [ ] excludes ( ) { } } }
} if ( "objectgroup" . equals ( element ) ) { map . objectGroups . add ( currObjectGroup ) ; currObjectGroup = null ; return ; } if ( "property" . equals ( element ) ) { putProperty ( currProperty ) ; currProperty = null ; return ; } if ( "polyline" . equals ( element ) ) { putPolyLine ( polyline ) ; polyline = null ; return ; } if ( "polygon" . equals ( element ) ) { putPolyLine ( polygon ) ; polygon = null ; return ; } if ( "data" . equals ( element ) ) { if ( "base64" . equals ( encoding ) ) { if ( ( ( dataString ) == null ) | ( "" . equals ( dataString . trim ( ) ) ) ) return ; data = Base64Coder . decode ( dataString . trim ( ) ) ; if ( "gzip" . equals ( compression ) ) { unGZip ( ) ; } else if ( "zlib" . equals ( compression ) ) { unZlib ( ) ; } else if ( ( compression ) == null ) { arrangeData ( ) ; } } else if ( ( "csv" . equals ( encoding ) ) && ( ( compression ) == null ) ) { fromCSV ( ) ; } else if ( ( ( encoding ) == null ) && ( ( compression ) == null ) ) { dataCounter = 0 ; } else { throw new GdxRuntimeException ( "Unsupported<seq2seq4repair_space>encoding<seq2seq4repair_space>and/or<seq2seq4repair_space>compression<seq2seq4repair_space>format" ) ; } awaitingData = false ; return ; } if ( "property" . equals ( element ) ) { putProperty ( currProperty ) ; currProperty = null ; } } private void putPolyLine ( Polyline polyLine ) { if ( polyLine == null ) { return ; } if ( "polyline" . equals ( polyLine . name ) ) { currObject . polyline = polyLine . points ; return ; } if ( "polygon" . equals ( polyLine . name ) ) { currObject . polygon = polyLine . points ; return ; } return ; } private void putProperty ( Property property ) { if ( "tile" . equals ( property . parentType ) ) { map . setTileProperty ( ( ( currTile ) + ( currTileSet . firstgid ) ) , property . name , property . value ) ; return ; } if ( "map" . equals ( property . parentType ) ) { map . properties . put ( property . name , property . value ) ; return ; } if ( "layer" . equals ( property . parentType ) ) { currLayer . properties . put ( property . name , property . value ) ; return ; } if ( "objectgroup" . equals ( property . parentType ) ) { currObjectGroup . properties . put ( property . name , property . value ) ; return ; } if ( "object" . equals ( property . parentType ) ) { currObject . properties . put ( property . name , property . value ) ; return ; } } private void fromCSV ( ) { StringTokenizer st = new StringTokenizer ( dataString . trim ( ) , "," ) ; for ( int row = 0 ; row < ( currLayerHeight ) ; row ++ ) { for ( int col = 0 ; col < ( currLayerWidth ) ; col ++ ) { <START_BUG> currLayer . tiles [ row ] [ col ] = Integer . parseInt ( st . nextToken ( ) . trim ( ) ) ; <END_BUG> } } } private void arrangeData ( ) { int byteCounter = 0 ; for ( int row = 0 ; row < ( currLayerHeight ) ; row ++ ) { for ( int col = 0 ; col < ( currLayerWidth ) ; col ++ ) { currLayer . tiles [ row ] [ col ] = ( ( ( TiledLoader . unsignedByteToInt ( data [ ( byteCounter ++ ) ] ) ) | ( ( TiledLoader . unsignedByteToInt ( data [ ( byteCounter ++ ) ] ) ) << 8 ) ) | ( ( TiledLoader . unsignedByteToInt ( data [ ( byteCounter ++ ) ] ) ) << 16 ) ) | ( ( TiledLoader . unsignedByteToInt ( data [ ( byteCounter ++ ) ] ) ) << 24 ) ; } } } private void unZlib ( ) { Inflater zlib = new Inflater ( ) ; byte [ ] readTemp = new byte [ 4 ] ; zlib . setInput ( data , 0 , data . length ) ; for ( int row = 0 ; row < ( currLayerHeight ) ; row ++ ) { for ( int col = 0 ; col < ( currLayerWidth ) ; col ++ ) { try { zlib . inflate ( readTemp , 0 , 4 ) ; currLayer . tiles [ row ] [ col ] = ( ( ( TiledLoader . unsignedByteToInt ( readTemp [ 0 ] ) ) | ( ( TiledLoader . unsignedByteToInt ( readTemp [ 1 ] ) ) << 8 ) ) | ( ( TiledLoader . unsignedByteToInt ( readTemp [ 2 ] ) ) << 16 ) ) | ( ( TiledLoader . unsignedByteToInt ( readTemp [ 3 ] ) ) << 24 ) ; } catch ( DataFormatException e ) { throw new GdxRuntimeException ( "Error<seq2seq4repair_space>Reading<seq2seq4repair_space>TMX<seq2seq4repair_space>Layer<seq2seq4repair_space>Data." , e ) ; } } } } private void unGZip ( ) { GZIPInputStream GZIS = null ; try { GZIS = new GZIPInputStream ( new ByteArrayInputStream ( data ) , data . length ) ; } catch ( IOException e ) { throw new GdxRuntimeException ( ( "Error<seq2seq4repair_space>Reading<seq2seq4repair_space>TMX<seq2seq4repair_space>Layer<seq2seq4repair_space>Data<seq2seq4repair_space>-<seq2seq4repair_space>IOException:<seq2seq4repair_space>" + ( e . getMessage ( ) ) ) ) ; } byte [ ] readTemp = new byte [ 4 ] ; for ( int row = 0 ; row < ( currLayerHeight ) ;
public class GwtFileHandle extends FileHandle { public final Preloader preloader ; private final String file ; private final FileType type ; protected GwtFileHandle ( Preloader preloader , String fileName , FileType type ) { } public GwtFileHandle ( String path ) { } public String path ( ) { } public String name ( ) { } public String extension ( ) { } public String nameWithoutExtension ( ) { } public String pathWithoutExtension ( ) { } public FileType type ( ) { } public File file ( ) { } public InputStream read ( ) { } public BufferedInputStream read ( int bufferSize ) { } public Reader reader ( ) { } public Reader reader ( String charset ) { } public BufferedReader reader ( int bufferSize ) { } public BufferedReader reader ( int bufferSize , String charset ) { } public String readString ( ) { } public String readString ( String charset ) { } public byte [ ] readBytes ( ) { } public int readBytes ( byte [ ] bytes , int offset , int size ) { } public OutputStream write ( boolean append ) { } public void write ( InputStream input , boolean append ) { } public Writer writer ( boolean append ) { } public Writer writer ( boolean append , String charset ) { } public void writeString ( String string , boolean append ) { } public void writeString ( String string , boolean append , String charset ) { } public void writeBytes ( byte [ ] bytes , boolean append ) { } public void writeBytes ( byte [ ] bytes , int offset , int length , boolean append ) { } public FileHandle [ ] list ( ) { } public FileHandle [ ] list ( String suffix ) { } public boolean isDirectory ( ) { } public FileHandle child ( String name ) { <START_BUG> return new GwtFileHandle ( preloader , ( file . isEmpty ( ) ? "" : ( ( file ) + ( file . endsWith ( "/" ) ? "" : "/" ) ) + name ) , FileType . Internal ) ; <END_BUG> } public FileHandle parent ( ) { } public FileHandle sibling ( String name ) { } public void mkdirs ( ) { } public boolean exists ( ) { } public boolean delete ( ) { } public boolean deleteDirectory ( ) { } public void copyTo ( FileHandle dest ) { } public void moveTo ( FileHandle dest ) { } public long length ( ) { } public long lastModified ( ) { } public String toString ( ) { } }
public class IntFloatMap { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; private static final int EMPTY = 0 ; public int size ; int [ ] keyTable ; float [ ] valueTable ; int capacity ; int stashSize ; float zeroValue ; boolean hasZeroValue ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private IntFloatMap . Entries entries1 ; private IntFloatMap . Entries entries2 ; private IntFloatMap . Values values1 ; private IntFloatMap . Values values2 ; private IntFloatMap . Keys keys1 ; private IntFloatMap . Keys keys2 ; public IntFloatMap ( ) { } public IntFloatMap ( int initialCapacity ) { } public IntFloatMap ( int initialCapacity , float loadFactor ) { } public void put ( int key , float value ) { } public void putAll ( IntFloatMap map ) { } private void putResize ( int key , float value ) { } private void push ( int insertKey , float insertValue , int index1 , int key1 , int index2 , int key2 , int index3 , int key3 ) { } private void putStash ( int key , float value ) { } public float get ( int key , float defaultValue ) { } private float getStash ( int key , float defaultValue ) { } public float getAndIncrement ( int key , float defaultValue , float increment ) { } private float getAndIncrementStash ( int key , float defaultValue , float increment ) { } public float remove ( int key , float defaultValue ) { } float removeStash ( int key , float defaultValue ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean containsValue ( float value ) { } public boolean containsValue ( float value , float epsilon ) { <START_BUG> if ( ( hasZeroValue ) && ( ( zeroValue ) == value ) ) <END_BUG> return true ; float [ ] valueTable = this . valueTable ; for ( int i = ( capacity ) + ( stashSize ) ; ( i -- ) > 0 ; ) if ( ( Math . abs ( ( ( valueTable [ i ] ) - value ) ) ) <= epsilon ) return true ; return false ; } public boolean containsKey ( int key ) { } private boolean containsKeyStash ( int key ) { } public int findKey ( float value , int notFound ) { } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public IntFloatMap . Entries entries ( ) { } public IntFloatMap . Values values ( ) { } public IntFloatMap . Keys keys ( ) { } public static class Entry < K > { public int key ; public float value ; public String toString ( ) { } } private static class MapIterator < K > { static final int INDEX_ILLEGAL = - 2 ; static final int INDEX_ZERO = - 1 ; public boolean hasNext ; final IntFloatMap map ; int nextIndex ; int currentIndex ; boolean valid = true ; public MapIterator ( IntFloatMap map ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { } } public static class Entries extends IntFloatMap . MapIterator implements Iterable < IntFloatMap . Entry > , Iterator < IntFloatMap . Entry > { private IntFloatMap . Entry entry = new IntFloatMap . Entry ( ) ; public Entries ( IntFloatMap map ) { } public IntFloatMap . Entry next ( ) { } public boolean hasNext ( ) { } public Iterator < IntFloatMap . Entry > iterator ( ) { } } public static class Values extends IntFloatMap . MapIterator < Object > { public Values ( IntFloatMap map ) { } public boolean hasNext ( ) { } public float next ( ) { } public FloatArray toArray ( ) { } } public static class Keys extends IntFloatMap . MapIterator { public Keys ( IntFloatMap map ) { } public boolean hasNext ( ) { } public int next ( ) { } public IntArray toArray ( ) { } } }
public class AccountDataManager { private static final String TAG = "GHDM" ; private static final Executor EXECUTOR = Executors . newFixedThreadPool ( 10 ) ; private static final int FORMAT_VERSION = 1 ; private static String digest ( String value ) { } private final Context context ; private final UserService users ; private final OrganizationService orgs ; private final RepositoryService repos ; private final IssueService issues ; private final File root ; public AccountDataManager ( final Context context , final File root , UserService users , OrganizationService orgs , RepositoryService repos , IssueService issues ) { } private < V > V read ( File file ) { long start = System . currentTimeMillis ( ) ; long length = file . length ( ) ; V data = new RequestReader ( file , AccountDataManager . FORMAT_VERSION ) . read ( ) ; if ( data != null ) Log . d ( AccountDataManager . TAG , MessageFormat . format ( "Cache<seq2seq4repair_space>hit<seq2seq4repair_space>to<seq2seq4repair_space>{0},<seq2seq4repair_space>{1}<seq2seq4repair_space>ms<seq2seq4repair_space>to<seq2seq4repair_space>load<seq2seq4repair_space>{2}<seq2seq4repair_space>bytes" , file . getName ( ) , ( ( System . currentTimeMillis ( ) ) - start ) , length ) ) ; <START_BUG> return data ; <END_BUG> } private AccountDataManager write ( File file , Object data ) { } public void getOrgs ( final RequestFuture < List < User > > requestFuture ) { } public void getRepos ( final User user , final RequestFuture < List < Repository > > requestFuture ) { } public void getIssues ( final IRepositoryIdProvider repository , final Map < String , String > filter , final RequestFuture < List < Issue > > requestFuture ) { } }
public class DashboardIssueFragment extends PagedItemFragment < RepositoryIssue > { public static final String ARG_FILTER = "filter" ; @ Inject private IssueService service ; @ Inject private IssueStore store ; @ Inject private AvatarLoader avatarHelper ; private Map < String , String > filterData ; @ Override public void onCreate ( Bundle savedInstanceState ) { } @ SuppressWarnings ( "unchecked" ) @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; filterData = ( ( Map < String , String > ) ( getArguments ( ) . getSerializable ( DashboardIssueFragment . ARG_FILTER ) ) ) ; <START_BUG> ListViewUtils . configure ( getActivity ( ) , getListView ( ) , true ) ; <END_BUG> } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override protected ResourcePager < RepositoryIssue > createPager ( ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected ItemListAdapter < RepositoryIssue , ? extends ItemView > createAdapter ( List < RepositoryIssue > items ) { } }
public final class Intersector { public static float getLowestPositiveRoot ( float a , float b , float c ) { } private static final Vector3 v0 = new Vector3 ( ) ; private static final Vector3 v1 = new Vector3 ( ) ; private static final Vector3 v2 = new Vector3 ( ) ; public static boolean isPointInTriangle ( Vector3 point , Vector3 t1 , Vector3 t2 , Vector3 t3 ) { } public static boolean intersectSegmentPlane ( Vector3 start , Vector3 end , Plane plane , Vector3 intersection ) { } public static Vector2 triangleCentroid ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , Vector2 centroid ) { centroid . x = ( ( x1 + x2 ) + x3 ) / 3 ; <START_BUG> centroid . y = ( ( y1 + y2 ) + y3 ) / 3 ; <END_BUG> return centroid ; } public static Vector2 quadrilateralCentroid ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 , Vector2 centroid ) { } public static int pointLineSide ( Vector2 linePoint1 , Vector2 linePoint2 , Vector2 point ) { } public static int pointLineSide ( float linePoint1X , float linePoint1Y , float linePoint2X , float linePoint2Y , float pointX , float pointY ) { } public static boolean isPointInPolygon ( List < Vector2 > polygon , Vector2 point ) { } public static float distanceLinePoint ( Vector2 start , Vector2 end , Vector2 point ) { } public static float distanceLinePoint ( float startX , float startY , float endX , float endY , float pointX , float pointY ) { } public static float distanceSegmentPoint ( float startX , float startY , float endX , float endY , float pointX , float pointY ) { } public static float distanceSegmentPoint ( Vector2 start , Vector2 end , Vector2 point ) { } public static Vector2 nearestSegmentPoint ( Vector2 start , Vector2 end , Vector2 point , Vector2 nearest ) { } public static Vector2 nearestSegmentPoint ( float startX , float startY , float endX , float endY , float pointX , float pointY , Vector2 nearest ) { } public static boolean intersectSegmentCircle ( Vector2 start , Vector2 end , Vector2 center , float squareRadius ) { } public static float intersectSegmentCircleDisplace ( Vector2 start , Vector2 end , Vector2 point , float radius , Vector2 displacement ) { } public static boolean intersectRayPlane ( Ray ray , Plane plane , Vector3 intersection ) { } public static float intersectLinePlane ( float x , float y , float z , float x2 , float y2 , float z2 , Plane plane , Vector3 intersection ) { } private static final Plane p = new Plane ( new Vector3 ( ) , 0 ) ; private static final Vector3 i = new Vector3 ( ) ; public static boolean intersectRayTriangle ( Ray ray , Vector3 t1 , Vector3 t2 , Vector3 t3 , Vector3 intersection ) { } private static final Vector3 dir = new Vector3 ( ) ; private static final Vector3 start = new Vector3 ( ) ; public static boolean intersectRaySphere ( Ray ray , Vector3 center , float radius , Vector3 intersection ) { } public static boolean intersectRayBounds ( Ray ray , BoundingBox box , Vector3 intersection ) { } public static boolean intersectRayBoundsFast ( Ray ray , BoundingBox box ) { } static Vector3 best = new Vector3 ( ) ; static Vector3 tmp = new Vector3 ( ) ; static Vector3 tmp1 = new Vector3 ( ) ; static Vector3 tmp2 = new Vector3 ( ) ; static Vector3 tmp3 = new Vector3 ( ) ; static Vector2 v2tmp = new Vector2 ( ) ; public static boolean intersectRayTriangles ( Ray ray , float [ ] triangles , Vector3 intersection ) { } public static boolean intersectRayTriangles ( Ray ray , float [ ] vertices , short [ ] indices , int vertexSize , Vector3 intersection ) { } public static boolean intersectRayTriangles ( Ray ray , List < Vector3 > triangles , Vector3 intersection ) { } public static boolean intersectLines ( Vector2 p1 , Vector2 p2 , Vector2 p3 , Vector2 p4 , Vector2 intersection ) { } public static boolean intersectLines ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 , Vector2 intersection ) { } public static boolean intersectLinePolygon ( Vector2 p1 , Vector2 p2 , Polygon polygon ) { } public static boolean intersectSegmentPolygon ( Vector2 p1 , Vector2 p2 , Polygon polygon ) { } public static boolean intersectSegments ( Vector2 p1 , Vector2 p2 , Vector2 p3 , Vector2 p4 , Vector2 intersection ) { } static float det ( float a , float b , float c , float d ) { } static double detd ( double a , double b , double c , double d ) { } public static boolean overlaps ( Circle c1 , Circle c2 ) { } public static boolean overlaps ( Rectangle r1 , Rectangle r2 ) { } public static boolean overlaps ( Circle c , Rectangle r ) { } public static boolean overlapConvexPolygons ( Polygon p1 , Polygon p2 ) { } public static boolean overlapConvexPolygons ( Polygon p1 , Polygon p2 , Intersector . MinimumTranslationVector mtv ) { } public static boolean overlapConvexPolygons ( float [ ] verts1 , float [ ] verts2 , Intersector . MinimumTranslationVector mtv ) { } public static void splitTriangle ( float [ ] triangle , Plane plane , Intersector . SplitTriangle split ) { } static Vector3 intersection = new Vector3 ( ) ;
public class Mesh { private static final ArrayList < Mesh > meshes = new ArrayList < Mesh > ( ) ; private final VertexAttributes attributes ; private final int maxVertices ; private final int maxIndices ; private final Buffer vertices ; private final FloatBuffer verticesFloat ; private final IntBuffer verticesFixed ; private final ShortBuffer indices ; private int vertexBufferObjectHandle ; private int indexBufferObjectHandle ; private boolean dirty = false ; private final Graphics graphics ; private final boolean managed ; private final boolean isStatic ; private final boolean useFixedPoint ; private boolean invalidated = false ; private boolean bufferCreatedFirstTime = false ; public Mesh ( Graphics graphics , boolean managed , boolean isStatic , boolean useFixedPoint , int maxVertices , int maxIndices , VertexAttribute ... attributes ) { } private void createBuffers ( ) { } private void constructBufferObjects ( GL11 gl ) { } private void constructBufferObjects ( GL20 gl ) { } private void fillBuffers ( ) { } private void fillBuffers ( GL11 gl ) { } private void fillBuffers ( GL20 gl ) { } public void setVertices ( float [ ] vertices ) { } public void setVertices ( float [ ] vertices , int offset , int count ) { if ( useFixedPoint ) throw new IllegalArgumentException ( "can't<seq2seq4repair_space>set<seq2seq4repair_space>float<seq2seq4repair_space>vertices<seq2seq4repair_space>for<seq2seq4repair_space>fixed<seq2seq4repair_space>point<seq2seq4repair_space>mesh" ) ; <START_BUG> int result = BufferUtils . copy ( vertices , this . vertices , count , offset ) ; <END_BUG> this . verticesFloat . limit ( ( ( this . vertices . limit ( ) ) > > 2 ) ) ; this . verticesFloat . position ( 0 ) ; dirty = true ; } public void setVertices ( int [ ] vertices ) { } public void setVertices ( int [ ] vertices , int offset , int count ) { } public void setIndices ( short [ ] indices ) { } public int getNumIndices ( ) { } public int getNumVertices ( ) { } public int getVertexSize ( ) { } public void render ( int primitiveType ) { } public void render ( int primitiveType , int offset , int count ) { } private void renderVBO ( int primitiveType , int offset , int count ) { } private void renderVA ( int primitiveType , int offset , int count ) { } public void render ( ShaderProgram shader , int primitiveType ) { } public void render ( ShaderProgram shader , int primitiveType , int offset , int count ) { } private void checkManagedAndDirty ( ) { } public void dispose ( ) { } private void dispose ( GL11 gl ) { } private void dispose ( GL20 gl ) { } public boolean usesFixedPoint ( ) { } public int getMaxVertices ( ) { } public int getMaxIndices ( ) { } public VertexAttribute getVertexAttribute ( int usage ) { } public VertexAttributes getVertexAttributes ( ) { } public Buffer getVerticesBuffer ( ) { } public ShortBuffer getIndicesBuffer ( ) { } public void getVertices ( float [ ] vertices ) { } public void getVertices ( int [ ] vertices ) { } public void getIndices ( short [ ] indices ) { } public static void invalidateAllMeshes ( ) { } }
public class FloatAttribute extends Attribute { public static final String ShininessAlias = "shininess" ; public static final long Shininess = register ( FloatAttribute . ShininessAlias ) ; public static FloatAttribute createShininess ( float value ) { } public static final String AlphaTestAlias = "alphaTest" ; public static final long AlphaTest = register ( FloatAttribute . AlphaTestAlias ) ; public static FloatAttribute createAlphaTest ( float value ) { } public float value ; public FloatAttribute ( long type ) { } public FloatAttribute ( long type , float value ) { } @ Override public Attribute copy ( ) { } @ Override public int hashCode ( ) { <START_BUG> int result = ( ( int ) ( type ) ) ; <END_BUG> result = ( 977 * result ) + ( NumberUtils . floatToRawIntBits ( value ) ) ; return result ; } }
public class IpFieldMapper extends NumberFieldMapper < Long > { public static final String CONTENT_TYPE = "ip" ; public static String longToIp ( long longIp ) { } private static final Pattern pattern = Pattern . compile ( "\\." ) ; public static long ipToLong ( String ip ) throws ElasticSearchIllegalArgumentException { } public static class Defaults extends NumberFieldMapper . Defaults { public static final String NULL_VALUE = null ; } public static class Builder extends NumberFieldMapper . Builder < IpFieldMapper . Builder , IpFieldMapper > { protected String nullValue = IpFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public IpFieldMapper . Builder nullValue ( String nullValue ) { } @ Override public IpFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private String nullValue ; protected IpFieldMapper ( Names names , int precisionStep , Field . Index index , Field . Store store , float boost , boolean omitNorms , boolean omitTermFreqAndPositions , String nullValue ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Long value ( Fieldable field ) { } @ Override public Long valueFromString ( String value ) { } @ Override public Object valueForSearch ( Fieldable field ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions ) { } @ Override public Query fuzzyQuery ( String value , double minSim , int prefixLength , int maxExpansions ) { <START_BUG> return new org . apache . lucene . search . FuzzyQuery ( termFactory . createTerm ( value ) , ( ( float ) ( minSim ) ) , prefixLength , maxExpansions ) ; <END_BUG> } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override public Filter rangeFilter ( FieldDataCache fieldDataCache , String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override protected Fieldable parseCreateField ( ParseContext context ) throws IOException { } @ Override public FieldDataType fieldDataType ( ) { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } public static class NumericIpAnalyzer extends NumericAnalyzer < IpFieldMapper . NumericIpTokenizer > { private final int precisionStep ; public NumericIpAnalyzer ( ) { } public NumericIpAnalyzer ( int precisionStep ) { } @ Override protected IpFieldMapper . NumericIpTokenizer createNumericTokenizer ( Reader reader , char [ ] buffer ) throws IOException { } } public static class NumericIpTokenizer extends NumericTokenizer { public NumericIpTokenizer ( Reader reader , int precisionStep ) throws IOException { } public NumericIpTokenizer ( Reader reader , int precisionStep , char [ ] buffer ) throws IOException { } @ Override protected void setValue ( NumericTokenStream tokenStream , String value ) { } } }
public class QuickSelect < T > { private T [ ] array ; private Comparator < ? super T > comp ; public int select ( T [ ] items , Comparator < T > comp , int n , int size ) { } private int partition ( int left , int right , int pivot ) { T pivotValue = array [ pivot ] ; swap ( right , pivot ) ; int storage = left ; for ( int i = left ; i < right ; i ++ ) { <START_BUG> if ( ( comp . compare ( array [ i ] , pivotValue ) ) == ( - 1 ) ) { <END_BUG> swap ( storage , i ) ; storage ++ ; } } swap ( right , storage ) ; return storage ; } private int recursiveSelect ( int left , int right , int k ) { } private int medianOfThreePivot ( int leftIdx , int rightIdx ) { } private void swap ( int left , int right ) { } }
public class DashboardIssueFragment extends PagedListFragment < Issue > { public static final String ARG_FILTER = "filter" ; @ Inject private IssueService service ; @ Inject private IssueStore store ; private Map < String , String > filterData ; @ Inject private AvatarHelper avatarHelper ; private final AtomicInteger numberWidth = new AtomicInteger ( ) ; private TextView numberView ; @ Override public void onCreate ( Bundle savedInstanceState ) { } @ SuppressWarnings ( "unchecked" ) @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override protected ViewHoldingListAdapter < Issue > adapterFor ( List < Issue > items ) { } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { <START_BUG> startActivity ( ViewIssuesActivity . createIntent ( listItems , position ) ) ; <END_BUG> } @ Override public void onLoadFinished ( Loader < List < Issue > > loader , List < Issue > items ) { } @ Override protected ResourcePager < Issue > createPager ( ) { } @ Override protected int getLoadingMessage ( ) { } }
@ ElasticsearchIntegrationTest . SuiteScopeTest public class DateHistogramTests extends ElasticsearchIntegrationTest { private DateTime date ( int month , int day ) { } private DateTime date ( String date ) { } private static String format ( DateTime date , String pattern ) { } private IndexRequestBuilder indexDoc ( String idx , DateTime date , int value ) throws Exception { } private IndexRequestBuilder indexDoc ( int month , int day , int value ) throws Exception { } @ Override public void setupSuiteScopeCluster ( ) throws Exception { } @ After public void afterEachTest ( ) throws IOException { } private static Bucket getBucket ( DateHistogram histogram , DateTime key ) { } private static Bucket getBucket ( DateHistogram histogram , DateTime key , String format ) { } @ Test public void singleValuedField ( ) throws Exception { } @ Test public void singleValuedField_WithPostTimeZone ( ) throws Exception { SearchResponse response ; if ( randomBoolean ( ) ) { response = client ( ) . prepareSearch ( "idx" ) . addAggregation ( dateHistogram ( "histo" ) . field ( "date" ) . interval ( DAY ) . postZone ( "-01:00" ) ) . execute ( ) . actionGet ( ) ; } else { response = client ( ) . prepareSearch ( "idx" ) . addAggregation ( new AbstractAggregationBuilder ( "histo" , "date_histogram" ) { @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { <START_BUG> return builder . startObject ( name ) . startObject ( type ) . field ( "field" , "date" ) . field ( "interval" , "1d" ) . field ( "post_zone" , ( - 1 ) ) . endObject ( ) . endObject ( ) ; <END_BUG> } } ) . execute ( ) . actionGet ( ) ; } assertSearchResponse ( response ) ; DateHistogram histo = response . getAggregations ( ) . get ( "histo" ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( "histo" ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( 6 ) ) ; long key = new DateTime ( 2012 , 1 , 2 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; DateHistogram . Bucket bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; key = new DateTime ( 2012 , 2 , 2 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; key = new DateTime ( 2012 , 2 , 15 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; key = new DateTime ( 2012 , 3 , 2 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; key = new DateTime ( 2012 , 3 , 15 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; key = new DateTime ( 2012 , 3 , 23 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; } @ Test public void singleValuedField_OrderedByKeyAsc ( ) throws Exception { } @ Test public void singleValuedField_OrderedByKeyDesc ( ) throws Exception { } @ Test public void singleValuedField_OrderedByCountAsc ( ) throws Exception { } @ Test public void singleValuedField_OrderedByCountDesc ( ) throws Exception { } @ Test public void singleValuedField_WithSubAggregation ( ) throws Exception { } @ Test public void singleValuedField_WithSubAggregation_Inherited ( ) throws Exception { } @ Test public void singleValuedField_OrderedBySubAggregationAsc ( ) throws Exception { } @ Test public void singleValuedField_OrderedBySubAggregationDesc ( ) throws Exception { } @ Test public void singleValuedField_OrderedByMultiValuedSubAggregationAsc_Inherited ( ) throws Exception { } @ Test public void singleValuedField_OrderedByMultiValuedSubAggregationDesc ( ) throws Exception { } @ Test public void singleValuedField_WithValueScript ( ) throws Exception { } @ Test public void multiValuedField ( ) throws Exception { }
public class FastByteArrayOutputStream extends OutputStream implements BytesStream { protected byte [ ] buf ; protected int count ; public FastByteArrayOutputStream ( ) { } public FastByteArrayOutputStream ( int size ) { } public void write ( int b ) { } public void write ( byte [ ] b , int off , int len ) { } public void writeTo ( OutputStream out ) throws IOException { } public void reset ( ) { } @ Override public BytesReference bytes ( ) { } public int size ( ) { } public void seek ( int position ) { } public String toString ( ) { <START_BUG> return new String ( buf , 0 , count ) ; <END_BUG> } public String toString ( String charsetName ) throws UnsupportedEncodingException { } public void close ( ) throws IOException { } }
public class QueryBinaryParseElement implements SearchParseElement { @ Override public void parse ( XContentParser parser , SearchContext context ) throws Exception { XContentIndexQueryParser indexQueryParser = ( ( XContentIndexQueryParser ) ( context . queryParser ( ) ) ) ; byte [ ] querySource = parser . binaryValue ( ) ; XContentParser qSourceParser = XContentFactory . xContent ( querySource ) . createParser ( querySource ) ; <START_BUG> Query query = indexQueryParser . parse ( qSourceParser ) ; <END_BUG> context . query ( query ) ; } }
public class ContextIndexSearcher extends IndexSearcher { public static enum Stage { NA , MAIN_QUERY , REWRITE ; } private final SearchContext searchContext ; private CachedDfSource dfSource ; private List < Collector > queryCollectors ; private ContextIndexSearcher . Stage currentState = ContextIndexSearcher . Stage . NA ; public ContextIndexSearcher ( SearchContext searchContext , Engine . Searcher searcher ) { } public void dfSource ( CachedDfSource dfSource ) { } public void addMainQueryCollector ( Collector collector ) { } public void inStage ( ContextIndexSearcher . Stage stage ) { } public void finishStage ( ContextIndexSearcher . Stage stage ) { <START_BUG> assert ( currentState ) == stage ; <END_BUG> this . currentState = ContextIndexSearcher . Stage . NA ; } @ Override public Query rewrite ( Query original ) throws IOException { } @ Override public Weight createNormalizedWeight ( Query query ) throws IOException { } private Filter combinedFilter ( Filter filter ) { } @ Override public void search ( Query query , Collector results ) throws IOException { } @ Override public TopDocs search ( Query query , Filter filter , int n ) throws IOException { } @ Override public void search ( List < AtomicReaderContext > leaves , Weight weight , Collector collector ) throws IOException { } @ Override public Explanation explain ( Query query , int doc ) throws IOException { } }
public class MultiOrdinals implements Ordinals { private static final int OFFSETS_PAGE_SIZE = 1024 ; private static final int OFFSET_INIT_PAGE_COUNT = 16 ; public static boolean significantlySmallerThanSinglePackedOrdinals ( int maxDoc , int numDocsWithValue , long numOrds ) { } private final boolean multiValued ; private final long numOrds ; private final MonotonicAppendingLongBuffer endOffsets ; private final AppendingLongBuffer ords ; public MultiOrdinals ( OrdinalsBuilder builder ) { } @ Override public boolean hasSingleArrayBackingStorage ( ) { } @ Override public Object getBackingStorage ( ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override public boolean isMultiValued ( ) { } @ Override public int getNumDocs ( ) { } @ Override public long getNumOrds ( ) { } @ Override public long getMaxOrd ( ) { } @ Override public Docs ordinals ( ) { return new MultiOrdinals . MultiDocs ( this ) ; } static class MultiDocs implements Ordinals . Docs { private final MultiOrdinals ordinals ; private final MonotonicAppendingLongBuffer endOffsets ; private final AppendingLongBuffer ords ; private final LongsRef longsScratch ; private final MultiOrdinals . MultiIter iter ; MultiDocs ( MultiOrdinals ordinals ) { } @ Override public Ordinals ordinals ( ) { <START_BUG> return null ; <END_BUG> } @ Override public int getNumDocs ( ) { } @ Override public long getNumOrds ( ) { } @ Override public long getMaxOrd ( ) { } @ Override public boolean isMultiValued ( ) { } @ Override public long getOrd ( int docId ) { } @ Override public LongsRef getOrds ( int docId ) { } @ Override public Iter getIter ( int docId ) { } } static class MultiIter implements Iter { final AppendingLongBuffer ordinals ; long offset ; long endOffset ; MultiIter ( AppendingLongBuffer ordinals ) { } @ Override public long next ( ) { } } }
public class QueryParseElement implements SearchParseElement { @ Override public void parse ( JsonParser jp , SearchContext context ) throws Exception { JsonIndexQueryParser indexQueryParser = ( ( JsonIndexQueryParser ) ( context . queryParser ( ) ) ) ; <START_BUG> Query query = indexQueryParser . parse ( jp , context . source ( ) ) ; <END_BUG> query . setBoost ( ( ( query . getBoost ( ) ) * ( context . queryBoost ( ) ) ) ) ; context . query ( query ) ; } }
public class TableLayoutTest extends GdxTest { Stage stage ; public void create ( ) { } public void render ( ) { } public void resize ( int width , int height ) { <START_BUG> stage . setViewport ( width , height , true ) ; <END_BUG> } public void dispose ( ) { } }
public class IOSMusic implements Music { private final OALAudioTrack track ; OnCompletionListener onCompletionListener ; public IOSMusic ( OALAudioTrack track ) { } @ Override public void play ( ) { } @ Override public void pause ( ) { } @ Override public void stop ( ) { } @ Override public boolean isPlaying ( ) { <START_BUG> return ( track . isPlaying ( ) ) && ( ! ( track . isPaused ( ) ) ) ; <END_BUG> } @ Override public void setLooping ( boolean isLooping ) { } @ Override public boolean isLooping ( ) { } @ Override public void setVolume ( float volume ) { } public void setPosition ( float position ) { } @ Override public float getPosition ( ) { } @ Override public void dispose ( ) { } @ Override public float getVolume ( ) { } @ Override public void setPan ( float pan , float volume ) { } @ Override public void setOnCompletionListener ( OnCompletionListener listener ) { } }
public class ClientTransportBulkAction extends BaseClientTransportAction < BulkRequest , BulkResponse > { @ Inject public ClientTransportBulkAction ( Settings settings , TransportService transportService ) { } @ Override protected String action ( ) { } @ Override protected TransportRequestOptions options ( ) { <START_BUG> return TransportRequestOptions . options ( ) . withCompress ( true ) ; <END_BUG> } }
public class ReproduceInfoPrinter extends RunListener { protected final ESLogger logger = Loggers . getLogger ( ElasticsearchTestCase . class ) ; @ Override public void testStarted ( Description description ) throws Exception { } @ Override public void testFinished ( Description description ) throws Exception { } @ Override public void testFailure ( Failure failure ) throws Exception { } protected ReproduceErrorMessageBuilder reproduceErrorMessageBuilder ( StringBuilder b ) { } protected TraceFormatting traces ( ) { } protected static class MavenMessageBuilder extends ReproduceErrorMessageBuilder { public MavenMessageBuilder ( StringBuilder b ) { } @ Override public ReproduceErrorMessageBuilder appendAllOpts ( Description description ) { } @ Override public ReproduceErrorMessageBuilder appendOpt ( String sysPropName , String value ) { } public ReproduceErrorMessageBuilder appendESProperties ( ) { <START_BUG> appendProperties ( "es.logger.level" , "es.node.mode" , "es.node.local" , TESTS_ENABLE_MOCK_MODULES , "tests.assertion.disabled" , "tests.security.manager" ) ; <END_BUG> if ( ( ( System . getProperty ( "tests.jvm.argline" ) ) != null ) && ( ! ( System . getProperty ( "tests.jvm.argline" ) . isEmpty ( ) ) ) ) { appendOpt ( "tests.jvm.argline" , ( ( "\"" + ( System . getProperty ( "tests.jvm.argline" ) ) ) + "\"" ) ) ; } return this ; } protected ReproduceErrorMessageBuilder appendProperties ( String ... properties ) { } } }
public static final int M20 = 2 ; public static final int M21 = 6 ; public static final int M22 = 10 ; public static final int M23 = 14 ; public static final int M30 = 3 ; public static final int M31 = 7 ; public static final int M32 = 11 ; public static final int M33 = 15 ; public final float [ ] tmp = new float [ 16 ] ; public final float [ ] val = new float [ 16 ] ; public Matrix4 ( ) { } public Matrix4 ( Matrix4 matrix ) { } public Matrix4 ( float [ ] values ) { } public Matrix4 ( Quaternion quaternion ) { } public Matrix4 set ( Matrix4 matrix ) { } public Matrix4 set ( float [ ] values ) { } public Matrix4 set ( Quaternion quaternion ) { } public Matrix4 set ( float x , float y , float z , float w ) { } public Matrix4 set ( Vector3 xAxis , Vector3 yAxis , Vector3 zAxis , Vector3 pos ) { } public Matrix4 cpy ( ) { } public Matrix4 trn ( Vector3 vector ) { } public Matrix4 trn ( float x , float y , float z ) { } public float [ ] getValues ( ) { } public Matrix4 mul ( Matrix4 matrix ) { } public Matrix4 tra ( ) { } public Matrix4 idt ( ) { } public Matrix4 inv ( ) { } public float det ( ) { } public Matrix4 setToProjection ( float near , float far , float fov , float aspectRatio ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height , float near , float far ) { } public Matrix4 setToOrtho ( float left , float right , float bottom , float top , float near , float far ) { } public Matrix4 setTranslation ( Vector3 vector ) { } public Matrix4 setToTranslation ( Vector3 vector ) { } public Matrix4 setToTranslation ( float x , float y , float z ) { } public Matrix4 setToTranslationAndScaling ( Vector3 translation , Vector3 scaling ) { } public Matrix4 setToTranslationAndScaling ( float translationX , float translationY , float translationZ , float scalingX , float scalingY , float scalingZ ) { } static Quaternion quat = new Quaternion ( ) ; public Matrix4 setToRotation ( Vector3 axis , float angle ) { } public Matrix4 setToRotation ( float axisX , float axisY , float axisZ , float angle ) { } public Matrix4 setToRotation ( final Vector3 v1 , final Vector3 v2 ) { } public Matrix4 setToRotation ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } public Matrix4 setFromEulerAngles ( float yaw , float pitch , float roll ) { } public Matrix4 setToScaling ( Vector3 vector ) { } public Matrix4 setToScaling ( float x , float y , float z ) { } static final Vector3 l_vez = new Vector3 ( ) ; static final Vector3 l_vex = new Vector3 ( ) ; static final Vector3 l_vey = new Vector3 ( ) ; public Matrix4 setToLookAt ( Vector3 direction , Vector3 up ) { } static final Vector3 tmpVec = new Vector3 ( ) ; static final Matrix4 tmpMat = new Matrix4 ( ) ; public Matrix4 setToLookAt ( Vector3 position , Vector3 target , Vector3 up ) { Matrix4 . tmpVec . set ( target ) . sub ( position ) ; setToLookAt ( Matrix4 . tmpVec , up ) ; <START_BUG> this . mul ( Matrix4 . tmpMat . setToTranslation ( position . tmp ( ) . mul ( ( - 1 ) ) ) ) ; <END_BUG> return this ; } static final Vector3 right = new Vector3 ( ) ; static final Vector3 tmpForward = new Vector3 ( ) ; static final Vector3 tmpUp = new Vector3 ( ) ; public Matrix4 setToWorld ( Vector3 position , Vector3 forward , Vector3 up ) { } public String toString ( ) { } public void lerp ( Matrix4 matrix , float alpha ) { } public Matrix4 set ( Matrix3 mat ) { } public Matrix4 scl ( Vector3 scale ) { } public Matrix4 scl ( float x , float y , float z ) { } public Matrix4 scl ( float scale ) { } public void getTranslation ( Vector3 position ) { } public void getRotation ( Quaternion rotation ) { } public Matrix4 toNormalMatrix ( ) { } static void matrix4_mul ( float [ ] mata , float [ ] matb ) { } static float matrix4_det ( float [ ] val ) { } static boolean matrix4_inv ( float [ ] val ) { } static void matrix4_mulVec ( float [ ] mat , float [ ] vec , int offset ) { } static void matrix4_proj ( float [ ] mat , float [ ] vec , int offset ) { } static void matrix4_rot ( float [ ] mat , float [ ] vec , int offset ) { } public static void mul ( float [ ] mata , float [ ] matb ) { } public static void mulVec ( float [ ] mat , float [ ] vec ) { } public static void mulVec ( float [ ] mat , float [ ] vecs , int offset , int numVecs , int stride ) { } public static void prj ( float [ ] mat , float [ ] vec ) { } public static void prj ( float [ ] mat , float [ ] vecs , int offset , int numVecs , int stride ) { }
public class GatewayService extends AbstractLifecycleComponent < GatewayService > implements ClusterStateListener { private final Gateway gateway ; private final ThreadPool threadPool ; private volatile ExecutorService executor ; private final ClusterService clusterService ; private final MetaDataService metaDataService ; private final AtomicBoolean firstMasterRead = new AtomicBoolean ( ) ; @ Inject public GatewayService ( Settings settings , Gateway gateway , ClusterService clusterService , ThreadPool threadPool , MetaDataService metaDataService ) { } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } @ Override public void clusterChanged ( final ClusterChangedEvent event ) { } private void writeToGateway ( final ClusterChangedEvent event ) { } private void readFromGateway ( ) { logger . debug ( "First<seq2seq4repair_space>master<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>cluster,<seq2seq4repair_space>reading<seq2seq4repair_space>state<seq2seq4repair_space>from<seq2seq4repair_space>gateway" ) ; executor . execute ( new Runnable ( ) { @ Override public void run ( ) { MetaData metaData ; try { metaData = gateway . read ( ) ; } catch ( Exception e ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>read<seq2seq4repair_space>from<seq2seq4repair_space>gateway" , e ) ; return ; } if ( metaData == null ) { logger . debug ( "No<seq2seq4repair_space>state<seq2seq4repair_space>read<seq2seq4repair_space>from<seq2seq4repair_space>gateway" ) ; return ; } final MetaData fMetaData = metaData ; clusterService . submitStateUpdateTask ( "gateway<seq2seq4repair_space>(recovered<seq2seq4repair_space>meta-data)" , new ClusterStateUpdateTask ( ) { @ Override public ClusterState execute ( ClusterState currentState ) { MetaData . Builder metaDataBuilder = newMetaDataBuilder ( ) . metaData ( currentState . metaData ( ) ) . maxNumberOfShardsPerNode ( fMetaData . maxNumberOfShardsPerNode ( ) ) ; for ( final IndexMetaData indexMetaData : fMetaData ) { threadPool . execute ( new Runnable ( ) { @ Override public void run ( ) { try { <START_BUG> metaDataService . createIndex ( indexMetaData . index ( ) , indexMetaData . settings ( ) , indexMetaData . mappings ( ) , timeValueMillis ( 10 ) ) ; <END_BUG> } catch ( Exception e ) { logger . error ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>create<seq2seq4repair_space>index<seq2seq4repair_space>[" + ( indexMetaData . index ( ) ) ) + "]" ) , e ) ; } } } ) ; } return newClusterStateBuilder ( ) . state ( currentState ) . metaData ( metaDataBuilder ) . build ( ) ; } } ) ; } } ) ; } }
@ Test public class SimpleJsonIndexQueryParserTests { private final Index index = new Index ( "test" ) ; @ Test public void testQueryStringBuilder ( ) throws Exception { } @ Test public void testQueryString ( ) throws Exception { } @ Test public void testQueryStringFields1Builder ( ) throws Exception { } @ Test public void testQueryStringFields1 ( ) throws Exception { } @ Test public void testQueryStringFields2Builder ( ) throws Exception { } @ Test public void testQueryStringFields2 ( ) throws Exception { } @ Test public void testQueryStringFields3Builder ( ) throws Exception { } @ Test public void testQueryStringFields3 ( ) throws Exception { } @ Test public void testMatchAllBuilder ( ) throws Exception { } @ Test public void testMatchAll ( ) throws Exception { } @ Test public void testDisMaxBuilder ( ) throws Exception { } @ Test public void testDisMax ( ) throws Exception { } @ Test public void testTermQueryBuilder ( ) throws IOException { } @ Test public void testTermQuery ( ) throws IOException { } @ Test public void testFieldQueryBuilder1 ( ) throws IOException { } @ Test public void testFieldQuery1 ( ) throws IOException { } @ Test public void testFieldQuery2 ( ) throws IOException { } @ Test public void testFieldQuery3 ( ) throws IOException { } @ Test public void testTermWithBoostQueryBuilder ( ) throws IOException { } @ Test public void testTermWithBoostQuery ( ) throws IOException { } @ Test public void testPrefixQueryBuilder ( ) throws IOException { } @ Test public void testPrefixQuery ( ) throws IOException { } @ Test public void testPrefixFilteredQueryBuilder ( ) throws IOException { } @ Test public void testPrefixFilteredQuery ( ) throws IOException { } @ Test public void testPrefixQueryBoostQueryBuilder ( ) throws IOException { } @ Test public void testPrefixQueryBoostQuery ( ) throws IOException { } @ Test public void testWildcardQueryBuilder ( ) throws IOException { } @ Test public void testWildcardQuery ( ) throws IOException { } @ Test public void testRangeQueryBuilder ( ) throws IOException { } @ Test public void testRangeQuery ( ) throws IOException { } @ Test public void testRangeFilteredQueryBuilder ( ) throws IOException { } @ Test public void testRangeFilteredQuery ( ) throws IOException { } @ Test public void testBoolFilteredQuery ( ) throws IOException { } @ Test public void testBoolQueryBuilder ( ) throws IOException { } @ Test public void testBoolQuery ( ) throws IOException { } @ Test public void testFilteredQueryBuilder ( ) throws IOException { } @ Test public void testFilteredQuery ( ) throws IOException { } @ Test public void testFilteredQuery2 ( ) throws IOException { } @ Test public void testFilteredQuery3 ( ) throws IOException { } @ Test public void testFilteredQuery4 ( ) throws IOException { } @ Test public void testTermsFilterQueryBuilder ( ) throws Exception { } @ Test public void testTermsFilterQuery ( ) throws Exception { } @ Test public void testConstantScoreQueryBuilder ( ) throws IOException { } @ Test public void testConstantScoreQuery ( ) throws IOException { } @ Test public void testSpanTermQueryBuilder ( ) throws IOException { } @ Test public void testSpanTermQuery ( ) throws IOException { } @ Test public void testSpanNotQueryBuilder ( ) throws IOException { } @ Test public void testSpanNotQuery ( ) throws IOException { } @ Test public void testSpanFirstQueryBuilder ( ) throws IOException { } @ Test public void testSpanFirstQuery ( ) throws IOException { } @ Test public void testSpanNearQueryBuilder ( ) throws IOException { } @ Test public void testSpanNearQuery ( ) throws IOException { } @ Test public void testSpanOrQueryBuilder ( ) throws IOException { } @ Test public void testSpanOrQuery ( ) throws IOException { } @ Test public void testQueryFilterBuilder ( ) throws Exception { } @ Test public void testQueryFilter ( ) throws Exception { } @ Test public void testMoreLikeThisBuilder ( ) throws Exception { } @ Test public void testMoreLikeThis ( ) throws Exception { } @ Test public void testMoreLikeThisFieldBuilder ( ) throws Exception { } @ Test public void testMoreLikeThisField ( ) throws Exception { } private JsonIndexQueryParser newQueryParser ( ) throws IOException { <START_BUG> return new JsonIndexQueryParser ( new Index ( "test" ) , EMPTY_SETTINGS , newMapperService ( ) , new org . elasticsearch . index . cache . filter . none . NoneFilterCache ( index , EMPTY_SETTINGS ) , new org . elasticsearch . index . analysis . AnalysisService ( index ) , null , null , "test" , null ) ; <END_BUG> } private MapperService newMapperService ( ) throws IOException { } }
public class QueryParseContext { private static ThreadLocal < String [ ] > typesContext = new ThreadLocal < String [ ] > ( ) ; public static void setTypes ( String [ ] types ) { } public static String [ ] getTypes ( ) { } public static String [ ] setTypesWithPrevious ( String [ ] types ) { } public static void removeTypes ( ) { } private final Index index ; IndexQueryParserService indexQueryParser ; private final Map < String , Filter > namedFilters = Maps . newHashMap ( ) ; private final MapperQueryParser queryParser = new MapperQueryParser ( this ) ; private XContentParser parser ; public QueryParseContext ( Index index , IndexQueryParserService indexQueryParser ) { } public void reset ( XContentParser jp ) { } public Index index ( ) { } public XContentParser parser ( ) { } public AnalysisService analysisService ( ) { } public ScriptService scriptService ( ) { } public MapperService mapperService ( ) { } public IndexEngine indexEngine ( ) { } @ Nullable public SimilarityService similarityService ( ) { } public Similarity searchSimilarity ( ) { } public IndexCache indexCache ( ) { } public String defaultField ( ) { } public boolean queryStringLenient ( ) { } public MapperQueryParser queryParser ( QueryParserSettings settings ) { } public Filter cacheFilter ( Filter filter , @ Nullable CacheKeyFilter . Key cacheKey ) { } public void addNamedFilter ( String name , Filter filter ) { } public ImmutableMap < String , Filter > copyNamedFilters ( ) { } @ Nullable public Query parseInnerQuery ( ) throws IOException , QueryParsingException { } @ Nullable public Filter parseInnerFilter ( ) throws IOException , QueryParsingException { } public Filter parseInnerFilter ( String filterName ) throws IOException , QueryParsingException { } public FieldMapper fieldMapper ( String name ) { } public String indexName ( String name ) { } public SmartNameFieldMappers smartFieldMappers ( String name ) { } public SmartNameObjectMapper smartObjectMapper ( String name ) { } public Collection < String > queryTypes ( ) { } private SearchLookup lookup = null ; public SearchLookup lookup ( ) { SearchContext current = SearchContext . current ( ) ; if ( current != null ) { return current . lookup ( ) ; } if ( ( lookup ) == null ) { <START_BUG> lookup = new SearchLookup ( mapperService ( ) , indexCache ( ) . fieldData ( ) ) ; <END_BUG> } return lookup ; } public long nowInMillis ( ) { } }
public class FilteredCollector extends Collector { private final Collector collector ; private final Filter filter ; private DocSet docSet ; public FilteredCollector ( Collector collector , Filter filter ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { collector . setNextReader ( context ) ; <START_BUG> docSet = DocSets . convert ( context . reader ( ) , filter . getDocIdSet ( context ) ) ; <END_BUG> } @ Override public boolean acceptsDocsOutOfOrder ( ) { } }
public class ClickListener extends InputListener { public static float visualPressedDuration = 0.1F ; private float tapSquareSize = 14 ; private float touchDownX = - 1 ; private float touchDownY = - 1 ; private int pressedPointer = - 1 ; private int pressedButton = - 1 ; private int button ; private boolean pressed ; private boolean over ; private boolean cancelled ; private float visualPressedTime ; private long tapCountInterval = ( ( long ) ( 0.4F * 1000000000L ) ) ; private int tapCount ; private long lastTapTime ; public ClickListener ( ) { } public ClickListener ( int button ) { } public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { } public void touchDragged ( InputEvent event , float x , float y , int pointer ) { } public void touchUp ( InputEvent event , float x , float y , int pointer , int button ) { } public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { } public void exit ( InputEvent event , float x , float y , int pointer , Actor toActor ) { } public void cancel ( ) { } public void clicked ( InputEvent event , float x , float y ) { } public boolean isOver ( Actor actor , float x , float y ) { } public boolean inTapSquare ( float x , float y ) { } public boolean inTapSquare ( ) { } public void invalidateTapSquare ( ) { } public boolean isPressed ( ) { } public boolean isVisualPressed ( ) { if ( pressed ) return true ; if ( ( visualPressedTime ) <= 0 ) return false ; <START_BUG> if ( ( ( visualPressedTime ) > ( TimeUtils . nanoTime ( ) ) ) && ( graphics . isContinuousRendering ( ) ) ) <END_BUG> return true ; visualPressedTime = 0 ; return false ; } public boolean isOver ( ) { } public void setTapSquareSize ( float halfTapSquareSize ) { } public float getTapSquareSize ( ) { } public void setTapCountInterval ( float tapCountInterval ) { } public int getTapCount ( ) { } public float getTouchDownX ( ) { } public float getTouchDownY ( ) { } public int getPressedButton ( ) { } public int getPressedPointer ( ) { } public int getButton ( ) { } public void setButton ( int button ) { } }
public class QueueRecyclerTests extends AbstractRecyclerTests { @ Override protected Recycler < byte [ ] > newRecycler ( ) { <START_BUG> return new QueueRecycler < byte [ ] > ( RECYCLER_C , randomIntBetween ( 5 , 10 ) ) ; <END_BUG> } }
public class TransportPercolateAction extends TransportSingleCustomOperationAction < PercolateRequest , PercolateResponse > { private final IndicesService indicesService ; @ Inject public TransportPercolateAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected PercolateRequest newRequest ( ) { } @ Override protected PercolateResponse newResponse ( ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected ShardsIterator shards ( ClusterState clusterState , PercolateRequest request ) { } @ Override protected PercolateResponse shardOperation ( PercolateRequest request , int shardId ) throws ElasticSearchException { IndexService indexService = indicesService . indexServiceSafe ( request . index ( ) ) ; PercolatorService percolatorService = indexService . percolateService ( ) ; <START_BUG> PercolatorExecutor . Response percolate = percolatorService . percolate ( new PercolatorExecutor . SourceRequest ( request . source ( ) ) ) ; <END_BUG> return new PercolateResponse ( percolate . matches ( ) ) ; } }
public class ParticleEffectPool extends Pool < ParticleEffectPool . PooledEffect > { private final ParticleEffect effect ; public ParticleEffectPool ( ParticleEffect effect , int initialCapacity , int max ) { } protected ParticleEffectPool . PooledEffect newObject ( ) { } public ParticleEffectPool . PooledEffect obtain ( ) { ParticleEffectPool . PooledEffect effect = super . obtain ( ) ; <START_BUG> effect . start ( ) ; <END_BUG> return effect ; } public class PooledEffect extends ParticleEffect { PooledEffect ( ParticleEffect effect ) { } public void free ( ) { } } }
public Vector3 ( final Vector3 vector ) { } public Vector3 ( final float [ ] values ) { } public Vector3 ( final Vector2 vector , float z ) { } public Vector3 set ( float x , float y , float z ) { } @ Override public Vector3 set ( final Vector3 vector ) { } public Vector3 set ( final float [ ] values ) { } public Vector3 set ( final Vector2 vector , float z ) { } @ Override public Vector3 cpy ( ) { } @ Override public Vector3 add ( final Vector3 vector ) { } public Vector3 add ( float x , float y , float z ) { } public Vector3 add ( float values ) { } @ Override public Vector3 sub ( final Vector3 a_vec ) { } public Vector3 sub ( float x , float y , float z ) { } public Vector3 sub ( float value ) { } @ Override public Vector3 scl ( float scalar ) { } @ Override public Vector3 scl ( final Vector3 other ) { } public Vector3 scl ( float vx , float vy , float vz ) { } @ Override public Vector3 mulAdd ( Vector3 vec , float scalar ) { } @ Override public Vector3 mulAdd ( Vector3 vec , Vector3 mulVec ) { } public static float len ( final float x , final float y , final float z ) { } @ Override public float len ( ) { } public static float len2 ( final float x , final float y , final float z ) { } @ Override public float len2 ( ) { } public boolean idt ( final Vector3 vector ) { } public static float dst ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } @ Override public float dst ( final Vector3 vector ) { } public float dst ( float x , float y , float z ) { } public static float dst2 ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } @ Override public float dst2 ( Vector3 point ) { } public float dst2 ( float x , float y , float z ) { } @ Override public Vector3 nor ( ) { } public static float dot ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { } @ Override public float dot ( final Vector3 vector ) { } public float dot ( float x , float y , float z ) { } public Vector3 crs ( final Vector3 vector ) { } public Vector3 crs ( float x , float y , float z ) { } public Vector3 mul4x3 ( float [ ] matrix ) { } public Vector3 mul ( final Matrix4 matrix ) { } public Vector3 traMul ( final Matrix4 matrix ) { } public Vector3 mul ( Matrix3 matrix ) { } public Vector3 traMul ( Matrix3 matrix ) { } public Vector3 mul ( final Quaternion quat ) { } public Vector3 prj ( final Matrix4 matrix ) { } public Vector3 rot ( final Matrix4 matrix ) { } public Vector3 unrotate ( final Matrix4 matrix ) { } public Vector3 untransform ( final Matrix4 matrix ) { } public Vector3 rotate ( float degrees , float axisX , float axisY , float axisZ ) { } public Vector3 rotateRad ( float radians , float axisX , float axisY , float axisZ ) { } public Vector3 rotate ( final Vector3 axis , float degrees ) { } public Vector3 rotateRad ( final Vector3 axis , float radians ) { } @ Override public boolean isUnit ( ) { } @ Override public boolean isUnit ( final float margin ) { } @ Override public boolean isZero ( ) { } @ Override public boolean isZero ( final float margin ) { } @ Override public boolean isOnLine ( Vector3 other , float epsilon ) { } @ Override public boolean isOnLine ( Vector3 other ) { } @ Override public boolean isCollinear ( Vector3 other , float epsilon ) { } @ Override public boolean isCollinear ( Vector3 other ) { } @ Override public boolean isCollinearOpposite ( Vector3 other , float epsilon ) { } @ Override public boolean isCollinearOpposite ( Vector3 other ) { } @ Override public boolean isPerpendicular ( Vector3 vector ) { } @ Override public boolean isPerpendicular ( Vector3 vector , float epsilon ) { } @ Override public boolean hasSameDirection ( Vector3 vector ) { } @ Override public boolean hasOppositeDirection ( Vector3 vector ) { } @ Override public Vector3 lerp ( final Vector3 target , float alpha ) { } @ Override public Vector3 interpolate ( Vector3 target , float alpha , Interpolation interpolator ) { } public Vector3 slerp ( final Vector3 target , float alpha ) { } public String toString ( ) { <START_BUG> return ( ( ( ( ( "[" + ( x ) ) + ",<seq2seq4repair_space>" ) + ( y ) ) + ",<seq2seq4repair_space>" ) + ( z ) ) + "]" ; <END_BUG> } @ Override public Vector3 limit ( float limit ) { } @ Override public Vector3 clamp ( float min , float max ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } @ Override public boolean epsilonEquals ( final Vector3 other , float epsilon ) { } public boolean epsilonEquals ( float x , float y , float z , float epsilon ) { } @ Override public Vector3 setZero ( ) { } }
public class InternalFacets implements Iterable < Facet > , Streamable , ToXContent , Facets { private List < Facet > facets = ImmutableList . of ( ) ; private Map < String , Facet > facetsAsMap ; private InternalFacets ( ) { } public InternalFacets ( List < Facet > facets ) { } @ Override public Iterator < Facet > iterator ( ) { } public List < Facet > facets ( ) { } public Map < String , Facet > getFacets ( ) { } public Map < String , Facet > facetsAsMap ( ) { if ( ( facetsAsMap ) != null ) { return facetsAsMap ; } Map < String , Facet > facetsAsMap = Maps . newHashMap ( ) ; for ( Facet facet : facets ) { <START_BUG> facetsAsMap . put ( facet . name ( ) , facet ) ; <END_BUG> } this . facetsAsMap = facetsAsMap ; return facetsAsMap ; } @ Override public < T extends Facet > T facet ( Class < T > facetType , String name ) { } @ SuppressWarnings ( { "unchecked" } ) @ Override public < T extends Facet > T facet ( String name ) { } static final class Fields { static final XContentBuilderString FACETS = new XContentBuilderString ( "facets" ) ; } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } public static InternalFacets readFacets ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public class WallElement extends FieldElement { Body wallBody ; Collection bodySet ; float x1 ; float y1 ; float x2 ; float y2 ; float kick ; boolean killBall ; boolean retractWhenHit ; @ Override public void finishCreate ( Map params , World world ) { } public boolean isRetracted ( ) { } public void setRetracted ( boolean retracted ) { } @ Override public Collection getBodies ( ) { } @ Override public boolean shouldCallTick ( ) { } Vector2 impulseForBall ( Body ball ) { } @ Override public void handleCollision ( Body ball , Body bodyHit , Field field ) { if ( retractWhenHit ) { this . setRetracted ( true ) ; } if ( killBall ) { field . removeBall ( ball ) ; } else { Vector2 impulse = this . impulseForBall ( ball ) ; if ( impulse != null ) { <START_BUG> ball . applyLinearImpulse ( impulse , ball . getWorldCenter ( ) , true ) ; <END_BUG> flashForFrames ( 3 ) ; } } } @ Override public void draw ( IFieldRenderer renderer ) { } }
public class DefaultRepositoryListAdapter extends RepositoryListAdapter < Repository > { private int descriptionColor ; private final AtomicReference < User > account ; private final Map < Long , String > headers = new HashMap < Long , String > ( ) ; private final Set < Long > noSeparators = new HashSet < Long > ( ) ; public DefaultRepositoryListAdapter ( LayoutInflater inflater , Repository [ ] elements , AtomicReference < User > account ) { } public DefaultRepositoryListAdapter ( LayoutInflater inflater , AtomicReference < User > account ) { } public DefaultRepositoryListAdapter clearHeaders ( ) { } public DefaultRepositoryListAdapter registerHeader ( Repository repository , String text ) { } public DefaultRepositoryListAdapter registerNoSeparator ( Repository repository ) { } protected View initialize ( View view ) { view = super . initialize ( view ) ; <START_BUG> TypefaceUtils . setOcticons ( textView ( view , 3 ) , ( ( TextView ) ( view . findViewById ( tv_forks_icon ) ) ) , ( ( TextView ) ( view . findViewById ( tv_watchers_icon ) ) ) ) ; <END_BUG> descriptionColor = view . getResources ( ) . getColor ( text_description ) ; return view ; } @ Override protected int [ ] getChildViewIds ( ) { } @ Override protected void update ( int position , Repository repository ) { } }
public class NoneIndexShardGateway extends AbstractIndexShardComponent implements IndexShardGateway { private final InternalIndexShard indexShard ; @ Inject public NoneIndexShardGateway ( ShardId shardId , @ IndexSettings Settings indexSettings , IndexShard indexShard ) { } @ Override public RecoveryStatus recover ( ) throws IndexShardGatewayRecoveryException { try { indexShard . store ( ) . deleteContent ( ) ; } catch ( IOException e ) { logger . warn ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>clean<seq2seq4repair_space>store<seq2seq4repair_space>before<seq2seq4repair_space>starting<seq2seq4repair_space>shard" , e ) ; } indexShard . start ( ) ; <START_BUG> return new RecoveryStatus ( Index . EMPTY , new RecoveryStatus . Translog ( 0 ) ) ; <END_BUG> } @ Override public String type ( ) { } @ Override public SnapshotStatus snapshot ( Snapshot snapshot ) { } @ Override public boolean requiresSnapshotScheduling ( ) { } @ Override public void close ( boolean delete ) { } }
public abstract class PrioritizedCallable < T > implements Comparable < PrioritizedCallable > , Callable < T > { private final Priority priority ; public static < T > PrioritizedCallable < T > wrap ( Callable < T > callable , Priority priority ) { <START_BUG> return new PrioritizedCallable . Wrapped < T > ( callable , priority ) ; <END_BUG> } protected PrioritizedCallable ( Priority priority ) { } @ Override public int compareTo ( PrioritizedCallable pc ) { } public Priority priority ( ) { } static class Wrapped < T > extends PrioritizedCallable < T > { private final Callable < T > callable ; private Wrapped ( Callable < T > callable , Priority priority ) { } @ Override public T call ( ) throws Exception { } } }
public class PrioritizedExecutorsTests extends ElasticsearchTestCase { @ Test public void testPriorityQueue ( ) throws Exception { } @ Test public void testSubmitPrioritizedExecutorWithRunnables ( ) throws Exception { } @ Test public void testExecutePrioritizedExecutorWithRunnables ( ) throws Exception { } @ Test public void testSubmitPrioritizedExecutorWithCallables ( ) throws Exception { } @ Test public void testSubmitPrioritizedExecutorWithMixed ( ) throws Exception { } @ Test public void testTimeout ( ) throws Exception { ScheduledExecutorService timer = Executors . newSingleThreadScheduledExecutor ( ) ; PrioritizedEsThreadPoolExecutor executor = EsExecutors . newSinglePrioritizing ( Executors . defaultThreadFactory ( ) ) ; final CountDownLatch block = new CountDownLatch ( 1 ) ; executor . execute ( new Runnable ( ) { @ Override public void run ( ) { try { block . await ( ) ; } catch ( InterruptedException e ) { <START_BUG> assert false ; <END_BUG> } } @ Override public String toString ( ) { return "the<seq2seq4repair_space>blocking" ; } } ) ; final AtomicBoolean executeCalled = new AtomicBoolean ( ) ; final CountDownLatch timedOut = new CountDownLatch ( 1 ) ; executor . execute ( new Runnable ( ) { @ Override public void run ( ) { executeCalled . set ( true ) ; } @ Override public String toString ( ) { return "the<seq2seq4repair_space>waiting" ; } } , timer , TimeValue . timeValueMillis ( 100 ) , new Runnable ( ) { @ Override public void run ( ) { timedOut . countDown ( ) ; } } ) ; PrioritizedEsThreadPoolExecutor [ ] pending = executor . getPending ( ) ; assertThat ( pending . length , equalTo ( 1 ) ) ; assertThat ( pending [ 0 ] . task . toString ( ) , equalTo ( "the<seq2seq4repair_space>waiting" ) ) ; assertThat ( timedOut . await ( 2 , TimeUnit . SECONDS ) , equalTo ( true ) ) ; block . countDown ( ) ; Thread . sleep ( 100 ) ; assertThat ( executeCalled . get ( ) , equalTo ( false ) ) ; timer . shutdownNow ( ) ; executor . shutdownNow ( ) ; } static class AwaitingJob extends PrioritizedRunnable { private final CountDownLatch latch ; private AwaitingJob ( CountDownLatch latch ) { } @ Override public void run ( ) { } } static class Job extends PrioritizedRunnable { private final int result ; private final List < Integer > results ; private final CountDownLatch latch ; Job ( int result , Priority priority , List < Integer > results , CountDownLatch latch ) { } @ Override public void run ( ) { } } static class CallableJob extends PrioritizedCallable < Integer > { private final int result ; private final List < Integer > results ; private final CountDownLatch latch ; CallableJob ( int result , Priority priority , List < Integer > results , CountDownLatch latch ) { } @ Override public Integer call ( ) throws Exception { } } }
public class FsIndexShardGateway extends BlobStoreIndexShardGateway { private final boolean snapshotLock ; @ Inject public FsIndexShardGateway ( ShardId shardId , @ IndexSettings Settings indexSettings , ThreadPool threadPool , IndexGateway fsIndexGateway , IndexShard indexShard , Store store ) { } @ Override public String type ( ) { } @ Override public SnapshotLock obtainSnapshotLock ( ) throws Exception { } public class FsSnapshotLock implements SnapshotLock { private final Lock lock ; public FsSnapshotLock ( Lock lock ) { } @ Override public void release ( ) { try { <START_BUG> lock . release ( ) ; <END_BUG> } catch ( IOException e ) { logger . warn ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>release<seq2seq4repair_space>snapshot<seq2seq4repair_space>lock<seq2seq4repair_space>[{}]" , e , lock ) ; } } } }
public class FileHandle { protected File file ; protected FileType type ; protected FileHandle ( ) { } public FileHandle ( String fileName ) { } public FileHandle ( File file ) { } protected FileHandle ( String fileName , FileType type ) { } protected FileHandle ( File file , FileType type ) { } public String path ( ) { } public String name ( ) { } public String extension ( ) { } public String nameWithoutExtension ( ) { } public String pathWithoutExtension ( ) { } public FileType type ( ) { } public File file ( ) { } public InputStream read ( ) { } public BufferedInputStream read ( int bufferSize ) { } public Reader reader ( ) { } public Reader reader ( String charset ) { } public BufferedReader reader ( int bufferSize ) { } public BufferedReader reader ( int bufferSize , String charset ) { } public String readString ( ) { } public String readString ( String charset ) { } public byte [ ] readBytes ( ) { } private int estimateLength ( ) { } public int readBytes ( byte [ ] bytes , int offset , int size ) { } public OutputStream write ( boolean append ) { } public void write ( InputStream input , boolean append ) { } public Writer writer ( boolean append ) { } public Writer writer ( boolean append , String charset ) { } public void writeString ( String string , boolean append ) { } public void writeString ( String string , boolean append , String charset ) { } public void writeBytes ( byte [ ] bytes , boolean append ) { } public void writeBytes ( byte [ ] bytes , int offset , int length , boolean append ) { } public FileHandle [ ] list ( ) { } public FileHandle [ ] list ( String suffix ) { } public boolean isDirectory ( ) { } public FileHandle child ( String name ) { } public FileHandle sibling ( String name ) { } public FileHandle parent ( ) { } public void mkdirs ( ) { } public boolean exists ( ) { switch ( type ) { case Internal : <START_BUG> if ( file ( ) . exists ( ) ) <END_BUG> return true ; case Classpath : return ( FileHandle . class . getResource ( ( "/" + ( file . getPath ( ) . replace ( '\\' , '/' ) ) ) ) ) != null ; } return file ( ) . exists ( ) ; } public boolean delete ( ) { } public boolean deleteDirectory ( ) { } public void emptyDirectory ( ) { } public void emptyDirectory ( boolean preserveTree ) { } public void copyTo ( FileHandle dest ) { } public void moveTo ( FileHandle dest ) { } public long length ( ) { } public long lastModified ( ) { } @ Override public boolean equals ( Object obj ) { } @ Override public int hashCode ( ) { } public String toString ( ) { } public static FileHandle tempFile ( String prefix ) { } public static FileHandle tempDirectory ( String prefix ) { } private static void emptyDirectory ( File file , boolean preserveTree ) { } private static boolean deleteDirectory ( File file ) { } private static void copyFile ( FileHandle source , FileHandle dest ) { } private static void copyDirectory ( FileHandle sourceDir , FileHandle destDir ) { } }
public class AndroidMultiTouchHandler implements AndroidTouchHandler { public void onTouch ( MotionEvent event , AndroidInput input ) { } private void postTouchEvent ( AndroidInput input , int type , int x , int y , int pointer ) { long timeStamp = System . nanoTime ( ) ; synchronized ( input ) { <START_BUG> TouchEvent event = input . usedTouchEvents . add ( ) ; <END_BUG> event . timeStamp = timeStamp ; event . pointer = pointer ; event . x = x ; event . y = y ; event . type = type ; input . touchEvents . add ( event ) ; } } public boolean supportsMultitouch ( AndroidApplication activity ) { } }
class InheritingState implements State { private final State parent ; private final Map < Key < ? > , Binding < ? > > explicitBindingsMutable = Maps . newLinkedHashMap ( ) ; private final Map < Key < ? > , Binding < ? > > explicitBindings = Collections . unmodifiableMap ( explicitBindingsMutable ) ; private final Map < Class < ? extends Annotation > , Scope > scopes = Maps . newHashMap ( ) ; private final List < MatcherAndConverter > converters = Lists . newArrayList ( ) ; private final List < TypeListenerBinding > listenerBindings = Lists . newArrayList ( ) ; private WeakKeySet blacklistedKeys = new WeakKeySet ( ) ; private final Object lock ; InheritingState ( State parent ) { } public State parent ( ) { } @ SuppressWarnings ( "unchecked" ) public < T > BindingImpl < T > getExplicitBinding ( Key < T > key ) { } public Map < Key < ? > , Binding < ? > > getExplicitBindingsThisLevel ( ) { } public void putBinding ( Key < ? > key , BindingImpl < ? > binding ) { } public Scope getScope ( Class < ? extends Annotation > annotationType ) { } public void putAnnotation ( Class < ? extends Annotation > annotationType , Scope scope ) { } public Iterable < MatcherAndConverter > getConvertersThisLevel ( ) { } public void addConverter ( MatcherAndConverter matcherAndConverter ) { } public MatcherAndConverter getConverter ( String stringValue , TypeLiteral < ? > type , Errors errors , Object source ) { } public void addTypeListener ( TypeListenerBinding listenerBinding ) { } public List < TypeListenerBinding > getTypeListenerBindings ( ) { List < TypeListenerBinding > parentBindings = parent . getTypeListenerBindings ( ) ; <START_BUG> List < TypeListenerBinding > result = new ArrayList < TypeListenerBinding > ( ( ( parentBindings . size ( ) ) + 1 ) ) ; <END_BUG> result . addAll ( parentBindings ) ; result . addAll ( listenerBindings ) ; return result ; } public void blacklist ( Key < ? > key ) { } public boolean isBlacklisted ( Key < ? > key ) { } @ Override public void clearBlacklisted ( ) { } @ Override public void makeAllBindingsToEagerSingletons ( Injector injector ) { } public Object lock ( ) { } }
public class AndroidSingleTouchHandler implements AndroidTouchHandler { public void onTouch ( MotionEvent event , AndroidInput input ) { } private void postTouchEvent ( AndroidInput input , int type , int x , int y , int pointer ) { long timeStamp = System . nanoTime ( ) ; synchronized ( input ) { <START_BUG> TouchEvent event = input . freeTouchEvents . newObject ( ) ; <END_BUG> event . timeStamp = timeStamp ; event . pointer = 0 ; event . x = x ; event . y = y ; event . type = type ; input . touchEvents . add ( event ) ; } } }
public class ScriptFilterParser implements FilterParser { public static final String NAME = "script" ; @ Inject public ScriptFilterParser ( ) { } @ Override public String [ ] names ( ) { } @ Override public Filter parse ( QueryParseContext parseContext ) throws IOException , QueryParsingException { } public static class ScriptFilter extends Filter { private final String script ; private final Map < String , Object > params ; private final SearchScript searchScript ; private ScriptFilter ( String scriptLang , String script , Map < String , Object > params , ScriptService scriptService ) { } @ Override public String toString ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } @ Override public DocIdSet getDocIdSet ( AtomicReaderContext context , Bits acceptDocs ) throws IOException { <START_BUG> searchScript . setNextReader ( context . reader ( ) ) ; <END_BUG> return BitsFilteredDocIdSet . wrap ( new ScriptFilterParser . ScriptFilter . ScriptDocSet ( context . reader ( ) , searchScript ) , acceptDocs ) ; } static class ScriptDocSet extends GetDocSet { private final SearchScript searchScript ; public ScriptDocSet ( IndexReader reader , SearchScript searchScript ) { } @ Override public long sizeInBytes ( ) { } @ Override public boolean isCacheable ( ) { } @ Override public boolean get ( int doc ) { } } } }
public class JdkESLoggerFactory extends ESLoggerFactory { @ Override public ESLogger newInstance ( String prefix , String name ) { final Logger logger = Logger . getLogger ( name ) ; <START_BUG> return new JdkESLogger ( prefix , logger ) ; <END_BUG> } }
public final class HppcMaps { private HppcMaps ( ) { } public static < K , V > ObjectObjectOpenHashMap < K , V > newMap ( int capacity ) { <START_BUG> return new ObjectObjectOpenHashMap < K , V > ( capacity ) ; <END_BUG> } public static < K , V > ObjectObjectOpenHashMap < K , V > newMap ( ) { } public static < K , V > ObjectObjectOpenHashMap < K , V > newNoNullKeysMap ( ) { } public static < K , V > ObjectObjectOpenHashMap < K , V > newNoNullKeysMap ( int capacity ) { } public static < K , V > ObjectObjectOpenHashMap < K , V > ensureNoNullKeys ( int capacity ) { } public static < T > Iterable < T > intersection ( ObjectLookupContainer < T > container1 , final ObjectLookupContainer < T > container2 ) { } public static final class Object { public static final class Integer { public static < V > ObjectIntOpenHashMap < V > ensureNoNullKeys ( int capacity , float loadFactor ) { } } } }
public class SignificantStringTerms extends InternalSignificantTerms { public static final Type TYPE = new Type ( "significant_terms" , "sigsterms" ) ; public static final Stream STREAM = new AggregationStreams . Stream ( ) { @ Override public SignificantStringTerms readResult ( StreamInput in ) throws IOException { } } ; public static void registerStreams ( ) { } public static class Bucket extends InternalSignificantTerms . Bucket { BytesRef termBytes ; public Bucket ( BytesRef term , long subsetDf , long subsetSize , long supersetDf , long supersetSize , InternalAggregations aggregations ) { } @ Override public Text getKeyAsText ( ) { } @ Override public Number getKeyAsNumber ( ) { } @ Override int compareTerm ( SignificantTerms . Bucket other ) { } @ Override public String getKey ( ) { } @ Override SignificantStringTerms . Bucket newBucket ( long subsetDf , long subsetSize , long supersetDf , long supersetSize , InternalAggregations aggregations ) { } } SignificantStringTerms ( ) { } public SignificantStringTerms ( long subsetSize , long supersetSize , String name , int requiredSize , long minDocCount , Collection < InternalSignificantTerms . Bucket > buckets ) { } @ Override public Type type ( ) { } @ Override InternalSignificantTerms newAggregation ( long subsetSize , long supersetSize , List < InternalSignificantTerms . Bucket > buckets ) { <START_BUG> return new SignificantStringTerms ( subsetSize , supersetSize , getName ( ) , requiredSize , supersetSize , buckets ) ; <END_BUG> } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class XContentIndexQueryParser extends AbstractIndexComponent implements IndexQueryParser { public static final class Defaults { public static final String QUERY_PREFIX = "index.queryparser.query" ; public static final String FILTER_PREFIX = "index.queryparser.filter" ; } private ThreadLocal < ThreadLocals . CleanableValue < QueryParseContext > > cache = new ThreadLocal < ThreadLocals . CleanableValue < QueryParseContext > > ( ) { @ Override protected ThreadLocals . CleanableValue < QueryParseContext > initialValue ( ) { } } ; private final String name ; final ScriptService scriptService ; final MapperService mapperService ; final SimilarityService similarityService ; final IndexCache indexCache ; final IndexEngine indexEngine ; private final Map < String , XContentQueryParser > queryParsers ; private final Map < String , XContentFilterParser > filterParsers ; @ Inject public XContentIndexQueryParser ( Index index , @ IndexSettings Settings indexSettings , ScriptService scriptService , MapperService mapperService , IndexCache indexCache , IndexEngine indexEngine , @ Nullable SimilarityService similarityService , @ Nullable Map < String , XContentQueryParserFactory > namedQueryParsers , @ Nullable Map < String , XContentFilterParserFactory > namedFilterParsers , @ Assisted String name , @ Assisted @ Nullable Settings settings ) { } @ Override public String name ( ) { } public XContentQueryParser queryParser ( String name ) { } public XContentFilterParser filterParser ( String name ) { } @ Override public ParsedQuery parse ( QueryBuilder queryBuilder ) throws ElasticSearchException { } @ Override public ParsedQuery parse ( byte [ ] source ) throws ElasticSearchException { } @ Override public ParsedQuery parse ( byte [ ] source , int offset , int length ) throws ElasticSearchException { } @ Override public ParsedQuery parse ( String source ) throws QueryParsingException { } public ParsedQuery parse ( XContentParser parser ) { } public Filter parseInnerFilter ( XContentParser parser ) throws IOException { } public Query parseInnerQuery ( XContentParser parser ) throws IOException { } private ParsedQuery parse ( QueryParseContext parseContext , XContentParser parser ) throws IOException , QueryParsingException { parseContext . reset ( parser ) ; Query query = parseContext . parseInnerQuery ( ) ; <START_BUG> return new ParsedQuery ( query , parseContext . copyNamedFilters ( ) ) ; <END_BUG> } private void add ( Map < String , XContentFilterParser > map , XContentFilterParser filterParser ) { } private void add ( Map < String , XContentQueryParser > map , XContentQueryParser queryParser ) { } }
public class IndicesFilterParser implements FilterParser { public static final String NAME = "indices" ; @ Nullable private final ClusterService clusterService ; @ Inject public IndicesFilterParser ( @ Nullable ClusterService clusterService ) { } @ Override public String [ ] names ( ) { } @ Override public Filter parse ( QueryParseContext parseContext ) throws IOException , QueryParsingException { } protected boolean matchesIndices ( String currentIndex , String ... indices ) { <START_BUG> final String [ ] concreteIndices = clusterService . state ( ) . metaData ( ) . concreteIndices ( indices , IndicesOptions . IGNORE_UNAVAILABLE_EXPAND_OPEN_ONLY ) ; <END_BUG> for ( String index : concreteIndices ) { if ( Regex . simpleMatch ( index , currentIndex ) ) { return true ; } } return false ; } }
public class InternalIndexService extends AbstractIndexComponent implements IndexService { private final Injector injector ; private final Settings indexSettings ; private final NodeEnvironment nodeEnv ; private final ThreadPool threadPool ; private final PluginsService pluginsService ; private final InternalIndicesLifecycle indicesLifecycle ; private final AnalysisService analysisService ; private final MapperService mapperService ; private final IndexQueryParserService queryParserService ; private final SimilarityService similarityService ; private final IndexAliasesService aliasesService ; private final IndexCache indexCache ; private final IndexFieldDataService indexFieldData ; private final IndexEngine indexEngine ; private final IndexGateway indexGateway ; private final IndexStore indexStore ; private final IndexSettingsService settingsService ; private volatile ImmutableMap < Integer , Injector > shardsInjectors = ImmutableMap . of ( ) ; private volatile ImmutableMap < Integer , IndexShard > shards = ImmutableMap . of ( ) ; private volatile boolean closed = false ; @ Inject public InternalIndexService ( Injector injector , Index index , @ IndexSettings Settings indexSettings , NodeEnvironment nodeEnv , ThreadPool threadPool , AnalysisService analysisService , MapperService mapperService , IndexQueryParserService queryParserService , SimilarityService similarityService , IndexAliasesService aliasesService , IndexCache indexCache , IndexEngine indexEngine , IndexGateway indexGateway , IndexStore indexStore , IndexSettingsService settingsService , IndexFieldDataService indexFieldData ) { } @ Override public int numberOfShards ( ) { } @ Override public UnmodifiableIterator < IndexShard > iterator ( ) { } @ Override public boolean hasShard ( int shardId ) { } @ Override public IndexShard shard ( int shardId ) { } @ Override public IndexShard shardSafe ( int shardId ) throws IndexShardMissingException { } @ Override public ImmutableSet < Integer > shardIds ( ) { } @ Override public Injector injector ( ) { } @ Override public IndexGateway gateway ( ) { } @ Override public IndexSettingsService settingsService ( ) { } @ Override public IndexStore store ( ) { } @ Override public IndexCache cache ( ) { } @ Override public IndexFieldDataService fieldData ( ) { } @ Override public AnalysisService analysisService ( ) { } @ Override public MapperService mapperService ( ) { } @ Override public IndexQueryParserService queryParserService ( ) { } @ Override public SimilarityService similarityService ( ) { } @ Override public IndexAliasesService aliasesService ( ) { } @ Override public IndexEngine engine ( ) { } public void close ( final String reason , @ Nullable Executor executor ) { synchronized ( this ) { closed = true ; } Set < Integer > shardIds = shardIds ( ) ; final CountDownLatch latch = new CountDownLatch ( shardIds . size ( ) ) ; for ( final int shardId : shardIds ) { executor = ( executor == null ) ? threadPool . generic ( ) : executor ; executor . execute ( new Runnable ( ) { @ Override public void run ( ) { try { removeShard ( shardId , reason ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> logger . warn ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>close<seq2seq4repair_space>shard" , e ) ; } finally { latch . countDown ( ) ; } } } ) ; } try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new org . elasticsearch . ElasticSearchInterruptedException ( ( ( "interrupted<seq2seq4repair_space>closing<seq2seq4repair_space>index<seq2seq4repair_space>[<seq2seq4repair_space>" + ( index ( ) . name ( ) ) ) + "]" ) , e ) ; } } @ Override public Injector shardInjector ( int shardId ) throws ElasticSearchException { } @ Override public Injector shardInjectorSafe ( int shardId ) throws IndexShardMissingException { } @ Override public synchronized IndexShard createShard ( int sShardId ) throws ElasticSearchException { } @ Override public synchronized void removeShard ( int shardId , String reason ) throws ElasticSearchException { } }
public abstract class HasChildFilter extends Filter implements ScopePhase . CollectorPhase { final Query childQuery ; final String scope ; final String parentType ; final String childType ; final SearchContext searchContext ; protected HasChildFilter ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext ) { } public Query query ( ) { } public String scope ( ) { } @ Override public String toString ( ) { } public static HasChildFilter create ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext , String executionType ) { } static class Bitset extends HasChildFilter { private Map < Object , FixedBitSet > parentDocs ; public Bitset ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext ) { } public boolean requiresProcessing ( ) { } public Collector collector ( ) { } public void processCollector ( Collector collector ) { } public void clear ( ) { } public DocIdSet getDocIdSet ( AtomicReaderContext context , Bits acceptDocs ) throws IOException { } } static class Uid extends HasChildFilter { THashSet < HashedBytesArray > collectedUids ; Uid ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext ) { } public boolean requiresProcessing ( ) { } public Collector collector ( ) { } public void processCollector ( Collector collector ) { } public DocIdSet getDocIdSet ( AtomicReaderContext context , Bits acceptDocs ) throws IOException { } public void clear ( ) { } static class ParentDocSet extends GetDocSet { final IndexReader reader ; final THashSet < HashedBytesArray > parents ; final IdReaderTypeCache typeCache ; final Bits acceptDocs ; ParentDocSet ( IndexReader reader , THashSet < HashedBytesArray > parents , IdReaderTypeCache typeCache , Bits acceptDocs ) { } public boolean get ( int doc ) { <START_BUG> return ( ! ( acceptDocs . get ( doc ) ) ) && ( parents . contains ( typeCache . idByDoc ( doc ) ) ) ; <END_BUG> } } static class UidCollector extends NoopCollector { final String parentType ; final SearchContext context ; final THashSet < HashedBytesArray > collectedUids ; private IdReaderTypeCache typeCache ; UidCollector ( String parentType , SearchContext context , THashSet < HashedBytesArray > collectedUids ) { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext readerContext ) throws IOException { } } } }
public abstract class ScoreFunction { private final CombineFunction scoreCombiner ; public abstract void setNextReader ( AtomicReaderContext context ) { } public abstract double score ( int docId , float subQueryScore ) { } <START_BUG> public abstract Explanation explainScore ( int docId , Explanation subQueryExpl ) ; <END_BUG> public CombineFunction getDefaultScoreCombiner ( ) { } protected ScoreFunction ( CombineFunction scoreCombiner ) { } }
public final class Dependency < T > { private final InjectionPoint injectionPoint ; private final Key < T > key ; private final boolean nullable ; private final int parameterIndex ; Dependency ( InjectionPoint injectionPoint , Key < T > key , boolean nullable , int parameterIndex ) { } public static < T > Dependency < T > get ( Key < T > key ) { <START_BUG> return new Dependency < T > ( null , key , true , ( - 1 ) ) ; <END_BUG> } public static Set < Dependency < ? > > forInjectionPoints ( Set < InjectionPoint > injectionPoints ) { } public Key < T > getKey ( ) { } public boolean isNullable ( ) { } public InjectionPoint getInjectionPoint ( ) { } public int getParameterIndex ( ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public String toString ( ) { } }
public class SizeByAction extends RelativeTemporalAction { private float amountWidth ; private float amountHeight ; protected void updateRelative ( float percentDelta ) { <START_BUG> actor . size ( ( ( amountWidth ) * percentDelta ) , ( ( amountHeight ) * percentDelta ) ) ; <END_BUG> } public void setAmount ( float width , float height ) { } public float getAmountWidth ( ) { } public void setAmountWidth ( float width ) { } public float getAmountHeight ( ) { } public void setAmountHeight ( float height ) { } }
public class Tree extends WidgetGroup { Tree . TreeStyle style ; final Array < Tree . Node > rootNodes = new Array ( ) ; final Array < Tree . Node > selectedNodes = new Array ( ) ; float ySpacing = 4 ; float iconSpacing = 2 ; float padding = 0 ; float indentSpacing ; private float leftColumnWidth ; private float prefWidth ; private float prefHeight ; private boolean sizeInvalid = true ; boolean multiSelect = true ; private Tree . Node foundNode ; Tree . Node overNode ; private ClickListener clickListener ; public Tree ( Skin skin ) { } public Tree ( Skin skin , String styleName ) { } public Tree ( Tree . TreeStyle style ) { } private void initialize ( ) { } public void setStyle ( Tree . TreeStyle style ) { } public void add ( Tree . Node node ) { } public void insert ( int index , Tree . Node node ) { } public void remove ( Tree . Node node ) { } public void clear ( ) { } public Array < Tree . Node > getNodes ( ) { } public void invalidate ( ) { } private void computeSize ( ) { } private void computeSize ( Array < Tree . Node > nodes , float indent ) { } public void layout ( ) { if ( sizeInvalid ) computeSize ( ) ; <START_BUG> layout ( rootNodes , ( ( leftColumnWidth ) + ( indentSpacing ) ) , ( ( getHeight ( ) ) - ( ( ySpacing ) / 2 ) ) ) ; <END_BUG> } private float layout ( Array < Tree . Node > nodes , float indent , float y ) { } public void draw ( SpriteBatch batch , float parentAlpha ) { } private void draw ( SpriteBatch batch , Array < Tree . Node > nodes , float indent ) { } public Tree . Node getNodeAt ( float y ) { } private float getNodeAt ( Array < Tree . Node > nodes , float y , float rowY ) { } void selectNodes ( Array < Tree . Node > nodes , float low , float high ) { } public Array < Tree . Node > getSelection ( ) { } public void setSelection ( Tree . Node node ) { } public void setSelection ( Array < Tree . Node > nodes ) { } public void addSelection ( Tree . Node node ) { } public void clearSelection ( ) { } public Tree . TreeStyle getStyle ( ) { } public Array < Tree . Node > getRootNodes ( ) { } public Tree . Node getOverNode ( ) { } public void setOverNode ( Tree . Node overNode ) { } public void setPadding ( float padding ) { } public void setYSpacing ( float ySpacing ) { } public void setIconSpacing ( float iconSpacing ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public Tree . Node findNode ( Object object ) { } static Tree . Node findNode ( Array < Tree . Node > nodes , Object object ) { } public void collapseAll ( ) { } static void collapseAll ( Array < Tree . Node > nodes ) { } public void expandAll ( ) { } static void expandAll ( Array < Tree . Node > nodes ) { } public ClickListener getClickListener ( ) { } public void setMultiSelect ( boolean multiSelect ) { } public static class Node { Actor actor ; Tree . Node parent ; final Array < Tree . Node > children = new Array ( 0 ) ; boolean selectable = true ; boolean expanded ; Drawable icon ; float height ; Object object ; public Node ( Actor actor ) { } public void setExpanded ( boolean expanded ) { } protected void addToTree ( Tree tree ) { } protected void removeFromTree ( Tree tree ) { } public void add ( Tree . Node node ) { } public void addAll ( Array < Tree . Node > nodes ) { } public void insert ( int index , Tree . Node node ) { } public void remove ( ) { } public void remove ( Tree . Node node ) { } public void removeAll ( ) { } public Tree getTree ( ) { } public Actor getActor ( ) { } public boolean isExpanded ( ) { } public Array < Tree . Node > getChildren ( ) { } public Tree . Node getParent ( ) { } public void setIcon ( Drawable icon ) { } public Object getObject ( ) { } public void setObject ( Object object ) { } public Drawable getIcon ( ) { } public Tree . Node findNode ( Object object ) { } public void collapseAll ( ) { } public void expandAll ( ) { } public void expandTo ( ) { } public boolean isSelectable ( ) { } public void setSelectable ( boolean selectable ) { } } public static class TreeStyle { public Drawable plus ; public Drawable minus ; public Drawable over ; public Drawable selection ; public Drawable background ; public TreeStyle ( ) { } public TreeStyle ( Drawable plus , Drawable minus , Drawable selection ) { } public TreeStyle ( Tree . TreeStyle style ) { } } }
public class CubemapAttribute extends Attribute { public static final String EnvironmentMapAlias = "environmentMapTexture" ; public static final long EnvironmentMap = register ( CubemapAttribute . EnvironmentMapAlias ) ; protected static long Mask = CubemapAttribute . EnvironmentMap ; public static final boolean is ( final long mask ) { } public final TextureDescriptor < Cubemap > textureDescription ; public CubemapAttribute ( final long type ) { } public < T extends Cubemap > CubemapAttribute ( final long type , final TextureDescriptor < T > textureDescription ) { } public CubemapAttribute ( final long type , final Cubemap texture ) { } public CubemapAttribute ( final CubemapAttribute copyFrom ) { } @ Override public Attribute copy ( ) { } @ Override public int hashCode ( ) { <START_BUG> int result = super . hashCode ( ) ; <END_BUG> result = ( 967 * result ) + ( textureDescription . hashCode ( ) ) ; return result ; } }
public class SoundTest extends GdxTest { Sound sound ; float volume = 0.5F ; long soundId = 0 ; Stage ui ; BitmapFont font ; SpriteBatch batch ; @ Override public void create ( ) { sound = audio . newSound ( files . getFileHandle ( "data/shotgun.wav" , Internal ) ) ; Skin skin = new Skin ( files . internal ( "data/uiskin.json" ) , files . internal ( "data/uiskin.png" ) ) ; ui = new Stage ( graphics . getWidth ( ) , graphics . getHeight ( ) , true ) ; Button play = new Button ( "Play" , skin ) ; Button stop = new Button ( "Stop" , skin ) ; final Slider pitch = new Slider ( 0.1F , 4 , 0.1F , skin ) ; pitch . setValue ( 1 ) ; final Label pitchValue = new Label ( "1.0" , skin ) ; final Slider volume = new Slider ( 0.1F , 1 , 0.1F , skin ) ; volume . setValue ( 1 ) ; final Label volumeValue = new Label ( "1.0" , skin ) ; Table table = new Table ( ) ; final Slider pan = new Slider ( ( - 1.0F ) , 1.0F , 0.1F , skin ) ; pan . setValue ( 0 ) ; final Label panValue = new Label ( "0.0" , skin ) ; table . width = graphics . getWidth ( ) ; table . height = graphics . getHeight ( ) ; table . align ( ( ( Align . CENTER ) | ( Align . TOP ) ) ) ; table . add ( play ) ; table . add ( stop ) ; table . row ( ) ; table . add ( new Label ( "Pitch" , skin ) ) ; table . add ( pitch ) ; table . add ( pitchValue ) ; table . row ( ) ; table . add ( new Label ( "Volume" , skin ) ) ; table . add ( volume ) ; table . add ( volumeValue ) ; table . row ( ) ; table . add ( new Label ( "Pan" , skin ) ) ; table . add ( pan ) ; table . add ( panValue ) ; ui . addActor ( table ) ; play . setClickListener ( new ClickListener ( ) { @ Override public void click ( Actor actor ) { <START_BUG> soundId = sound . play ( ) ; <END_BUG> sound . setPitch ( soundId , pitch . getValue ( ) ) ; sound . setPan ( soundId , pan . getValue ( ) , volume . getValue ( ) ) ; } } ) ; stop . setClickListener ( new ClickListener ( ) { @ Override public void click ( Actor actor ) { sound . stop ( soundId ) ; } } ) ; pitch . setValueChangedListener ( new ValueChangedListener ( ) { @ Override public void changed ( Slider slider , float value ) { sound . setPitch ( soundId , value ) ; pitchValue . setText ( ( "" + value ) ) ; } } ) ; volume . setValueChangedListener ( new ValueChangedListener ( ) { @ Override public void changed ( Slider slider , float value ) { sound . setVolume ( soundId , value ) ; volumeValue . setText ( ( "" + value ) ) ; } } ) ; pan . setValueChangedListener ( new ValueChangedListener ( ) { @ Override public void changed ( Slider slider , float value ) { sound . setPan ( soundId , value , volume . getValue ( ) ) ; panValue . setText ( ( "" + value ) ) ; } } ) ; input . setInputProcessor ( ui ) ; } @ Override public void render ( ) { } @ Override public boolean needsGL20 ( ) { } }
public class DashboardIssueFragment extends PagedItemFragment < RepositoryIssue > { public static final String ARG_FILTER = "filter" ; @ Inject private IssueService service ; @ Inject private IssueStore store ; @ Inject private AvatarLoader avatars ; private Map < String , String > filterData ; @ SuppressWarnings ( "unchecked" ) @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode == ( RequestCodes . ISSUE_VIEW ) ) { <START_BUG> getListAdapter ( ) . getWrappedAdapter ( ) . notifyDataSetChanged ( ) ; <END_BUG> forceRefresh ( ) ; return ; } super . onActivityResult ( requestCode , resultCode , data ) ; } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override protected ResourcePager < RepositoryIssue > createPager ( ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected int getErrorMessage ( Exception exception ) { } @ Override protected SingleTypeAdapter < RepositoryIssue > createAdapter ( List < RepositoryIssue > items ) { } }
@ ClusterScope ( scope = Scope . TEST , numNodes = 0 ) public class IndicesLifecycleListenerTests extends ElasticsearchIntegrationTest { @ Test public void testIndexStateShardChanged ( ) throws Throwable { } private static void assertShardStatesMatch ( final IndicesLifecycleListenerTests . IndexShardStateChangeListener stateChangeListener , final int numShards , final IndexShardState ... shardStates ) throws InterruptedException { } private static class IndexShardStateChangeListener extends IndicesLifecycle . Listener { final ConcurrentMap < ShardId , List < IndexShardState > > shardStates = Maps . newConcurrentMap ( ) ; @ Override public void indexShardStateChanged ( IndexShard indexShard , @ Nullable IndexShardState previousState , IndexShardState newState , @ Nullable String reason ) { <START_BUG> List < IndexShardState > shardStates = this . shardStates . putIfAbsent ( indexShard . shardId ( ) , new CopyOnWriteArrayList < IndexShardState > ( new IndexShardState [ ] { newState } ) ) ; <END_BUG> if ( shardStates != null ) { shardStates . add ( newState ) ; } } @ Override public String toString ( ) { } } }
public class AndroidMultiTouchHandler implements AndroidTouchHandler { public void onTouch ( MotionEvent event , AndroidInput input ) { } private void postTouchEvent ( AndroidInput input , int type , int x , int y , int pointer ) { long timeStamp = System . nanoTime ( ) ; synchronized ( input ) { <START_BUG> TouchEvent event = input . freeTouchEvents . newObject ( ) ; <END_BUG> event . timeStamp = timeStamp ; event . pointer = pointer ; event . x = x ; event . y = y ; event . type = type ; input . touchEvents . add ( event ) ; } } public boolean supportsMultitouch ( AndroidApplication activity ) { } }
public class GwtTestWrapper extends GdxTest { Stage ui ; Table container ; Skin skin ; BitmapFont font ; GdxTest test ; boolean dispose = false ; @ Override public void create ( ) { } public void render ( ) { } public void resize ( int width , int height ) { <START_BUG> ui . getViewport ( ) . update ( width , height ) ; <END_BUG> container . setSize ( width , height ) ; if ( ( test ) != null ) { test . resize ( width , height ) ; } } class InputWrapper extends InputAdapter implements Input { Input input ; InputProcessor lastProcessor ; InputMultiplexer multiplexer ; public InputWrapper ( Input input ) { } @ Override public float getAccelerometerX ( ) { } @ Override public float getAccelerometerY ( ) { } @ Override public float getAccelerometerZ ( ) { } @ Override public int getX ( ) { } @ Override public int getX ( int pointer ) { } @ Override public int getDeltaX ( ) { } @ Override public int getDeltaX ( int pointer ) { } @ Override public int getY ( ) { } @ Override public int getY ( int pointer ) { } @ Override public int getDeltaY ( ) { } @ Override public int getDeltaY ( int pointer ) { } @ Override public boolean isTouched ( ) { } @ Override public boolean justTouched ( ) { } @ Override public boolean isTouched ( int pointer ) { } @ Override public boolean isButtonPressed ( int button ) { } @ Override public boolean isKeyPressed ( int key ) { } @ Override public void getTextInput ( TextInputListener listener , String title , String text ) { } @ Override public void getPlaceholderTextInput ( TextInputListener listener , String title , String placeholder ) { } @ Override public void setOnscreenKeyboardVisible ( boolean visible ) { } @ Override public void vibrate ( int milliseconds ) { } @ Override public void vibrate ( long [ ] pattern , int repeat ) { } @ Override public void cancelVibrate ( ) { } @ Override public float getAzimuth ( ) { } @ Override public float getPitch ( ) { } @ Override public float getRoll ( ) { } @ Override public void getRotationMatrix ( float [ ] matrix ) { } @ Override public long getCurrentEventTime ( ) { } @ Override public void setCatchBackKey ( boolean catchBack ) { } @ Override public void setCatchMenuKey ( boolean catchMenu ) { } @ Override public void setInputProcessor ( InputProcessor processor ) { } @ Override public InputProcessor getInputProcessor ( ) { } @ Override public boolean isPeripheralAvailable ( Peripheral peripheral ) { } @ Override public int getRotation ( ) { } @ Override public Orientation getNativeOrientation ( ) { } @ Override public void setCursorCatched ( boolean catched ) { } @ Override public boolean isCursorCatched ( ) { } @ Override public void setCursorPosition ( int x , int y ) { } @ Override public void setCursorImage ( Pixmap pixmap , int xHotspot , int yHotspot ) { } } interface Instancer { public GdxTest instance ( ) { } } GwtTestWrapper . Instancer [ ] tests = new GwtTestWrapper . Instancer [ ] { new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } } , new GwtTestWrapper . Instancer ( ) { public GdxTest instance ( ) { } }
public interface IReflectionCache { public Collection < Type > getKnownTypes ( ) { } public Type forName ( String name ) { } <START_BUG> public Object newArray ( Type componentType , int size ) ; <END_BUG> public int getArrayLength ( Type type , Object obj ) { } public Object getArrayElement ( Type type , Object obj , int i ) { } public void setArrayElement ( Type type , Object obj , int i , Object value ) { } public Object get ( Field field , Object obj ) throws IllegalAccessException { } public void set ( Field field , Object obj , Object value ) throws IllegalAccessException { } public Object invoke ( Method m , Object obj , Object [ ] params ) { } }
public final class BytesRefValComparator extends NestedWrappableComparator < BytesRef > { private final IndexFieldData < ? > indexFieldData ; private final SortMode sortMode ; private final BytesRef missingValue ; private final BytesRef [ ] values ; private BytesRef bottom ; private BytesValues docTerms ; BytesRefValComparator ( IndexFieldData < ? > indexFieldData , int numHits , SortMode sortMode , BytesRef missingValue ) { } @ Override public int compare ( int slot1 , int slot2 ) { } @ Override public int compareBottom ( int doc ) throws IOException { } @ Override public void copy ( int slot , int doc ) throws IOException { } @ Override public FieldComparator < BytesRef > setNextReader ( AtomicReaderContext context ) throws IOException { <START_BUG> docTerms = indexFieldData . load ( context ) . getBytesValues ( ) ; <END_BUG> if ( docTerms . isMultiValued ( ) ) { docTerms = new BytesRefValComparator . MultiValuedBytesWrapper ( docTerms , sortMode ) ; } return this ; } @ Override public void setBottom ( final int bottom ) { } @ Override public BytesRef value ( int slot ) { } @ Override public int compareValues ( BytesRef val1 , BytesRef val2 ) { } @ Override public int compareDocToValue ( int doc , BytesRef value ) { } private static final class MultiValuedBytesWrapper extends FilterBytesValues { private final SortMode sortMode ; private int numValues ; public MultiValuedBytesWrapper ( BytesValues delegate , SortMode sortMode ) { } @ Override public BytesRef getValue ( int docId ) { } public int setDocument ( int docId ) { } public BytesRef nextValue ( ) { } } @ Override public void missing ( int slot ) { } @ Override public int compareBottomMissing ( ) { } }
public class JglfwInput implements Input { JglfwApplication app ; InputProcessor processor ; int pressedKeys = 0 ; boolean justTouched ; int deltaX ; int deltaY ; public JglfwInput ( final JglfwApplication app ) { } public void update ( ) { } public float getAccelerometerX ( ) { } public float getAccelerometerY ( ) { } public float getAccelerometerZ ( ) { } public int getX ( ) { } public int getX ( int pointer ) { } public int getY ( ) { <START_BUG> return ( ( app . graphics . getHeight ( ) ) - 1 ) - ( glfwGetCursorPosY ( app . graphics . window ) ) ; <END_BUG> } public int getY ( int pointer ) { } public int getDeltaX ( ) { } public int getDeltaX ( int pointer ) { } public int getDeltaY ( ) { } public int getDeltaY ( int pointer ) { } public boolean isTouched ( ) { } public boolean isTouched ( int pointer ) { } public boolean justTouched ( ) { } public boolean isButtonPressed ( int button ) { } public boolean isKeyPressed ( int key ) { } public void getTextInput ( final TextInputListener listener , final String title , final String text ) { } public void getPlaceholderTextInput ( final TextInputListener listener , final String title , final String placeholder ) { } public void setOnscreenKeyboardVisible ( boolean visible ) { } public void vibrate ( int milliseconds ) { } public void vibrate ( long [ ] pattern , int repeat ) { } public void cancelVibrate ( ) { } public float getAzimuth ( ) { } public float getPitch ( ) { } public float getRoll ( ) { } public void getRotationMatrix ( float [ ] matrix ) { } public long getCurrentEventTime ( ) { } public void setCatchBackKey ( boolean catchBack ) { } public void setCatchMenuKey ( boolean catchMenu ) { } public void setInputProcessor ( InputProcessor processor ) { } public InputProcessor getInputProcessor ( ) { } public boolean isPeripheralAvailable ( Peripheral peripheral ) { } public int getRotation ( ) { } public Orientation getNativeOrientation ( ) { } public void setCursorCatched ( boolean captured ) { } public boolean isCursorCatched ( ) { } public void setCursorPosition ( int x , int y ) { } public static int getGdxKeyCode ( int lwjglKeyCode ) { } public static int getJglfwKeyCode ( int gdxKeyCode ) { } }
public class MatchQuery { public static enum Type { BOOLEAN , PHRASE , PHRASE_PREFIX ; } public static enum ZeroTermsQuery { NONE , ALL ; } protected final QueryParseContext parseContext ; protected String analyzer ; protected Occur occur = Occur . SHOULD ; protected boolean enablePositionIncrements = true ; protected int phraseSlop = 0 ; protected String fuzziness = null ; protected int fuzzyPrefixLength = FuzzyQuery . defaultPrefixLength ; protected int maxExpansions = FuzzyQuery . defaultMaxExpansions ; protected boolean transpositions = false ; protected RewriteMethod rewriteMethod ; protected RewriteMethod fuzzyRewriteMethod ; protected boolean lenient ; protected MatchQuery . ZeroTermsQuery zeroTermsQuery = MatchQuery . ZeroTermsQuery . NONE ; protected Float commonTermsCutoff = null ; public MatchQuery ( QueryParseContext parseContext ) { } public void setAnalyzer ( String analyzer ) { } public void setOccur ( BooleanClause . Occur occur ) { } public void setCommonTermsCutoff ( float cutoff ) { } public void setEnablePositionIncrements ( boolean enablePositionIncrements ) { } public void setPhraseSlop ( int phraseSlop ) { } public void setFuzziness ( String fuzziness ) { } public void setFuzzyPrefixLength ( int fuzzyPrefixLength ) { } public void setMaxExpansions ( int maxExpansions ) { } public void setTranspositions ( boolean transpositions ) { } public void setRewriteMethod ( MultiTermQuery . RewriteMethod rewriteMethod ) { } public void setFuzzyRewriteMethod ( MultiTermQuery . RewriteMethod fuzzyRewriteMethod ) { } public void setLenient ( boolean lenient ) { } public void setZeroTermsQuery ( MatchQuery . ZeroTermsQuery zeroTermsQuery ) { } public Query parse ( MatchQuery . Type type , String fieldName , Object value ) throws IOException { } private Query newTermQuery ( @ Nullable FieldMapper mapper , Term term ) { } private static BytesRef termToByteRef ( CharTermAttribute attr ) { } protected Query zeroTermsQuery ( ) { <START_BUG> return ( zeroTermsQuery ) == ( MatchQuery . ZeroTermsQuery . NONE ) ? MatchNoDocsQuery . INSTANCE : Queries . MATCH_ALL_QUERY ; <END_BUG> } }
public class ObjectFloatMap < K > { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; public int size ; K [ ] keyTable ; float [ ] valueTable ; int capacity ; int stashSize ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private ObjectFloatMap . Entries entries1 ; private ObjectFloatMap . Entries entries2 ; private ObjectFloatMap . Values values1 ; private ObjectFloatMap . Values values2 ; private ObjectFloatMap . Keys keys1 ; private ObjectFloatMap . Keys keys2 ; public ObjectFloatMap ( ) { } public ObjectFloatMap ( int initialCapacity ) { } public ObjectFloatMap ( int initialCapacity , float loadFactor ) { } public ObjectFloatMap ( ObjectFloatMap < ? extends K > map ) { } public void put ( K key , float value ) { } public void putAll ( ObjectFloatMap < K > map ) { } private void putResize ( K key , float value ) { } private void push ( K insertKey , float insertValue , int index1 , K key1 , int index2 , K key2 , int index3 , K key3 ) { } private void putStash ( K key , float value ) { } public float get ( K key , float defaultValue ) { } private float getStash ( K key , float defaultValue ) { } public float getAndIncrement ( K key , float defaultValue , float increment ) { } private float getAndIncrementStash ( K key , float defaultValue , float increment ) { } public float remove ( K key , float defaultValue ) { } float removeStash ( K key , float defaultValue ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean containsValue ( float value ) { } public boolean containsKey ( K key ) { } private boolean containsKeyStash ( K key ) { } public K findKey ( float value ) { } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public ObjectFloatMap . Entries < K > entries ( ) { } public ObjectFloatMap . Values values ( ) { } public ObjectFloatMap . Keys < K > keys ( ) { } public static class Entry < K > { public K key ; public float value ; public String toString ( ) { } } private static class MapIterator < K > { public boolean hasNext ; final ObjectFloatMap < K > map ; int nextIndex ; int currentIndex ; boolean valid = true ; public MapIterator ( ObjectFloatMap < K > map ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { if ( ( currentIndex ) < 0 ) throw new IllegalStateException ( "next<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>called<seq2seq4repair_space>before<seq2seq4repair_space>remove." ) ; if ( ( currentIndex ) >= ( map . capacity ) ) { map . removeStashIndex ( currentIndex ) ; <START_BUG> nextIndex = ( currentIndex ) - 1 ; <END_BUG> findNextIndex ( ) ; } else { map . keyTable [ currentIndex ] = null ; } currentIndex = - 1 ; ( map . size ) -- ; } } public static class Entries < K > extends ObjectFloatMap . MapIterator < K > implements Iterable < ObjectFloatMap . Entry < K > > , Iterator < ObjectFloatMap . Entry < K > > { private ObjectFloatMap . Entry < K > entry = new ObjectFloatMap . Entry ( ) ; public Entries ( ObjectFloatMap < K > map ) { } public ObjectFloatMap . Entry < K > next ( ) { } public boolean hasNext ( ) { } public Iterator < ObjectFloatMap . Entry < K > > iterator ( ) { } } public static class Values extends ObjectFloatMap . MapIterator < Object > { public Values ( ObjectFloatMap < ? > map ) { } public boolean hasNext ( ) { } public float next ( ) { } public FloatArray toArray ( ) { } } public static class Keys < K > extends ObjectFloatMap . MapIterator < K > implements Iterable < K > , Iterator < K > { public Keys ( ObjectFloatMap < K > map ) { } public boolean hasNext ( ) { } public K next ( ) { } public Iterator < K > iterator ( ) { } public Array < K > toArray ( ) { } } }
public class TransportPercolateAction extends TransportSingleCustomOperationAction < PercolateRequest , PercolateResponse > { private final IndicesService indicesService ; @ Inject public TransportPercolateAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected PercolateRequest newRequest ( ) { } @ Override protected PercolateResponse newResponse ( ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected ShardsIterator shards ( ClusterState clusterState , PercolateRequest request ) { } @ Override protected PercolateResponse shardOperation ( PercolateRequest request , int shardId ) throws ElasticSearchException { IndexService indexService = indicesService . indexServiceSafe ( request . index ( ) ) ; PercolatorService percolatorService = indexService . percolateService ( ) ; <START_BUG> PercolatorExecutor . Response percolate = percolatorService . percolate ( new PercolatorExecutor . SourceRequest ( request . type ( ) , request . source ( ) ) ) ; <END_BUG> return new PercolateResponse ( percolate . matches ( ) ) ; } }
public class MoreLikeThisRequest implements ActionRequest { private static final XContentType contentType = Requests . CONTENT_TYPE ; private String index ; private String type ; private String id ; private String [ ] fields ; private float percentTermsToMatch = - 1 ; private int minTermFreq = - 1 ; private int maxQueryTerms = - 1 ; private String [ ] stopWords = null ; private int minDocFreq = - 1 ; private int maxDocFreq = - 1 ; private int minWordLen = - 1 ; private int maxWordLen = - 1 ; private float boostTerms = - 1 ; private SearchType searchType = SearchType . DEFAULT ; private String searchQueryHint ; private String [ ] searchIndices ; private String [ ] searchTypes ; private Scroll searchScroll ; private byte [ ] searchSource ; private int searchSourceOffset ; private int searchSourceLength ; private boolean searchSourceUnsafe ; private boolean threadedListener = false ; MoreLikeThisRequest ( ) { } public MoreLikeThisRequest ( String index ) { } public String index ( ) { } public String type ( ) { } void index ( String index ) { } @ Required public MoreLikeThisRequest type ( String type ) { } public String id ( ) { } @ Required public MoreLikeThisRequest id ( String id ) { } public String [ ] fields ( ) { } public MoreLikeThisRequest fields ( String ... fields ) { } public MoreLikeThisRequest percentTermsToMatch ( float percentTermsToMatch ) { } public float percentTermsToMatch ( ) { } public MoreLikeThisRequest minTermFreq ( int minTermFreq ) { } public int minTermFreq ( ) { } public MoreLikeThisRequest maxQueryTerms ( int maxQueryTerms ) { } public int maxQueryTerms ( ) { } public MoreLikeThisRequest stopWords ( String ... stopWords ) { } public String [ ] stopWords ( ) { } public MoreLikeThisRequest minDocFreq ( int minDocFreq ) { } public int minDocFreq ( ) { } public MoreLikeThisRequest maxDocFreq ( int maxDocFreq ) { } public int maxDocFreq ( ) { } public MoreLikeThisRequest minWordLen ( int minWordLen ) { } public int minWordLen ( ) { } public MoreLikeThisRequest maxWordLen ( int maxWordLen ) { } public int maxWordLen ( ) { } public MoreLikeThisRequest boostTerms ( float boostTerms ) { } public float boostTerms ( ) { } void beforeLocalFork ( ) { if ( searchSourceUnsafe ) { <START_BUG> searchSource = Arrays . copyOfRange ( searchSource , searchSourceOffset , searchSourceLength ) ; <END_BUG> searchSourceOffset = 0 ; searchSourceUnsafe = false ; } } public MoreLikeThisRequest searchSource ( SearchSourceBuilder sourceBuilder ) { } public MoreLikeThisRequest searchSource ( String searchSource ) { } public MoreLikeThisRequest searchSource ( Map searchSource ) { } public MoreLikeThisRequest searchSource ( XContentBuilder builder ) { } public MoreLikeThisRequest searchSource ( byte [ ] searchSource ) { } public MoreLikeThisRequest searchSource ( byte [ ] searchSource , int offset , int length , boolean unsafe ) { } public byte [ ] searchSource ( ) { } public int searchSourceOffset ( ) { } public int searchSourceLength ( ) { } public boolean searchSourceUnsafe ( ) { } public MoreLikeThisRequest searchType ( SearchType searchType ) { } public MoreLikeThisRequest searchType ( String searchType ) throws ElasticSearchIllegalArgumentException { } public SearchType searchType ( ) { } public MoreLikeThisRequest searchIndices ( String ... searchIndices ) { } public String [ ] searchIndices ( ) { } public MoreLikeThisRequest searchTypes ( String ... searchTypes ) { } public String [ ] searchTypes ( ) { } public MoreLikeThisRequest searchQueryHint ( String searchQueryHint ) { } public String searchQueryHint ( ) { } public MoreLikeThisRequest searchScroll ( Scroll searchScroll ) { } public Scroll searchScroll ( ) { } @ Override public ActionRequestValidationException validate ( ) { } @ Override public boolean listenerThreaded ( ) { } @ Override public ActionRequest listenerThreaded ( boolean listenerThreaded ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } }
public abstract class GwtApplication implements Application , EntryPoint { private ApplicationListener listener ; private GwtApplicationConfiguration config ; private GwtGraphics graphics ; private Panel root = null ; private TextArea log = null ; private int logLevel = LOG_ERROR ; private Array < Runnable > runnables = new Array < Runnable > ( ) ; private int lastWidth ; private int lastHeight ; private Preloader preloader ; private static GwtApplication . AgentInfo agentInfo ; private ObjectMap < String , Preferences > prefs = new ObjectMap < String , Preferences > ( ) ; @ Override public void onModuleLoad ( ) { } private void setupLoop ( ) { } public abstract GwtApplicationConfiguration getConfig ( ) { } public abstract ApplicationListener getApplicationListener ( ) { } public Panel getRootPanel ( ) { } public PreloaderCallback getPreloaderCallback ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Input getInput ( ) { } @ Override public Files getFiles ( ) { } private void checkLogLabel ( ) { } @ Override public void log ( String tag , String message ) { } @ Override public void log ( String tag , String message , Exception exception ) { } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } private String getStackTrace ( Throwable e ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } @ Override public Preferences getPreferences ( String name ) { Preferences pref = prefs . get ( name ) ; if ( pref == null ) { <START_BUG> pref = new GwtPreferences ( ) ; <END_BUG> prefs . put ( name , pref ) ; } return pref ; } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void exit ( ) { } public static GwtApplication . AgentInfo agentInfo ( ) { } private static native GwtApplication . AgentInfo computeAgentInfo ( ) { } public static class AgentInfo extends JavaScriptObject { public final native boolean isFirefox ( ) { } public final native boolean isChrome ( ) { } public final native boolean isSafari ( ) { } public final native boolean isOpera ( ) { } public final native boolean isIE ( ) { } public final native boolean isMacOS ( ) { } public final native boolean isLinux ( ) { } public final native boolean isWindows ( ) { } protected AgentInfo ( ) { } } }
public interface Indexer extends IndexerComponent { <START_BUG> void close ( boolean delete ) ; <END_BUG> }
public final class SortedSetDVBytesAtomicFieldData extends SortedSetDVAtomicFieldData implements AtomicFieldData . WithOrdinals < ScriptDocValues . Strings > { SortedSetDVBytesAtomicFieldData ( AtomicReader reader , String field ) { } @ Override public Strings getScriptValues ( ) { <START_BUG> return new ScriptDocValues . Strings ( getBytesValues ( false ) ) ; <END_BUG> } }
public class Box2DCharacterControllerTest extends GdxTest implements ApplicationListener { static final float MAX_VELOCITY = 14.0F ; boolean jump = false ; World world ; Body player ; Fixture playerPhysicsFixture ; Fixture playerSensorFixture ; OrthographicCamera cam ; Box2DDebugRenderer renderer ; Array < Box2DCharacterControllerTest . Platform > platforms = new Array < Box2DCharacterControllerTest . Platform > ( ) ; Box2DCharacterControllerTest . Platform groundedPlatform = null ; float stillTime = 0 ; long lastGroundTime = 0 ; SpriteBatch batch ; BitmapFont font ; float accum = 0 ; float TICK = 1 / 60.0F ; @ Override public void create ( ) { world = new World ( new Vector2 ( 0 , ( - 40 ) ) , true ) ; renderer = new Box2DDebugRenderer ( ) ; cam = new OrthographicCamera ( 28 , 20 ) ; createWorld ( ) ; input . setInputProcessor ( this ) ; batch = new SpriteBatch ( ) ; <START_BUG> font = new BitmapFont ( ) ; <END_BUG> } private void createWorld ( ) { } Body createBox ( BodyType type , float width , float height , float density ) { } private Body createEdge ( BodyType type , float x1 , float y1 , float x2 , float y2 , float density ) { } private Body createCircle ( BodyType type , float radius , float density ) { } private Body createPlayer ( ) { } @ Override public void resume ( ) { } @ Override public void render ( ) { } private boolean isPlayerGrounded ( float deltaTime ) { } @ Override public void resize ( int width , int height ) { } @ Override public void pause ( ) { } @ Override public void dispose ( ) { } @ Override public boolean keyDown ( int keycode ) { } @ Override public boolean keyUp ( int keycode ) { } Vector2 last = null ; Vector3 point = new Vector3 ( ) ; @ Override public boolean touchDown ( int x , int y , int pointerId , int button ) { } abstract class Platform { abstract void update ( float deltatime ) { } } class CirclePlatform extends Box2DCharacterControllerTest . Platform { Body platform ; public CirclePlatform ( int x , int y , float radius , float da ) { } @ Override void update ( float deltatime ) { } } class MovingPlatform extends Box2DCharacterControllerTest . Platform { Body platform ; Vector2 pos = new Vector2 ( ) ; Vector2 dir = new Vector2 ( ) ; float dist = 0 ; float maxDist = 0 ; public MovingPlatform ( float x , float y , float width , float height , float dx , float dy , float da , float maxDist ) { } public void update ( float deltaTime ) { } } }
public class AllEntries extends Reader { public static class Entry { private final String name ; private final FastStringReader reader ; private final float boost ; public Entry ( String name , FastStringReader reader , float boost ) { } public String name ( ) { } public float boost ( ) { } public FastStringReader reader ( ) { } } private final List < AllEntries . Entry > entries = Lists . newArrayList ( ) ; private AllEntries . Entry current ; private Iterator < AllEntries . Entry > it ; private boolean itsSeparatorTime = false ; private boolean customBoost = false ; public void addText ( String name , String text , float boost ) { } public void clear ( ) { } public void reset ( ) { } public String buildText ( ) { reset ( ) ; <START_BUG> FastCharArrayWriter writer = Cached . cached ( ) ; <END_BUG> for ( AllEntries . Entry entry : entries ) { writer . append ( entry . reader ( ) ) ; writer . append ( '<seq2seq4repair_space>' ) ; } reset ( ) ; return writer . toString ( ) ; } public List < AllEntries . Entry > entries ( ) { } public Set < String > fields ( ) { } public AllEntries . Entry current ( ) { } @ Override public int read ( char [ ] cbuf , int off , int len ) throws IOException { } @ Override public void close ( ) { } @ Override public boolean ready ( ) throws IOException { } @ Override public String toString ( ) { } }
public class IndexCache extends AbstractIndexComponent implements ClusterStateListener , CloseableComponent { private final FilterCache filterCache ; private final FieldDataCache fieldDataCache ; private final QueryParserCache queryParserCache ; private final IdCache idCache ; private final BloomCache bloomCache ; private ClusterService clusterService ; @ Inject public IndexCache ( Index index , @ IndexSettings Settings indexSettings , FilterCache filterCache , FieldDataCache fieldDataCache , QueryParserCache queryParserCache , IdCache idCache , BloomCache bloomCache ) { } @ Inject ( optional = true ) public void setClusterService ( @ Nullable ClusterService clusterService ) { } public CacheStats stats ( ) { <START_BUG> return new CacheStats ( fieldDataCache . evictions ( ) , fieldDataCache . sizeInBytes ( ) , filterCache . sizeInBytes ( ) , bloomCache . sizeInBytes ( ) ) ; <END_BUG> } public FilterCache filter ( ) { } public FieldDataCache fieldData ( ) { } public IdCache idCache ( ) { } public BloomCache bloomCache ( ) { } public QueryParserCache queryParserCache ( ) { } @ Override public void close ( ) throws ElasticSearchException { } public void clear ( IndexReader reader ) { } public void clear ( ) { } public void clearUnreferenced ( ) { } @ Override public void clusterChanged ( ClusterChangedEvent event ) { } }
public class TransportCountAction extends TransportBroadcastOperationAction < CountRequest , CountResponse , ShardCountRequest , ShardCountResponse > { @ Inject public TransportCountAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected CountRequest newRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ShardRouting shard , CountRequest request ) { <START_BUG> return new ShardCountRequest ( shard . index ( ) , shard . id ( ) , request . querySource ( ) , request . minScore ( ) , request . queryParserName ( ) , request . types ( ) ) ; <END_BUG> } @ Override protected ShardCountResponse newShardResponse ( ) { } @ Override protected GroupShardsIterator shards ( CountRequest request , ClusterState clusterState ) { } @ Override protected CountResponse newResponse ( CountRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardCountResponse shardOperation ( ShardCountRequest request ) throws ElasticSearchException { } }
public class InternalIndexService extends AbstractIndexComponent implements IndexService { private final Injector injector ; private final Settings indexSettings ; private final ThreadPool threadPool ; private final PluginsService pluginsService ; private final InternalIndicesLifecycle indicesLifecycle ; private final AnalysisService analysisService ; private final MapperService mapperService ; private final IndexQueryParserService queryParserService ; private final SimilarityService similarityService ; private final IndexAliasesService aliasesService ; private final IndexCache indexCache ; private final IndexFieldDataService indexFieldData ; private final IndexEngine indexEngine ; private final IndexGateway indexGateway ; private final IndexStore indexStore ; private final IndexSettingsService settingsService ; private volatile ImmutableMap < Integer , Injector > shardsInjectors = ImmutableMap . of ( ) ; private volatile ImmutableMap < Integer , IndexShard > shards = ImmutableMap . of ( ) ; private volatile boolean closed = false ; @ Inject public InternalIndexService ( Injector injector , Index index , @ IndexSettings Settings indexSettings , NodeEnvironment nodeEnv , ThreadPool threadPool , AnalysisService analysisService , MapperService mapperService , IndexQueryParserService queryParserService , SimilarityService similarityService , IndexAliasesService aliasesService , IndexCache indexCache , IndexEngine indexEngine , IndexGateway indexGateway , IndexStore indexStore , IndexSettingsService settingsService , IndexFieldDataService indexFieldData ) { } @ Override public int numberOfShards ( ) { } @ Override public UnmodifiableIterator < IndexShard > iterator ( ) { } @ Override public boolean hasShard ( int shardId ) { } @ Override public IndexShard shard ( int shardId ) { } @ Override public IndexShard shardSafe ( int shardId ) throws IndexShardMissingException { } @ Override public ImmutableSet < Integer > shardIds ( ) { } @ Override public Injector injector ( ) { } @ Override public IndexGateway gateway ( ) { } @ Override public IndexSettingsService settingsService ( ) { } @ Override public IndexStore store ( ) { } @ Override public IndexCache cache ( ) { } @ Override public IndexFieldDataService fieldData ( ) { } @ Override public AnalysisService analysisService ( ) { } @ Override public MapperService mapperService ( ) { } @ Override public IndexQueryParserService queryParserService ( ) { } @ Override public SimilarityService similarityService ( ) { } @ Override public IndexAliasesService aliasesService ( ) { } @ Override public IndexEngine engine ( ) { } public void close ( final String reason , @ Nullable Executor executor ) { } @ Override public Injector shardInjector ( int shardId ) throws ElasticSearchException { } @ Override public Injector shardInjectorSafe ( int shardId ) throws IndexShardMissingException { } @ Override public String indexUUID ( ) { <START_BUG> return indexSettings . get ( SETTING_UUID ) ; <END_BUG> } @ Override public synchronized IndexShard createShard ( int sShardId ) throws ElasticSearchException { } @ Override public synchronized void removeShard ( int shardId , String reason ) throws ElasticSearchException { } }
public class RoutingNode implements Iterable < MutableShardRouting > { private final String nodeId ; private final List < MutableShardRouting > shards ; public RoutingNode ( String nodeId ) { } public RoutingNode ( String nodeId , List < MutableShardRouting > shards ) { } @ Override public Iterator < MutableShardRouting > iterator ( ) { } public String nodeId ( ) { } public List < MutableShardRouting > shards ( ) { } public void add ( MutableShardRouting shard ) { } public void removeByShardId ( int shardId ) { } public int numberOfShardsWithState ( ShardRoutingState ... states ) { } public List < MutableShardRouting > shardsWithState ( ShardRoutingState ... states ) { } public int numberOfShardsNotWithState ( ShardRoutingState state ) { } public int numberOfOwningShards ( ) { } public boolean canAllocate ( MetaData metaData , RoutingTable routingTable ) { <START_BUG> return ( shards ( ) . size ( ) ) < ( metaData . maxNumberOfShardsPerNode ( ) ) ; <END_BUG> } public boolean canAllocate ( ShardRouting requested ) { } public boolean canAllocate ( MutableShardRouting requested ) { } public String prettyPrint ( ) { } }
public class MvelScriptEngineService extends AbstractComponent implements ScriptEngineService { private final ParserConfiguration parserConfiguration ; @ Inject public MvelScriptEngineService ( Settings settings ) { } @ Override public void close ( ) { } @ Override public String [ ] types ( ) { } @ Override public String [ ] extensions ( ) { } @ Override public Object compile ( String script ) { <START_BUG> return MVEL . compileExpression ( script , new org . mvel2 . ParserContext ( parserConfiguration ) ) ; <END_BUG> } @ Override public Object execute ( Object compiledScript , Map vars ) { } @ Override public ExecutableScript executable ( Object compiledScript , Map vars ) { } @ Override public SearchScript search ( Object compiledScript , SearchLookup lookup , @ Nullable Map < String , Object > vars ) { } @ Override public Object unwrap ( Object value ) { } public static class MvelExecutableScript implements ExecutableScript { private final ExecutableStatement script ; private final MapVariableResolverFactory resolver ; public MvelExecutableScript ( Object script , Map vars ) { } @ Override public void setNextVar ( String name , Object value ) { } @ Override public Object run ( ) { } @ Override public Object unwrap ( Object value ) { } } public static class MvelSearchScript implements SearchScript { private final ExecutableStatement script ; private final SearchLookup lookup ; private final MapVariableResolverFactory resolver ; public MvelSearchScript ( Object script , SearchLookup lookup , Map < String , Object > vars ) { } @ Override public void setScorer ( Scorer scorer ) { } @ Override public void setNextReader ( AtomicReaderContext context ) { } @ Override public void setNextDocId ( int doc ) { } @ Override public void setNextScore ( float score ) { } @ Override public void setNextVar ( String name , Object value ) { } @ Override public void setNextSource ( Map < String , Object > source ) { } @ Override public Object run ( ) { } @ Override public float runAsFloat ( ) { } @ Override public long runAsLong ( ) { } @ Override public double runAsDouble ( ) { } @ Override public Object unwrap ( Object value ) { } } }
@ ClusterScope ( scope = Scope . SUITE ) public class IndicesRequestTests extends ElasticsearchIntegrationTest { private final List < String > indices = new ArrayList < > ( ) ; private Client nodeClient ; @ Override protected int minimumNumberOfShards ( ) { } @ Override protected int minimumNumberOfReplicas ( ) { } @ Override protected Settings nodeSettings ( int nodeOrdinal ) { } @ Before public void setup ( ) { } @ After public void cleanUp ( ) { } @ Test public void testGetFieldMappings ( ) { } @ Test public void testAnalyze ( ) { } @ Test public void testIndex ( ) { } @ Test public void testDelete ( ) { } @ Test public void testUpdate ( ) { } @ Test public void testUpdateUpsert ( ) { } @ Test public void testUpdateDelete ( ) { } @ Test public void testDeleteByQuery ( ) { } @ Test public void testBulk ( ) { } @ Test public void testGet ( ) { } @ Test public void testExplain ( ) { } @ Test public void testTermVector ( ) { } @ Test public void testMultiTermVector ( ) { } @ Test public void testMultiGet ( ) { } @ Test public void testCount ( ) { } @ Test public void testExists ( ) { } @ Test public void testFlush ( ) { } @ Test public void testOptimize ( ) { } @ Test public void testRefresh ( ) { } @ Test public void testClearCache ( ) { } @ Test public void testRecovery ( ) { } @ Test public void testSegments ( ) { } @ Test public void testIndicesStats ( ) { } @ Test public void testSuggest ( ) { } @ Test public void testValidateQuery ( ) { } @ Test public void testPercolate ( ) { } @ Test public void testMultiPercolate ( ) { } @ Test public void testOpenIndex ( ) { } @ Test public void testCloseIndex ( ) { } @ Test public void testDeleteIndex ( ) { } @ Test public void testGetMappings ( ) { } @ Test public void testPutMapping ( ) { } @ Test public void testDeleteMapping ( ) { } @ Test public void testGetSettings ( ) { } @ Test public void testUpdateSettings ( ) { } @ Test public void testSearchQueryThenFetch ( ) throws Exception { } @ Test public void testSearchDfsQueryThenFetch ( ) throws Exception { } @ Test public void testSearchQueryAndFetch ( ) throws Exception { } @ Test public void testSearchDfsQueryAndFetch ( ) throws Exception { } @ Test public void testSearchScan ( ) throws Exception { } @ Test public void testMoreLikeThis ( ) { } private static void assertSameIndices ( IndicesRequest originalRequest , String ... actions ) { } private static void assertSameIndicesOptionalRequests ( IndicesRequest originalRequest , String ... actions ) { } private static void assertSameIndices ( IndicesRequest originalRequest , boolean optional , String ... actions ) { } private static void assertSameIndicesOptionalRequests ( String [ ] indices , String ... actions ) { } private static void assertSameIndices ( String [ ] indices , boolean optional , String ... actions ) { } private static void assertIndicesSubset ( List < String > indices , String ... actions ) { } private String randomIndexOrAlias ( ) { } private String [ ] randomIndicesOrAliases ( ) { } private String [ ] randomUniqueIndicesOrAliases ( ) { } private static void assertAllRequestsHaveBeenConsumed ( ) { Iterable < TransportService > transportServices = internalCluster ( ) . getInstances ( TransportService . class ) ; for ( TransportService transportService : transportServices ) { <START_BUG> assertThat ( ( ( IndicesRequestTests . InterceptingTransportService ) ( transportService ) ) . requests . isEmpty ( ) , equalTo ( true ) ) ; <END_BUG> } } private static void clearInterceptedActions ( ) { } private static void interceptTransportActions ( String ... actions ) { } private static List < TransportRequest > consumeTransportRequests ( String action ) { } public static class InterceptingTransportService extends TransportService { private final Set < String > actions = new CopyOnWriteArraySet < > ( ) ; private final ConcurrentMap < String , List < TransportRequest > > requests = new ConcurrentHashMap < > ( ) ; @ Inject public InterceptingTransportService ( Settings settings , Transport transport , ThreadPool threadPool ) { } List < TransportRequest > consumeRequests ( String action ) { } void interceptTransportActions ( String ... actions ) { } void clearInterceptedActions ( ) { } @ Override public void registerHandler ( String action , TransportRequestHandler handler ) { } private class InterceptingRequestHandler implements TransportRequestHandler { private final TransportRequestHandler requestHandler ; private final String action ; InterceptingRequestHandler ( String action , TransportRequestHandler requestHandler ) { } @ Override public TransportRequest newInstance ( ) { } @ Override @ SuppressWarnings ( "unchecked" ) public void messageReceived ( TransportRequest request , TransportChannel channel ) throws Exception { } @ Override public String executor ( ) { } @ Override public boolean isForceExecution ( ) { } } } }
public class TopHitsBuilder extends AbstractAggregationBuilder { private SearchSourceBuilder sourceBuilder ; public TopHitsBuilder ( String name ) { } public TopHitsBuilder setSize ( int size ) { } public TopHitsBuilder setTrackScores ( boolean trackScores ) { } public TopHitsBuilder setExplain ( boolean explain ) { } public TopHitsBuilder setVersion ( boolean version ) { } public TopHitsBuilder setNoFields ( ) { } public TopHitsBuilder setFetchSource ( boolean fetch ) { } public TopHitsBuilder setFetchSource ( @ Nullable String include , @ Nullable String exclude ) { } public TopHitsBuilder setFetchSource ( @ Nullable String [ ] includes , @ Nullable String [ ] excludes ) { } public TopHitsBuilder addFieldDataField ( String name ) { } public TopHitsBuilder addScriptField ( String name , String script ) { } public TopHitsBuilder addScriptField ( String name , String script , Map < String , Object > params ) { } public TopHitsBuilder addScriptField ( String name , String lang , String script , Map < String , Object > params ) { } public TopHitsBuilder addSort ( String field , SortOrder order ) { } public TopHitsBuilder addSort ( SortBuilder sort ) { } public TopHitsBuilder addHighlightedField ( String name ) { } public TopHitsBuilder addHighlightedField ( String name , int fragmentSize ) { } public TopHitsBuilder addHighlightedField ( String name , int fragmentSize , int numberOfFragments ) { } public TopHitsBuilder addHighlightedField ( String name , int fragmentSize , int numberOfFragments , int fragmentOffset ) { } public TopHitsBuilder addHighlightedField ( HighlightBuilder . Field field ) { } public TopHitsBuilder setHighlighterTagsSchema ( String schemaName ) { } public TopHitsBuilder setHighlighterFragmentSize ( Integer fragmentSize ) { } public TopHitsBuilder setHighlighterNumOfFragments ( Integer numOfFragments ) { } public TopHitsBuilder setHighlighterFilter ( Boolean highlightFilter ) { } public TopHitsBuilder setHighlighterEncoder ( String encoder ) { } public TopHitsBuilder setHighlighterPreTags ( String ... preTags ) { } public TopHitsBuilder setHighlighterPostTags ( String ... postTags ) { } public TopHitsBuilder setHighlighterOrder ( String order ) { } public TopHitsBuilder setHighlighterRequireFieldMatch ( boolean requireFieldMatch ) { } public TopHitsBuilder setHighlighterBoundaryMaxScan ( Integer boundaryMaxScan ) { } public TopHitsBuilder setHighlighterBoundaryChars ( char [ ] boundaryChars ) { } public TopHitsBuilder setHighlighterType ( String type ) { } public TopHitsBuilder setHighlighterFragmenter ( String fragmenter ) { } public TopHitsBuilder setHighlighterQuery ( QueryBuilder highlightQuery ) { } public TopHitsBuilder setHighlighterNoMatchSize ( Integer noMatchSize ) { } public TopHitsBuilder setHighlighterPhraseLimit ( Integer phraseLimit ) { } public TopHitsBuilder setHighlighterOptions ( Map < String , Object > options ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( name ) . field ( type ) ; <START_BUG> sourceBuilder . toXContent ( builder , params ) ; <END_BUG> return builder . endObject ( ) ; } private SearchSourceBuilder sourceBuilder ( ) { } public HighlightBuilder highlightBuilder ( ) { } }
public class TransportCreateIndexAction extends TransportMasterNodeOperationAction < CreateIndexRequest , CreateIndexResponse > { private final MetaDataService metaDataService ; @ Inject public TransportCreateIndexAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , MetaDataService metaDataService ) { } @ Override protected String transportAction ( ) { } @ Override protected CreateIndexRequest newRequest ( ) { } @ Override protected CreateIndexResponse newResponse ( ) { } @ Override protected CreateIndexResponse masterOperation ( CreateIndexRequest request ) throws ElasticSearchException { <START_BUG> MetaDataService . CreateIndexResult createIndexResult = metaDataService . createIndex ( request . index ( ) , request . settings ( ) , request . timeout ( ) ) ; <END_BUG> return new CreateIndexResponse ( createIndexResult . acknowledged ( ) ) ; } }
public class RotateBy extends AnimationAction { private static final ActionResetingPool < RotateBy > pool = new ActionResetingPool < RotateBy > ( 4 , 100 ) { @ Override protected RotateBy newObject ( ) { } } ; protected float rotation ; protected float startRotation ; protected float deltaRotation ; public static RotateBy $ ( float rotation , float duration ) { } @ Override public void setTarget ( Actor actor ) { } @ Override public void act ( float delta ) { float alpha = createInterpolatedAlpha ( delta ) ; if ( done ) { <START_BUG> target . rotation = rotation ; <END_BUG> } else { target . rotation = ( startRotation ) + ( ( deltaRotation ) * alpha ) ; } } @ Override public void finish ( ) { } @ Override public Action copy ( ) { } }
public class InternalCircuitBreakerService extends AbstractLifecycleComponent < InternalCircuitBreakerService > implements CircuitBreakerService { public static final String CIRCUIT_BREAKER_MAX_BYTES_SETTING = "indices.fielddata.breaker.limit" ; public static final String CIRCUIT_BREAKER_OVERHEAD_SETTING = "indices.fielddata.breaker.overhead" ; public static final double DEFAULT_OVERHEAD_CONSTANT = 1.03 ; private static final String DEFAULT_BREAKER_LIMIT = "60%" ; private volatile MemoryCircuitBreaker breaker ; private volatile long maxBytes ; private volatile double overhead ; @ Inject public InternalCircuitBreakerService ( Settings settings , NodeSettingsService nodeSettingsService ) { } class ApplySettings implements NodeSettingsService . Listener { @ Override public void onRefreshSettings ( Settings settings ) { } } public MemoryCircuitBreaker getBreaker ( ) { } public synchronized void resetBreaker ( ) { } @ Override public FieldDataBreakerStats stats ( ) { <START_BUG> return new FieldDataBreakerStats ( breaker . getMaximum ( ) , breaker . getUsed ( ) , breaker . getOverhead ( ) ) ; <END_BUG> } @ Override protected void doStart ( ) throws ElasticsearchException { } @ Override protected void doStop ( ) throws ElasticsearchException { } @ Override protected void doClose ( ) throws ElasticsearchException { } }
public class BitmapFont implements Disposable { private static final int LOG2_PAGE_SIZE = 9 ; private static final int PAGE_SIZE = 1 << ( BitmapFont . LOG2_PAGE_SIZE ) ; private static final int PAGES = 65536 / ( BitmapFont . PAGE_SIZE ) ; TextureRegion region ; float lineHeight ; float capHeight ; float ascent ; float down ; float scaleX = 1 ; float scaleY = 1 ; private final BitmapFont . Glyph [ ] [ ] glyphs = new BitmapFont . Glyph [ BitmapFont . PAGES ] [ ] ; private float spaceWidth ; private float xHeight ; private final BitmapFont . TextBounds textBounds = new BitmapFont . TextBounds ( ) ; private float color = WHITE . toFloatBits ( ) ; private Color tempColor = new Color ( 1 , 1 , 1 , 1 ) ; private boolean flipped ; public BitmapFont ( ) { } public BitmapFont ( boolean flip ) { } public BitmapFont ( FileHandle fontFile , TextureRegion region , boolean flip ) { } public BitmapFont ( FileHandle fontFile , boolean flip ) { } public BitmapFont ( FileHandle fontFile , FileHandle imageFile , boolean flip ) { } private void init ( FileHandle fontFile , TextureRegion region , boolean flip ) { } BitmapFont . Glyph getGlyph ( char ch ) { } public BitmapFont . TextBounds draw ( SpriteBatch spriteBatch , CharSequence str , float x , float y ) { } public BitmapFont . TextBounds draw ( SpriteBatch spriteBatch , CharSequence str , float x , float y , int start , int end ) { } public BitmapFont . TextBounds drawMultiLine ( SpriteBatch spriteBatch , CharSequence str , float x , float y ) { } public BitmapFont . TextBounds drawMultiLine ( SpriteBatch spriteBatch , CharSequence str , float x , float y , float alignmentWidth , BitmapFont . HAlignment alignment ) { } public BitmapFont . TextBounds drawWrapped ( SpriteBatch spriteBatch , CharSequence str , float x , float y , float wrapWidth ) { } public BitmapFont . TextBounds drawWrapped ( SpriteBatch spriteBatch , CharSequence str , float x , float y , float wrapWidth , BitmapFont . HAlignment alignment ) { } public BitmapFont . TextBounds getBounds ( CharSequence str ) { } public BitmapFont . TextBounds getBounds ( CharSequence str , int start , int end ) { } public BitmapFont . TextBounds getMultiLineBounds ( CharSequence str ) { } public BitmapFont . TextBounds getWrappedBounds ( CharSequence str , float wrapWidth ) { } public int computeVisibleGlyphs ( CharSequence str , int start , int end , float availableWidth ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { int intBits = ( ( ( ( ( int ) ( 255 * a ) ) << 24 ) | ( ( ( int ) ( 255 * b ) ) << 16 ) ) | ( ( ( int ) ( 255 * g ) ) << 8 ) ) | ( ( int ) ( 255 * r ) ) ; <START_BUG> color = Float . intBitsToFloat ( intBits ) ; <END_BUG> } public Color getColor ( ) { } public void setScale ( float scaleX , float scaleY ) { } public void setScale ( float scaleXY ) { } public void scale ( float amount ) { } public float getScaleX ( ) { } public float getScaleY ( ) { } public TextureRegion getRegion ( ) { } public float getLineHeight ( ) { } public float getSpaceWidth ( ) { } public float getXHeight ( ) { } public float getCapHeight ( ) { } public float getAscent ( ) { } public boolean isFlipped ( ) { } public void dispose ( ) { } public void setFixedWidthGlyphs ( CharSequence glyphs ) { } static class Glyph { int width ; int height ; float u ; float v ; float u2 ; float v2 ; int xoffset ; int yoffset ; int xadvance ; byte [ ] [ ] kerning ; int getKerning ( char ch ) { } void setKerning ( int ch , int value ) { } } static int indexOf ( CharSequence text , char ch , int start ) { } public static class TextBounds { public float width ; public float height ; public TextBounds ( ) { } public TextBounds ( BitmapFont . TextBounds bounds ) { } public void set ( BitmapFont . TextBounds bounds ) { } } public static enum HAlignment { LEFT , CENTER , RIGHT ; } }
public class RestClusterSearchShardsAction extends BaseRestHandler { @ Inject public RestClusterSearchShardsAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { String [ ] indices = RestActions . splitIndices ( request . param ( "index" ) ) ; final ClusterSearchShardsRequest clusterSearchShardsRequest = Requests . clusterSearchShardsRequest ( indices ) ; clusterSearchShardsRequest . local ( request . paramAsBoolean ( "local" , clusterSearchShardsRequest . local ( ) ) ) ; clusterSearchShardsRequest . listenerThreaded ( false ) ; clusterSearchShardsRequest . types ( RestActions . splitTypes ( request . param ( "type" ) ) ) ; clusterSearchShardsRequest . routing ( request . param ( "routing" ) ) ; clusterSearchShardsRequest . preference ( request . param ( "preference" ) ) ; if ( request . hasParam ( "ignore_indices" ) ) { clusterSearchShardsRequest . ignoreIndices ( IgnoreIndices . fromString ( request . param ( "ignore_indices" ) ) ) ; } client . admin ( ) . cluster ( ) . searchShards ( clusterSearchShardsRequest , new org . elasticsearch . action . ActionListener < ClusterSearchShardsResponse > ( ) { @ Override public void onResponse ( ClusterSearchShardsResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; builder . field ( "ok" , true ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class AllFieldMapper extends AbstractFieldMapper < Void > implements org . elasticsearch . index . mapper . AllFieldMapper { public static final String CONTENT_TYPE = "_all" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = org . elasticsearch . index . mapper . AllFieldMapper . NAME ; public static final String INDEX_NAME = org . elasticsearch . index . mapper . AllFieldMapper . NAME ; public static final boolean ENABLED = true ; } public static class Builder extends AbstractFieldMapper . Builder < AllFieldMapper . Builder , AllFieldMapper > { private boolean enabled = AllFieldMapper . Defaults . ENABLED ; public Builder ( ) { } public AllFieldMapper . Builder enabled ( boolean enabled ) { } @ Override public AllFieldMapper . Builder store ( Field . Store store ) { } @ Override public AllFieldMapper . Builder termVector ( Field . TermVector termVector ) { } @ Override protected AllFieldMapper . Builder indexAnalyzer ( NamedAnalyzer indexAnalyzer ) { } @ Override protected AllFieldMapper . Builder searchAnalyzer ( NamedAnalyzer searchAnalyzer ) { } @ Override public AllFieldMapper build ( BuilderContext context ) { } } private boolean enabled ; public AllFieldMapper ( ) { } protected AllFieldMapper ( String name , Field . Store store , Field . TermVector termVector , boolean omitNorms , boolean omitTermFreqAndPositions , NamedAnalyzer indexAnalyzer , NamedAnalyzer searchAnalyzer , boolean enabled ) { } public boolean enabled ( ) { } @ Override public Query queryStringTermQuery ( Term term ) { } @ Override public Query fieldQuery ( String value , QueryParseContext context ) { <START_BUG> return new AllTermQuery ( new Term ( names . indexName ( ) , value ) ) ; <END_BUG> } @ Override protected Fieldable parseCreateField ( ParseContext context ) throws IOException { } private Analyzer findAnalyzer ( ParseContext context ) { } @ Override public Void value ( Fieldable field ) { } @ Override public Void valueFromString ( String value ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public Object valueForSearch ( Fieldable field ) { } @ Override protected String contentType ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( XContentMapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public class TransportSearchDfsQueryAndFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchDfsQueryAndFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < DfsSearchResult > { private final AtomicArray < QueryFetchSearchResult > queryFetchResults ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , ShardSearchRequest request , SearchServiceListener < DfsSearchResult > listener ) { } @ Override protected void moveToSecondPhase ( ) { } void executeSecondPhase ( final int shardIndex , final DfsSearchResult dfsResult , final AtomicInteger counter , DiscoveryNode node , final QuerySearchRequest querySearchRequest ) { } void finishHim ( ) { try { innerFinishHim ( ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> ReduceSearchPhaseException failure = new ReduceSearchPhaseException ( "query_fetch" , "" , e , buildShardFailures ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>reduce<seq2seq4repair_space>search" , failure ) ; } listener . onFailure ( failure ) ; } finally { } } void innerFinishHim ( ) throws Exception { } } }
public final class OrthographicCamera { public enum Side { FRONT , BACK , TOP , BOTTOM , LEFT , RIGHT ; } private OrthographicCamera . Side side ; private Vector3 position = new Vector3 ( ) ; private Vector3 direction = new Vector3 ( 0 , 0 , ( - 1 ) ) ; private Vector3 up = new Vector3 ( 0 , 0 , ( - 1 ) ) ; private Vector3 axis = new Vector3 ( 0 , 1 , 0 ) ; private float near = - 1000 ; private float far = 1000 ; private float scale = 1.0F ; private float viewportWidth = 0 ; private float viewportHeight = 0 ; private final Matrix4 proj = new Matrix4 ( ) ; private final Matrix4 model = new Matrix4 ( ) ; private final Matrix4 combined = new Matrix4 ( ) ; private final Matrix4 rotationMatrix = new Matrix4 ( ) ; public OrthographicCamera ( ) { } public OrthographicCamera . Side getSide ( ) { } public void setSide ( OrthographicCamera . Side side ) { } public float getNear ( ) { } public void setNear ( float near ) { } public float getFar ( ) { } public void setFar ( float far ) { } public float getScale ( ) { } public void setScale ( float scale ) { } public Vector3 getPosition ( ) { } public void setViewport ( float width , float height ) { } Vector3 tmp = new Vector3 ( ) ; public void update ( ) { } public void setMatrices ( ) { update ( ) ; <START_BUG> GL10 gl = graphics . getGL10 ( ) ; <END_BUG> gl . glMatrixMode ( GL_PROJECTION ) ; gl . glLoadMatrixf ( getCombinedMatrix ( ) . val , 0 ) ; gl . glMatrixMode ( GL_MODELVIEW ) ; gl . glLoadIdentity ( ) ; } private Matrix4 calculateRotationMatrix ( ) { } public void getScreenToWorld ( float screenX , float screenY , Vector2 world ) { } public void getWorldToScreen ( float worldX , float worldY , Vector2 screen ) { } public float getScreenToWorldX ( float screenX ) { } public int getWorldToScreenX ( float worldX ) { } public float getScreenToWorldY ( float screenY ) { } public int getWorldToScreenY ( float worldY ) { } Ray ray = new Ray ( new Vector3 ( ) , new Vector3 ( ) ) ; Vector3 tmp2 = new Vector3 ( ) ; public Ray getPickRay ( int screenX , int screenY ) { } public Matrix4 getCombinedMatrix ( ) { } }
@ Immutable public class IndexRoutingTable implements Iterable < IndexShardRoutingTable > { private final String index ; private final ImmutableMap < Integer , IndexShardRoutingTable > shards ; private final ImmutableList < ShardRouting > allShards ; private final AtomicInteger counter = new AtomicInteger ( ) ; IndexRoutingTable ( String index , Map < Integer , IndexShardRoutingTable > shards ) { } public String index ( ) { } public String getIndex ( ) { } public IndexRoutingTable normalizeVersions ( ) { } public void validate ( RoutingTableValidation validation , MetaData metaData ) { } @ Override public UnmodifiableIterator < IndexShardRoutingTable > iterator ( ) { } public int numberOfNodesShardsAreAllocatedOn ( String ... excludedNodes ) { } public ImmutableMap < Integer , IndexShardRoutingTable > shards ( ) { } public ImmutableMap < Integer , IndexShardRoutingTable > getShards ( ) { } public IndexShardRoutingTable shard ( int shardId ) { } public boolean allPrimaryShardsActive ( ) { } public int primaryShardsActive ( ) { } public boolean allPrimaryShardsUnassigned ( ) { } public int primaryShardsUnassigned ( ) { } public List < ShardRouting > shardsWithState ( ShardRoutingState ... states ) { } public ShardsIterator randomAllShardsIt ( ) { <START_BUG> return new PlainShardsIterator ( allShards , Math . abs ( counter . incrementAndGet ( ) ) ) ; <END_BUG> } public GroupShardsIterator groupByShardsIt ( ) { } public GroupShardsIterator groupByAllIt ( ) { } public void validate ( ) throws RoutingValidationException { } public static class Builder { private final String index ; private final Map < Integer , IndexShardRoutingTable > shards = new HashMap < Integer , IndexShardRoutingTable > ( ) ; public Builder ( String index ) { } public static IndexRoutingTable readFrom ( StreamInput in ) throws IOException { } public static void writeTo ( IndexRoutingTable index , StreamOutput out ) throws IOException { } public IndexRoutingTable . Builder initializeEmpty ( IndexMetaData indexMetaData ) { } public IndexRoutingTable . Builder initializeEmpty ( IndexMetaData indexMetaData , boolean fromApi ) { } public IndexRoutingTable . Builder addReplica ( ) { } public IndexRoutingTable . Builder removeReplica ( ) { } public IndexRoutingTable . Builder addIndexShard ( IndexShardRoutingTable indexShard ) { } public IndexRoutingTable . Builder addShard ( ShardRouting shard , boolean fromApi ) { } private IndexRoutingTable . Builder addShard ( int shardId , String nodeId , boolean primary , ShardRoutingState state , long version , boolean fromApi ) { } private IndexRoutingTable . Builder internalAddShard ( ImmutableShardRouting shard , boolean fromApi ) { } public IndexRoutingTable build ( ) throws RoutingValidationException { } } public String prettyPrint ( ) { } }
public class NativeCodeGenerator { private static final String JNI_METHOD_MARKER = "native" ; private static final String JNI_ARG_PREFIX = "obj_" ; private static final String JNI_RETURN_VALUE = "JNI_returnValue" ; private static final String JNI_WRAPPER_PREFIX = "wrapped_" ; FileDescriptor sourceDir ; String classpath ; FileDescriptor jniDir ; String [ ] includes ; String [ ] excludes ; AntPathMatcher matcher = new AntPathMatcher ( ) ; JavaMethodParser javaMethodParser = new RobustJavaMethodParser ( ) ; CMethodParser cMethodParser = new JniHeaderCMethodParser ( ) ; CMethodParserResult cResult ; public void generate ( ) throws Exception { <START_BUG> generate ( "src" , "bin" , "jni" , new String [ 0 ] , new String [ 0 ] ) ; <END_BUG> } public void generate ( String sourceDir , String classpath , String jniDir ) throws Exception { } public void generate ( String sourceDir , String classpath , String jniDir , String [ ] includes , String [ ] excludes ) throws Exception { } private void processDirectory ( FileDescriptor dir ) throws Exception { } private String getFullyQualifiedClassName ( FileDescriptor file ) { } private void generateHFile ( FileDescriptor file ) throws Exception { } private void generateCppFile ( ArrayList < JavaSegment > javaSegments , FileDescriptor hFile , FileDescriptor cppFile ) throws Exception { } private CMethod findCMethod ( JavaMethod javaMethod , ArrayList < CMethod > cMethods ) { } private void emitLineMarker ( StringBuffer buffer , int line ) { } private void emitJniSection ( StringBuffer buffer , JniSection section ) { } private void emitJavaMethod ( StringBuffer buffer , JavaMethod javaMethod , CMethod cMethod ) { } private void emitMethodBody ( StringBuffer buffer , JavaMethod javaMethod ) { } private String emitMethodSignature ( StringBuffer buffer , JavaMethod javaMethod , CMethod cMethod , String additionalArguments ) { } private void emitJniSetupCode ( StringBuffer buffer , JavaMethod javaMethod , StringBuffer additionalArgs , StringBuffer wrapperArgs ) { } private void emitJniCleanupCode ( StringBuffer buffer , JavaMethod javaMethod , CMethod cMethod ) { } }
public class ReproduceInfoPrinter extends RunListener { protected final ESLogger logger = Loggers . getLogger ( ElasticsearchTestCase . class ) ; @ Override public void testStarted ( Description description ) throws Exception { } @ Override public void testFinished ( Description description ) throws Exception { } @ Override public void testFailure ( Failure failure ) throws Exception { } protected boolean mustAppendClusterSeed ( Failure failure ) { } protected void appendClusterSeed ( ReproduceErrorMessageBuilder builder ) { } protected ReproduceErrorMessageBuilder reproduceErrorMessageBuilder ( StringBuilder b ) { } protected TraceFormatting traces ( ) { } protected static class MavenMessageBuilder extends ReproduceErrorMessageBuilder { public MavenMessageBuilder ( StringBuilder b ) { } @ Override public ReproduceErrorMessageBuilder appendAllOpts ( Description description ) { } @ Override public ReproduceErrorMessageBuilder appendOpt ( String sysPropName , String value ) { } public ReproduceErrorMessageBuilder appendESProperties ( ) { <START_BUG> appendProperties ( "es.logger.level" , "es.node.mode" , "es.node.local" , TESTS_ENABLE_MOCK_MODULES , "tests.assertion.disabled" ) ; <END_BUG> if ( ( ( System . getProperty ( "tests.jvm.argline" ) ) != null ) && ( ! ( System . getProperty ( "tests.jvm.argline" ) . isEmpty ( ) ) ) ) { appendOpt ( "tests.jvm.argline" , ( ( "\"" + ( System . getProperty ( "tests.jvm.argline" ) ) ) + "\"" ) ) ; } return this ; } protected ReproduceErrorMessageBuilder appendProperties ( String ... properties ) { } } }
public class CachedDfSource extends Searcher { private final AggregatedDfs dfs ; private final int maxDoc ; public CachedDfSource ( AggregatedDfs dfs , Similarity similarity ) throws IOException { } public int docFreq ( Term term ) { int df = dfs . dfMap ( ) . get ( term ) ; if ( df == ( - 1 ) ) { <START_BUG> throw new IllegalArgumentException ( ( ( "df<seq2seq4repair_space>for<seq2seq4repair_space>term<seq2seq4repair_space>" + ( term . text ( ) ) ) + "<seq2seq4repair_space>not<seq2seq4repair_space>available" ) ) ; <END_BUG> } return df ; } public int [ ] docFreqs ( Term [ ] terms ) { } public int maxDoc ( ) { } public Query rewrite ( Query query ) { } public void close ( ) { } public Document doc ( int i ) { } public Document doc ( int i , FieldSelector fieldSelector ) { } public Explanation explain ( Weight weight , int doc ) { } public void search ( Weight weight , Filter filter , Collector results ) { } public TopDocs search ( Weight weight , Filter filter , int n ) { } public TopFieldDocs search ( Weight weight , Filter filter , int n , Sort sort ) { } }
public class ParticleEffect { private ArrayList < ParticleEmitter > emitters = new ArrayList ( ) ; public void start ( ) { } public void draw ( SpriteBatch spriteBatch , float delta ) { } public void allowCompletion ( ) { } public boolean isComplete ( ) { } public void setDuration ( int duration ) { } public void setPosition ( int x , int y ) { } public ArrayList < ParticleEmitter > getEmitters ( ) { } public void save ( File file ) { } public void load ( FileHandle effectFile , FileHandle imagesDir ) { } void loadEmitters ( FileHandle file ) { } private void loadEmitterImages ( FileHandle imagesDir ) { for ( int i = 0 , n = emitters . size ( ) ; i < n ; i ++ ) { ParticleEmitter emitter = emitters . get ( i ) ; String imagePath = emitter . getImagePath ( ) ; if ( imagePath == null ) continue ; <START_BUG> String imageName = new File ( imagePath ) . getName ( ) ; <END_BUG> emitter . setTexture ( loadTexture ( imagesDir . child ( imageName ) ) ) ; } } protected Texture loadTexture ( FileHandle file ) { } }
public class QueryParseElement implements SearchParseElement { @ Override public void parse ( XContentParser parser , SearchContext context ) throws Exception { XContentIndexQueryParser indexQueryParser = ( ( XContentIndexQueryParser ) ( context . queryParser ( ) ) ) ; <START_BUG> Query query = indexQueryParser . parse ( parser ) ; <END_BUG> context . query ( query ) ; } }
public class RecoverySource extends AbstractComponent { public static class Actions { public static final String START_RECOVERY = "index/shard/recovery/startRecovery" ; } private final ThreadPool threadPool ; private final TransportService transportService ; private final IndicesService indicesService ; private final RecoveryThrottler recoveryThrottler ; private final ByteSizeValue fileChunkSize ; @ Inject public RecoverySource ( Settings settings , ThreadPool threadPool , TransportService transportService , IndicesService indicesService , RecoveryThrottler recoveryThrottler ) { } private RecoveryResponse recover ( final StartRecoveryRequest request ) { } class StartRecoveryTransportRequestHandler extends BaseTransportRequestHandler < StartRecoveryRequest > { @ Override public StartRecoveryRequest newInstance ( ) { } @ Override public void messageReceived ( final StartRecoveryRequest request , final TransportChannel channel ) throws Exception { threadPool . cached ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { try { RecoveryResponse response = recover ( request ) ; channel . sendResponse ( response ) ; } catch ( Exception e ) { try { channel . sendResponse ( e ) ; <START_BUG> } catch ( IOException e1 ) { <END_BUG> } } } } ) ; } @ Override public boolean spawn ( ) { } } }
public class ParticleEmitter { private static final int UPDATE_SCALE = 1 << 0 ; private static final int UPDATE_ANGLE = 1 << 1 ; private static final int UPDATE_ROTATION = 1 << 2 ; private static final int UPDATE_VELOCITY = 1 << 3 ; private static final int UPDATE_WIND = 1 << 4 ; private static final int UPDATE_GRAVITY = 1 << 5 ; private static final int UPDATE_TINT = 1 << 6 ; private ParticleEmitter . RangedNumericValue delayValue = new ParticleEmitter . RangedNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue lifeOffsetValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . RangedNumericValue durationValue = new ParticleEmitter . RangedNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue lifeValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue emissionValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue scaleValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue rotationValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue velocityValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue angleValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue windValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue gravityValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue transparencyValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . GradientColorValue tintValue = new ParticleEmitter . GradientColorValue ( ) ; private ParticleEmitter . RangedNumericValue xOffsetValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . RangedNumericValue yOffsetValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue spawnWidthValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . ScaledNumericValue spawnHeightValue = new ParticleEmitter . ScaledNumericValue ( ) ; private ParticleEmitter . SpawnShapeValue spawnShapeValue = new ParticleEmitter . SpawnShapeValue ( ) ; private float accumulator ; private Sprite sprite ; private ParticleEmitter . Particle [ ] particles ; private int minParticleCount ; private int maxParticleCount = 4 ; private float x ; private float y ; private String name ; private String imagePath ; private int activeCount ; private boolean [ ] active ; private boolean firstUpdate ; private boolean flipX ; private boolean flipY ; private int updateFlags ; private boolean allowCompletion ; private int emission ; private int emissionDiff ; private int emissionDelta ; private int lifeOffset ; private int lifeOffsetDiff ; private int life ; private int lifeDiff ; private float spawnWidth ; private float spawnWidthDiff ; private float spawnHeight ; private float spawnHeightDiff ; public float duration = 1 ; public float durationTimer ; private float delay ; private float delayTimer ; private boolean attached ; private boolean continuous ; private boolean aligned ; private boolean behind ; private boolean additive = true ; public ParticleEmitter ( ) { } public ParticleEmitter ( BufferedReader reader ) throws IOException { } public ParticleEmitter ( ParticleEmitter emitter ) { } private void initialize ( ) { } public void setMaxParticleCount ( int maxParticleCount ) { } public void addParticle ( ) { } public void addParticles ( int count ) { } public void update ( float delta ) { } public void draw ( SpriteBatch spriteBatch ) { } public void draw ( SpriteBatch spriteBatch , float delta ) { } public void start ( ) { } public void reset ( ) { emissionDelta = 0 ; <START_BUG> durationTimer = 0 ; <END_BUG> start ( ) ; } private void restart ( ) { } protected ParticleEmitter . Particle newParticle ( Sprite sprite ) { } private void activateParticle ( int index ) { } private boolean updateParticle ( ParticleEmitter . Particle particle , float delta , int deltaMillis ) { } public void setPosition ( float x , float y ) { } public void setSprite ( Sprite sprite ) { } public void allowCompletion ( ) { } public Sprite getSprite ( ) { } public String getName ( ) { } public void setName ( String name ) { } public ParticleEmitter . ScaledNumericValue getLife ( ) { } public ParticleEmitter . ScaledNumericValue getScale ( ) { } public ParticleEmitter . ScaledNumericValue getRotation ( ) { } public ParticleEmitter . GradientColorValue getTint ( ) { } public ParticleEmitter . ScaledNumericValue getVelocity ( ) { } public ParticleEmitter . ScaledNumericValue getWind ( ) { } public ParticleEmitter . ScaledNumericValue getGravity ( ) { } public ParticleEmitter . ScaledNumericValue getAngle ( ) { } public ParticleEmitter . ScaledNumericValue getEmission ( ) { } public ParticleEmitter . ScaledNumericValue getTransparency ( ) { } public ParticleEmitter . RangedNumericValue getDuration ( ) { } public ParticleEmitter . RangedNumericValue getDelay ( ) { } public ParticleEmitter . ScaledNumericValue getLifeOffset ( ) { } public ParticleEmitter . RangedNumericValue getXOffsetValue ( ) { } public ParticleEmitter . RangedNumericValue getYOffsetValue ( ) { } public ParticleEmitter . ScaledNumericValue getSpawnWidth ( ) { } public ParticleEmitter . ScaledNumericValue getSpawnHeight ( ) { } public ParticleEmitter . SpawnShapeValue getSpawnShape ( ) { } public boolean isAttached ( ) { } public void setAttached ( boolean attached ) { } public boolean isContinuous ( ) { } public void setContinuous ( boolean continuous ) { } public boolean isAligned ( ) { } public void setAligned ( boolean aligned ) { } public boolean isAdditive ( ) { } public void setAdditive ( boolean additive ) { } public boolean isBehind ( ) { } public void setBehind ( boolean behind ) { } public int getMinParticleCount ( ) { } public void setMinParticleCount ( int minParticleCount ) { } public int getMaxParticleCount ( ) { } public boolean isComplete ( ) { } public float getPercentComplete ( ) { } public float getX ( ) { } public float getY ( ) { } public int getActiveCount ( ) { } public String getImagePath ( ) { } public void setImagePath ( String imagePath ) { }
public class SignificantLongTerms extends InternalSignificantTerms { public static final Type TYPE = new Type ( "significant_terms" , "siglterms" ) ; public static final Stream STREAM = new AggregationStreams . Stream ( ) { @ Override public SignificantLongTerms readResult ( StreamInput in ) throws IOException { } } ; public static void registerStreams ( ) { } static class Bucket extends InternalSignificantTerms . Bucket { long term ; public Bucket ( long subsetDf , long subsetSize , long supersetDf , long supersetSize , long term , InternalAggregations aggregations ) { } @ Override public Text getKeyAsText ( ) { } @ Override public Number getKeyAsNumber ( ) { } @ Override int compareTerm ( SignificantTerms . Bucket other ) { } @ Override public String getKey ( ) { } @ Override SignificantLongTerms . Bucket newBucket ( long subsetDf , long subsetSize , long supersetDf , long supersetSize , InternalAggregations aggregations ) { } } private ValueFormatter formatter ; SignificantLongTerms ( ) { } public SignificantLongTerms ( long subsetSize , long supersetSize , String name , @ Nullable ValueFormatter formatter , int requiredSize , long minDocCount , Collection < InternalSignificantTerms . Bucket > buckets ) { } @ Override public Type type ( ) { } @ Override InternalSignificantTerms newAggregation ( long subsetSize , long supersetSize , List < InternalSignificantTerms . Bucket > buckets ) { <START_BUG> return new SignificantLongTerms ( subsetSize , supersetSize , getName ( ) , formatter , requiredSize , supersetSize , buckets ) ; <END_BUG> } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class Quaternion implements Serializable { private static final long serialVersionUID = - 7661875440774897168L ; private static Quaternion tmp1 = new Quaternion ( 0 , 0 , 0 , 0 ) ; private static Quaternion tmp2 = new Quaternion ( 0 , 0 , 0 , 0 ) ; public float x ; public float y ; public float z ; public float w ; public Quaternion ( float x , float y , float z , float w ) { } public Quaternion ( ) { } public Quaternion ( Quaternion quaternion ) { } public Quaternion ( Vector3 axis , float angle ) { } public Quaternion set ( float x , float y , float z , float w ) { } public Quaternion set ( Quaternion quaternion ) { } public Quaternion set ( Vector3 axis , float angle ) { } public Quaternion cpy ( ) { } public static final float len ( final float x , final float y , final float z , final float w ) { } public float len ( ) { } @ Override public String toString ( ) { } public Quaternion setEulerAngles ( float yaw , float pitch , float roll ) { } public Quaternion setEulerAnglesRad ( float yaw , float pitch , float roll ) { } public int getGimbalPole ( ) { } public float getRollRad ( ) { } public float getRoll ( ) { } public float getPitchRad ( ) { } public float getPitch ( ) { } public float getYawRad ( ) { } public float getYaw ( ) { } public static final float len2 ( final float x , final float y , final float z , final float w ) { } public float len2 ( ) { } public Quaternion nor ( ) { float len = len2 ( ) ; <START_BUG> if ( ( len != 0.0F ) && ( ( Math . abs ( ( len - 1.0F ) ) ) > ( MathUtils . FLOAT_ROUNDING_ERROR ) ) ) { <END_BUG> len = ( ( float ) ( Math . sqrt ( len ) ) ) ; w /= len ; x /= len ; y /= len ; z /= len ; } return this ; } public Quaternion conjugate ( ) { } public Vector3 transform ( Vector3 v ) { } public Quaternion mul ( final Quaternion other ) { } public Quaternion mul ( final float x , final float y , final float z , final float w ) { } public Quaternion mulLeft ( Quaternion other ) { } public Quaternion mulLeft ( final float x , final float y , final float z , final float w ) { } public Quaternion add ( Quaternion quaternion ) { } public Quaternion add ( float qx , float qy , float qz , float qw ) { } public void toMatrix ( final float [ ] matrix ) { } public Quaternion idt ( ) { } public boolean isIdentity ( ) { } public boolean isIdentity ( final float tolerance ) { } public Quaternion setFromAxis ( final Vector3 axis , final float degrees ) { } public Quaternion setFromAxisRad ( final Vector3 axis , final float radians ) { } public Quaternion setFromAxis ( final float x , final float y , final float z , final float degrees ) { } public Quaternion setFromAxisRad ( final float x , final float y , final float z , final float radians ) { } public Quaternion setFromMatrix ( boolean normalizeAxes , Matrix4 matrix ) { } public Quaternion setFromMatrix ( Matrix4 matrix ) { } public Quaternion setFromMatrix ( boolean normalizeAxes , Matrix3 matrix ) { } public Quaternion setFromMatrix ( Matrix3 matrix ) { } public Quaternion setFromAxes ( float xx , float xy , float xz , float yx , float yy , float yz , float zx , float zy , float zz ) { } public Quaternion setFromAxes ( boolean normalizeAxes , float xx , float xy , float xz , float yx , float yy , float yz , float zx , float zy , float zz ) { } public Quaternion setFromCross ( final Vector3 v1 , final Vector3 v2 ) { } public Quaternion setFromCross ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } public Quaternion slerp ( Quaternion end , float alpha ) { } public Quaternion slerp ( Quaternion [ ] q ) { } public Quaternion slerp ( Quaternion [ ] q , float [ ] w ) { } public Quaternion exp ( float alpha ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } public static final float dot ( final float x1 , final float y1 , final float z1 , final float w1 , final float x2 , final float y2 , final float z2 , final float w2 ) { } public float dot ( final Quaternion other ) { } public float dot ( final float x , final float y , final float z , final float w ) { } public Quaternion mul ( float scalar ) { } public float getAxisAngle ( Vector3 axis ) { } public float getAxisAngleRad ( Vector3 axis ) { } public float getAngleRad ( ) { } public float getAngle ( ) { } public void getSwingTwist ( final float axisX , final float axisY , final float axisZ , final Quaternion swing , final Quaternion twist ) { } public void getSwingTwist ( final Vector3 axis , final Quaternion swing , final Quaternion twist ) { } public float getAngleAroundRad ( final float axisX , final float axisY , final float axisZ ) { }
public class JsonXContent implements XContent { public static XContentBuilder contentBuilder ( ) throws IOException { } private static final JsonFactory jsonFactory ; public static final JsonXContent jsonXContent ; private JsonXContent ( ) { } @ Override public XContentType type ( ) { } @ Override public byte streamSeparator ( ) { } @ Override public XContentGenerator createGenerator ( OutputStream os ) throws IOException { } @ Override public XContentGenerator createGenerator ( Writer writer ) throws IOException { } @ Override public XContentParser createParser ( String content ) throws IOException { } @ Override public XContentParser createParser ( InputStream is ) throws IOException { } @ Override public XContentParser createParser ( byte [ ] data ) throws IOException { } @ Override public XContentParser createParser ( byte [ ] data , int offset , int length ) throws IOException { } @ Override public XContentParser createParser ( BytesReference bytes ) throws IOException { } @ Override public XContentParser createParser ( Reader reader ) throws IOException { <START_BUG> return new JsonXContentParser ( JsonXContent . jsonFactory . createJsonParser ( reader ) ) ; <END_BUG> } }
public class HomeActivity extends RoboActivity { private static final String TAG = "HA" ; private static final int CODE_LOGIN = 1 ; private class LinksListAdapter extends ArrayAdapter < String > { public LinksListAdapter ( List < String > objects ) { } @ Override public View getView ( int position , View convertView , ViewGroup parent ) { } } private class OrgListAdapter extends ArrayAdapter < User > { public OrgListAdapter ( List < User > objects ) { } @ Override public View getView ( int position , View convertView , ViewGroup parent ) { } } private Map < String , Integer > linkViews = new LinkedHashMap < String , Integer > ( ) ; @ Inject private ContextScopedProvider < Account > accountProvider ; @ Inject private ContextScopedProvider < AccountDataManager > cache ; @ InjectView ( id . lv_orgs ) private ListView orgsList ; @ InjectView ( id . lv_links ) private ListView linksList ; protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( home ) ; linkViews . put ( "Dashboard" , dashboard_icon ) ; linkViews . put ( "Gists" , gist_icon ) ; linksList . setAdapter ( new HomeActivity . LinksListAdapter ( new ArrayList < String > ( linkViews . keySet ( ) ) ) ) ; linksList . setOnItemClickListener ( new OnItemClickListener ( ) { public void onItemClick ( AdapterView < ? > arg0 , View arg1 , int position , long id ) { switch ( position ) { case 1 : startActivity ( new Intent ( HomeActivity . this , GistsActivity . class ) ) ; break ; default : break ; } } } ) ; orgsList . setOnItemClickListener ( new OnItemClickListener ( ) { public void onItemClick ( AdapterView < ? > view , View arg1 , int position , long id ) { User user = ( ( User ) ( view . getItemAtPosition ( position ) ) ) ; <START_BUG> startActivity ( RepoBrowseActivity . createIntent ( HomeActivity . this , user ) ) ; <END_BUG> } } ) ; } private void loadOrgs ( ) { } protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { } @ Override protected void onResume ( ) { } }
public abstract class HasParentFilter extends Filter implements ScopePhase . CollectorPhase { final Query parentQuery ; final String scope ; final String parentType ; final SearchContext context ; HasParentFilter ( Query parentQuery , String scope , String parentType , SearchContext context ) { } public String scope ( ) { } public Query query ( ) { } @ Override public String toString ( ) { } public static HasParentFilter create ( String executionType , Query query , String scope , String parentType , SearchContext context ) { } static class Uid extends HasParentFilter { THashSet < HashedBytesArray > parents ; Uid ( Query query , String scope , String parentType , SearchContext context ) { } public boolean requiresProcessing ( ) { } public Collector collector ( ) { } public void processCollector ( Collector collector ) { } public DocIdSet getDocIdSet ( IndexReader reader ) throws IOException { if ( ( parents ) == null ) { throw new ElasticSearchIllegalStateException ( "has_parent<seq2seq4repair_space>filter/query<seq2seq4repair_space>hasn't<seq2seq4repair_space>executed<seq2seq4repair_space>properly" ) ; } IdReaderTypeCache idReaderTypeCache = context . idCache ( ) . reader ( reader ) . type ( parentType ) ; if ( idReaderTypeCache != null ) { return new HasParentFilter . Uid . ChildrenDocSet ( reader , parents , idReaderTypeCache ) ; } else { <START_BUG> return DocIdSet . EMPTY_DOCIDSET ; <END_BUG> } } public void clear ( ) { } static class ChildrenDocSet extends GetDocSet { final IndexReader reader ; final THashSet < HashedBytesArray > parents ; final IdReaderTypeCache idReaderTypeCache ; ChildrenDocSet ( IndexReader reader , THashSet < HashedBytesArray > parents , IdReaderTypeCache idReaderTypeCache ) { } public boolean get ( int doc ) { } } static class ParentUidsCollector extends NoopCollector { final THashSet < HashedBytesArray > collectedUids ; final SearchContext context ; final String parentType ; IdReaderTypeCache typeCache ; ParentUidsCollector ( THashSet < HashedBytesArray > collectedUids , SearchContext context , String parentType ) { } public void collect ( int doc ) throws IOException { } public void setNextReader ( IndexReader reader , int docBase ) throws IOException { } } } static class Bitset extends HasParentFilter { Map < Object , FixedBitSet > parentDocs ; Bitset ( Query query , String scope , String parentType , SearchContext context ) { } public boolean requiresProcessing ( ) { } public Collector collector ( ) { } public void processCollector ( Collector collector ) { } public DocIdSet getDocIdSet ( IndexReader reader ) throws IOException { if ( ( parentDocs ) == null ) { throw new ElasticSearchIllegalStateException ( "has_parent<seq2seq4repair_space>filter/query<seq2seq4repair_space>hasn't<seq2seq4repair_space>executed<seq2seq4repair_space>properly" ) ; } return new HasParentFilter . Bitset . ChildrenDocSet ( reader , parentDocs , context , parentType ) ; } public void clear ( ) { } static class ChildrenDocSet extends GetDocSet { final IdReaderTypeCache currentTypeCache ; final IndexReader currentReader ; final Tuple < IndexReader , IdReaderTypeCache > [ ] readersToTypeCache ; final Map < Object , FixedBitSet > parentDocs ; ChildrenDocSet ( IndexReader currentReader , Map < Object , FixedBitSet > parentDocs , SearchContext context , String parentType ) { } public boolean get ( int doc ) { } } static class ParentDocsCollector extends NoopCollector { final Map < Object , FixedBitSet > segmentResults = Maps . newHashMap ( ) ; FixedBitSet current ; public void collect ( int doc ) throws IOException { } public void setNextReader ( IndexReader reader , int docBase ) throws IOException { } } } }
public class btOverlapCallback extends BulletBase { private long swigCPtr ; protected btOverlapCallback ( final String className , long cPtr , boolean cMemoryOwn ) { } public btOverlapCallback ( long cPtr , boolean cMemoryOwn ) { } @ Override protected void reset ( long cPtr , boolean cMemoryOwn ) { } public static long getCPtr ( btOverlapCallback obj ) { } @ Override protected void finalize ( ) throws Throwable { } @ Override protected synchronized void delete ( ) { } protected void swigDirectorDisconnect ( ) { } public void swigReleaseOwnership ( ) { } public void swigTakeOwnership ( ) { } public boolean processOverlap ( btBroadphasePair pair ) { <START_BUG> return CollisionJNI . btOverlapCallback_processOverlap ( swigCPtr , this , btBroadphasePair . getCPtr ( pair ) , pair ) ; <END_BUG> } public btOverlapCallback ( ) { } }
@ ChannelHandler . Sharable public class HttpRequestHandler extends SimpleChannelUpstreamHandler { private final NettyHttpServerTransport serverTransport ; public HttpRequestHandler ( NettyHttpServerTransport serverTransport ) { } @ Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { HttpRequest request = ( ( HttpRequest ) ( e . getMessage ( ) ) ) ; <START_BUG> serverTransport . dispatchRequest ( new NettyHttpRequest ( request ) , new NettyHttpChannel ( serverTransport , e . getChannel ( ) , request ) ) ; <END_BUG> super . messageReceived ( ctx , e ) ; } @ Override public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception { } }
public class TileAtlas implements Disposable { private IntMap < AtlasRegion > regionsMap ; private final HashSet < Texture > textures = new HashSet < Texture > ( 1 ) ; public TileAtlas ( TiledMap map , FileHandle inputDir ) { } public AtlasRegion getRegion ( int id ) { } public void dispose ( ) { } private static String removeExtension ( String s ) { } private static String removePath ( String s ) { } private static FileHandle getRelativeFileHandle ( FileHandle path , String relativePath ) { <START_BUG> if ( relativePath . trim ( ) . isEmpty ( ) ) <END_BUG> return path ; FileHandle child = path ; StringTokenizer tokenizer = new StringTokenizer ( relativePath , "\\/" ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( ".." ) ) child = child . parent ( ) ; else { child = child . child ( token ) ; } } return child ; } }
public class LZFCompressedIndexInput extends CompressedIndexInput < LZFCompressorContext > { private final ChunkDecoder decoder ; private byte [ ] inputBuffer ; public LZFCompressedIndexInput ( IndexInput in , ChunkDecoder decoder ) throws IOException { } @ Override protected void readHeader ( IndexInput in ) throws IOException { } @ Override protected int uncompress ( IndexInput in , byte [ ] out ) throws IOException { } @ Override protected void doClose ( ) throws IOException { } @ Override <START_BUG> public Object clone ( ) { <END_BUG> LZFCompressedIndexInput cloned = ( ( LZFCompressedIndexInput ) ( super . clone ( ) ) ) ; cloned . inputBuffer = new byte [ LZFChunk . MAX_CHUNK_LEN ] ; return cloned ; } }
public class Queries { public static final Query MATCH_ALL_QUERY = new DeletionAwareConstantScoreQuery ( new MatchAllDocsFilter ( ) , true ) ; public static final Filter MATCH_ALL_FILTER = new MatchAllDocsFilter ( ) ; private static final Field disjuncts ; public static List < Query > disMaxClauses ( DisjunctionMaxQuery query ) { } public static Query optimizeQuery ( Query q ) { } public static boolean isNegativeQuery ( Query q ) { } public static Query fixNegativeQueryIfNeeded ( Query q ) { if ( Queries . isNegativeQuery ( q ) ) { BooleanQuery newBq = ( ( BooleanQuery ) ( q . clone ( ) ) ) ; <START_BUG> newBq . add ( new MatchAllDocsQuery ( ) , MUST ) ; <END_BUG> return newBq ; } return q ; } }
public abstract class AndroidLiveWallpaperService extends WallpaperService { static final String TAG = "WallpaperService" ; static boolean DEBUG = false ; protected volatile AndroidLiveWallpaper app = null ; protected Callback view = null ; protected int viewFormat ; protected int viewWidth ; protected int viewHeight ; protected int engines = 0 ; protected int visibleEngines = 0 ; protected volatile AndroidLiveWallpaperService . AndroidWallpaperEngine linkedEngine = null ; protected void setLinkedEngine ( AndroidLiveWallpaperService . AndroidWallpaperEngine linkedEngine ) { } protected volatile boolean isPreviewNotified = false ; protected volatile boolean notifiedPreviewState = false ; volatile int [ ] sync = new int [ 0 ] ; public AndroidLiveWallpaperService ( ) { } @ Override public void onCreate ( ) { } @ Override public Engine onCreateEngine ( ) { } public void onCreateApplication ( ) { } public void initialize ( ApplicationListener listener , boolean useGL2IfAvailable ) { } public void initialize ( ApplicationListener listener , AndroidApplicationConfiguration config ) { if ( AndroidLiveWallpaperService . DEBUG ) Log . d ( AndroidLiveWallpaperService . TAG , "<seq2seq4repair_space>><seq2seq4repair_space>AndroidLiveWallpaperService<seq2seq4repair_space>-<seq2seq4repair_space>initialize()" ) ; app . initialize ( listener , config ) ; <START_BUG> if ( ( config . getTouchEventsForLiveWallpaper ) && ( ( Integer . parseInt ( SDK ) ) < 9 ) ) <END_BUG> linkedEngine . setTouchEventsEnabled ( true ) ; } public SurfaceHolder getSurfaceHolder ( ) { } public void onDeepPauseApplication ( ) { } @ Override public void onDestroy ( ) { } @ Override protected void finalize ( ) throws Throwable { } public AndroidLiveWallpaper getLiveWallpaper ( ) { } public WindowManager getWindowManager ( ) { } public class AndroidWallpaperEngine extends Engine { protected boolean engineIsVisible = false ; protected int engineFormat ; protected int engineWidth ; protected int engineHeight ; public AndroidWallpaperEngine ( ) { } @ Override public void onCreate ( final SurfaceHolder surfaceHolder ) { } @ Override public void onSurfaceCreated ( final SurfaceHolder holder ) { } @ Override public void onSurfaceChanged ( final SurfaceHolder holder , final int format , final int width , final int height ) { } private void notifySurfaceChanged ( final int format , final int width , final int height , boolean forceUpdate ) { } @ Override public void onVisibilityChanged ( final boolean visible ) { } private void notifyVisibilityChanged ( final boolean visible ) { } public void onResume ( ) { } public void onPause ( ) { } @ Override public void onSurfaceDestroyed ( final SurfaceHolder holder ) { } @ Override public void onDestroy ( ) { } @ Override public Bundle onCommand ( final String pAction , final int pX , final int pY , final int pZ , final Bundle pExtras , final boolean pResultRequested ) { } @ Override public void onTouchEvent ( MotionEvent event ) { } boolean offsetsConsumed = true ; float xOffset = 0.0F ; float yOffset = 0.0F ; float xOffsetStep = 0.0F ; float yOffsetStep = 0.0F ; int xPixelOffset = 0 ; int yPixelOffset = 0 ; @ Override public void onOffsetsChanged ( final float xOffset , final float yOffset , final float xOffsetStep , final float yOffsetStep , final int xPixelOffset , final int yPixelOffset ) { } protected void notifyOffsetsChanged ( ) { } protected void notifyPreviewState ( ) { } } }
public class ImageTest extends GdxTest { Skin skin ; Stage ui ; Table root ; TextureRegion image2 ; @ Override public void create ( ) { } @ Override public void dispose ( ) { } @ Override public void render ( ) { } @ Override public void resize ( int width , int height ) { <START_BUG> ui . getViewport ( ) . update ( width , height ) ; <END_BUG> root . setSize ( width , height ) ; } }
@ ElasticsearchIntegrationTest . SuiteScopeTest public class DateHistogramTests extends ElasticsearchIntegrationTest { private DateTime date ( int month , int day ) { } private DateTime date ( String date ) { } private static String format ( DateTime date , String pattern ) { } private IndexRequestBuilder indexDoc ( String idx , DateTime date , int value ) throws Exception { } private IndexRequestBuilder indexDoc ( int month , int day , int value ) throws Exception { } @ Override public void setupSuiteScopeCluster ( ) throws Exception { } @ After public void afterEachTest ( ) throws IOException { } private static Bucket getBucket ( DateHistogram histogram , DateTime key ) { } private static Bucket getBucket ( DateHistogram histogram , DateTime key , String format ) { } @ Test public void singleValuedField ( ) throws Exception { } @ Test public void singleValuedField_WithPostTimeZone ( ) throws Exception { SearchResponse response ; if ( randomBoolean ( ) ) { response = client ( ) . prepareSearch ( "idx" ) . addAggregation ( dateHistogram ( "histo" ) . field ( "date" ) . interval ( DAY ) . postZone ( "-01:00" ) ) . execute ( ) . actionGet ( ) ; } else { response = client ( ) . prepareSearch ( "idx" ) . addAggregation ( new AbstractAggregationBuilder ( "histo" , "date_histogram" ) { @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { <START_BUG> return builder . startObject ( getName ( ) ) . startObject ( type ) . field ( "field" , "date" ) . field ( "interval" , "1d" ) . field ( "post_zone" , ( - 1 ) ) . endObject ( ) . endObject ( ) ; <END_BUG> } } ) . execute ( ) . actionGet ( ) ; } assertSearchResponse ( response ) ; DateHistogram histo = response . getAggregations ( ) . get ( "histo" ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( "histo" ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( 6 ) ) ; long key = new DateTime ( 2012 , 1 , 2 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; DateHistogram . Bucket bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; key = new DateTime ( 2012 , 2 , 2 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; key = new DateTime ( 2012 , 2 , 15 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; key = new DateTime ( 2012 , 3 , 2 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; key = new DateTime ( 2012 , 3 , 15 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; key = new DateTime ( 2012 , 3 , 23 , 0 , 0 , org . joda . time . DateTimeZone . forID ( "+01:00" ) ) . getMillis ( ) ; bucket = histo . getBucketByKey ( key ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsNumber ( ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( 1L ) ) ; } @ Test public void singleValuedField_OrderedByKeyAsc ( ) throws Exception { } @ Test public void singleValuedField_OrderedByKeyDesc ( ) throws Exception { } @ Test public void singleValuedField_OrderedByCountAsc ( ) throws Exception { } @ Test public void singleValuedField_OrderedByCountDesc ( ) throws Exception { } @ Test public void singleValuedField_WithSubAggregation ( ) throws Exception { } @ Test public void singleValuedField_WithSubAggregation_Inherited ( ) throws Exception { } @ Test public void singleValuedField_OrderedBySubAggregationAsc ( ) throws Exception { } @ Test public void singleValuedField_OrderedBySubAggregationDesc ( ) throws Exception { } @ Test public void singleValuedField_OrderedByMultiValuedSubAggregationAsc_Inherited ( ) throws Exception { } @ Test public void singleValuedField_OrderedByMultiValuedSubAggregationDesc ( ) throws Exception { } @ Test public void singleValuedField_WithValueScript ( ) throws Exception { } @ Test public void multiValuedField ( ) throws Exception { }
public class SizeByAction extends RelativeTemporalAction { private float amountWidth ; private float amountHeight ; protected void updateRelative ( float percentDelta ) { <START_BUG> actor . sizeBy ( ( ( amountWidth ) * percentDelta ) , ( ( amountHeight ) * percentDelta ) ) ; <END_BUG> } public void setAmount ( float width , float height ) { } public float getAmountWidth ( ) { } public void setAmountWidth ( float width ) { } public float getAmountHeight ( ) { } public void setAmountHeight ( float height ) { } }
public class BitmapFont implements Disposable { private static final int LOG2_PAGE_SIZE = 9 ; private static final int PAGE_SIZE = 1 << ( BitmapFont . LOG2_PAGE_SIZE ) ; private static final int PAGES = 65536 / ( BitmapFont . PAGE_SIZE ) ; public static final char [ ] xChars = new char [ ] { 'x' , 'e' , 'a' , 'o' , 'n' , 's' , 'r' , 'c' , 'u' , 'm' , 'v' , 'w' , 'z' } ; public static final char [ ] capChars = new char [ ] { 'M' , 'N' , 'B' , 'D' , 'C' , 'E' , 'F' , 'K' , 'A' , 'G' , 'H' , 'I' , 'J' , 'L' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } ; final BitmapFont . BitmapFontData data ; TextureRegion [ ] regions ; private final BitmapFontCache cache ; private boolean flipped ; private boolean integer ; private boolean ownsTexture ; public BitmapFont ( ) { } public BitmapFont ( boolean flip ) { } public BitmapFont ( FileHandle fontFile , TextureRegion region ) { } public BitmapFont ( FileHandle fontFile , TextureRegion region , boolean flip ) { } public BitmapFont ( FileHandle fontFile ) { } public BitmapFont ( FileHandle fontFile , boolean flip ) { } public BitmapFont ( FileHandle fontFile , FileHandle imageFile , boolean flip ) { } public BitmapFont ( FileHandle fontFile , FileHandle imageFile , boolean flip , boolean integer ) { } public BitmapFont ( BitmapFont . BitmapFontData data , TextureRegion region , boolean integer ) { } public BitmapFont ( BitmapFont . BitmapFontData data , TextureRegion [ ] regions , boolean integer ) { } private void load ( BitmapFont . BitmapFontData data ) { } public BitmapFont . TextBounds draw ( Batch batch , CharSequence str , float x , float y ) { } public BitmapFont . TextBounds draw ( Batch batch , CharSequence str , float x , float y , int start , int end ) { } public BitmapFont . TextBounds drawMultiLine ( Batch batch , CharSequence str , float x , float y ) { } public BitmapFont . TextBounds drawMultiLine ( Batch batch , CharSequence str , float x , float y , float alignmentWidth , BitmapFont . HAlignment alignment ) { } public BitmapFont . TextBounds drawWrapped ( Batch batch , CharSequence str , float x , float y , float wrapWidth ) { } public BitmapFont . TextBounds drawWrapped ( Batch batch , CharSequence str , float x , float y , float wrapWidth , BitmapFont . HAlignment alignment ) { } public BitmapFont . TextBounds getBounds ( CharSequence str ) { <START_BUG> return getBounds ( str , 0 , str . length ( ) , cache . getBounds ( ) ) ; <END_BUG> } public BitmapFont . TextBounds getBounds ( CharSequence str , BitmapFont . TextBounds textBounds ) { } public BitmapFont . TextBounds getBounds ( CharSequence str , int start , int end ) { } public BitmapFont . TextBounds getBounds ( CharSequence str , int start , int end , BitmapFont . TextBounds textBounds ) { } public BitmapFont . TextBounds getMultiLineBounds ( CharSequence str ) { } public BitmapFont . TextBounds getMultiLineBounds ( CharSequence str , BitmapFont . TextBounds textBounds ) { } public BitmapFont . TextBounds getWrappedBounds ( CharSequence str , float wrapWidth ) { } public BitmapFont . TextBounds getWrappedBounds ( CharSequence str , float wrapWidth , BitmapFont . TextBounds textBounds ) { } public void computeGlyphAdvancesAndPositions ( CharSequence str , FloatArray glyphAdvances , FloatArray glyphPositions ) { } public int computeVisibleGlyphs ( CharSequence str , int start , int end , float availableWidth ) { } public void setColor ( float color ) { } public void setColor ( Color color ) { } public void setColor ( float r , float g , float b , float a ) { } public Color getColor ( ) { } public void setScale ( float scaleX , float scaleY ) { } public void setScale ( float scaleXY ) { } public void scale ( float amount ) { } public float getScaleX ( ) { } public float getScaleY ( ) { } public TextureRegion getRegion ( ) { } public TextureRegion [ ] getRegions ( ) { } public TextureRegion getRegion ( int index ) { } public float getLineHeight ( ) { } public float getSpaceWidth ( ) { } public float getXHeight ( ) { } public float getCapHeight ( ) { } public float getAscent ( ) { } public float getDescent ( ) { } public boolean isFlipped ( ) { } public void dispose ( ) { } public void setFixedWidthGlyphs ( CharSequence glyphs ) { } public boolean containsCharacter ( char character ) { } public void setUseIntegerPositions ( boolean integer ) { } public boolean usesIntegerPositions ( ) { } public BitmapFontCache getCache ( ) { } public BitmapFont . BitmapFontData getData ( ) { } public boolean ownsTexture ( ) { } public void setOwnsTexture ( boolean ownsTexture ) { } public static class Glyph { public int id ; public int srcX ; public int srcY ; public int width ; public int height ; public float u ; public float v ; public float u2 ; public float v2 ; public int xoffset ; public int yoffset ; public int xadvance ; public byte [ ] [ ] kerning ; public int page = 0 ; public int getKerning ( char ch ) { } public void setKerning ( int ch , int value ) { } } static int indexOf ( CharSequence text , char ch , int start ) { } static boolean isWhitespace ( char c ) { } public static class TextBounds { public float width ; public float height ;
public class Loggers { private static final String commonPrefix = System . getProperty ( "es.logger.prefix" , "org.elasticsearch." ) ; public static final String SPACE = "<seq2seq4repair_space>" ; private static boolean consoleLoggingEnabled = true ; public static void disableConsoleLogging ( ) { } public static void enableConsoleLogging ( ) { } public static boolean consoleLoggingEnabled ( ) { } public static ESLogger getLogger ( Class clazz , Settings settings , ShardId shardId , String ... prefixes ) { } public static ESLogger getLogger ( Class clazz , Settings settings , Index index , String ... prefixes ) { } public static ESLogger getLogger ( Class clazz , Settings settings , RiverName riverName , String ... prefixes ) { } public static ESLogger getLogger ( Class clazz , Settings settings , String ... prefixes ) { } public static ESLogger getLogger ( String loggerName , Settings settings , String ... prefixes ) { } public static ESLogger getLogger ( ESLogger parentLogger , String s ) { <START_BUG> return Loggers . getLogger ( ( ( parentLogger . getName ( ) ) + s ) , parentLogger . getPrefix ( ) ) ; <END_BUG> } public static ESLogger getLogger ( String s ) { } public static ESLogger getLogger ( Class clazz ) { } public static ESLogger getLogger ( Class clazz , String ... prefixes ) { } public static ESLogger getLogger ( String name , String ... prefixes ) { } private static String buildClassLoggerName ( Class clazz ) { } private static String getLoggerName ( String name ) { } }
public class PreBuiltTokenizerFactoryFactory implements TokenizerFactoryFactory { private final TokenizerFactory tokenizerFactory ; public PreBuiltTokenizerFactoryFactory ( TokenizerFactory tokenizerFactory ) { } @ Override public TokenizerFactory create ( String name , Settings settings ) { <START_BUG> Version indexVersion = settings . getAsVersion ( SETTING_VERSION_CREATED , CURRENT ) ; <END_BUG> if ( ! ( CURRENT . equals ( indexVersion ) ) ) { PreBuiltTokenizers preBuiltTokenizers = PreBuiltTokenizers . getOrDefault ( name , null ) ; if ( preBuiltTokenizers != null ) { return preBuiltTokenizers . getTokenizerFactory ( indexVersion ) ; } } return tokenizerFactory ; } }
public class Sprite extends TextureRegion { static final int VERTEX_SIZE = ( 2 + 1 ) + 2 ; static final int SPRITE_SIZE = 4 * ( Sprite . VERTEX_SIZE ) ; final float [ ] vertices = new float [ Sprite . SPRITE_SIZE ] ; private final Color color = new Color ( 1 , 1 , 1 , 1 ) ; private float x ; private float y ; float width ; float height ; private float originX ; private float originY ; private float rotation ; private float scaleX = 1 ; private float scaleY = 1 ; private boolean dirty = true ; private Rectangle bounds ; public Sprite ( ) { } public Sprite ( Texture texture ) { } public Sprite ( Texture texture , int srcWidth , int srcHeight ) { } public Sprite ( Texture texture , int srcX , int srcY , int srcWidth , int srcHeight ) { } public Sprite ( TextureRegion region ) { } public Sprite ( TextureRegion region , int srcX , int srcY , int srcWidth , int srcHeight ) { } public Sprite ( Sprite sprite ) { } public void set ( Sprite sprite ) { } public void setBounds ( float x , float y , float width , float height ) { } public void setSize ( float width , float height ) { } public void setPosition ( float x , float y ) { } public void setX ( float x ) { } public void setY ( float y ) { } public void translateX ( float xAmount ) { } public void translateY ( float yAmount ) { } public void translate ( float xAmount , float yAmount ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public void setOrigin ( float originX , float originY ) { } public void setRotation ( float degrees ) { } public void rotate ( float degrees ) { } public void rotate90 ( boolean clockwise ) { } public void setScale ( float scaleXY ) { } public void setScale ( float scaleX , float scaleY ) { } public void scale ( float amount ) { } public float [ ] getVertices ( ) { } public Rectangle getBoundingRectangle ( ) { } public void draw ( SpriteBatch . SpriteBatch spriteBatch ) { } public void draw ( SpriteBatch . SpriteBatch spriteBatch , float alphaModulation ) { } public float getX ( ) { } public float getY ( ) { } public float getWidth ( ) { } public float getHeight ( ) { } public float getOriginX ( ) { } public float getOriginY ( ) { } public float getRotation ( ) { } public float getScaleX ( ) { } public float getScaleY ( ) { } public Color getColor ( ) { } public void setRegion ( float u , float v , float u2 , float v2 ) { } public void setU ( float u ) { } public void setV ( float v ) { <START_BUG> super . setV ( u ) ; <END_BUG> vertices [ V2 ] = v ; vertices [ V3 ] = v ; } public void setU2 ( float u2 ) { } public void setV2 ( float v2 ) { } public void flip ( boolean x , boolean y ) { } public void scroll ( float xAmount , float yAmount ) { } }
public class IndexRequestBuilder extends ShardReplicationOperationRequestBuilder < IndexRequest , IndexResponse , IndexRequestBuilder > { public IndexRequestBuilder ( Client client ) { } public IndexRequestBuilder ( Client client , @ Nullable String index ) { } public IndexRequestBuilder setType ( String type ) { } public IndexRequestBuilder setId ( String id ) { } public IndexRequestBuilder setRouting ( String routing ) { } public IndexRequestBuilder setParent ( String parent ) { } public IndexRequestBuilder setSource ( BytesReference source , boolean unsafe ) { } public IndexRequestBuilder setSource ( BytesReference source ) { } public IndexRequestBuilder setSource ( Map < String , Object > source ) { } public IndexRequestBuilder setSource ( Map < String , Object > source , XContentType contentType ) { } public IndexRequestBuilder setSource ( String source ) { } public IndexRequestBuilder setSource ( XContentBuilder sourceBuilder ) { } public IndexRequestBuilder setSource ( byte [ ] source ) { } public IndexRequestBuilder setSource ( byte [ ] source , int offset , int length ) { } public IndexRequestBuilder setSource ( byte [ ] source , int offset , int length , boolean unsafe ) { } public IndexRequestBuilder setSource ( String field1 , Object value1 ) { } public IndexRequestBuilder setSource ( String field1 , Object value1 , String field2 , Object value2 ) { } public IndexRequestBuilder setSource ( String field1 , Object value1 , String field2 , Object value2 , String field3 , Object value3 ) { } public IndexRequestBuilder setSource ( String field1 , Object value1 , String field2 , Object value2 , String field3 , Object value3 , String field4 , Object value4 ) { } public IndexRequestBuilder setSource ( Object ... source ) { } public IndexRequestBuilder setContentType ( XContentType contentType ) { } public IndexRequestBuilder setOpType ( IndexRequest . OpType opType ) { } public IndexRequestBuilder setOpType ( String opType ) { <START_BUG> request . opType ( opType ) ; <END_BUG> return this ; } public IndexRequestBuilder setCreate ( boolean create ) { } public IndexRequestBuilder setRefresh ( boolean refresh ) { } public IndexRequestBuilder setReplicationType ( ReplicationType replicationType ) { } public IndexRequestBuilder setConsistencyLevel ( WriteConsistencyLevel consistencyLevel ) { } public IndexRequestBuilder setReplicationType ( String replicationType ) { } public IndexRequestBuilder setVersion ( long version ) { } public IndexRequestBuilder setVersionType ( VersionType versionType ) { } public IndexRequestBuilder setTimestamp ( String timestamp ) { } public IndexRequestBuilder setTTL ( long ttl ) { } @ Override protected void doExecute ( ActionListener < IndexResponse > listener ) { } }
public class MultiMatchQuery extends MatchQuery { private Float groupTieBreaker = null ; public void setTieBreaker ( float tieBreaker ) { } public MultiMatchQuery ( QueryParseContext parseContext ) { } private Query parseAndApply ( Type type , String fieldName , Object value , String minimumShouldMatch , Float boostValue ) throws IOException { } public Query parse ( MultiMatchQueryBuilder . Type type , Map < String , Float > fieldNames , Object value , String minimumShouldMatch ) throws IOException { } private MultiMatchQuery . QueryBuilder queryBuilder ; public class QueryBuilder { protected final boolean groupDismax ; protected final float tieBreaker ; public QueryBuilder ( float tieBreaker ) { } public QueryBuilder ( boolean groupDismax , float tieBreaker ) { } public List < Query > buildGroupedQueries ( MultiMatchQueryBuilder . Type type , Map < String , Float > fieldNames , Object value , String minimumShouldMatch ) throws IOException { } public Query parseGroup ( Type type , String field , Float boostValue , Object value , String minimumShouldMatch ) throws IOException { } public Query conbineGrouped ( List < ? extends Query > groupQuery ) { } public Query blendTerm ( Term term , FieldMapper mapper ) { } public boolean forceAnalyzeQueryString ( ) { return false ; } } public class CrossFieldsQueryBuilder extends MultiMatchQuery . QueryBuilder { private MultiMatchQuery . FieldAndMapper [ ] blendedFields ; public CrossFieldsQueryBuilder ( float tieBreaker ) { } public List < Query > buildGroupedQueries ( MultiMatchQueryBuilder . Type type , Map < String , Float > fieldNames , Object value , String minimumShouldMatch ) throws IOException { } public boolean forceAnalyzeQueryString ( ) { return ( blendedFields ) != null ; } public Query blendTerm ( Term term , FieldMapper mapper ) { } } @ Override protected Query blendTermQuery ( Term term , FieldMapper mapper ) { } private static final class FieldAndMapper { final String field ; final FieldMapper mapper ; final float boost ; private FieldAndMapper ( String field , FieldMapper mapper , float boost ) { } public Term newTerm ( String value ) { } } protected boolean forceAnalyzeQueryString ( ) { <START_BUG> return this . queryBuilder . forceAnalyzeQueryString ( ) ; <END_BUG> } }
public class TransportSearchQueryThenFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchQueryThenFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportSearchCache transportSearchCache , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < QuerySearchResult > { private final Map < SearchShardTarget , QuerySearchResultProvider > queryResults = searchCache . obtainQueryResults ( ) ; private final Map < SearchShardTarget , FetchSearchResult > fetchResults = searchCache . obtainFetchResults ( ) ; private volatile Map < SearchShardTarget , ExtTIntArrayList > docIdsToLoad ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , InternalSearchRequest request , SearchServiceListener < QuerySearchResult > listener ) { } @ Override protected void processFirstPhaseResult ( ShardRouting shard , QuerySearchResult result ) { } @ Override protected void moveToSecondPhase ( ) { } private void executeFetch ( final SearchShardTarget shardTarget , final AtomicInteger counter , final FetchSearchRequest fetchSearchRequest , DiscoveryNode node ) { } private void finishHim ( ) { } private void innerFinishHim ( ) throws Exception { InternalSearchResponse internalResponse = searchPhaseController . merge ( sortedShardList , queryResults , fetchResults ) ; String scrollId = null ; if ( ( request . scroll ( ) ) != null ) { <START_BUG> scrollId = TransportSearchHelper . buildScrollId ( request . searchType ( ) , queryResults . values ( ) ) ; <END_BUG> } listener . onResponse ( new SearchResponse ( internalResponse , scrollId , expectedSuccessfulOps , successulOps . get ( ) , buildTookInMillis ( ) , buildShardFailures ( ) ) ) ; } } }
abstract class AbstractStringTermsAggregator extends TermsAggregator { protected final boolean showTermDocCountError ; public AbstractStringTermsAggregator ( String name , AggregatorFactories factories , long estimatedBucketsCount , AggregationContext context , Aggregator parent , Terms . Order order , BucketCountThresholds bucketCountThresholds , SubAggCollectionMode subAggCollectMode , boolean showTermDocCountError ) { } @ Override public boolean shouldCollect ( ) { } @ Override public InternalAggregation buildEmptyAggregation ( ) { <START_BUG> return new StringTerms ( name , order , bucketCountThresholds . getRequiredSize ( ) , bucketCountThresholds . getShardSize ( ) , bucketCountThresholds . getMinDocCount ( ) , Collections . < InternalTerms . Bucket > emptyList ( ) , showTermDocCountError , 0 ) ; <END_BUG> } }
public class MasterFaultDetection extends AbstractComponent { public static interface Listener { void onMasterFailure ( DiscoveryNode masterNode , String reason ) { } void onDisconnectedFromMaster ( ) { } } private final ThreadPool threadPool ; private final TransportService transportService ; private final DiscoveryNodesProvider nodesProvider ; private final CopyOnWriteArrayList < MasterFaultDetection . Listener > listeners = new CopyOnWriteArrayList < MasterFaultDetection . Listener > ( ) ; private final boolean connectOnNetworkDisconnect ; private final TimeValue pingInterval ; private final TimeValue pingRetryTimeout ; private final int pingRetryCount ; private final boolean registerConnectionListener ; private final MasterFaultDetection . FDConnectionListener connectionListener ; private volatile MasterFaultDetection . MasterPinger masterPinger ; private final Object masterNodeMutex = new Object ( ) ; private volatile DiscoveryNode masterNode ; private volatile int retryCount ; private final AtomicBoolean notifiedMasterFailure = new AtomicBoolean ( ) ; public MasterFaultDetection ( Settings settings , ThreadPool threadPool , TransportService transportService , DiscoveryNodesProvider nodesProvider ) { } public DiscoveryNode masterNode ( ) { } public void addListener ( MasterFaultDetection . Listener listener ) { } public void removeListener ( MasterFaultDetection . Listener listener ) { } public void restart ( DiscoveryNode masterNode , String reason ) { } public void start ( final DiscoveryNode masterNode , String reason ) { } private void innerStart ( final DiscoveryNode masterNode ) { } public void stop ( String reason ) { } private void innerStop ( ) { } public void close ( ) { } private void handleTransportDisconnect ( DiscoveryNode node ) { } private void notifyDisconnectedFromMaster ( ) { } private void notifyMasterFailure ( final DiscoveryNode masterNode , final String reason ) { if ( notifiedMasterFailure . compareAndSet ( false , true ) ) { <START_BUG> threadPool . execute ( new Runnable ( ) { <END_BUG> @ Override public void run ( ) { for ( MasterFaultDetection . Listener listener : listeners ) { listener . onMasterFailure ( masterNode , reason ) ; } } } ) ; stop ( ( "master<seq2seq4repair_space>failure,<seq2seq4repair_space>" + reason ) ) ; } } private class FDConnectionListener implements TransportConnectionListener { @ Override public void onNodeConnected ( DiscoveryNode node ) { } @ Override public void onNodeDisconnected ( DiscoveryNode node ) { } } private class MasterPinger implements Runnable { private volatile boolean running = true ; public void stop ( ) { } @ Override public void run ( ) { } } private class MasterPingRequestHandler extends BaseTransportRequestHandler < MasterFaultDetection . MasterPingRequest > { public static final String ACTION = "discovery/zen/fd/masterPing" ; @ Override public MasterFaultDetection . MasterPingRequest newInstance ( ) { } @ Override public void messageReceived ( MasterFaultDetection . MasterPingRequest request , TransportChannel channel ) throws Exception { } } private static class MasterPingRequest implements Streamable { private String nodeId ; private String masterNodeId ; private MasterPingRequest ( ) { } private MasterPingRequest ( String nodeId , String masterNodeId ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } private static class MasterPingResponseResponse implements Streamable { private boolean connectedToMaster ; private MasterPingResponseResponse ( ) { } private MasterPingResponseResponse ( boolean connectedToMaster ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class RecoveryAction extends AbstractIndexShardComponent implements CloseableComponent { private final ByteSizeValue fileChunkSize ; private final ThreadPool threadPool ; private final TransportService transportService ; private final InternalIndexShard indexShard ; private final Store store ; private final RecoveryThrottler recoveryThrottler ; private final ConcurrentMap < String , IndexOutput > openIndexOutputs = newConcurrentMap ( ) ; private final String startTransportAction ; private final String fileChunkTransportAction ; private final String cleanFilesTransportAction ; private final String prepareForTranslogOperationsTransportAction ; private final String translogOperationsTransportAction ; private final String finalizeRecoveryTransportAction ; private volatile boolean closed = false ; private volatile Thread sendStartRecoveryThread ; private volatile Thread receiveSnapshotRecoveryThread ; private volatile Thread sendSnapshotRecoveryThread ; private final CopyOnWriteArrayList < Future > sendFileChunksRecoveryFutures = new CopyOnWriteArrayList < Future > ( ) ; @ Inject public RecoveryAction ( ShardId shardId , @ IndexSettings Settings indexSettings , ThreadPool threadPool , TransportService transportService , IndexShard indexShard , Store store , RecoveryThrottler recoveryThrottler ) { } public void close ( ) { } public synchronized void startRecovery ( DiscoveryNode node , DiscoveryNode targetNode , boolean markAsRelocated ) throws ElasticSearchException { } private void cleanOpenIndex ( ) { } static class StartRecoveryRequest implements Streamable { DiscoveryNode node ; boolean markAsRelocated ; Map < String , StoreFileMetaData > existingFiles ; private StartRecoveryRequest ( ) { } private StartRecoveryRequest ( DiscoveryNode node , boolean markAsRelocated , Map < String , StoreFileMetaData > existingFiles ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } private class StartRecoveryTransportRequestHandler extends BaseTransportRequestHandler < RecoveryAction . StartRecoveryRequest > { @ Override public RecoveryAction . StartRecoveryRequest newInstance ( ) { } @ Override public void messageReceived ( final RecoveryAction . StartRecoveryRequest startRecoveryRequest , final TransportChannel channel ) throws Exception { } } private static class RecoveryStatus implements Streamable { boolean retry = false ; List < String > phase1FileNames = Lists . newArrayList ( ) ; List < Long > phase1FileSizes = Lists . newArrayList ( ) ; List < String > phase1ExistingFileNames = Lists . newArrayList ( ) ; List < Long > phase1ExistingFileSizes = Lists . newArrayList ( ) ; long phase1TotalSize ; long phase1ExistingTotalSize ; long phase1Time ; long phase1ThrottlingWaitTime ; int phase2Operations ; long phase2Time ; int phase3Operations ; long phase3Time ; private RecoveryStatus ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } static class CleanFilesRequest implements Streamable { Set < String > snapshotFiles = Sets . newHashSet ( ) ; @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } class CleanFilesRequestHandler extends BaseTransportRequestHandler < RecoveryAction . CleanFilesRequest > { @ Override public RecoveryAction . CleanFilesRequest newInstance ( ) { } @ Override public void messageReceived ( RecoveryAction . CleanFilesRequest request , TransportChannel channel ) throws Exception { } } class PrepareForTranslogOperationsRequestHandler extends BaseTransportRequestHandler < VoidStreamable > { @ Override public VoidStreamable newInstance ( ) { } @ Override public void messageReceived ( VoidStreamable stream , TransportChannel channel ) throws Exception { receiveSnapshotRecoveryThread = Thread . currentThread ( ) ; try { indexShard . performRecoveryPrepareForTranslog ( ) ; channel . sendResponse ( INSTANCE ) ; } finally { receiveSnapshotRecoveryThread = null ; } } } class FinalizeRecoveryRequestHandler extends BaseTransportRequestHandler < VoidStreamable > { @ Override public VoidStreamable newInstance ( ) { } @ Override public void messageReceived ( VoidStreamable stream , TransportChannel channel ) throws Exception { receiveSnapshotRecoveryThread = Thread . currentThread ( ) ; try { <START_BUG> indexShard . performRecoveryFinalization ( ) ; <END_BUG> channel . sendResponse ( INSTANCE ) ; } finally { receiveSnapshotRecoveryThread = null ; } } } class TranslogOperationsRequestHandler extends BaseTransportRequestHandler < RecoveryAction . TranslogOperationsRequest > { @ Override public RecoveryAction . TranslogOperationsRequest newInstance ( ) { } @ Override public void messageReceived ( RecoveryAction . TranslogOperationsRequest snapshot , TransportChannel channel ) throws Exception { } } static class TranslogOperationsRequest implements Streamable { List < Translog . Operation > operations = Lists . newArrayList ( ) ; TranslogOperationsRequest ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } private class FileChunkTransportRequestHandler extends BaseTransportRequestHandler < RecoveryAction . FileChunk > { @ Override public RecoveryAction . FileChunk newInstance ( ) { } @ Override public void messageReceived ( RecoveryAction . FileChunk request , TransportChannel channel ) throws Exception { } } private static class FileChunk implements Streamable { String name ; long position ; long length ; byte [ ] content ; transient int contentLength ; private FileChunk ( ) { } private FileChunk ( String name , long position , long length , byte [ ] content , int contentLength ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class FloatArray { public float [ ] items ; public int size ; public boolean ordered ; public FloatArray ( ) { } public FloatArray ( int capacity ) { } public FloatArray ( boolean ordered , int capacity ) { } public FloatArray ( FloatArray array ) { } public FloatArray ( float [ ] array ) { } public FloatArray ( boolean ordered , float [ ] array , int startIndex , int count ) { } public void add ( float value ) { } public void addAll ( FloatArray array ) { } public void addAll ( FloatArray array , int offset , int length ) { } public void addAll ( float [ ] array ) { } public void addAll ( float [ ] array , int offset , int length ) { float [ ] items = this . items ; <START_BUG> int sizeNeeded = ( ( size ) + length ) - offset ; <END_BUG> if ( sizeNeeded >= ( items . length ) ) items = resize ( Math . max ( 8 , ( ( int ) ( sizeNeeded * 1.75F ) ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size += length ; } public float get ( int index ) { } public void set ( int index , float value ) { } public void insert ( int index , float value ) { } public void swap ( int first , int second ) { } public boolean contains ( float value ) { } public int indexOf ( float value ) { } public int lastIndexOf ( char value ) { } public boolean removeValue ( float value ) { } public float removeIndex ( int index ) { } public boolean removeAll ( FloatArray array ) { } public float pop ( ) { } public float peek ( ) { } public float first ( ) { } public void clear ( ) { } public void shrink ( ) { } public float [ ] ensureCapacity ( int additionalCapacity ) { } protected float [ ] resize ( int newSize ) { } public void sort ( ) { } public void reverse ( ) { } public void shuffle ( ) { } public void truncate ( int newSize ) { } public float random ( ) { } public float [ ] toArray ( ) { } public boolean equals ( Object object ) { } public String toString ( ) { } public String toString ( String separator ) { } }
public class NodeIndicesStats implements Serializable , Streamable , ToXContent { private StoreStats storeStats ; private DocsStats docsStats ; private IndexingStats indexingStats ; private GetStats getStats ; private SearchStats searchStats ; private CacheStats cacheStats ; private MergeStats mergeStats ; private RefreshStats refreshStats ; private FlushStats flushStats ; NodeIndicesStats ( ) { } public NodeIndicesStats ( StoreStats storeStats , DocsStats docsStats , IndexingStats indexingStats , GetStats getStats , SearchStats searchStats , CacheStats cacheStats , MergeStats mergeStats , RefreshStats refreshStats , FlushStats flushStats ) { } public StoreStats store ( ) { } public StoreStats getStore ( ) { } public DocsStats docs ( ) { } public DocsStats getDocs ( ) { } public IndexingStats indexing ( ) { } public IndexingStats getIndexing ( ) { } public GetStats get ( ) { } public GetStats getGet ( ) { } public SearchStats search ( ) { } public SearchStats getSearch ( ) { } public CacheStats cache ( ) { } public CacheStats getCache ( ) { } public MergeStats merge ( ) { } public MergeStats getMerge ( ) { } public RefreshStats refresh ( ) { <START_BUG> return this . refresh ( ) ; <END_BUG> } public RefreshStats getRefresh ( ) { } public FlushStats flush ( ) { } public FlushStats getFlush ( ) { } public static NodeIndicesStats readIndicesStats ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } static final class Fields { static final XContentBuilderString INDICES = new XContentBuilderString ( "indices" ) ; } }
public class ClusterDiscoveryConfiguration extends SettingsSource { public static Settings DEFAULT_SETTINGS = ImmutableSettings . settingsBuilder ( ) . put ( "gateway.type" , "local" ) . put ( "discovery.type" , "zen" ) . build ( ) ; final int numOfNodes ; final Settings baseSettings ; public ClusterDiscoveryConfiguration ( int numOfNodes ) { } public ClusterDiscoveryConfiguration ( int numOfNodes , Settings extraSettings ) { } @ Override public Settings node ( int nodeOrdinal ) { } @ Override public Settings transportClient ( ) { } public static class UnicastZen extends ClusterDiscoveryConfiguration { private static final AtomicInteger portRangeCounter = new AtomicInteger ( ) ; private final int [ ] unicastHostOrdinals ; private final int basePort ; public UnicastZen ( int numOfNodes ) { } public UnicastZen ( int numOfNodes , Settings extraSettings ) { } public UnicastZen ( int numOfNodes , int numOfUnicastHosts ) { } public UnicastZen ( int numOfNodes , int numOfUnicastHosts , Settings extraSettings ) { } public UnicastZen ( int numOfNodes , int [ ] unicastHostOrdinals ) { } public UnicastZen ( int numOfNodes , Settings extraSettings , int [ ] unicastHostOrdinals ) { } private static final int calcBasePort ( ) { <START_BUG> return ( 10000 + ( 1000 * ( ( CHILD_VM_ID . hashCode ( ) ) % 60 ) ) ) + ( 100 * ( ClusterDiscoveryConfiguration . UnicastZen . portRangeCounter . incrementAndGet ( ) ) ) ; <END_BUG> } @ Override public Settings node ( int nodeOrdinal ) { } } }
public class RoutingNode implements Iterable < MutableShardRouting > { private final String nodeId ; private final DiscoveryNode node ; private final List < MutableShardRouting > shards ; public RoutingNode ( String nodeId , DiscoveryNode node ) { } public RoutingNode ( String nodeId , DiscoveryNode node , List < MutableShardRouting > shards ) { } @ Override public Iterator < MutableShardRouting > iterator ( ) { } Iterator < MutableShardRouting > mutableIterator ( ) { } public DiscoveryNode node ( ) { } public String nodeId ( ) { } public int size ( ) { } void add ( MutableShardRouting shard ) { } public int numberOfShardsWithState ( ShardRoutingState ... states ) { } public List < MutableShardRouting > shardsWithState ( ShardRoutingState ... states ) { } public List < MutableShardRouting > shardsWithState ( String index , ShardRoutingState ... states ) { } public int numberOfOwningShards ( ) { } public String prettyPrint ( ) { } public MutableShardRouting get ( int i ) { } public Collection < MutableShardRouting > copyShards ( ) { <START_BUG> return new ArrayList < MutableShardRouting > ( shards ) ; <END_BUG> } public boolean isEmpty ( ) { } }
public final class LongValuesComparator extends LongValuesComparatorBase < Long > { private final long [ ] values ; public LongValuesComparator ( IndexNumericFieldData < ? > indexFieldData , long missingValue , int numHits , SortMode sortMode ) { } @ Override public int compare ( int slot1 , int slot2 ) { final long v1 = values [ slot1 ] ; final long v2 = values [ slot2 ] ; <START_BUG> return compare ( v1 , v2 ) ; <END_BUG> } @ Override public void setBottom ( int slot ) { } public void copy ( int slot , int doc ) throws IOException { } @ Override public Long value ( int slot ) { } @ Override public void add ( int slot , int doc ) { } @ Override public void divide ( int slot , int divisor ) { } @ Override public void missing ( int slot ) { } }
public class IntAttribute extends Attribute { public static final String CullFaceAlias = "cullface" ; public static final long CullFace = register ( IntAttribute . CullFaceAlias ) ; public static IntAttribute createCullFace ( int value ) { } public int value ; public IntAttribute ( long type ) { } public IntAttribute ( long type , int value ) { } @ Override public Attribute copy ( ) { } @ Override public int hashCode ( ) { <START_BUG> int result = super . hashCode ( ) ; <END_BUG> result = ( 983 * result ) + ( value ) ; return result ; } }
public class FilterCacheGcStress { public static void main ( String [ ] args ) { Settings settings = ImmutableSettings . settingsBuilder ( ) . put ( "gateway.type" , "none" ) . build ( ) ; Node node = org . elasticsearch . node . NodeBuilder . nodeBuilder ( ) . settings ( settings ) . node ( ) ; final Client client = node . client ( ) ; client . admin ( ) . indices ( ) . prepareCreate ( "test" ) . execute ( ) . actionGet ( ) ; client . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForYellowStatus ( ) . execute ( ) . actionGet ( ) ; final AtomicBoolean stop = new AtomicBoolean ( ) ; Thread indexingThread = new Thread ( ) { @ Override public void run ( ) { while ( ! ( stop . get ( ) ) ) { client . prepareIndex ( "test" , "type1" ) . setSource ( "field" , System . currentTimeMillis ( ) ) . execute ( ) . actionGet ( ) ; } } } ; indexingThread . start ( ) ; Thread searchThread = new Thread ( ) { @ Override public void run ( ) { while ( ! ( stop . get ( ) ) ) { <START_BUG> client . prepareSearch ( ) . setQuery ( filteredQuery ( matchAllQuery ( ) , rangeFilter ( "field" ) . from ( System . currentTimeMillis ( ) ) ) ) . execute ( ) . actionGet ( ) ; <END_BUG> } } } ; searchThread . start ( ) ; } }
public class GistFragment extends DialogFragment implements OnItemClickListener { private String gistId ; private List < Comment > comments ; private Gist gist ; @ InjectView ( id . list ) private ListView list ; @ InjectView ( id . pb_loading ) private ProgressBar progress ; @ Inject private GistStore store ; @ Inject private HttpImageGetter imageGetter ; private View headerView ; private View footerView ; private TextView created ; private TextView updated ; private TextView description ; private View loadingView ; private HeaderFooterListAdapter < CommentListAdapter > adapter ; private boolean starred ; private boolean loadFinished ; @ Inject private AvatarLoader avatars ; private List < View > fileHeaders = new ArrayList < View > ( ) ; public void onCreate ( Bundle savedInstanceState ) { } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; Activity activity = getActivity ( ) ; <START_BUG> adapter = new HeaderFooterListAdapter < CommentListAdapter > ( list , new CommentListAdapter ( activity . getLayoutInflater ( ) , avatars , new HttpImageGetter ( activity ) ) ) ; <END_BUG> list . setAdapter ( adapter ) ; } @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } private boolean isOwner ( ) { } private void updateHeader ( Gist gist ) { } @ Override public void onCreateOptionsMenu ( Menu options , MenuInflater inflater ) { } @ Override public void onPrepareOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } private void starGist ( ) { } private void unstarGist ( ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } private void updateFiles ( Gist gist ) { } private void updateList ( Gist gist , List < Comment > comments ) { } private void refreshGist ( ) { } @ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { } }
public interface Engine extends CloseableComponent , IndexShardComponent { static final String INDEX_CODEC = "index.codec" ; static ByteSizeValue INACTIVE_SHARD_INDEXING_BUFFER = ByteSizeValue . parseBytesSizeValue ( "500kb" ) ; TimeValue defaultRefreshInterval ( ) { } void enableGcDeletes ( boolean enableGcDeletes ) { } void updateIndexingBufferSize ( ByteSizeValue indexingBufferSize ) { } void addFailedEngineListener ( Engine . FailedEngineListener listener ) { } void start ( ) throws EngineException { } void create ( Engine . Create create ) throws EngineException { } void index ( Engine . Index index ) throws EngineException { } void delete ( Engine . Delete delete ) throws EngineException { } void delete ( Engine . DeleteByQuery delete ) throws EngineException { } Engine . GetResult get ( Engine . Get get ) throws EngineException { } Engine . Searcher acquireSearcher ( String source ) throws EngineException { } List < Segment > segments ( ) { } boolean refreshNeeded ( ) { } boolean possibleMergeNeeded ( ) { } void maybeMerge ( ) throws EngineException { } void refresh ( Engine . Refresh refresh ) throws EngineException { } void flush ( Engine . Flush flush ) throws EngineException , FlushNotAllowedEngineException { } void optimize ( Engine . Optimize optimize ) throws EngineException { } < T > T snapshot ( Engine . SnapshotHandler < T > snapshotHandler ) throws EngineException { } SnapshotIndexCommit snapshotIndex ( ) throws EngineException { } void recover ( Engine . RecoveryHandler recoveryHandler ) throws EngineException { } static interface FailedEngineListener { void onFailedEngine ( ShardId shardId , Throwable t ) { } } static interface RecoveryHandler { void phase1 ( SnapshotIndexCommit snapshot ) throws ElasticSearchException { } void phase2 ( Translog . Snapshot snapshot ) throws ElasticSearchException { } void phase3 ( Translog . Snapshot snapshot ) throws ElasticSearchException { } } static interface SnapshotHandler < T > { T snapshot ( SnapshotIndexCommit snapshotIndexCommit , Translog . Snapshot translogSnapshot ) throws EngineException { } } static interface Searcher extends Releasable { String source ( ) ; IndexReader reader ( ) { } IndexSearcher searcher ( ) { } } static class SimpleSearcher implements Engine . Searcher { private final String source ; private final IndexSearcher searcher ; public SimpleSearcher ( String source , IndexSearcher searcher ) { } @ Override public String source ( ) { <START_BUG> return this . source ( ) ; <END_BUG> } @ Override public IndexReader reader ( ) { } @ Override public IndexSearcher searcher ( ) { } @ Override public boolean release ( ) throws ElasticSearchException { } } static class Refresh { private final String source ; private boolean force = false ; public Refresh ( String source ) { } public Engine . Refresh force ( boolean force ) { } public boolean force ( ) { } public String source ( ) { return this . source ; } @ Override public String toString ( ) { } } static class Flush { public static enum Type { NEW_WRITER , COMMIT , COMMIT_TRANSLOG ; } private Engine . Flush . Type type = Engine . Flush . Type . COMMIT_TRANSLOG ; private boolean force = false ; private boolean waitIfOngoing = false ; public Engine . Flush . Type type ( ) { } public Engine . Flush type ( Engine . Flush . Type type ) { } public boolean force ( ) { } public Engine . Flush force ( boolean force ) { } public boolean waitIfOngoing ( ) { } public Engine . Flush waitIfOngoing ( boolean waitIfOngoing ) { } @ Override public String toString ( ) { } } static class Optimize { private boolean waitForMerge = true ; private int maxNumSegments = - 1 ; private boolean onlyExpungeDeletes = false ; private boolean flush = false ; public Optimize ( ) { } public boolean waitForMerge ( ) { } public Engine . Optimize waitForMerge ( boolean waitForMerge ) { } public int maxNumSegments ( ) { } public Engine . Optimize maxNumSegments ( int maxNumSegments ) { } public boolean onlyExpungeDeletes ( ) { } public Engine . Optimize onlyExpungeDeletes ( boolean onlyExpungeDeletes ) { } public boolean flush ( ) { } public Engine . Optimize flush ( boolean flush ) { } @ Override public String toString ( ) { } } static interface Operation { static enum Type { CREATE , INDEX , DELETE ; } static enum Origin { PRIMARY , REPLICA , RECOVERY ; } Engine . Operation . Type opType ( ) { } Engine . Operation . Origin origin ( ) { } } static interface IndexingOperation extends Engine . Operation { ParsedDocument parsedDoc ( ) { } List < Document > docs ( ) { } DocumentMapper docMapper ( ) { } } static class Create implements Engine . IndexingOperation { private final DocumentMapper docMapper ; private final Term uid ; private final ParsedDocument doc ; private long version = Versions . MATCH_ANY ; private VersionType versionType = VersionType . INTERNAL ; private Engine . Operation . Origin origin = Engine . Operation . Origin . PRIMARY ; private long startTime ; private long endTime ; public Create ( DocumentMapper docMapper , Term uid , ParsedDocument doc ) { } @ Override public DocumentMapper docMapper ( ) { } @ Override public Engine . Operation . Type opType ( ) { } public Engine . Create origin ( Engine . Operation . Origin origin ) { } @ Override public Engine . Operation . Origin origin ( ) { } @ Override public ParsedDocument parsedDoc ( ) { } public Term uid ( ) { } public String type ( ) { } public String id ( ) { } public String routing ( ) { } public long timestamp ( ) { } public long ttl ( ) { } public long version ( ) { } public Engine . Create version ( long version ) { } public VersionType versionType ( ) { }
public class AllocationService extends AbstractComponent { private final AllocationDeciders allocationDeciders ; private final ShardsAllocators shardsAllocators ; public AllocationService ( ) { } public AllocationService ( Settings settings ) { } @ Inject public AllocationService ( Settings settings , AllocationDeciders allocationDeciders , ShardsAllocators shardsAllocators ) { } public Result applyStartedShards ( ClusterState clusterState , List < ? extends ShardRouting > startedShards ) { } public Result applyFailedShard ( ClusterState clusterState , ShardRouting failedShard ) { } public Result reroute ( ClusterState clusterState ) { } public Result rerouteWithNoReassign ( ClusterState clusterState ) { } private boolean reroute ( RoutingAllocation allocation ) { } private boolean electPrimaries ( RoutingNodes routingNodes ) { } private void applyNewNodes ( RoutingNodes routingNodes , Iterable < DiscoveryNode > liveNodes ) { for ( DiscoveryNode node : liveNodes ) { if ( ! ( routingNodes . nodesToShards ( ) . containsKey ( node . id ( ) ) ) ) { <START_BUG> RoutingNode routingNode = new RoutingNode ( node . id ( ) ) ; <END_BUG> routingNodes . nodesToShards ( ) . put ( node . id ( ) , routingNode ) ; } } } private boolean deassociateDeadNodes ( RoutingNodes routingNodes , Iterable < DiscoveryNode > liveNodes ) { } private boolean applyStartedShards ( RoutingNodes routingNodes , Iterable < ? extends ShardRouting > startedShardEntries ) { } private boolean applyFailedShard ( FailedRerouteAllocation allocation ) { } }
public final class BytesRefHash extends AbstractHash { private LongArray startOffsets ; private ByteArray bytes ; private IntArray hashes ; private final BytesRef spare ; public BytesRefHash ( long capacity , PageCacheRecycler recycler ) { } public BytesRefHash ( long capacity , float maxLoadFactor , PageCacheRecycler recycler ) { } private static int rehash ( int hash ) { } public BytesRef get ( long id , BytesRef dest ) { } public long find ( BytesRef key , int code ) { } public long find ( BytesRef key ) { } private long set ( BytesRef key , int code , long id ) { } private void append ( long id , BytesRef key , int code ) { } private boolean assertConsistent ( long id , int code ) { } private void reset ( int code , long id ) { } public long add ( BytesRef key , int code ) { } public long add ( BytesRef key ) { } @ Override protected void removeAndAdd ( long index , long id ) { } @ Override public boolean release ( ) { boolean success = false ; try { super . release ( ) ; success = true ; } finally { <START_BUG> Releasables . release ( success , bytes , hashes ) ; <END_BUG> } return true ; } }
public class AccountDataManager { private static final String TAG = "GHDM" ; private static final Executor EXECUTOR = Executors . newFixedThreadPool ( 10 ) ; private static final int FORMAT_VERSION = 1 ; private static String digest ( String value ) { } private final Context context ; private final UserService users ; private final OrganizationService orgs ; private final RepositoryService repos ; private final IssueService issues ; private final File root ; public AccountDataManager ( final Context context , final File root , UserService users , OrganizationService orgs , RepositoryService repos , IssueService issues ) { } private < V > V read ( File file ) { long start = System . currentTimeMillis ( ) ; long length = file . length ( ) ; V data = new RequestReader ( file , AccountDataManager . FORMAT_VERSION ) . read ( ) ; if ( data != null ) Log . d ( AccountDataManager . TAG , MessageFormat . format ( "Cache<seq2seq4repair_space>hit<seq2seq4repair_space>to<seq2seq4repair_space>{0},<seq2seq4repair_space>{1}<seq2seq4repair_space>ms<seq2seq4repair_space>to<seq2seq4repair_space>load<seq2seq4repair_space>{2}<seq2seq4repair_space>bytes" , file . getName ( ) , ( ( System . currentTimeMillis ( ) ) - start ) , length ) ) ; <START_BUG> return new RequestReader ( file , AccountDataManager . FORMAT_VERSION ) . read ( ) ; <END_BUG> } private AccountDataManager write ( File file , Object data ) { } public void getOrgs ( final RequestFuture < List < User > > requestFuture ) { } public void getRepos ( final User user , final RequestFuture < List < Repository > > requestFuture ) { } public void getIssues ( final IRepositoryIdProvider repository , final Map < String , String > filter , final RequestFuture < List < Issue > > requestFuture ) { } }
public class InternalIndicesService extends AbstractLifecycleComponent < IndicesService > implements IndicesService { private final NodeEnvironment nodeEnv ; private final ThreadPool threadPool ; private final InternalIndicesLifecycle indicesLifecycle ; private final IndicesAnalysisService indicesAnalysisService ; private final IndicesStore indicesStore ; private final Injector injector ; private final PluginsService pluginsService ; private final Map < String , Injector > indicesInjectors = new HashMap < String , Injector > ( ) ; private volatile ImmutableMap < String , IndexService > indices = ImmutableMap . of ( ) ; private final InternalIndicesService . OldShardsStats oldShardsStats = new InternalIndicesService . OldShardsStats ( ) ; @ Inject public InternalIndicesService ( Settings settings , NodeEnvironment nodeEnv , ThreadPool threadPool , IndicesLifecycle indicesLifecycle , IndicesAnalysisService indicesAnalysisService , IndicesStore indicesStore , Injector injector ) { } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { ImmutableSet < String > indices = ImmutableSet . copyOf ( this . indices . keySet ( ) ) ; final CountDownLatch latch = new CountDownLatch ( indices . size ( ) ) ; final ExecutorService indicesStopExecutor = Executors . newFixedThreadPool ( 5 , EsExecutors . daemonThreadFactory ( "indices_shutdown" ) ) ; final ExecutorService shardsStopExecutor = Executors . newFixedThreadPool ( 5 , EsExecutors . daemonThreadFactory ( "shards_shutdown" ) ) ; for ( final String index : indices ) { indicesStopExecutor . execute ( new Runnable ( ) { @ Override public void run ( ) { try { removeIndex ( index , "shutdown" , shardsStopExecutor ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> logger . warn ( ( ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>delete<seq2seq4repair_space>index<seq2seq4repair_space>on<seq2seq4repair_space>stop<seq2seq4repair_space>[" + index ) + "]" ) , e ) ; } finally { latch . countDown ( ) ; } } } ) ; } try { latch . await ( ) ; } catch ( InterruptedException e ) { } finally { shardsStopExecutor . shutdown ( ) ; indicesStopExecutor . shutdown ( ) ; } } @ Override protected void doClose ( ) throws ElasticSearchException { } @ Override public IndicesLifecycle indicesLifecycle ( ) { } @ Override public NodeIndicesStats stats ( boolean includePrevious ) { } @ Override public NodeIndicesStats stats ( boolean includePrevious , CommonStatsFlags flags ) { } public boolean changesAllowed ( ) { } @ Override public UnmodifiableIterator < IndexService > iterator ( ) { } public boolean hasIndex ( String index ) { } public Set < String > indices ( ) { } public IndexService indexService ( String index ) { } @ Override public IndexService indexServiceSafe ( String index ) throws IndexMissingException { } public synchronized IndexService createIndex ( String sIndexName , Settings settings , String localNodeId ) throws ElasticSearchException { } @ Override public synchronized void removeIndex ( String index , String reason ) throws ElasticSearchException { } private void removeIndex ( String index , String reason , @ Nullable Executor executor ) throws ElasticSearchException { } static class OldShardsStats extends IndicesLifecycle . Listener { final SearchStats searchStats = new SearchStats ( ) ; final GetStats getStats = new GetStats ( ) ; final IndexingStats indexingStats = new IndexingStats ( ) ; final MergeStats mergeStats = new MergeStats ( ) ; final RefreshStats refreshStats = new RefreshStats ( ) ; final FlushStats flushStats = new FlushStats ( ) ; @ Override public synchronized void beforeIndexShardClosed ( ShardId shardId , @ Nullable IndexShard indexShard ) { } } }
public final class SettingsLoaderFactory { private SettingsLoaderFactory ( ) { } public static SettingsLoader loaderFromResource ( String resourceName ) { if ( resourceName . endsWith ( ".json" ) ) { return new JsonSettingsLoader ( ) ; } else <START_BUG> if ( resourceName . endsWith ( ".yml" ) ) { <END_BUG> return new YamlSettingsLoader ( ) ; } else if ( resourceName . endsWith ( ".properties" ) ) { return new PropertiesSettingsLoader ( ) ; } else { return new JsonSettingsLoader ( ) ; } } public static SettingsLoader loaderFromSource ( String source ) { } }
public class ObjectFloatMap < K > { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; public int size ; K [ ] keyTable ; float [ ] valueTable ; int capacity ; int stashSize ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private ObjectFloatMap . Entries entries1 ; private ObjectFloatMap . Entries entries2 ; private ObjectFloatMap . Values values1 ; private ObjectFloatMap . Values values2 ; private ObjectFloatMap . Keys keys1 ; private ObjectFloatMap . Keys keys2 ; public ObjectFloatMap ( ) { } public ObjectFloatMap ( int initialCapacity ) { } public ObjectFloatMap ( int initialCapacity , float loadFactor ) { } public ObjectFloatMap ( ObjectFloatMap < ? extends K > map ) { } public void put ( K key , float value ) { } public void putAll ( ObjectFloatMap < K > map ) { } private void putResize ( K key , float value ) { } private void push ( K insertKey , float insertValue , int index1 , K key1 , int index2 , K key2 , int index3 , K key3 ) { } private void putStash ( K key , float value ) { } public float get ( K key , float defaultValue ) { } private float getStash ( K key , float defaultValue ) { } public float getAndIncrement ( K key , float defaultValue , float increment ) { } private float getAndIncrementStash ( K key , float defaultValue , float increment ) { } public float remove ( K key , float defaultValue ) { } float removeStash ( K key , float defaultValue ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean containsValue ( float value ) { } public boolean containsKey ( K key ) { } private boolean containsKeyStash ( K key ) { } public K findKey ( float value ) { } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public ObjectFloatMap . Entries < K > entries ( ) { } public ObjectFloatMap . Values values ( ) { } public ObjectFloatMap . Keys < K > keys ( ) { } public static class Entry < K > { public K key ; public float value ; public String toString ( ) { } } private static class MapIterator < K > { public boolean hasNext ; final ObjectFloatMap < K > map ; int nextIndex ; int currentIndex ; boolean valid = true ; public MapIterator ( ObjectFloatMap < K > map ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { if ( ( currentIndex ) < 0 ) throw new IllegalStateException ( "next<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>called<seq2seq4repair_space>before<seq2seq4repair_space>remove." ) ; if ( ( currentIndex ) >= ( map . capacity ) ) { map . removeStashIndex ( currentIndex ) ; <START_BUG> nextIndex = currentIndex ; <END_BUG> findNextIndex ( ) ; } else { map . keyTable [ currentIndex ] = null ; } currentIndex = - 1 ; ( map . size ) -- ; } } public static class Entries < K > extends ObjectFloatMap . MapIterator < K > implements Iterable < ObjectFloatMap . Entry < K > > , Iterator < ObjectFloatMap . Entry < K > > { private ObjectFloatMap . Entry < K > entry = new ObjectFloatMap . Entry ( ) ; public Entries ( ObjectFloatMap < K > map ) { } public ObjectFloatMap . Entry < K > next ( ) { } public boolean hasNext ( ) { } public Iterator < ObjectFloatMap . Entry < K > > iterator ( ) { } } public static class Values extends ObjectFloatMap . MapIterator < Object > { public Values ( ObjectFloatMap < ? > map ) { } public boolean hasNext ( ) { } public float next ( ) { } public FloatArray toArray ( ) { } } public static class Keys < K > extends ObjectFloatMap . MapIterator < K > implements Iterable < K > , Iterator < K > { public Keys ( ObjectFloatMap < K > map ) { } public boolean hasNext ( ) { } public K next ( ) { } public Iterator < K > iterator ( ) { } public Array < K > toArray ( ) { } } }
public class FileHandle { protected File file ; protected FileType type ; protected FileHandle ( ) { } public FileHandle ( String fileName ) { } public FileHandle ( File file ) { } protected FileHandle ( String fileName , FileType type ) { } protected FileHandle ( File file , FileType type ) { } public String path ( ) { } public String name ( ) { } public String extension ( ) { } public String nameWithoutExtension ( ) { } public String pathWithoutExtension ( ) { } public FileType type ( ) { } public File file ( ) { } public InputStream read ( ) { } public BufferedInputStream read ( int bufferSize ) { } public Reader reader ( ) { } public Reader reader ( String charset ) { } public BufferedReader reader ( int bufferSize ) { } public BufferedReader reader ( int bufferSize , String charset ) { } public String readString ( ) { } public String readString ( String charset ) { } public byte [ ] readBytes ( ) { } private int estimateLength ( ) { } public int readBytes ( byte [ ] bytes , int offset , int size ) { } public OutputStream write ( boolean append ) { } public void write ( InputStream input , boolean append ) { } public Writer writer ( boolean append ) { } public Writer writer ( boolean append , String charset ) { } public void writeString ( String string , boolean append ) { } public void writeString ( String string , boolean append , String charset ) { } public void writeBytes ( byte [ ] bytes , boolean append ) { } public void writeBytes ( byte [ ] bytes , int offset , int length , boolean append ) { } public FileHandle [ ] list ( ) { } public FileHandle [ ] list ( String suffix ) { } public boolean isDirectory ( ) { } public FileHandle child ( String name ) { } public FileHandle sibling ( String name ) { } public FileHandle parent ( ) { } public void mkdirs ( ) { } public boolean exists ( ) { switch ( type ) { case Internal : <START_BUG> if ( file . exists ( ) ) <END_BUG> return true ; case Classpath : return ( FileHandle . class . getResource ( ( "/" + ( file . getPath ( ) . replace ( '\\' , '/' ) ) ) ) ) != null ; } return file ( ) . exists ( ) ; } public boolean delete ( ) { } public boolean deleteDirectory ( ) { } public void emptyDirectory ( ) { } public void emptyDirectory ( boolean preserveTree ) { } public void copyTo ( FileHandle dest ) { } public void moveTo ( FileHandle dest ) { } public long length ( ) { } public long lastModified ( ) { } @ Override public boolean equals ( Object obj ) { } @ Override public int hashCode ( ) { } public String toString ( ) { } public static FileHandle tempFile ( String prefix ) { } public static FileHandle tempDirectory ( String prefix ) { } private static void emptyDirectory ( File file , boolean preserveTree ) { } private static boolean deleteDirectory ( File file ) { } private static void copyFile ( FileHandle source , FileHandle dest ) { } private static void copyDirectory ( FileHandle sourceDir , FileHandle destDir ) { } }
public class RestSuggestAction extends BaseRestHandler { @ Inject public RestSuggestAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { SuggestRequest suggestRequest = new SuggestRequest ( RestActions . splitIndices ( request . param ( "index" ) ) ) ; if ( request . hasParam ( "ignore_indices" ) ) { suggestRequest . ignoreIndices ( IgnoreIndices . fromString ( request . param ( "ignore_indices" ) ) ) ; } suggestRequest . listenerThreaded ( false ) ; try { BroadcastOperationThreading operationThreading = BroadcastOperationThreading . fromString ( request . param ( "operation_threading" ) , SINGLE_THREAD ) ; if ( operationThreading == ( BroadcastOperationThreading . NO_THREADS ) ) { operationThreading = BroadcastOperationThreading . SINGLE_THREAD ; } suggestRequest . operationThreading ( operationThreading ) ; if ( request . hasContent ( ) ) { suggestRequest . suggest ( request . content ( ) , request . contentUnsafe ( ) ) ; } else { String source = request . param ( "source" ) ; if ( source != null ) { suggestRequest . suggest ( source ) ; } else { throw new ElasticSearchIllegalArgumentException ( "no<seq2seq4repair_space>content<seq2seq4repair_space>or<seq2seq4repair_space>source<seq2seq4repair_space>provided<seq2seq4repair_space>to<seq2seq4repair_space>execute<seq2seq4repair_space>suggestion" ) ; } } suggestRequest . routing ( request . param ( "routing" ) ) ; suggestRequest . preference ( request . param ( "preference" ) ) ; } catch ( Exception e ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . BAD_REQUEST , builder . startObject ( ) . field ( "error" , e . getMessage ( ) ) . endObject ( ) ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } return ; } client . suggest ( suggestRequest , new org . elasticsearch . action . ActionListener < SuggestResponse > ( ) { @ Override public void onResponse ( SuggestResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; buildBroadcastShardsHeader ( builder , response ) ; Suggest suggest = response . getSuggest ( ) ; if ( suggest != null ) { suggest . toXContent ( builder , request ) ; } builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public abstract class TransportMasterNodeOperationAction < Request extends MasterNodeOperationRequest , Response extends ActionResponse > extends BaseAction < Request , Response > { protected final TransportService transportService ; protected final ClusterService clusterService ; final String transportAction ; final String executor ; protected TransportMasterNodeOperationAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } protected abstract String transportAction ( ) { } protected abstract String executor ( ) { } protected abstract Request newRequest ( ) { } protected abstract Response newResponse ( ) { } protected abstract Response masterOperation ( Request request , ClusterState state ) throws ElasticSearchException { } protected boolean localExecute ( Request request ) { } protected ClusterBlockException checkBlock ( Request request , ClusterState state ) { } protected void processBeforeDelegationToMaster ( Request request , ClusterState state ) { } @ Override protected void doExecute ( final Request request , final ActionListener < Response > listener ) { } private void innerExecute ( final Request request , final ActionListener < Response > listener , final boolean retrying ) { final ClusterState clusterState = clusterService . state ( ) ; final DiscoveryNodes nodes = clusterState . nodes ( ) ; if ( ( nodes . localNodeMaster ( ) ) || ( localExecute ( request ) ) ) { final ClusterBlockException blockException = checkBlock ( request , clusterState ) ; if ( blockException != null ) { if ( ! ( blockException . retryable ( ) ) ) { listener . onFailure ( blockException ) ; return ; } clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { <START_BUG> ClusterBlockException blockException = checkBlock ( request , clusterState ) ; <END_BUG> if ( ( blockException == null ) || ( ! ( blockException . retryable ( ) ) ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( blockException ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; listener . onFailure ( blockException ) ; } @ Override public void clusterChanged ( ClusterChangedEvent event ) { ClusterBlockException blockException = checkBlock ( request , event . state ( ) ) ; if ( ( blockException == null ) || ( ! ( blockException . retryable ( ) ) ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } } ) ; } else { threadPool . executor ( executor ) . execute ( new Runnable ( ) { @ Override public void run ( ) { try { Response response = masterOperation ( request , clusterState ) ; listener . onResponse ( response ) ; } catch ( Exception e ) { listener . onFailure ( e ) ; } } } ) ; } } else { if ( ( nodes . masterNode ( ) ) == null ) { if ( retrying ) { listener . onFailure ( new MasterNotDiscoveredException ( ) ) ; } else { clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { ClusterState clusterStateV2 = clusterService . state ( ) ; if ( ( clusterStateV2 . nodes ( ) . masterNodeId ( ) ) != null ) { clusterService . remove ( this ) ; innerExecute ( request , listener , true ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( new org . elasticsearch . node . NodeClosedException ( nodes . localNode ( ) ) ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; listener . onFailure ( new MasterNotDiscoveredException ( ) ) ; } @ Override public void clusterChanged ( ClusterChangedEvent event ) { if ( event . nodesDelta ( ) . masterNodeChanged ( ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , true ) ; } } } ) ; } return ; } processBeforeDelegationToMaster ( request , clusterState ) ; transportService . sendRequest ( nodes . masterNode ( ) , transportAction , request , new BaseTransportResponseHandler < Response > ( ) { @ Override public Response newInstance ( ) { return newResponse ( ) ; } @ Override public void handleResponse ( Response response ) { listener . onResponse ( response ) ; } @ Override public String executor ( ) { return Names . SAME ; } @ Override public void handleException ( final TransportException exp ) { if ( ( exp . unwrapCause ( ) ) instanceof ConnectTransportException ) { clusterService . add ( request . masterNodeTimeout ( ) , new TimeoutClusterStateListener ( ) { @ Override public void postAdded ( ) { ClusterState clusterStateV2 = clusterService . state ( ) ; if ( ! ( clusterState . nodes ( ) . masterNodeId ( ) . equals ( clusterStateV2 . nodes ( ) . masterNodeId ( ) ) ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; } } @ Override public void onClose ( ) { clusterService . remove ( this ) ; listener . onFailure ( new org . elasticsearch . node . NodeClosedException ( nodes . localNode ( ) ) ) ; } @ Override public void onTimeout ( TimeValue timeout ) { clusterService . remove ( this ) ; listener . onFailure ( new MasterNotDiscoveredException ( ) ) ; } @ Override public void clusterChanged ( ClusterChangedEvent event ) { if ( event . nodesDelta ( ) . masterNodeChanged ( ) ) { clusterService . remove ( this ) ; innerExecute ( request , listener , false ) ; }
public final class ClassReflection { public static Class forName ( String name ) throws ReflectionException { } public static String getSimpleName ( Class c ) { } public static boolean isInstance ( Class c , Object obj ) { } public static boolean isAssignableFrom ( Class c1 , Class c2 ) { Type c1Type = ReflectionCache . getType ( c1 ) ; Type c2Type = ReflectionCache . getType ( c2 ) ; <START_BUG> return c2Type . isAssignableFrom ( c1Type ) ; <END_BUG> } public static boolean isMemberClass ( Class c ) { } public static boolean isStaticClass ( Class c ) { } public static < T > T newInstance ( Class < T > c ) throws ReflectionException { } public static Constructor [ ] getConstructors ( Class c ) { } public static Constructor getConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Constructor getDeclaredConstructor ( Class c , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getMethods ( Class c ) { } public static Method getMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Method [ ] getDeclaredMethods ( Class c ) { } public static Method getDeclaredMethod ( Class c , String name , Class ... parameterTypes ) throws ReflectionException { } public static Field [ ] getFields ( Class c ) { } public static Field getField ( Class c , String name ) throws ReflectionException { } public static Field [ ] getDeclaredFields ( Class c ) { } public static Field getDeclaredField ( Class c , String name ) throws ReflectionException { } }
public class GistFragment extends ListLoadingFragment < Gist > { @ Inject private GistService service ; public Loader < List < Gist > > onCreateLoader ( int id , Bundle bundle ) { } protected ListAdapter adapterFor ( List < Gist > items ) { } public void onListItemClick ( ListView list , View view , int position , long id ) { Gist gist = ( ( Gist ) ( list . getItemAtPosition ( position ) ) ) ; <START_BUG> startActivity ( ViewGistActivity . createIntent ( getActivity ( ) , gist ) ) ; <END_BUG> } }
public class NotDeletedFilter extends Filter { private final Filter filter ; public NotDeletedFilter ( Filter filter ) { } @ Override public DocIdSet getDocIdSet ( AtomicReaderContext context , Bits acceptDocs ) throws IOException { } public Filter filter ( ) { } @ Override public String toString ( ) { } static class NotDeletedDocIdSet extends DocIdSet { private final DocIdSet innerSet ; private final Bits liveDocs ; NotDeletedDocIdSet ( DocIdSet innerSet , Bits liveDocs ) { } @ Override public DocIdSetIterator iterator ( ) throws IOException { } } static class NotDeletedDocIdSetIterator extends FilteredDocIdSetIterator { private final Bits liveDocs ; NotDeletedDocIdSetIterator ( DocIdSetIterator innerIter , Bits liveDocs ) { } @ Override protected boolean match ( int doc ) { <START_BUG> return liveDocs . get ( doc ) ; <END_BUG> } } }
public class AndroidApplication extends Activity implements Application { protected AndroidGraphics graphics ; protected AndroidInput input ; protected AndroidAudio audio ; protected AndroidFiles files ; protected AndroidNet net ; protected ApplicationListener listener ; public Handler handler ; protected boolean firstResume = true ; protected final Array < Runnable > runnables = new Array < Runnable > ( ) ; protected final Array < Runnable > executedRunnables = new Array < Runnable > ( ) ; protected final Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; protected int logLevel = LOG_INFO ; protected boolean useImmersiveMode = false ; protected boolean hideStatusBar = false ; private int wasFocusChanged = - 1 ; private boolean isWaitingForAudio = false ; public void initialize ( ApplicationListener listener , boolean useGL2IfAvailable ) { } public void initialize ( ApplicationListener listener , AndroidApplicationConfiguration config ) { } protected LayoutParams createLayoutParams ( ) { } protected void createWakeLock ( boolean use ) { } protected void hideStatusBar ( boolean hide ) { } @ Override public void onWindowFocusChanged ( boolean hasFocus ) { } protected void useImmersiveMode ( boolean use ) { } public View initializeForView ( ApplicationListener listener , boolean useGL2IfAvailable ) { } public View initializeForView ( ApplicationListener listener , AndroidApplicationConfiguration config ) { } @ Override protected void onPause ( ) { } @ Override protected void onResume ( ) { } @ Override protected void onDestroy ( ) { } @ Override public ApplicationListener getApplicationListener ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Files getFiles ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Input getInput ( ) { } @ Override public Net getNet ( ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { <START_BUG> return Integer . parseInt ( SDK ) ; <END_BUG> } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } @ Override public Preferences getPreferences ( String name ) { } AndroidClipboard clipboard ; @ Override public Clipboard getClipboard ( ) { } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void onConfigurationChanged ( Configuration config ) { } @ Override public void exit ( ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } @ Override public void log ( String tag , String message ) { } @ Override public void log ( String tag , String message , Throwable exception ) { } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public int getLogLevel ( ) { } @ Override public void addLifecycleListener ( LifecycleListener listener ) { } @ Override public void removeLifecycleListener ( LifecycleListener listener ) { } }
public class TransportNodesInfoAction extends TransportNodesOperationAction < NodesInfoRequest , NodesInfoResponse , TransportNodesInfoAction . NodeInfoRequest , NodeInfo > { private final NodeService nodeService ; @ Inject public TransportNodesInfoAction ( Settings settings , ClusterName clusterName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , NodeService nodeService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected NodesInfoResponse newResponse ( NodesInfoRequest nodesInfoRequest , AtomicReferenceArray responses ) { } @ Override protected NodesInfoRequest newRequest ( ) { } @ Override protected TransportNodesInfoAction . NodeInfoRequest newNodeRequest ( ) { } @ Override protected TransportNodesInfoAction . NodeInfoRequest newNodeRequest ( String nodeId , NodesInfoRequest request ) { } @ Override protected NodeInfo newNodeResponse ( ) { } @ Override protected NodeInfo nodeOperation ( TransportNodesInfoAction . NodeInfoRequest nodeRequest ) throws ElasticSearchException { NodesInfoRequest request = nodeRequest . request ; <START_BUG> return nodeService . info ( request . settings ( ) , request . os ( ) , request . process ( ) , request . jvm ( ) , request . network ( ) , request . transport ( ) , request . http ( ) ) ; <END_BUG> } @ Override protected boolean accumulateExceptions ( ) { } static class NodeInfoRequest extends NodeOperationRequest { NodesInfoRequest request ; NodeInfoRequest ( ) { } NodeInfoRequest ( String nodeId , NodesInfoRequest request ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class TimerTest extends GdxTest { @ Override public void create ( ) { new Timer ( ) . scheduleTask ( new Task ( ) { @ Override public void run ( ) { app . log ( "TimerTest" , "ping" ) ; } <START_BUG> } , 1 , 1 ) ; <END_BUG> } }
public class VertexArray implements VertexData { final VertexAttributes attributes ; final FloatBuffer buffer ; final ByteBuffer byteBuffer ; boolean isBound = false ; public VertexArray ( int numVertices , VertexAttribute ... attributes ) { } public VertexArray ( int numVertices , VertexAttributes attributes ) { } @ Override public void dispose ( ) { } @ Override public FloatBuffer getBuffer ( ) { } @ Override public int getNumVertices ( ) { } public int getNumMaxVertices ( ) { } @ Override public void setVertices ( float [ ] vertices , int offset , int count ) { } @ Override public void updateVertices ( int targetOffset , float [ ] vertices , int sourceOffset , int count ) { final int pos = byteBuffer . position ( ) ; byteBuffer . position ( ( targetOffset * 4 ) ) ; <START_BUG> BufferUtils . copy ( vertices , sourceOffset , byteBuffer , count ) ; <END_BUG> byteBuffer . position ( pos ) ; } @ Override public void bind ( ) { } @ Override public void unbind ( ) { } @ Override public void bind ( final ShaderProgram shader ) { } @ Override public void bind ( final ShaderProgram shader , final int [ ] locations ) { } @ Override public void unbind ( ShaderProgram shader ) { } @ Override public void unbind ( ShaderProgram shader , int [ ] locations ) { } @ Override public VertexAttributes getAttributes ( ) { } }
public class PercolateRequest extends SingleCustomOperationRequest { private String index ; private String type ; private BytesReference source ; private boolean sourceUnsafe ; public PercolateRequest ( ) { } public PercolateRequest ( String index , String type ) { } public PercolateRequest index ( String index ) { } public PercolateRequest type ( String type ) { } public String index ( ) { } public String type ( ) { } @ Override public void beforeLocalFork ( ) { } public BytesReference source ( ) { } @ Required public PercolateRequest source ( Map source ) throws ElasticSearchGenerationException { } @ Required public PercolateRequest source ( Map source , XContentType contentType ) throws ElasticSearchGenerationException { } @ Required public PercolateRequest source ( String source ) { } @ Required public PercolateRequest source ( XContentBuilder sourceBuilder ) { } public PercolateRequest source ( byte [ ] source ) { } @ Required public PercolateRequest source ( byte [ ] source , int offset , int length ) { } @ Required public PercolateRequest source ( byte [ ] source , int offset , int length , boolean unsafe ) { } @ Required public PercolateRequest source ( BytesReference source , boolean unsafe ) { } @ Override public PercolateRequest preferLocal ( boolean preferLocal ) { } @ Override public ActionRequestValidationException validate ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeUTF ( index ) ; out . writeUTF ( type ) ; <START_BUG> out . writeBytesReference ( source , true ) ; <END_BUG> } }
public class TransportSearchQueryThenFetchAction extends TransportSearchTypeAction { @ Inject public TransportSearchQueryThenFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportSearchCache transportSearchCache , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } @ Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { } private class AsyncAction extends BaseAsyncAction < QuerySearchResult > { private final Map < SearchShardTarget , QuerySearchResultProvider > queryResults = searchCache . obtainQueryResults ( ) ; private final Map < SearchShardTarget , FetchSearchResult > fetchResults = searchCache . obtainFetchResults ( ) ; private volatile Map < SearchShardTarget , ExtTIntArrayList > docIdsToLoad ; private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { } @ Override protected String firstPhaseName ( ) { } @ Override protected void sendExecuteFirstPhase ( DiscoveryNode node , InternalSearchRequest request , SearchServiceListener < QuerySearchResult > listener ) { } @ Override protected void processFirstPhaseResult ( ShardRouting shard , QuerySearchResult result ) { } @ Override protected void moveToSecondPhase ( ) { } private void executeFetch ( final SearchShardTarget shardTarget , final AtomicInteger counter , final FetchSearchRequest fetchSearchRequest , DiscoveryNode node ) { } private void finishHim ( ) { } private void innerFinishHim ( ) { InternalSearchResponse internalResponse = searchPhaseController . merge ( sortedShardList , queryResults , fetchResults ) ; String scrollId = null ; if ( ( request . scroll ( ) ) != null ) { scrollId = TransportSearchHelper . buildScrollId ( request . searchType ( ) , queryResults . values ( ) ) ; } <START_BUG> invokeListener ( new SearchResponse ( internalResponse , scrollId , expectedSuccessfulOps , successulOps . get ( ) , buildShardFailures ( ) ) ) ; <END_BUG> } } }
public class LocalIndexGateway extends AbstractIndexComponent implements IndexGateway { @ Inject public LocalIndexGateway ( Index index , @ IndexSettings Settings indexSettings ) { } @ Override public String type ( ) { } @ Override public Class < ? extends IndexShardGateway > shardGatewayClass ( ) { } @ Override public String toString ( ) { } @ Override <START_BUG> public void close ( boolean delete ) { <END_BUG> } }
public class SelectBox extends Widget { SelectBox . SelectBoxStyle style ; String [ ] items ; int selectedIndex = 0 ; private final TextBounds bounds = new TextBounds ( ) ; final Vector2 screenCoords = new Vector2 ( ) ; SelectBox . SelectList list ; private float prefWidth ; private float prefHeight ; private ClickListener clickListener ; static final Vector2 tmpCoords = new Vector2 ( ) ; public SelectBox ( Object [ ] items , Skin skin ) { } public SelectBox ( Object [ ] items , Skin skin , String styleName ) { } public SelectBox ( Object [ ] items , SelectBox . SelectBoxStyle style ) { } public void setStyle ( SelectBox . SelectBoxStyle style ) { } public SelectBox . SelectBoxStyle getStyle ( ) { } public void setItems ( Object [ ] objects ) { } @ Override public void draw ( SpriteBatch batch , float parentAlpha ) { } public void setSelection ( int selection ) { } public void setSelection ( String item ) { } public int getSelectionIndex ( ) { } public String getSelection ( ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public void hideList ( ) { <START_BUG> if ( ( list . getParent ( ) ) == null ) <END_BUG> return ; getStage ( ) . removeCaptureListener ( list . stageListener ) ; list . addAction ( sequence ( fadeOut ( 0.15F , fade ) , removeActor ( ) ) ) ; } class SelectList extends Actor { Vector2 oldScreenCoords = new Vector2 ( ) ; float itemHeight ; float textOffsetX ; float textOffsetY ; int listSelectedIndex = SelectBox . this . selectedIndex ; InputListener stageListener = new InputListener ( ) { public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { } public void touchUp ( InputEvent event , float x , float y , int pointer , int button ) { } public boolean mouseMoved ( InputEvent event , float x , float y ) { } } ; public SelectList ( float x , float y ) { } private void layout ( ) { } @ Override public void draw ( SpriteBatch batch , float parentAlpha ) { } @ Override public Actor hit ( float x , float y , boolean touchable ) { } public void act ( float delta ) { } } public static class SelectBoxStyle { public Drawable background ; public Drawable backgroundOver ; public Drawable backgroundOpen ; public Drawable listBackground ; public Drawable listSelection ; public BitmapFont font ; public Color fontColor = new Color ( 1 , 1 , 1 , 1 ) ; public float itemSpacing = 10 ; public SelectBoxStyle ( ) { } public SelectBoxStyle ( BitmapFont font , Color fontColor , Drawable background , Drawable listBackground , Drawable listSelection ) { } public SelectBoxStyle ( SelectBox . SelectBoxStyle style ) { } } }
final class ExternalNode implements Closeable { private final File path ; private final Random random ; private final SettingsSource settingsSource ; private Process process ; private NodeInfo nodeInfo ; private final String clusterName ; private TransportClient client ; private final ESLogger logger = Loggers . getLogger ( getClass ( ) ) ; ExternalNode ( File path , long seed , SettingsSource settingsSource ) { } ExternalNode ( File path , String clusterName , long seed , SettingsSource settingsSource ) { } synchronized ExternalNode start ( Client localNode , Settings defaultSettings , String nodeName , String clusterName , int nodeOrdinal ) throws IOException , InterruptedException { ExternalNode externalNode = new ExternalNode ( path , clusterName , random . nextLong ( ) , settingsSource ) ; <START_BUG> Settings settings = ImmutableSettings . builder ( ) . put ( settingsSource . node ( nodeOrdinal ) ) . put ( defaultSettings ) . build ( ) ; <END_BUG> externalNode . startInternal ( localNode , settings , nodeName , clusterName ) ; return externalNode ; } synchronized void startInternal ( Client client , Settings settings , String nodeName , String clusterName ) throws IOException , InterruptedException { } static boolean waitForNode ( final Client client , final String name ) throws InterruptedException { } static NodeInfo nodeInfo ( final Client client , final String nodeName ) { } synchronized TransportAddress getTransportAddress ( ) { } synchronized Client getClient ( ) { } synchronized void reset ( long seed ) { } synchronized void stop ( ) { } synchronized void stop ( boolean forceKill ) { } synchronized boolean running ( ) { } @ Override public void close ( ) { } synchronized String getName ( ) { } }
public class TermsStatsLongFacetCollector extends AbstractFacetCollector { private final ComparatorType comparatorType ; private final FieldDataCache fieldDataCache ; private final String keyFieldName ; private final String valueFieldName ; private final int size ; private final int numberOfShards ; private final FieldDataType keyFieldDataType ; private NumericFieldData keyFieldData ; private final FieldDataType valueFieldDataType ; private final SearchScript script ; private final TermsStatsLongFacetCollector . Aggregator aggregator ; public TermsStatsLongFacetCollector ( String facetName , String keyFieldName , String valueFieldName , int size , TermsStatsFacet . ComparatorType comparatorType , SearchContext context , String scriptLang , String script , Map < String , Object > params ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { keyFieldData = ( ( NumericFieldData ) ( fieldDataCache . cache ( keyFieldDataType , context . reader ( ) , keyFieldName ) ) ) ; if ( ( script ) != null ) { <START_BUG> script . setNextReader ( context . reader ( ) ) ; <END_BUG> } else { aggregator . valueFieldData = ( ( NumericFieldData ) ( fieldDataCache . cache ( valueFieldDataType , context . reader ( ) , valueFieldName ) ) ) ; } } @ Override protected void doCollect ( int doc ) throws IOException { } @ Override public Facet facet ( ) { } public static class Aggregator implements NumericFieldData . MissingLongValueInDocProc { final ExtTLongObjectHashMap < InternalTermsStatsLongFacet . LongEntry > entries = CacheRecycler . popLongObjectMap ( ) ; int missing ; NumericFieldData valueFieldData ; final TermsStatsLongFacetCollector . Aggregator . ValueAggregator valueAggregator = new TermsStatsLongFacetCollector . Aggregator . ValueAggregator ( ) ; @ Override public void onValue ( int docId , long value ) { } @ Override public void onMissing ( int docId ) { } public static class ValueAggregator implements NumericFieldData . DoubleValueInDocProc { LongEntry longEntry ; @ Override public void onValue ( int docId , double value ) { } } } public static class ScriptAggregator extends TermsStatsLongFacetCollector . Aggregator { private final SearchScript script ; public ScriptAggregator ( SearchScript script ) { } @ Override public void onValue ( int docId , long value ) { } } }
public abstract class AbstractConcurrentMapFilterCache extends AbstractIndexComponent implements FilterCache { final ConcurrentMap < Object , AbstractConcurrentMapFilterCache . ReaderValue > cache ; final boolean labEnabled ; final ByteSizeValue labMaxAlloc ; final ByteSizeValue labChunkSize ; final int labMaxAllocBytes ; final int labChunkSizeBytes ; protected AbstractConcurrentMapFilterCache ( Index index , @ IndexSettings Settings indexSettings ) { } protected ConcurrentMap < Object , AbstractConcurrentMapFilterCache . ReaderValue > buildCache ( ) { } protected ConcurrentMap < Filter , DocSet > buildFilterMap ( ) { } @ Override public void close ( ) { } @ Override public void clear ( ) { } @ Override public void clear ( IndexReader reader ) { } @ Override public EntriesStats entriesStats ( ) { long sizeInBytes = 0 ; long totalCount = 0 ; int segmentsCount = 0 ; for ( AbstractConcurrentMapFilterCache . ReaderValue readerValue : cache . values ( ) ) { segmentsCount ++ ; for ( DocSet docSet : readerValue . filters ( ) . values ( ) ) { sizeInBytes += docSet . sizeInBytes ( ) ; totalCount ++ ; } } <START_BUG> return new EntriesStats ( sizeInBytes , ( totalCount / segmentsCount ) ) ; <END_BUG> } @ Override public Filter cache ( Filter filterToCache ) { } @ Override public boolean isCached ( Filter filter ) { } static class FilterCacheFilterWrapper extends Filter { private final Filter filter ; private final AbstractConcurrentMapFilterCache cache ; FilterCacheFilterWrapper ( Filter filter , AbstractConcurrentMapFilterCache cache ) { } @ Override public DocIdSet getDocIdSet ( IndexReader reader ) throws IOException { } public String toString ( ) { } public boolean equals ( Object o ) { } public int hashCode ( ) { } private DocSet cacheable ( IndexReader reader , AbstractConcurrentMapFilterCache . ReaderValue readerValue , DocIdSet set ) throws IOException { } } public static class ReaderValue { private final ConcurrentMap < Filter , DocSet > filters ; private final LongsLAB longsLAB ; public ReaderValue ( ConcurrentMap < Filter , DocSet > filters , LongsLAB longsLAB ) { } public ConcurrentMap < Filter , DocSet > filters ( ) { } public LongsLAB longsLAB ( ) { } } }
public class TransportIndexAction extends TransportShardReplicationOperationAction < IndexRequest , IndexRequest , IndexResponse > { private final AutoCreateIndex autoCreateIndex ; private final boolean allowIdGeneration ; private final TransportCreateIndexAction createIndexAction ; private final MappingUpdatedAction mappingUpdatedAction ; private final boolean waitForMappingChange ; @ Inject public TransportIndexAction ( Settings settings , TransportService transportService , ClusterService clusterService , IndicesService indicesService , ThreadPool threadPool , ShardStateAction shardStateAction , TransportCreateIndexAction createIndexAction , MappingUpdatedAction mappingUpdatedAction ) { } @ Override protected void doExecute ( final IndexRequest request , final ActionListener < IndexResponse > listener ) { if ( autoCreateIndex . shouldAutoCreate ( request . index ( ) , clusterService . state ( ) ) ) { request . beforeLocalFork ( ) ; createIndexAction . execute ( new org . elasticsearch . action . admin . indices . create . CreateIndexRequest ( request . index ( ) ) . cause ( "auto(index<seq2seq4repair_space>api)" ) . masterNodeTimeout ( request . timeout ( ) ) , new ActionListener < CreateIndexResponse > ( ) { @ Override public void onResponse ( CreateIndexResponse result ) { innerExecute ( request , listener ) ; } @ Override public void onFailure ( Throwable e ) { if ( ( ExceptionsHelper . unwrapCause ( e ) ) instanceof IndexAlreadyExistsException ) { try { innerExecute ( request , listener ) ; <START_BUG> } catch ( Exception e1 ) { <END_BUG> listener . onFailure ( e1 ) ; } } else { listener . onFailure ( e ) ; } } } ) ; } else { innerExecute ( request , listener ) ; } } @ Override protected boolean resolveRequest ( ClusterState state , IndexRequest request , ActionListener < IndexResponse > indexResponseActionListener ) { } private void innerExecute ( final IndexRequest request , final ActionListener < IndexResponse > listener ) { } @ Override protected boolean checkWriteConsistency ( ) { } @ Override protected IndexRequest newRequestInstance ( ) { } @ Override protected IndexRequest newReplicaRequestInstance ( ) { } @ Override protected IndexResponse newResponseInstance ( ) { } @ Override protected String transportAction ( ) { } @ Override protected String executor ( ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , IndexRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , IndexRequest request ) { } @ Override protected ShardIterator shards ( ClusterState clusterState , IndexRequest request ) { } @ Override protected PrimaryResponse < IndexResponse , IndexRequest > shardOperationOnPrimary ( ClusterState clusterState , PrimaryOperationRequest shardRequest ) { } @ Override protected void postPrimaryOperation ( IndexRequest request , PrimaryResponse < IndexResponse , IndexRequest > response ) { } @ Override protected void shardOperationOnReplica ( ReplicaOperationRequest shardRequest ) { } private void updateMappingOnMaster ( final IndexRequest request ) { } }
public final class SortedSetDVBytesAtomicFieldData extends SortedSetDVAtomicFieldData implements AtomicFieldData . WithOrdinals < ScriptDocValues . Strings > { SortedSetDVBytesAtomicFieldData ( AtomicReader reader , String field ) { } @ Override public boolean isValuesOrdered ( ) { } @ Override public Strings getScriptValues ( ) { <START_BUG> return new ScriptDocValues . Strings ( getBytesValues ( ) ) ; <END_BUG> } }
public class TopHitsBuilder extends AbstractAggregationBuilder { private SearchSourceBuilder sourceBuilder ; public TopHitsBuilder ( String name ) { } public TopHitsBuilder setFrom ( int from ) { } public TopHitsBuilder setSize ( int size ) { } public TopHitsBuilder setTrackScores ( boolean trackScores ) { } public TopHitsBuilder setExplain ( boolean explain ) { } public TopHitsBuilder setVersion ( boolean version ) { } public TopHitsBuilder setNoFields ( ) { } public TopHitsBuilder setFetchSource ( boolean fetch ) { } public TopHitsBuilder setFetchSource ( @ Nullable String include , @ Nullable String exclude ) { } public TopHitsBuilder setFetchSource ( @ Nullable String [ ] includes , @ Nullable String [ ] excludes ) { } public TopHitsBuilder addFieldDataField ( String name ) { } public TopHitsBuilder addScriptField ( String name , String script ) { } public TopHitsBuilder addScriptField ( String name , String script , Map < String , Object > params ) { } public TopHitsBuilder addScriptField ( String name , String lang , String script , Map < String , Object > params ) { } public TopHitsBuilder addSort ( String field , SortOrder order ) { } public TopHitsBuilder addSort ( SortBuilder sort ) { } public TopHitsBuilder addHighlightedField ( String name ) { } public TopHitsBuilder addHighlightedField ( String name , int fragmentSize ) { } public TopHitsBuilder addHighlightedField ( String name , int fragmentSize , int numberOfFragments ) { } public TopHitsBuilder addHighlightedField ( String name , int fragmentSize , int numberOfFragments , int fragmentOffset ) { } public TopHitsBuilder addHighlightedField ( HighlightBuilder . Field field ) { } public TopHitsBuilder setHighlighterTagsSchema ( String schemaName ) { } public TopHitsBuilder setHighlighterFragmentSize ( Integer fragmentSize ) { } public TopHitsBuilder setHighlighterNumOfFragments ( Integer numOfFragments ) { } public TopHitsBuilder setHighlighterFilter ( Boolean highlightFilter ) { } public TopHitsBuilder setHighlighterEncoder ( String encoder ) { } public TopHitsBuilder setHighlighterPreTags ( String ... preTags ) { } public TopHitsBuilder setHighlighterPostTags ( String ... postTags ) { } public TopHitsBuilder setHighlighterOrder ( String order ) { } public TopHitsBuilder setHighlighterRequireFieldMatch ( boolean requireFieldMatch ) { } public TopHitsBuilder setHighlighterBoundaryMaxScan ( Integer boundaryMaxScan ) { } public TopHitsBuilder setHighlighterBoundaryChars ( char [ ] boundaryChars ) { } public TopHitsBuilder setHighlighterType ( String type ) { } public TopHitsBuilder setHighlighterFragmenter ( String fragmenter ) { } public TopHitsBuilder setHighlighterQuery ( QueryBuilder highlightQuery ) { } public TopHitsBuilder setHighlighterNoMatchSize ( Integer noMatchSize ) { } public TopHitsBuilder setHighlighterPhraseLimit ( Integer phraseLimit ) { } public TopHitsBuilder setHighlighterOptions ( Map < String , Object > options ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { <START_BUG> builder . startObject ( getName ( ) ) . field ( type ) ; <END_BUG> sourceBuilder ( ) . toXContent ( builder , params ) ; return builder . endObject ( ) ; } private SearchSourceBuilder sourceBuilder ( ) { } public HighlightBuilder highlightBuilder ( ) { } }
@ ClusterScope ( scope = Scope . SUITE , numDataNodes = 1 ) public class CustomSuggesterSearchTests extends ElasticsearchIntegrationTest { @ Override protected Settings nodeSettings ( int nodeOrdinal ) { <START_BUG> return ImmutableSettings . settingsBuilder ( ) . put ( "plugin.types" , CustomSuggesterPlugin . class . getName ( ) ) . put ( super . nodeSettings ( nodeOrdinal ) ) . build ( ) ; <END_BUG> } @ Test public void testThatCustomSuggestersCanBeRegisteredAndWork ( ) throws Exception { } }
public final class InternalContext { private Map < Object , ConstructionContext < ? > > constructionContexts = Maps . newHashMap ( ) ; private Dependency dependency ; @ SuppressWarnings ( "unchecked" ) public < T > ConstructionContext < T > getConstructionContext ( Object key ) { ConstructionContext < T > constructionContext = ( ( ConstructionContext < T > ) ( constructionContexts . get ( key ) ) ) ; if ( constructionContext == null ) { <START_BUG> constructionContext = new ConstructionContext < T > ( ) ; <END_BUG> constructionContexts . put ( key , constructionContext ) ; } return constructionContext ; } public Dependency getDependency ( ) { } public void setDependency ( Dependency dependency ) { } }
public class BouncyAndroid extends AndroidApplication { @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; <START_BUG> initialize ( new Bouncy ( ) , false , new FillResolutionStrategy ( ) , 16 ) ; <END_BUG> } }
public interface EventListener { <START_BUG> public boolean handle ( Event event ) ; <END_BUG> }
public class JsonReader implements BaseJsonReader { public JsonValue parse ( String json ) { } public JsonValue parse ( Reader reader ) { } @ Override public JsonValue parse ( InputStream input ) { } @ Override public JsonValue parse ( FileHandle file ) { try { <START_BUG> return parse ( file . reader ( "UTF-8" ) ) ; <END_BUG> } catch ( Exception ex ) { throw new SerializationException ( ( "Error<seq2seq4repair_space>parsing<seq2seq4repair_space>file:<seq2seq4repair_space>" + file ) , ex ) ; } } public JsonValue parse ( char [ ] data , int offset , int length ) { } private static byte [ ] init__json_actions_0 ( ) { } private static final byte [ ] _json_actions = JsonReader . init__json_actions_0 ( ) ; private static short [ ] init__json_key_offsets_0 ( ) { } private static final short [ ] _json_key_offsets = JsonReader . init__json_key_offsets_0 ( ) ; private static char [ ] init__json_trans_keys_0 ( ) { } private static final char [ ] _json_trans_keys = JsonReader . init__json_trans_keys_0 ( ) ; private static byte [ ] init__json_single_lengths_0 ( ) { } private static final byte [ ] _json_single_lengths = JsonReader . init__json_single_lengths_0 ( ) ; private static byte [ ] init__json_range_lengths_0 ( ) { } private static final byte [ ] _json_range_lengths = JsonReader . init__json_range_lengths_0 ( ) ; private static short [ ] init__json_index_offsets_0 ( ) { } private static final short [ ] _json_index_offsets = JsonReader . init__json_index_offsets_0 ( ) ; private static byte [ ] init__json_trans_targs_0 ( ) { } private static final byte [ ] _json_trans_targs = JsonReader . init__json_trans_targs_0 ( ) ; private static byte [ ] init__json_trans_actions_0 ( ) { } private static final byte [ ] _json_trans_actions = JsonReader . init__json_trans_actions_0 ( ) ; private static byte [ ] init__json_eof_actions_0 ( ) { } private static final byte [ ] _json_eof_actions = JsonReader . init__json_eof_actions_0 ( ) ; static final int json_start = 1 ; static final int json_first_final = 72 ; static final int json_error = 0 ; static final int json_en_object = 8 ; static final int json_en_array = 46 ; static final int json_en_main = 1 ; private final Array < JsonValue > elements = new Array ( 8 ) ; private final Array < JsonValue > lastChild = new Array ( 8 ) ; private JsonValue root ; private JsonValue current ; private void addChild ( String name , JsonValue child ) { } protected void startObject ( String name ) { } protected void startArray ( String name ) { } protected void pop ( ) { } protected void string ( String name , String value ) { } protected void number ( String name , double value ) { } protected void number ( String name , long value ) { } protected void bool ( String name , boolean value ) { } private String unescape ( String value ) { } }
public class AlphaTest extends GdxTest { SpriteBatch batch ; Texture texture ; @ Override public void create ( ) { } @ Override public void render ( ) { graphics . getGL10 ( ) . glClear ( GL_COLOR_BUFFER_BIT ) ; batch . begin ( ) ; <START_BUG> batch . draw ( texture , 0 , 0 , 256 , 256 , 0 , 0 , 256 , 256 , WHITE , false , false ) ; <END_BUG> batch . end ( ) ; } @ Override public boolean needsGL20 ( ) { } }
public class TransportNodesListGatewayStartedShards extends TransportNodesOperationAction < TransportNodesListGatewayStartedShards . Request , TransportNodesListGatewayStartedShards . NodesLocalGatewayStartedShards , TransportNodesListGatewayStartedShards . NodeRequest , TransportNodesListGatewayStartedShards . NodeLocalGatewayStartedShards > { private LocalGateway gateway ; @ Inject public TransportNodesListGatewayStartedShards ( Settings settings , ClusterName clusterName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService ) { } TransportNodesListGatewayStartedShards initGateway ( LocalGateway gateway ) { } public ActionFuture < TransportNodesListGatewayStartedShards . NodesLocalGatewayStartedShards > list ( Set < String > nodesIds , @ Nullable TimeValue timeout ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportNodeAction ( ) { } @ Override protected TransportNodesListGatewayStartedShards . Request newRequest ( ) { } @ Override protected TransportNodesListGatewayStartedShards . NodeRequest newNodeRequest ( ) { } @ Override protected TransportNodesListGatewayStartedShards . NodeRequest newNodeRequest ( String nodeId , TransportNodesListGatewayStartedShards . Request request ) { } @ Override protected TransportNodesListGatewayStartedShards . NodeLocalGatewayStartedShards newNodeResponse ( ) { } @ Override protected TransportNodesListGatewayStartedShards . NodesLocalGatewayStartedShards newResponse ( TransportNodesListGatewayStartedShards . Request request , AtomicReferenceArray responses ) { } @ Override protected TransportNodesListGatewayStartedShards . NodeLocalGatewayStartedShards nodeOperation ( TransportNodesListGatewayStartedShards . NodeRequest request ) throws ElasticSearchException { } @ Override protected boolean accumulateExceptions ( ) { } static class Request extends NodesOperationRequest { public Request ( ) { } public Request ( Set < String > nodesIds ) { } @ Override public TransportNodesListGatewayStartedShards . Request timeout ( TimeValue timeout ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } public static class NodesLocalGatewayStartedShards extends NodesOperationResponse < TransportNodesListGatewayStartedShards . NodeLocalGatewayStartedShards > { private FailedNodeException [ ] failures ; NodesLocalGatewayStartedShards ( ) { } public NodesLocalGatewayStartedShards ( ClusterName clusterName , TransportNodesListGatewayStartedShards . NodeLocalGatewayStartedShards [ ] nodes , FailedNodeException [ ] failures ) { } public FailedNodeException [ ] failures ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; nodes = new TransportNodesListGatewayStartedShards . NodeLocalGatewayStartedShards [ in . readVInt ( ) ] ; for ( int i = 0 ; i < ( nodes . length ) ; i ++ ) { nodes [ i ] = new TransportNodesListGatewayStartedShards . NodeLocalGatewayStartedShards ( ) ; nodes [ i ] . readFrom ( in ) ; } } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } static class NodeRequest extends NodeOperationRequest { NodeRequest ( ) { } NodeRequest ( String nodeId ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } public static class NodeLocalGatewayStartedShards extends NodeOperationResponse { private LocalGatewayStartedShards state ; NodeLocalGatewayStartedShards ( ) { } public NodeLocalGatewayStartedShards ( DiscoveryNode node , LocalGatewayStartedShards state ) { } public LocalGatewayStartedShards state ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; if ( in . readBoolean ( ) ) { <START_BUG> state = Builder . readFrom ( in , null ) ; <END_BUG> } } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public static final int M33 = 15 ; public final float [ ] tmp = new float [ 16 ] ; public final float [ ] val = new float [ 16 ] ; public Matrix4 ( ) { } public Matrix4 ( Matrix4 matrix ) { } public Matrix4 ( float [ ] values ) { } public Matrix4 ( Quaternion quaternion ) { } public Matrix4 ( Vector3 position , Quaternion rotation , Vector3 scale ) { } public Matrix4 set ( Matrix4 matrix ) { } public Matrix4 set ( float [ ] values ) { } public Matrix4 set ( Quaternion quaternion ) { } public Matrix4 set ( float x , float y , float z , float w ) { } public Matrix4 set ( Vector3 position , Quaternion orientation ) { } public Matrix4 set ( float translationX , float translationY , float translationZ , float quaternionX , float quaternionY , float quaternionZ , float quaternionW ) { } public Matrix4 set ( Vector3 xAxis , Vector3 yAxis , Vector3 zAxis , Vector3 pos ) { } public Matrix4 set ( Vector3 position , Quaternion orientation , Vector3 scale ) { } public Matrix4 cpy ( ) { } public Matrix4 trn ( Vector3 vector ) { } public Matrix4 trn ( float x , float y , float z ) { } public float [ ] getValues ( ) { } public Matrix4 mul ( Matrix4 matrix ) { } public Matrix4 mulLeft ( Matrix4 matrix ) { } public Matrix4 tra ( ) { } public Matrix4 idt ( ) { } public Matrix4 inv ( ) { } public float det ( ) { } public float det3x3 ( ) { } public Matrix4 setToProjection ( float near , float far , float fov , float aspectRatio ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height ) { } public Matrix4 setToOrtho2D ( float x , float y , float width , float height , float near , float far ) { } public Matrix4 setToOrtho ( float left , float right , float bottom , float top , float near , float far ) { } public Matrix4 setTranslation ( Vector3 vector ) { } public Matrix4 setTranslation ( float x , float y , float z ) { } public Matrix4 setToTranslation ( Vector3 vector ) { } public Matrix4 setToTranslation ( float x , float y , float z ) { } public Matrix4 setToTranslationAndScaling ( Vector3 translation , Vector3 scaling ) { } public Matrix4 setToTranslationAndScaling ( float translationX , float translationY , float translationZ , float scalingX , float scalingY , float scalingZ ) { } static Quaternion quat = new Quaternion ( ) ; public Matrix4 setToRotation ( Vector3 axis , float degrees ) { } public Matrix4 setToRotationRad ( Vector3 axis , float radians ) { } public Matrix4 setToRotationRad ( float axisX , float axisY , float axisZ , float radians ) { } public Matrix4 setToRotation ( float axisX , float axisY , float axisZ , float angle ) { } public Matrix4 setToRotation ( final Vector3 v1 , final Vector3 v2 ) { } public Matrix4 setToRotation ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { } public Matrix4 setFromEulerAngles ( float yaw , float pitch , float roll ) { } public Matrix4 setToScaling ( Vector3 vector ) { } public Matrix4 setToScaling ( float x , float y , float z ) { } static final Vector3 l_vez = new Vector3 ( ) ; static final Vector3 l_vex = new Vector3 ( ) ; static final Vector3 l_vey = new Vector3 ( ) ; public Matrix4 setToLookAt ( Vector3 direction , Vector3 up ) { } static final Vector3 tmpVec = new Vector3 ( ) ; static final Matrix4 tmpMat = new Matrix4 ( ) ; public Matrix4 setToLookAt ( Vector3 position , Vector3 target , Vector3 up ) { Matrix4 . tmpVec . set ( target ) . sub ( position ) ; setToLookAt ( Matrix4 . tmpVec , up ) ; <START_BUG> this . mul ( Matrix4 . tmpMat . setToTranslation ( position . tmp ( ) . scl ( ( - 1 ) ) ) ) ; <END_BUG> return this ; } static final Vector3 right = new Vector3 ( ) ; static final Vector3 tmpForward = new Vector3 ( ) ; static final Vector3 tmpUp = new Vector3 ( ) ; public Matrix4 setToWorld ( Vector3 position , Vector3 forward , Vector3 up ) { } public String toString ( ) { } public Matrix4 lerp ( Matrix4 matrix , float alpha ) { } public Matrix4 set ( Matrix3 mat ) { } public Matrix4 scl ( Vector3 scale ) { } public Matrix4 scl ( float x , float y , float z ) { } public Matrix4 scl ( float scale ) { } public Vector3 getTranslation ( Vector3 position ) { } public Quaternion getRotation ( Quaternion rotation , boolean normalizeAxes ) { } public Quaternion getRotation ( Quaternion rotation ) { } public float getScaleXSquared ( ) { } public float getScaleYSquared ( ) { } public float getScaleZSquared ( ) { } public float getScaleX ( ) { } public float getScaleY ( ) { } public float getScaleZ ( ) { } public Vector3 getScale ( Vector3 scale ) { } public Matrix4 toNormalMatrix ( ) { } static void matrix4_mul ( float [ ] mata , float [ ] matb ) { } static float matrix4_det ( float [ ] val ) { } static boolean matrix4_inv ( float [ ] val ) { } static void matrix4_mulVec ( float [ ] mat , float [ ] vec , int offset ) { }
public class FileProcessor { FilenameFilter inputFilter ; Comparator < File > comparator ; Array < Pattern > inputRegex = new Array ( ) ; String outputSuffix ; ArrayList < FileProcessor . InputFile > outputFiles = new ArrayList ( ) ; boolean recursive = true ; boolean flattenOutput ; Comparator < FileProcessor . InputFile > inputFileComparator = new Comparator < FileProcessor . InputFile > ( ) { public int compare ( FileProcessor . InputFile o1 , FileProcessor . InputFile o2 ) { } } ; public FileProcessor setInputFilter ( FilenameFilter inputFilter ) { } public FileProcessor setComparator ( Comparator < File > comparator ) { } public FileProcessor addInputSuffix ( String ... suffixes ) { } public FileProcessor addInputRegex ( String ... regexex ) { } public FileProcessor setOutputSuffix ( String outputSuffix ) { } public FileProcessor setFlattenOutput ( boolean flattenOutput ) { } public FileProcessor setRecursive ( boolean recursive ) { } public ArrayList < FileProcessor . InputFile > process ( File inputFile , File outputRoot ) throws Exception { } public ArrayList < FileProcessor . InputFile > process ( File [ ] files , File outputRoot ) throws Exception { } private void process ( File [ ] files , File outputRoot , File outputDir , HashMap < File , ArrayList < FileProcessor . InputFile > > dirToEntries , int depth ) { } protected void processFile ( FileProcessor . InputFile inputFile ) throws Exception { } <START_BUG> protected void processDir ( FileProcessor . InputFile inputDir , ArrayList < FileProcessor . InputFile > value ) throws Exception { <END_BUG> } protected void addProcessedFile ( FileProcessor . InputFile inputFile ) { } public static class InputFile { public File inputFile ; public File outputDir ; public File outputFile ; public int depth ; public InputFile ( ) { } public InputFile ( File inputFile , File outputFile ) { } } }
public class LwjglGraphics implements Graphics { static int major ; static int minor ; GLCommon gl ; GL10 gl10 ; GL11 gl11 ; GL20 gl20 ; GLU glu ; float deltaTime = 0 ; long frameStart = 0 ; int frames = 0 ; int fps ; long lastTime = System . nanoTime ( ) ; Canvas canvas ; boolean vsync = false ; boolean resize = false ; LwjglApplicationConfiguration config ; BufferFormat bufferFormat = new BufferFormat ( 8 , 8 , 8 , 8 , 16 , 8 , 0 , false ) ; String extensions ; LwjglGraphics ( LwjglApplicationConfiguration config ) { } LwjglGraphics ( Canvas canvas , boolean useGL2IfAvailable ) { } LwjglGraphics ( Canvas canvas , LwjglApplicationConfiguration config ) { } public GL10 getGL10 ( ) { } public GL11 getGL11 ( ) { } public GL20 getGL20 ( ) { } public GLU getGLU ( ) { } public int getHeight ( ) { } public int getWidth ( ) { } public boolean isGL11Available ( ) { } public boolean isGL20Available ( ) { } public float getDeltaTime ( ) { } public float getRawDeltaTime ( ) { } public GraphicsType getType ( ) { } public int getFramesPerSecond ( ) { } @ Override public GLCommon getGLCommon ( ) { } void updateTime ( ) { } void setupDisplay ( ) throws LWJGLException { } private void createDisplayPixelFormat ( ) { } public void initiateGLInstances ( ) { } @ Override public float getPpiX ( ) { } @ Override public float getPpiY ( ) { } @ Override public float getPpcX ( ) { } @ Override public float getPpcY ( ) { } @ Override public float getDensity ( ) { } @ Override public boolean supportsDisplayModeChange ( ) { } private class LwjglDisplayMode extends DisplayMode { org . lwjgl . opengl . DisplayMode mode ; public LwjglDisplayMode ( int width , int height , int refreshRate , int bitsPerPixel , org . lwjgl . opengl . DisplayMode mode ) { } } @ Override public boolean setDisplayMode ( DisplayMode displayMode ) { } @ Override public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { } @ Override public DisplayMode [ ] getDisplayModes ( ) { } @ Override public DisplayMode getDesktopDisplayMode ( ) { } @ Override public void setTitle ( String title ) { } @ Override public BufferFormat getBufferFormat ( ) { } @ Override public void setVSync ( boolean vsync ) { } @ Override public boolean supportsExtension ( String extension ) { } public LwjglApplicationConfiguration getConfig ( ) { } volatile boolean isContinuous = true ; volatile boolean requestRendering = false ; @ Override public void setContinuousRendering ( boolean isContinuous ) { } @ Override public boolean isContinuousRendering ( ) { } @ Override public void requestRendering ( ) { } public boolean shouldRender ( ) { synchronized ( this ) { boolean rq = requestRendering ; requestRendering = false ; <START_BUG> return rq || ( isContinuous ) ; <END_BUG> } } @ Override public boolean isFullscreen ( ) { } }
public class RestGatewaySnapshotAction extends BaseRestHandler { @ Inject public RestGatewaySnapshotAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { GatewaySnapshotRequest gatewaySnapshotRequest = new GatewaySnapshotRequest ( RestActions . splitIndices ( request . param ( "index" ) ) ) ; gatewaySnapshotRequest . listenerThreaded ( false ) ; if ( request . hasParam ( "ignore_indices" ) ) { gatewaySnapshotRequest . ignoreIndices ( IgnoreIndices . fromString ( request . param ( "ignore_indices" ) ) ) ; } client . admin ( ) . indices ( ) . gatewaySnapshot ( gatewaySnapshotRequest , new org . elasticsearch . action . ActionListener < GatewaySnapshotResponse > ( ) { @ Override public void onResponse ( GatewaySnapshotResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; builder . field ( "ok" , true ) ; buildBroadcastShardsHeader ( builder , response ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
class TableToolkit extends Toolkit < Actor , Table , TableLayout > { static boolean drawDebug ; static Pool < Cell > cellPool = new Pool ( ) { protected Cell newObject ( ) { } } ; public Cell obtainCell ( TableLayout layout ) { } public void freeCell ( Cell cell ) { <START_BUG> cell . setLayout ( null ) ; <END_BUG> TableToolkit . cellPool . free ( cell ) ; } public void addChild ( Actor parent , Actor child ) { } public void removeChild ( Actor parent , Actor child ) { } public float getMinWidth ( Actor actor ) { } public float getMinHeight ( Actor actor ) { } public float getPrefWidth ( Actor actor ) { } public float getPrefHeight ( Actor actor ) { } public float getMaxWidth ( Actor actor ) { } public float getMaxHeight ( Actor actor ) { } public float getWidth ( Actor widget ) { } public float getHeight ( Actor widget ) { } public void clearDebugRectangles ( TableLayout layout ) { } public void addDebugRectangle ( TableLayout layout , Debug type , float x , float y , float w , float h ) { } static class DebugRect extends Rectangle { final Debug type ; public DebugRect ( Debug type , float x , float y , float width , float height ) { } } }
public class SuperJumperDesktop { public static void main ( String [ ] argv ) { <START_BUG> new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new SuperJumper ( ) , "Super<seq2seq4repair_space>Jumper" , 320 , 480 ) ; <END_BUG> } }
public class JsonDoubleFieldMapper extends JsonNumberFieldMapper < Double > { public static final String JSON_TYPE = "double" ; public static class Defaults extends JsonNumberFieldMapper . Defaults { public static final Double NULL_VALUE = null ; } public static class Builder extends JsonNumberFieldMapper . Builder < JsonDoubleFieldMapper . Builder , JsonDoubleFieldMapper > { protected Double nullValue = JsonDoubleFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public JsonDoubleFieldMapper . Builder nullValue ( double nullValue ) { } @ Override public JsonDoubleFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements JsonTypeParser { @ Override public JsonMapper . Builder parse ( String name , JsonNode node , ParserContext parserContext ) throws MapperParsingException { } } private final Double nullValue ; private final String nullValueAsString ; protected JsonDoubleFieldMapper ( Names names , int precisionStep , Field . Index index , Field . Store store , float boost , boolean omitNorms , boolean omitTermFreqAndPositions , Double nullValue ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Double value ( Fieldable field ) { byte [ ] value = field . getBinaryValue ( ) ; if ( value == null ) { <START_BUG> return Double . NaN ; <END_BUG> } return Numbers . bytesToDouble ( value ) ; } @ Override public String indexedValue ( String value ) { } @ Override public String indexedValue ( Double value ) { } @ Override public Object valueFromTerm ( String term ) { } @ Override public Object valueFromString ( String text ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override protected Field parseCreateField ( JsonParseContext jsonContext ) throws IOException { } @ Override public int sortType ( ) { } @ Override protected String jsonType ( ) { } @ Override protected void doJsonBody ( JsonBuilder builder ) throws IOException { } }
public class JsonDateFieldMapper extends JsonNumberFieldMapper < Long > { public static final String JSON_TYPE = "date" ; public static class Defaults extends JsonNumberFieldMapper . Defaults { public static final FormatDateTimeFormatter DATE_TIME_FORMATTER = Joda . forPattern ( "dateOptionalTime" ) ; public static final String NULL_VALUE = null ; } public static class Builder extends JsonNumberFieldMapper . Builder < JsonDateFieldMapper . Builder , JsonDateFieldMapper > { protected String nullValue = JsonDateFieldMapper . Defaults . NULL_VALUE ; protected FormatDateTimeFormatter dateTimeFormatter = JsonDateFieldMapper . Defaults . DATE_TIME_FORMATTER ; public Builder ( String name ) { } public JsonDateFieldMapper . Builder nullValue ( String nullValue ) { } public JsonDateFieldMapper . Builder dateTimeFormatter ( FormatDateTimeFormatter dateTimeFormatter ) { } @ Override public JsonDateFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements JsonTypeParser { @ Override public JsonMapper . Builder parse ( String name , JsonNode node , ParserContext parserContext ) throws MapperParsingException { } } private final FormatDateTimeFormatter dateTimeFormatter ; private final String nullValue ; protected JsonDateFieldMapper ( Names names , FormatDateTimeFormatter dateTimeFormatter , int precisionStep , Field . Index index , Field . Store store , float boost , boolean omitNorms , boolean omitTermFreqAndPositions , String nullValue ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Long value ( Fieldable field ) { byte [ ] value = field . getBinaryValue ( ) ; if ( value == null ) { <START_BUG> return Long . MIN_VALUE ; <END_BUG> } return Numbers . bytesToLong ( value ) ; } @ Override public Object valueForSearch ( Fieldable field ) { } @ Override public Object valueForSearch ( Object value ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } @ Override public String indexedValue ( Long value ) { } @ Override public Object valueFromTerm ( String term ) { } @ Override public Object valueFromString ( String text ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override protected Field parseCreateField ( JsonParseContext jsonContext ) throws IOException { } @ Override public int sortType ( ) { } @ Override protected String jsonType ( ) { } @ Override protected void doJsonBody ( JsonBuilder builder ) throws IOException { } }
public interface Gateway extends LifecycleComponent < Gateway > { String type ( ) { } void performStateRecovery ( Gateway . GatewayStateRecoveredListener listener ) throws GatewayException { } Class < ? extends Module > suggestIndexGateway ( ) { } void reset ( ) throws Exception { } interface GatewayStateRecoveredListener { void onSuccess ( ClusterState recoveredState ) { } <START_BUG> void onFailure ( Throwable t ) ; <END_BUG> } }
public class InternalClusterService extends AbstractLifecycleComponent < ClusterService > implements ClusterService { private final ThreadPool threadPool ; private final DiscoveryService discoveryService ; private final OperationRouting operationRouting ; private final TransportService transportService ; private final NodeSettingsService nodeSettingsService ; private final TimeValue reconnectInterval ; private volatile PrioritizedEsThreadPoolExecutor updateTasksExecutor ; private final List < ClusterStateListener > priorityClusterStateListeners = new CopyOnWriteArrayList < ClusterStateListener > ( ) ; private final List < ClusterStateListener > clusterStateListeners = new CopyOnWriteArrayList < ClusterStateListener > ( ) ; private final List < ClusterStateListener > lastClusterStateListeners = new CopyOnWriteArrayList < ClusterStateListener > ( ) ; private final InternalClusterService . LocalNodeMasterListeners localNodeMasterListeners ; private final Queue < InternalClusterService . NotifyTimeout > onGoingTimeouts = ConcurrentCollections . newQueue ( ) ; private volatile ClusterState clusterState = org . elasticsearch . cluster . ClusterState . newClusterStateBuilder ( ) . build ( ) ; private final org . elasticsearch . cluster . ClusterState . Builder initialBlocks = ClusterBlocks . builder ( ) . addGlobalBlock ( NO_MASTER_BLOCK ) ; private volatile ScheduledFuture reconnectToNodes ; @ Inject public InternalClusterService ( Settings settings , DiscoveryService discoveryService , OperationRouting operationRouting , TransportService transportService , NodeSettingsService nodeSettingsService , ThreadPool threadPool ) { } public NodeSettingsService settingsService ( ) { } public void addInitialStateBlock ( ClusterBlock block ) throws ElasticSearchIllegalStateException { } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } @ Override public DiscoveryNode localNode ( ) { } @ Override public OperationRouting operationRouting ( ) { } public ClusterState state ( ) { } public void addFirst ( ClusterStateListener listener ) { } public void addLast ( ClusterStateListener listener ) { } public void add ( ClusterStateListener listener ) { } public void remove ( ClusterStateListener listener ) { } @ Override public void add ( LocalNodeMasterListener listener ) { } @ Override public void remove ( LocalNodeMasterListener listener ) { } public void add ( final TimeValue timeout , final TimeoutClusterStateListener listener ) { } public void submitStateUpdateTask ( final String source , final ClusterStateUpdateTask updateTask ) { } public void submitStateUpdateTask ( final String source , Priority priority , final ClusterStateUpdateTask updateTask ) { if ( ! ( lifecycle . started ( ) ) ) { return ; } final InternalClusterService . UpdateTask task = new InternalClusterService . UpdateTask ( source , priority , updateTask ) ; if ( updateTask instanceof TimeoutClusterStateUpdateTask ) { final TimeoutClusterStateUpdateTask timeoutUpdateTask = ( ( TimeoutClusterStateUpdateTask ) ( updateTask ) ) ; updateTasksExecutor . execute ( task , threadPool . scheduler ( ) , timeoutUpdateTask . timeout ( ) , new Runnable ( ) { @ Override public void run ( ) { threadPool . generic ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { <START_BUG> timeoutUpdateTask . onTimeout ( task . source ) ; <END_BUG> } } ) ; } } ) ; } else { updateTasksExecutor . execute ( task ) ; } } class UpdateTask extends PrioritizedRunnable { public final String source ; public final ClusterStateUpdateTask updateTask ; UpdateTask ( String source , Priority priority , ClusterStateUpdateTask updateTask ) { } @ Override public void run ( ) { } } class NotifyTimeout implements Runnable { final TimeoutClusterStateListener listener ; final TimeValue timeout ; ScheduledFuture future ; NotifyTimeout ( TimeoutClusterStateListener listener , TimeValue timeout ) { } public void cancel ( ) { } @ Override public void run ( ) { } } private class ReconnectToNodes implements Runnable { private ConcurrentMap < DiscoveryNode , Integer > failureCount = ConcurrentCollections . newConcurrentMap ( ) ; @ Override public void run ( ) { } } private boolean nodeRequiresConnection ( DiscoveryNode node ) { } private static class LocalNodeMasterListeners implements ClusterStateListener { private final List < LocalNodeMasterListener > listeners = new CopyOnWriteArrayList < LocalNodeMasterListener > ( ) ; private final ThreadPool threadPool ; private volatile boolean master = false ; private LocalNodeMasterListeners ( ThreadPool threadPool ) { } @ Override public void clusterChanged ( ClusterChangedEvent event ) { } private void add ( LocalNodeMasterListener listener ) { } private void remove ( LocalNodeMasterListener listener ) { } private void clear ( ) { } } private static class OnMasterRunnable implements Runnable { private final LocalNodeMasterListener listener ; private OnMasterRunnable ( LocalNodeMasterListener listener ) { } @ Override public void run ( ) { } } private static class OffMasterRunnable implements Runnable { private final LocalNodeMasterListener listener ; private OffMasterRunnable ( LocalNodeMasterListener listener ) { } @ Override public void run ( ) { } } }
public class LwjglAWTCanvas implements Application { final LwjglGraphics graphics ; final OpenALAudio audio ; final LwjglFiles files ; final LwjglAWTInput input ; final LwjglNet net ; final ApplicationListener listener ; final AWTGLCanvas canvas ; final List < Runnable > runnables = new ArrayList ( ) ; final List < Runnable > executedRunnables = new ArrayList ( ) ; final Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; boolean running = true ; int lastWidth ; int lastHeight ; int logLevel = LOG_INFO ; private Cursor cursor ; public LwjglAWTCanvas ( ApplicationListener listener , boolean useGL2 ) { } public LwjglAWTCanvas ( ApplicationListener listener , boolean useGL2 , LwjglAWTCanvas sharedContextCanvas ) { } protected void setDisplayMode ( int width , int height ) { } protected void setTitle ( String title ) { } @ Override public ApplicationListener getApplicationListener ( ) { } public Canvas getCanvas ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Files getFiles ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Input getInput ( ) { } @ Override public Net getNet ( ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { } void setGlobals ( ) { } void create ( ) { } void render ( ) { } protected void start ( ) { } protected void resize ( int width , int height ) { } protected void stopped ( ) { } public void stop ( ) { } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } Map < String , Preferences > preferences = new HashMap < String , Preferences > ( ) ; @ Override public Preferences getPreferences ( String name ) { if ( preferences . containsKey ( name ) ) { return preferences . get ( name ) ; } else { <START_BUG> Preferences prefs = new LwjglPreferences ( name ) ; <END_BUG> preferences . put ( name , prefs ) ; return prefs ; } } @ Override public Clipboard getClipboard ( ) { } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } public void log ( String tag , String message ) { } @ Override public void log ( String tag , String message , Throwable exception ) { } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public int getLogLevel ( ) { } @ Override public void exit ( ) { } public void makeCurrent ( ) { } public boolean isCurrent ( ) { } public void setCursor ( Cursor cursor ) { } @ Override public void addLifecycleListener ( LifecycleListener listener ) { } @ Override public void removeLifecycleListener ( LifecycleListener listener ) { } }
public class DoubleFieldMapper extends NumberFieldMapper < Double > { public static final String CONTENT_TYPE = "double" ; public static class Defaults extends NumberFieldMapper . Defaults { public static final FieldType FIELD_TYPE = new FieldType ( NumberFieldMapper . Defaults . FIELD_TYPE ) ; public static final Double NULL_VALUE = null ; } public static class Builder extends NumberFieldMapper . Builder < DoubleFieldMapper . Builder , DoubleFieldMapper > { protected Double nullValue = DoubleFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public DoubleFieldMapper . Builder nullValue ( double nullValue ) { } @ Override public DoubleFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private Double nullValue ; private String nullValueAsString ; protected DoubleFieldMapper ( Names names , int precisionStep , float boost , FieldType fieldType , Double nullValue , Explicit < Boolean > ignoreMalformed , PostingsFormatProvider provider , SimilarityProvider similarity , @ Nullable Settings fieldDataSettings ) { } @ Override public FieldType defaultFieldType ( ) { } @ Override public FieldDataType defaultFieldDataType ( ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Double value ( Object value ) { } @ Override public BytesRef indexedValueForSearch ( Object value ) { long longValue = NumericUtils . doubleToSortableLong ( parseValue ( value ) ) ; BytesRef bytesRef = new BytesRef ( ) ; <START_BUG> NumericUtils . longToPrefixCoded ( longValue , precisionStep ( ) , bytesRef ) ; <END_BUG> return bytesRef ; } private double parseValue ( Object value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query termQuery ( Object value , @ Nullable QueryParseContext context ) { } @ Override public Query rangeQuery ( Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter termFilter ( Object value , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } public Filter rangeFilter ( Double lowerTerm , Double upperTerm , boolean includeLower , boolean includeUpper ) { } @ Override public Filter rangeFilter ( IndexFieldDataService fieldData , Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected boolean customBoost ( ) { } @ Override protected Field innerParseCreateField ( ParseContext context ) throws IOException { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } public static class CustomDoubleNumericField extends CustomNumericField { private final double number ; private final NumberFieldMapper mapper ; public CustomDoubleNumericField ( NumberFieldMapper mapper , double number , FieldType fieldType ) { } @ Override public TokenStream tokenStream ( Analyzer analyzer ) throws IOException { } @ Override public String numericAsString ( ) { } } }
public class AccelerometerTest extends GdxTest { @ Override public boolean needsGL20 ( ) { } BitmapFont font ; SpriteBatch batch ; @ Override public void create ( ) { <START_BUG> font = new BitmapFont ( ) ; <END_BUG> batch = new SpriteBatch ( ) ; } @ Override public void render ( ) { } }
public class AssetManager implements Disposable { final ObjectMap < Class , ObjectMap < String , RefCountedContainer > > assets = new ObjectMap < Class , ObjectMap < String , RefCountedContainer > > ( ) ; final ObjectMap < String , Class > assetTypes = new ObjectMap < String , Class > ( ) ; final ObjectMap < String , Array < String > > assetDependencies = new ObjectMap < String , Array < String > > ( ) ; final ObjectMap < Class , AssetLoader > loaders = new ObjectMap < Class , AssetLoader > ( ) ; final Array < AssetDescriptor > loadQueue = new Array < AssetDescriptor > ( ) ; final ExecutorService threadPool ; Stack < AssetLoadingTask > tasks = new Stack < AssetLoadingTask > ( ) ; AssetErrorListener listener = null ; int loaded = 0 ; int toLoad = 0 ; Logger log = new Logger ( AssetManager . class . getSimpleName ( ) ) ; public AssetManager ( ) { } public AssetManager ( FileHandleResolver resolver ) { } public synchronized < T > T get ( String fileName , Class < T > type ) { } public synchronized void unload ( String fileName ) { } public synchronized < T > boolean containsAsset ( T asset ) { } public synchronized < T > String getAssetFileName ( T asset ) { } public synchronized boolean isLoaded ( String fileName ) { } public synchronized boolean isLoaded ( String fileName , Class type ) { } public synchronized < T > void load ( String fileName , Class < T > type ) { } public synchronized < T > void load ( String fileName , Class < T > type , AssetLoaderParameters < T > parameter ) { } public synchronized void load ( AssetDescriptor desc ) { } private void disposeDependencies ( String fileName ) { } public synchronized boolean update ( ) { } public void finishLoading ( ) { } synchronized void injectDependency ( String parentAssetFilename , AssetDescriptor dependendAssetDesc ) { } private void nextTask ( ) { } private void addTask ( AssetDescriptor assetDesc ) { } private boolean updateTask ( ) { } private void incrementRefCountedDependencies ( String parent ) { } private void handleTaskError ( Throwable t ) { } public synchronized < T , P extends AssetLoaderParameters < T > > void setLoader ( Class < T > type , AssetLoader < T , P > loader ) { } public synchronized int getLoadedAssets ( ) { } public synchronized int getQueuedAssets ( ) { } public synchronized float getProgress ( ) { if ( ( toLoad ) == 0 ) return 1 ; <START_BUG> return ( loaded ) / ( ( float ) ( toLoad ) ) ; <END_BUG> } public synchronized void setErrorListener ( AssetErrorListener listener ) { } public synchronized void dispose ( ) { } public synchronized void clear ( ) { } public Logger getLogger ( ) { } public synchronized int getReferenceCount ( String fileName ) { } public synchronized void setReferenceCount ( String fileName , int refCount ) { } public synchronized String getDiagnostics ( ) { } }
public class Pixmap implements Disposable { public static Map < Integer , Pixmap > pixmaps = new HashMap < Integer , Pixmap > ( ) ; static int nextId = 0 ; public enum Format { Alpha , Intensity , LuminanceAlpha , RGB565 , RGBA4444 , RGB888 , RGBA8888 ; } public enum Blending { None , SourceOver ; } public enum Filter { NearestNeighbour , BiLinear ; } int width ; int height ; Pixmap . Format format ; Canvas canvas ; Context2d context ; int id ; IntBuffer buffer ; int r = 255 ; int g = 255 ; int b = 255 ; float a ; String color = Pixmap . make ( r , g , b , a ) ; static Pixmap . Blending blending ; CanvasPixelArray pixels ; public Pixmap ( FileHandle file ) { } private static Composite getComposite ( ) { } public Pixmap ( ImageElement img ) { } public Pixmap ( int width , int height , Pixmap . Format format ) { } private void create ( int width , int height , Pixmap . Format format2 ) { } public static String make ( int r2 , int g2 , int b2 , float a2 ) { } public static void setBlending ( Pixmap . Blending blending ) { } public static Pixmap . Blending getBlending ( ) { } public static void setFilter ( Pixmap . Filter filter ) { } public Pixmap . Format getFormat ( ) { } public int getGLInternalFormat ( ) { } public int getGLFormat ( ) { } public int getGLType ( ) { } public int getWidth ( ) { } public int getHeight ( ) { } public Buffer getPixels ( ) { } @ Override public void dispose ( ) { } public CanvasElement getCanvasElement ( ) { } public void setColor ( int color ) { } public void setColor ( float r , float g , float b , float a ) { } public void setColor ( Color color ) { } public void fill ( ) { } public void drawLine ( int x , int y , int x2 , int y2 ) { } public void drawRectangle ( int x , int y , int width , int height ) { } public void drawPixmap ( Pixmap pixmap , int x , int y ) { } public void drawPixmap ( Pixmap pixmap , int x , int y , int srcx , int srcy , int srcWidth , int srcHeight ) { } public void drawPixmap ( Pixmap pixmap , int srcx , int srcy , int srcWidth , int srcHeight , int dstx , int dsty , int dstWidth , int dstHeight ) { } public void fillRectangle ( int x , int y , int width , int height ) { } public void drawCircle ( int x , int y , int radius ) { } public void fillCircle ( int x , int y , int radius ) { } <START_BUG> public void fillTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int radius ) { <END_BUG> context . beginPath ( ) ; context . moveTo ( x1 , y1 ) ; context . lineTo ( x2 , y2 ) ; context . lineTo ( x3 , y3 ) ; context . lineTo ( x1 , y1 ) ; context . fill ( ) ; context . closePath ( ) ; } public int getPixel ( int x , int y ) { } public void drawPixel ( int x , int y ) { } public void drawPixel ( int x , int y , int color ) { } }
public class Key < T > { private final Key . AnnotationStrategy annotationStrategy ; private final TypeLiteral < T > typeLiteral ; private final int hashCode ; @ SuppressWarnings ( "unchecked" ) protected Key ( Class < ? extends Annotation > annotationType ) { } @ SuppressWarnings ( "unchecked" ) protected Key ( Annotation annotation ) { } @ SuppressWarnings ( "unchecked" ) protected Key ( ) { } @ SuppressWarnings ( "unchecked" ) private Key ( Type type , Key . AnnotationStrategy annotationStrategy ) { } private Key ( TypeLiteral < T > typeLiteral , Key . AnnotationStrategy annotationStrategy ) { } private int computeHashCode ( ) { } public final TypeLiteral < T > getTypeLiteral ( ) { } public final Class < ? extends Annotation > getAnnotationType ( ) { } public final Annotation getAnnotation ( ) { } boolean hasAnnotationType ( ) { } String getAnnotationName ( ) { } Class < ? super T > getRawType ( ) { } Key < Provider < T > > providerKey ( ) { } @ Override public final boolean equals ( Object o ) { } @ Override public final int hashCode ( ) { } @ Override public final String toString ( ) { } static < T > Key < T > get ( Class < T > type , Key . AnnotationStrategy annotationStrategy ) { } public static < T > Key < T > get ( Class < T > type ) { } public static < T > Key < T > get ( Class < T > type , Class < ? extends Annotation > annotationType ) { } public static < T > Key < T > get ( Class < T > type , Annotation annotation ) { } public static Key < ? > get ( Type type ) { } public static Key < ? > get ( Type type , Class < ? extends Annotation > annotationType ) { } public static Key < ? > get ( Type type , Annotation annotation ) { } public static < T > Key < T > get ( TypeLiteral < T > typeLiteral ) { } public static < T > Key < T > get ( TypeLiteral < T > typeLiteral , Class < ? extends Annotation > annotationType ) { } public static < T > Key < T > get ( TypeLiteral < T > typeLiteral , Annotation annotation ) { } < T > Key < T > ofType ( Class < T > type ) { } Key < ? > ofType ( Type type ) { } < T > Key < T > ofType ( TypeLiteral < T > type ) { } boolean hasAttributes ( ) { } Key < T > withoutAttributes ( ) { } interface AnnotationStrategy { Annotation getAnnotation ( ) { } Class < ? extends Annotation > getAnnotationType ( ) { } boolean hasAttributes ( ) { } Key . AnnotationStrategy withoutAttributes ( ) { } } static boolean isMarker ( Class < ? extends Annotation > annotationType ) { } static Key . AnnotationStrategy strategyFor ( Annotation annotation ) { } static Key . AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { } private static void ensureRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { } private static void ensureIsBindingAnnotation ( Class < ? extends Annotation > annotationType ) { } static enum NullAnnotationStrategy implements Key . AnnotationStrategy { INSTANCE ; public boolean hasAttributes ( ) { } public Key . AnnotationStrategy withoutAttributes ( ) { } public Annotation getAnnotation ( ) { } public Class < ? extends Annotation > getAnnotationType ( ) { } @ Override public String toString ( ) { } } static class AnnotationInstanceStrategy implements Key . AnnotationStrategy { final Annotation annotation ; AnnotationInstanceStrategy ( Annotation annotation ) { } public boolean hasAttributes ( ) { } public Key . AnnotationStrategy withoutAttributes ( ) { } public Annotation getAnnotation ( ) { } public Class < ? extends Annotation > getAnnotationType ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } } static class AnnotationTypeStrategy implements Key . AnnotationStrategy { final Class < ? extends Annotation > annotationType ; final Annotation annotation ; AnnotationTypeStrategy ( Class < ? extends Annotation > annotationType , Annotation annotation ) { } public boolean hasAttributes ( ) { } public Key . AnnotationStrategy withoutAttributes ( ) { } public Annotation getAnnotation ( ) { } public Class < ? extends Annotation > getAnnotationType ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } } static boolean isBindingAnnotation ( Annotation annotation ) { } static boolean isBindingAnnotation ( Class < ? extends Annotation > annotationType ) { <START_BUG> return annotationType . isAnnotationPresent ( BindingAnnotation . class ) ; <END_BUG> } }
public class JglfwGraphics implements Graphics { static int glMajorVersion ; static int glMinorVersion ; long window ; boolean fullscreen ; long fullscreenMonitor ; String title ; boolean resizable ; BufferFormat bufferFormat ; boolean sync ; volatile boolean isContinuous = true ; volatile boolean requestRendering ; float deltaTime ; long frameStart ; long lastTime ; int frames ; int fps ; GLCommon gl ; JglfwGL10 gl10 ; JglfwGL11 gl11 ; JglfwGL20 gl20 ; public JglfwGraphics ( JglfwApplicationConfiguration config ) { } public boolean isGL11Available ( ) { } public boolean isGL20Available ( ) { } public GLCommon getGLCommon ( ) { } public GL10 getGL10 ( ) { } public GL11 getGL11 ( ) { } public GL20 getGL20 ( ) { } public int getWidth ( ) { } public int getHeight ( ) { } void updateTime ( ) { } public float getDeltaTime ( ) { } public float getRawDeltaTime ( ) { } public int getFramesPerSecond ( ) { } public GraphicsType getType ( ) { } public float getPpiX ( ) { } public float getPpiY ( ) { } public float getPpcX ( ) { } public float getPpcY ( ) { } public float getDensity ( ) { } public boolean supportsDisplayModeChange ( ) { } public DisplayMode [ ] getDisplayModes ( ) { } public DisplayMode getDesktopDisplayMode ( ) { } public boolean setDisplayMode ( DisplayMode displayMode ) { } public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { } private boolean createWindow ( int width , int height , boolean fullscreen ) { } public void setTitle ( String title ) { if ( title == null ) <START_BUG> glfwSetWindowTitle ( window , "" ) ; <END_BUG> glfwSetWindowTitle ( window , title ) ; this . title = title ; } public void setVSync ( boolean vsync ) { } public BufferFormat getBufferFormat ( ) { } public boolean supportsExtension ( String extension ) { } public void setContinuousRendering ( boolean isContinuous ) { } public boolean isContinuousRendering ( ) { } public void requestRendering ( ) { } public boolean isFullscreen ( ) { } public long getWindow ( ) { } boolean shouldRender ( ) { } static class JglfwDisplayMode extends DisplayMode { protected JglfwDisplayMode ( int width , int height , int refreshRate , int bitsPerPixel ) { } } }
public class ClusterChangedEvent { private final String source ; private final ClusterState previousState ; private final ClusterState state ; private final Delta nodesDelta ; public ClusterChangedEvent ( String source , ClusterState state , ClusterState previousState ) { } public String source ( ) { } public ClusterState state ( ) { } public ClusterState previousState ( ) { } public boolean routingTableChanged ( ) { } public boolean indexRoutingTableChanged ( String index ) { } public List < String > indicesCreated ( ) { } public List < String > indicesDeleted ( ) { } public boolean metaDataChanged ( ) { } public boolean indexMetaDataChanged ( IndexMetaData current ) { MetaData previousMetaData = previousState . metaData ( ) ; if ( previousMetaData == null ) { return true ; } IndexMetaData previousIndexMetaData = previousMetaData . index ( current . index ( ) ) ; if ( previousIndexMetaData == current ) { return false ; } <START_BUG> return false ; <END_BUG> } public boolean blocksChanged ( ) { } public boolean localNodeMaster ( ) { } public Delta nodesDelta ( ) { } public boolean nodesRemoved ( ) { } public boolean nodesAdded ( ) { } public boolean nodesChanged ( ) { } }
public class Node { public String id ; public Node parent ; public final Array < Node > children = new Array < Node > ( 2 ) ; public boolean isAnimated ; public final Vector3 translation = new Vector3 ( ) ; public final Quaternion rotation = new Quaternion ( 0 , 0 , 0 , 1 ) ; public final Vector3 scale = new Vector3 ( 1 , 1 , 1 ) ; public final Matrix4 localTransform = new Matrix4 ( ) ; public final Matrix4 globalTransform = new Matrix4 ( ) ; public Array < NodePart > parts = new Array < NodePart > ( 2 ) ; public Matrix4 calculateLocalTransform ( ) { if ( ! ( isAnimated ) ) <START_BUG> localTransform . set ( translation , rotation , scale ) ; <END_BUG> return localTransform ; } public Matrix4 calculateWorldTransform ( ) { } public void calculateTransforms ( boolean recursive ) { } public void calculateBoneTransforms ( boolean recursive ) { } public BoundingBox calculateBoundingBox ( final BoundingBox out ) { } public BoundingBox calculateBoundingBox ( final BoundingBox out , boolean transform ) { } public BoundingBox extendBoundingBox ( final BoundingBox out ) { } public BoundingBox extendBoundingBox ( final BoundingBox out , boolean transform ) { } public Node getChild ( final String id , boolean recursive , boolean ignoreCase ) { } public static Node getNode ( final Array < Node > nodes , final String id , boolean recursive , boolean ignoreCase ) { } }
public class ImmutableSettings implements Settings { private ImmutableMap < String , String > settings ; private transient ClassLoader classLoader ; private ImmutableSettings ( Map < String , String > settings , ClassLoader classLoader ) { } @ Override public ClassLoader getClassLoader ( ) { } @ Override public ImmutableMap < String , String > getAsMap ( ) { } @ Override public Settings getComponentSettings ( Class component ) { } @ Override public Settings getComponentSettings ( String prefix , Class component ) { } @ Override public Settings getByPrefix ( String prefix ) { } @ Override public String get ( String setting ) { } @ Override public String get ( String setting , String defaultValue ) { } @ Override public Float getAsFloat ( String setting , Float defaultValue ) { } @ Override public Double getAsDouble ( String setting , Double defaultValue ) { } @ Override public Integer getAsInt ( String setting , Integer defaultValue ) { } @ Override public Long getAsLong ( String setting , Long defaultValue ) { } @ Override public Boolean getAsBoolean ( String setting , Boolean defaultValue ) { } @ Override public TimeValue getAsTime ( String setting , TimeValue defaultValue ) { } @ Override public ByteSizeValue getAsBytesSize ( String setting , ByteSizeValue defaultValue ) throws SettingsException { } @ Override public SizeValue getAsSize ( String setting , SizeValue defaultValue ) throws SettingsException { } @ SuppressWarnings ( { "unchecked" } ) @ Override public < T > Class < ? extends T > getAsClass ( String setting , Class < ? extends T > defaultClazz ) throws NoClassSettingsException { } @ SuppressWarnings ( { "unchecked" } ) @ Override public < T > Class < ? extends T > getAsClass ( String setting , Class < ? extends T > defaultClazz , String prefixPackage , String suffixClassName ) throws NoClassSettingsException { } @ Override public String [ ] getAsArray ( String settingPrefix ) throws SettingsException { } @ Override public String [ ] getAsArray ( String settingPrefix , String [ ] defaultArray ) throws SettingsException { } @ Override public Map < String , Settings > getGroups ( String settingPrefix ) throws SettingsException { } @ Override public Version getAsVersion ( String setting , Version defaultVersion ) throws SettingsException { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } private static ClassLoader buildClassLoader ( ) { } public static Settings readSettingsFromStream ( StreamInput in ) throws IOException { } public static void writeSettingsToStream ( Settings settings , StreamOutput out ) throws IOException { } public static ImmutableSettings . Builder settingsBuilder ( ) { } public static class Builder implements Settings . Builder { public static final Settings EMPTY_SETTINGS = new ImmutableSettings . Builder ( ) . build ( ) ; private final Map < String , String > map = new LinkedHashMap < String , String > ( ) ; private ClassLoader classLoader ; private Builder ( ) { } public Map < String , String > internalMap ( ) { } public String remove ( String key ) { } public String get ( String key ) { } public ImmutableSettings . Builder put ( String key , String value ) { } public ImmutableSettings . Builder put ( String key , Class clazz ) { } public ImmutableSettings . Builder put ( String setting , boolean value ) { } public ImmutableSettings . Builder put ( String setting , int value ) { } public ImmutableSettings . Builder put ( String setting , Version version ) { } public ImmutableSettings . Builder put ( String setting , long value ) { } public ImmutableSettings . Builder put ( String setting , float value ) { } public ImmutableSettings . Builder put ( String setting , double value ) { } public ImmutableSettings . Builder put ( String setting , long value , TimeUnit timeUnit ) { } public ImmutableSettings . Builder put ( String setting , long value , ByteSizeUnit sizeUnit ) { } public ImmutableSettings . Builder putArray ( String setting , String ... values ) { } public ImmutableSettings . Builder put ( String settingPrefix , String groupName , String [ ] settings , String [ ] values ) throws SettingsException { } public ImmutableSettings . Builder put ( Settings settings ) { } public ImmutableSettings . Builder put ( Map < String , String > settings ) { } public ImmutableSettings . Builder put ( Properties properties ) { } public ImmutableSettings . Builder loadFromSource ( String source ) { SettingsLoader settingsLoader = SettingsLoaderFactory . loaderFromSource ( source ) ; try { Map < String , String > loadedSettings = settingsLoader . load ( source ) ; put ( loadedSettings ) ; } catch ( Exception e ) { <START_BUG> throw new SettingsException ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>load<seq2seq4repair_space>settings<seq2seq4repair_space>from<seq2seq4repair_space>[" + source ) + "]" ) ) ; <END_BUG> } return this ; } public ImmutableSettings . Builder loadFromUrl ( URL url ) throws SettingsException { } public ImmutableSettings . Builder loadFromStream ( String resourceName , InputStream is ) throws SettingsException { } public ImmutableSettings . Builder loadFromClasspath ( String resourceName ) throws SettingsException { } public ImmutableSettings . Builder classLoader ( ClassLoader classLoader ) { } public ImmutableSettings . Builder putProperties ( String prefix , Properties properties ) { } public ImmutableSettings . Builder replacePropertyPlaceholders ( ) { } public Settings build ( ) { } } }
public class MoveBy extends AnimationAction { private static final ActionResetingPool < MoveBy > pool = new ActionResetingPool < MoveBy > ( 4 , 100 ) { @ Override protected MoveBy newObject ( ) { } } ; protected float x ; protected float y ; protected float startX ; protected float startY ; protected float deltaX ; protected float deltaY ; public static MoveBy $ ( float x , float y , float duration ) { } @ Override public void setTarget ( Actor actor ) { } @ Override public void act ( float delta ) { } @ Override public void finish ( ) { } @ Override public Action copy ( ) { <START_BUG> return MoveBy . $ ( x , y , duration ) ; <END_BUG> } }
public class RestIndicesAliasesAction extends BaseRestHandler { @ Inject public RestIndicesAliasesAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest ( ) ; indicesAliasesRequest . listenerThreaded ( false ) ; XContentParser parser = null ; try { indicesAliasesRequest . timeout ( request . paramAsTime ( "timeout" , timeValueSeconds ( 10 ) ) ) ; parser = XContentFactory . xContent ( request . content ( ) ) . createParser ( request . content ( ) ) ; XContentParser . Token token = parser . nextToken ( ) ; if ( token == null ) { throw new ElasticSearchIllegalArgumentException ( "No<seq2seq4repair_space>action<seq2seq4repair_space>is<seq2seq4repair_space>specified" ) ; } while ( ( token = parser . nextToken ( ) ) != ( Token . END_OBJECT ) ) { if ( token == ( Token . START_ARRAY ) ) { while ( ( token = parser . nextToken ( ) ) != ( Token . END_ARRAY ) ) { if ( token == ( Token . FIELD_NAME ) ) { String action = parser . currentName ( ) ; AliasAction . Type type ; if ( "add" . equals ( action ) ) { type = Type . ADD ; } else if ( "remove" . equals ( action ) ) { type = Type . REMOVE ; } else { throw new ElasticSearchIllegalArgumentException ( ( ( "Alias<seq2seq4repair_space>action<seq2seq4repair_space>[" + action ) + "]<seq2seq4repair_space>not<seq2seq4repair_space>supported" ) ) ; } String index = null ; String alias = null ; Map < String , Object > filter = null ; String routing = null ; boolean routingSet = false ; String indexRouting = null ; boolean indexRoutingSet = false ; String searchRouting = null ; boolean searchRoutingSet = false ; String currentFieldName = null ; while ( ( token = parser . nextToken ( ) ) != ( Token . END_OBJECT ) ) { if ( token == ( Token . FIELD_NAME ) ) { currentFieldName = parser . currentName ( ) ; } else if ( token == ( Token . VALUE_STRING ) ) { if ( "index" . equals ( currentFieldName ) ) { index = parser . text ( ) ; } else if ( "alias" . equals ( currentFieldName ) ) { alias = parser . text ( ) ; } else if ( "routing" . equals ( currentFieldName ) ) { routing = parser . textOrNull ( ) ; routingSet = true ; } else if ( ( ( "indexRouting" . equals ( currentFieldName ) ) || ( "index-routing" . equals ( currentFieldName ) ) ) || ( "index_routing" . equals ( currentFieldName ) ) ) { indexRouting = parser . textOrNull ( ) ; indexRoutingSet = true ; } else if ( ( ( "searchRouting" . equals ( currentFieldName ) ) || ( "search-routing" . equals ( currentFieldName ) ) ) || ( "search_routing" . equals ( currentFieldName ) ) ) { searchRouting = parser . textOrNull ( ) ; searchRoutingSet = true ; } } else if ( token == ( Token . START_OBJECT ) ) { if ( "filter" . equals ( currentFieldName ) ) { filter = parser . mapOrdered ( ) ; } } } if ( index == null ) { throw new ElasticSearchIllegalArgumentException ( ( ( "Alias<seq2seq4repair_space>action<seq2seq4repair_space>[" + action ) + "]<seq2seq4repair_space>requires<seq2seq4repair_space>an<seq2seq4repair_space>[index]<seq2seq4repair_space>to<seq2seq4repair_space>be<seq2seq4repair_space>set" ) ) ; } if ( alias == null ) { throw new ElasticSearchIllegalArgumentException ( ( ( "Alias<seq2seq4repair_space>action<seq2seq4repair_space>[" + action ) + "]<seq2seq4repair_space>requires<seq2seq4repair_space>an<seq2seq4repair_space>[alias]<seq2seq4repair_space>to<seq2seq4repair_space>be<seq2seq4repair_space>set" ) ) ; } if ( type == ( Type . ADD ) ) { AliasAction aliasAction = newAddAliasAction ( index , alias ) . filter ( filter ) ; if ( routingSet ) { aliasAction . routing ( routing ) ; } if ( indexRoutingSet ) { aliasAction . indexRouting ( indexRouting ) ; } if ( searchRoutingSet ) { aliasAction . searchRouting ( searchRouting ) ; } indicesAliasesRequest . addAliasAction ( aliasAction ) ; } else if ( type == ( Type . REMOVE ) ) { indicesAliasesRequest . removeAlias ( index , alias ) ; } } } } } } catch ( Exception e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>response" , e1 ) ; } return ; } finally { parser . close ( ) ; } client . admin ( ) . indices ( ) . aliases ( indicesAliasesRequest , new org . elasticsearch . action . ActionListener < IndicesAliasesResponse > ( ) { @ Override public void onResponse ( IndicesAliasesResponse response ) { try { XContentBuilder builder = restContentBuilder ( request ) ; builder . startObject ( ) . field ( "ok" , true ) . field ( "acknowledged" , response . isAcknowledged ( ) ) . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class LZFCompressor implements Compressor { static final byte [ ] LUCENE_HEADER = new byte [ ] { 'L' , 'Z' , 'F' , 0 } ; public static final String TYPE = "lzf" ; private ChunkEncoder encoder ; private ChunkDecoder decoder ; public LZFCompressor ( ) { } @ Override public String type ( ) { } @ Override public void configure ( Settings settings ) { } @ Override public boolean isCompressed ( BytesReference bytes ) { } @ Override public boolean isCompressed ( byte [ ] data , int offset , int length ) { } @ Override public boolean isCompressed ( ChannelBuffer buffer ) { } @ Override public boolean isCompressed ( IndexInput in ) throws IOException { } @ Override public byte [ ] uncompress ( byte [ ] data , int offset , int length ) throws IOException { } @ Override public byte [ ] compress ( byte [ ] data , int offset , int length ) throws IOException { } @ Override public CompressedStreamInput streamInput ( StreamInput in ) throws IOException { } @ Override public CompressedStreamOutput streamOutput ( StreamOutput out ) throws IOException { <START_BUG> return new LZFCompressedStreamOutput ( out , encoder ) ; <END_BUG> } @ Override public CompressedIndexInput indexInput ( IndexInput in ) throws IOException { } }
public class Label extends Actor { public BitmapFontCache cache ; public Label ( String name , BitmapFont font , String text ) { } public void setText ( String text ) { <START_BUG> cache . setText ( text , 0 , 0 ) ; <END_BUG> TextBounds bounds = cache . getBounds ( ) ; width = bounds . width ; height = bounds . height ; } @ Override protected void draw ( SpriteBatch batch , float parentAlpha ) { } @ Override protected boolean touchDown ( float x , float y , int pointer ) { } @ Override protected boolean touchUp ( float x , float y , int pointer ) { } @ Override protected boolean touchDragged ( float x , float y , int pointer ) { } @ Override public Actor hit ( float x , float y ) { } }
public class IOSFiles implements Files { static final String appDir = System . getenv ( "HOME" ) ; static final String externalPath = ( IOSFiles . appDir ) + "/Documents" ; static final String localPath = ( IOSFiles . appDir ) + "/Library/local" ; static final String internalPath = NSBundle . getMainBundle ( ) . getBundlePath ( ) ; public IOSFiles ( ) { } @ Override public FileHandle getFileHandle ( String fileName , FileType type ) { } @ Override public FileHandle classpath ( String path ) { } @ Override public FileHandle internal ( String path ) { <START_BUG> return new IOSFileHandle ( new File ( IOSFiles . internalPath , path ) , FileType . Internal ) ; <END_BUG> } @ Override public FileHandle external ( String path ) { } @ Override public FileHandle absolute ( String path ) { } @ Override public FileHandle local ( String path ) { } @ Override public String getExternalStoragePath ( ) { } @ Override public boolean isExternalStorageAvailable ( ) { } @ Override public String getLocalStoragePath ( ) { } @ Override public boolean isLocalStorageAvailable ( ) { } }
public class SearchScanScrollingTests extends ElasticsearchIntegrationTest { @ Test public void testRandomized ( ) throws Exception { <START_BUG> testScroll ( atLeast ( 100 ) , between ( 1 , 300 ) , getRandom ( ) . nextBoolean ( ) , getRandom ( ) . nextBoolean ( ) ) ; <END_BUG> } private void testScroll ( long numberOfDocs , int size , boolean unbalanced , boolean trackScores ) throws Exception { } }
public class Vector3 implements Serializable { private static final long serialVersionUID = 3840054589595372522L ; public float x ; public float y ; public float z ; private static Vector3 tmp = new Vector3 ( ) ; private static Vector3 tmp2 = new Vector3 ( ) ; private static Vector3 tmp3 = new Vector3 ( ) ; public Vector3 ( ) { } public Vector3 ( float x , float y , float z ) { } public Vector3 ( Vector3 vector ) { } public Vector3 ( float [ ] values ) { } public Vector3 set ( float x , float y , float z ) { } public Vector3 set ( Vector3 vector ) { } public Vector3 set ( float [ ] values ) { } public Vector3 cpy ( ) { } public Vector3 tmp ( ) { } public Vector3 tmp2 ( ) { } Vector3 tmp3 ( ) { } public Vector3 add ( Vector3 vector ) { } public Vector3 add ( float x , float y , float z ) { } public Vector3 add ( float values ) { } public Vector3 sub ( Vector3 a_vec ) { } public Vector3 sub ( float x , float y , float z ) { } public Vector3 sub ( float value ) { } public Vector3 mul ( float value ) { } public Vector3 div ( float value ) { } public float len ( ) { } public float len2 ( ) { } public boolean idt ( Vector3 vector ) { } public float dst ( Vector3 vector ) { } public float dist2 ( Vector3 vector ) { } public Vector3 nor ( ) { } public float dot ( Vector3 vector ) { } public Vector3 crs ( Vector3 vector ) { } public Vector3 crs ( float x , float y , float z ) { <START_BUG> return this . set ( ( ( y * z ) - ( z * y ) ) , ( ( z * x ) - ( x * z ) ) , ( ( x * y ) - ( y * x ) ) ) ; <END_BUG> } public Vector3 mul ( Matrix4 matrix ) { } public Vector3 prj ( Matrix4 matrix ) { } public Vector3 rot ( Matrix4 matrix ) { } public boolean isUnit ( ) { } public boolean isZero ( ) { } public Vector3 lerp ( Vector3 target , float alpha ) { } public Vector3 slerp ( Vector3 target , float alpha ) { } public String toString ( ) { } public float dot ( float x , float y , float z ) { } public float dst2 ( Vector3 point ) { } public float dst2 ( float x , float y , float z ) { } public float dst ( float x , float y , float z ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } public Vector3 scale ( float scalarX , float scalarY , float scalarZ ) { } }
public class CompletionSuggestSearchTests extends AbstractSharedClusterTest { private static final String INDEX = "test" ; private static final String TYPE = "testType" ; private static final String FIELD = "testField" ; @ Test public void testSimple ( ) throws Exception { } @ Test public void testBasicPrefixSuggestion ( ) throws Exception { } @ Test public void testThatWeightsAreWorking ( ) throws Exception { } @ Test public void testThatInputCanBeAStringInsteadOfAnArray ( ) throws Exception { } @ Test public void testThatPayloadsAreArbitraryJsonObjects ( ) throws Exception { } @ Test public void testPayloadAsNumeric ( ) throws Exception { } @ Test public void testPayloadAsString ( ) throws Exception { } @ Test ( expected = MapperException . class ) public void testThatExceptionIsThrownWhenPayloadsAreDisabledButInIndexRequest ( ) throws Exception { } @ Test public void testDisabledPreserveSeperators ( ) throws Exception { } @ Test public void testEnabledPreserveSeperators ( ) throws Exception { } @ Test public void testThatMultipleInputsAreSupported ( ) throws Exception { } @ Test public void testThatShortSyntaxIsWorking ( ) throws Exception { } @ Test public void testThatDisablingPositionIncrementsWorkForStopwords ( ) throws Exception { } @ Test public void testThatSynonymsWork ( ) throws Exception { } @ Test public void testThatUpgradeToMultiFieldWorks ( ) throws Exception { } @ Test public void testThatFuzzySuggesterWorks ( ) throws Exception { } @ Test public void testThatFuzzySuggesterSupportsEditDistances ( ) throws Exception { } @ Test public void testThatFuzzySuggesterSupportsTranspositions ( ) throws Exception { } @ Test public void testThatFuzzySuggesterSupportsMinPrefixLength ( ) throws Exception { } @ Test public void testThatFuzzySuggesterSupportsNonPrefixLength ( ) throws Exception { } @ Test public void testThatStatsAreWorking ( ) throws Exception { } public void assertSuggestions ( String suggestion , String ... suggestions ) { } public void assertSuggestionsNotInOrder ( String suggestString , String ... suggestions ) { } private void assertSuggestions ( SuggestResponse suggestResponse , String name , String ... suggestions ) { } private void assertSuggestions ( SuggestResponse suggestResponse , boolean suggestionOrderStrict , String name , String ... suggestions ) { } private List < String > getNames ( Suggest . Suggestion . Entry < Suggest . Suggestion . Entry . Option > suggestEntry ) { } private void createIndexAndMapping ( ) throws IOException { } private void createIndexAndMappingAndSettings ( Settings . Builder settingsBuilder , String indexAnalyzer , String searchAnalyzer , boolean payloads , boolean preserveSeparators , boolean preservePositionIncrements ) throws IOException { } private void createIndexAndMapping ( String indexAnalyzer , String searchAnalyzer , boolean payloads , boolean preserveSeparators , boolean preservePositionIncrements ) throws IOException { } private Builder createDefaultSettings ( ) { int randomShardNumber = between ( 1 , 5 ) ; <START_BUG> int randomReplicaNumber = between ( 0 , ( ( numberOfNodes ( ) ) - 1 ) ) ; <END_BUG> return settingsBuilder ( ) . put ( SETTING_NUMBER_OF_SHARDS , randomShardNumber ) . put ( SETTING_NUMBER_OF_REPLICAS , randomReplicaNumber ) ; } private void createData ( boolean optimize ) throws IOException , InterruptedException , ExecutionException { } @ Test public void testPrunedSegments ( ) throws IOException { } @ Test public void testMaxFieldLength ( ) throws IOException { } @ Test public void testVeryLongInput ( ) throws IOException { } @ Test ( expected = MapperParsingException . class ) public void testReservedChars ( ) throws IOException { } private static String replaceReservedChars ( String input , char replacement ) { } }
public class VertexBufferObject implements VertexData { static final IntBuffer tmpHandle = BufferUtils . newIntBuffer ( 1 ) ; final VertexAttributes attributes ; final FloatBuffer buffer ; final ByteBuffer byteBuffer ; int bufferHandle ; final boolean isDirect ; final boolean isStatic ; final int usage ; boolean isDirty = false ; boolean isBound = false ; public VertexBufferObject ( boolean isStatic , int numVertices , VertexAttribute ... attributes ) { } private int createBufferObject ( ) { } @ Override public VertexAttributes getAttributes ( ) { } @ Override public int getNumVertices ( ) { } public int getNumMaxVertices ( ) { <START_BUG> return ( byteBuffer . capacity ( ) ) / ( attributes . vertexSize ) ; <END_BUG> } @ Override public FloatBuffer getBuffer ( ) { } @ Override public void setVertices ( float [ ] vertices , int offset , int count ) { } @ Override public void bind ( ) { } public void bind ( ShaderProgram shader ) { } @ Override public void unbind ( ) { } public void unbind ( ShaderProgram shader ) { } public void invalidate ( ) { } @ Override public void dispose ( ) { } }
public class NestedBuilder extends AggregationBuilder < NestedBuilder > { private String path ; public NestedBuilder ( String name ) { } public NestedBuilder path ( String path ) { } @ Override protected XContentBuilder internalXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; if ( ( path ) == null ) { <START_BUG> throw new org . elasticsearch . search . builder . SearchSourceBuilderException ( ( ( "nested<seq2seq4repair_space>path<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>set<seq2seq4repair_space>on<seq2seq4repair_space>nested<seq2seq4repair_space>aggregation<seq2seq4repair_space>[" + ( name ) ) + "]" ) ) ; <END_BUG> } builder . field ( "path" , path ) ; return builder . endObject ( ) ; } }
public class RobinEngine extends AbstractIndexShardComponent implements Engine { private volatile ByteSizeValue indexingBufferSize ; private volatile int termIndexInterval ; private volatile int termIndexDivisor ; private volatile int indexConcurrency ; private volatile boolean compoundOnFlush = true ; private long gcDeletesInMillis ; private volatile boolean enableGcDeletes = true ; private volatile String codecName ; private final ThreadPool threadPool ; private final ShardIndexingService indexingService ; private final IndexSettingsService indexSettingsService ; @ Nullable private final InternalIndicesWarmer warmer ; private final Store store ; private final SnapshotDeletionPolicy deletionPolicy ; private final Translog translog ; private final MergePolicyProvider mergePolicyProvider ; private final MergeSchedulerProvider mergeScheduler ; private final AnalysisService analysisService ; private final SimilarityService similarityService ; private final CodecService codecService ; private final ReadWriteLock rwl = new ReentrantReadWriteLock ( ) ; private volatile IndexWriter indexWriter ; private final SearcherFactory searcherFactory = new RobinEngine . RobinSearchFactory ( ) ; private volatile SearcherManager searcherManager ; private volatile boolean closed = false ; private volatile boolean dirty = false ; private volatile boolean possibleMergeNeeded = false ; private final AtomicBoolean optimizeMutex = new AtomicBoolean ( ) ; private volatile boolean flushNeeded = false ; private final AtomicInteger flushing = new AtomicInteger ( ) ; private final Lock flushLock = new ReentrantLock ( ) ; private final RobinEngine . RecoveryCounter onGoingRecoveries = new RobinEngine . RecoveryCounter ( ) ; private final ConcurrentMap < HashedBytesRef , RobinEngine . VersionValue > versionMap ; private final Object [ ] dirtyLocks ; private final Object refreshMutex = new Object ( ) ; private final RobinEngine . ApplySettings applySettings = new RobinEngine . ApplySettings ( ) ; private volatile boolean failOnMergeFailure ; private Throwable failedEngine = null ; private final Object failedEngineMutex = new Object ( ) ; private final CopyOnWriteArrayList < FailedEngineListener > failedEngineListeners = new CopyOnWriteArrayList < FailedEngineListener > ( ) ; private final AtomicLong translogIdGenerator = new AtomicLong ( ) ; private SegmentInfos lastCommittedSegmentInfos ; @ Inject public RobinEngine ( ShardId shardId , @ IndexSettings Settings indexSettings , ThreadPool threadPool , IndexSettingsService indexSettingsService , ShardIndexingService indexingService , @ Nullable IndicesWarmer warmer , Store store , SnapshotDeletionPolicy deletionPolicy , Translog translog , MergePolicyProvider mergePolicyProvider , MergeSchedulerProvider mergeScheduler , AnalysisService analysisService , SimilarityService similarityService , CodecService codecService ) throws EngineException { } @ Override public void updateIndexingBufferSize ( ByteSizeValue indexingBufferSize ) { } @ Override public void addFailedEngineListener ( FailedEngineListener listener ) { } @ Override public void start ( ) throws EngineException { } private void readLastCommittedSegmentsInfo ( ) throws IOException { } @ Override public TimeValue defaultRefreshInterval ( ) { } @ Override public void enableGcDeletes ( boolean enableGcDeletes ) { } public GetResult get ( Get get ) throws EngineException { } @ Override public void create ( Create create ) throws EngineException { } private void innerCreate ( Create create , IndexWriter writer ) throws IOException { } @ Override public void index ( Index index ) throws EngineException { } private void innerIndex ( Index index , IndexWriter writer ) throws IOException { } @ Override public void delete ( Delete delete ) throws EngineException { } private void innerDelete ( Delete delete , IndexWriter writer ) throws IOException { } @ Override public void delete ( DeleteByQuery delete ) throws EngineException { } @ Override public final Searcher acquireSearcher ( String source ) throws EngineException { SearcherManager manager = this . searcherManager ; if ( manager == null ) { throw new EngineClosedException ( shardId ) ; } try { IndexSearcher searcher = manager . acquire ( ) ; return newSearcher ( source , searcher , manager ) ; <START_BUG> } catch ( IOException ex ) { <END_BUG> logger . error ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>acquire<seq2seq4repair_space>searcher,<seq2seq4repair_space>source<seq2seq4repair_space>{}" , ex , source ) ; throw new EngineException ( shardId , ex . getMessage ( ) ) ; } } protected Searcher newSearcher ( String source , IndexSearcher searcher , SearcherManager manager ) { } @ Override public boolean refreshNeeded ( ) { } @ Override public boolean possibleMergeNeeded ( ) { } @ Override public void refresh ( Refresh refresh ) throws EngineException { } @ Override public void flush ( Flush flush ) throws EngineException { } private void ensureOpen ( ) { } private void refreshVersioningTable ( long time ) { } @ Override public void maybeMerge ( ) throws EngineException { } @ Override public void optimize ( Optimize optimize ) throws EngineException { } @ Override public < T > T snapshot ( SnapshotHandler < T > snapshotHandler ) throws EngineException { } @ Override public SnapshotIndexCommit snapshotIndex ( ) throws EngineException { } @ Override public void recover ( RecoveryHandler recoveryHandler ) throws EngineException { } @ Override public SegmentsStats segmentsStats ( ) { } @ Override public List < Segment > segments ( ) { } @ Override public void close ( ) throws ElasticSearchException { } class FailEngineOnMergeFailure implements MergeSchedulerProvider . FailureListener { @ Override public void onFailedMerge ( MergePolicy . MergeException e ) { } } private void failEngine ( Throwable failure ) { } private void innerClose ( ) { } private HashedBytesRef versionKey ( Term uid ) { } private Object dirtyLock ( BytesRef uid ) { } private Object dirtyLock ( Term uid ) { } private long loadCurrentVersionFromIndex ( Term uid ) throws IOException { } private static boolean isMergedSegment ( AtomicReader reader ) { } private IndexWriter createWriter ( ) throws IOException { } public static final String INDEX_TERM_INDEX_INTERVAL = "index.term_index_interval" ; public static final String INDEX_TERM_INDEX_DIVISOR = "index.term_index_divisor" ; public static final String INDEX_INDEX_CONCURRENCY = "index.index_concurrency" ; public static final String INDEX_COMPOUND_ON_FLUSH = "index.compound_on_flush" ; public static final String INDEX_GC_DELETES = "index.gc_deletes" ; public static final String INDEX_FAIL_ON_MERGE_FAILURE = "index.fail_on_merge_failure" ; class ApplySettings implements IndexSettingsService . Listener { @ Override public void onRefreshSettings ( Settings settings ) { } } private SearcherManager buildSearchManager ( IndexWriter indexWriter ) throws IOException { } static class RobinSearcher implements Searcher { private final String source ; private final IndexSearcher searcher ; private final SearcherManager manager ;
public class DepthTestAttribute extends Attribute { public static final String Alias = "depthStencil" ; public static final long Type = register ( DepthTestAttribute . Alias ) ; protected static long Mask = DepthTestAttribute . Type ; public static final boolean is ( final long mask ) { } public int depthFunc ; public float depthRangeNear ; public float depthRangeFar ; public boolean depthMask ; public DepthTestAttribute ( ) { } public DepthTestAttribute ( boolean depthMask ) { } public DepthTestAttribute ( final int depthFunc ) { } public DepthTestAttribute ( int depthFunc , boolean depthMask ) { } public DepthTestAttribute ( int depthFunc , float depthRangeNear , float depthRangeFar ) { } public DepthTestAttribute ( int depthFunc , float depthRangeNear , float depthRangeFar , boolean depthMask ) { } public DepthTestAttribute ( final long type , int depthFunc , float depthRangeNear , float depthRangeFar , boolean depthMask ) { } public DepthTestAttribute ( final DepthTestAttribute rhs ) { } @ Override public Attribute copy ( ) { } @ Override public int hashCode ( ) { <START_BUG> int result = super . hashCode ( ) ; <END_BUG> result = ( 971 * result ) + ( depthFunc ) ; result = ( 971 * result ) + ( NumberUtils . floatToRawIntBits ( depthRangeNear ) ) ; result = ( 971 * result ) + ( NumberUtils . floatToRawIntBits ( depthRangeFar ) ) ; result = ( 971 * result ) + ( depthMask ? 1 : 0 ) ; return result ; } }
public class RepositoryCodeFragment extends DialogFragment implements OnItemClickListener { private FullTree tree ; private ListView listView ; private ProgressBar progressView ; private TextView branchIconView ; private TextView branchView ; private TextView pathView ; private View pathHeaderView ; private View branchFooterView ; private HeaderFooterListAdapter < CodeTreeAdapter > adapter ; private boolean pathShowing ; private Folder folder ; @ InjectExtra ( Intents . EXTRA_REPOSITORY ) private Repository repository ; @ Inject private DataService service ; private RefDialog dialog ; @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override public void onCreateOptionsMenu ( Menu optionsMenu , MenuInflater inflater ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } private void showLoading ( final boolean loading ) { } private void refreshTree ( final Reference reference ) { } private void switchBranches ( ) { } @ Override public void onDialogResult ( int requestCode , int resultCode , Bundle arguments ) { } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { } public boolean onBackPressed ( ) { } private void setFolder ( final FullTree tree , final Folder folder ) { } @ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { Entry entry = ( ( Entry ) ( parent . getItemAtPosition ( position ) ) ) ; if ( entry instanceof Folder ) setFolder ( tree , ( ( Folder ) ( entry ) ) ) ; else <START_BUG> startActivity ( BranchFileViewActivity . createIntent ( repository , tree . branch , entry . name , entry . entry . getSha ( ) ) ) ; <END_BUG> } }
public class QueryParseContext { private static ThreadLocal < String [ ] > typesContext = new ThreadLocal < > ( ) ; public static void setTypes ( String [ ] types ) { } public static String [ ] getTypes ( ) { } public static String [ ] setTypesWithPrevious ( String [ ] types ) { } public static void removeTypes ( ) { } private final Index index ; private boolean propagateNoCache = false ; private boolean requireCustomQueryWrappingFilter = false ; final IndexQueryParserService indexQueryParser ; private final Map < String , Filter > namedFilters = Maps . newHashMap ( ) ; private final MapperQueryParser queryParser = new MapperQueryParser ( this ) ; private XContentParser parser ; private EnumSet < ParseField . Flag > parseFlags = ParseField . EMPTY_FLAGS ; private final boolean disableFilterCaching ; private boolean allowUnmappedFields ; public QueryParseContext ( Index index , IndexQueryParserService indexQueryParser ) { } public QueryParseContext ( Index index , IndexQueryParserService indexQueryParser , boolean disableFilterCaching ) { } public void parseFlags ( EnumSet < ParseField . Flag > parseFlags ) { } public EnumSet < ParseField . Flag > parseFlags ( ) { } public void reset ( XContentParser jp ) { } public Index index ( ) { } public void parser ( XContentParser parser ) { } public XContentParser parser ( ) { } public AnalysisService analysisService ( ) { } public ScriptService scriptService ( ) { } public MapperService mapperService ( ) { } public IndexEngine indexEngine ( ) { } @ Nullable public SimilarityService similarityService ( ) { } public Similarity searchSimilarity ( ) { } public QueryParserCache queryParserCache ( ) { } public String defaultField ( ) { } public boolean queryStringLenient ( ) { } public MapperQueryParser queryParser ( QueryParserSettings settings ) { } public FixedBitSetFilter fixedBitSetFilter ( Filter filter ) { } public Filter cacheFilter ( Filter filter , @ Nullable CacheKeyFilter . Key cacheKey ) { } public < IFD extends IndexFieldData < ? > > IFD getForField ( FieldMapper < ? > mapper ) { } public void addNamedFilter ( String name , Filter filter ) { } public void addNamedQuery ( String name , Query query ) { } public ImmutableMap < String , Filter > copyNamedFilters ( ) { } @ Nullable public Query parseInnerQuery ( ) throws IOException , QueryParsingException { } @ Nullable public Filter parseInnerFilter ( ) throws IOException , QueryParsingException { } public Filter parseInnerFilter ( String filterName ) throws IOException , QueryParsingException { } private Filter executeFilterParser ( FilterParser filterParser ) throws IOException { } public FieldMapper fieldMapper ( String name ) { } public String indexName ( String name ) { } <START_BUG> public Set < String > simpleMatchToIndexNames ( String pattern ) { <END_BUG> return indexQueryParser . mapperService . simpleMatchToIndexNames ( pattern , QueryParseContext . getTypes ( ) ) ; } public SmartNameFieldMappers smartFieldMappers ( String name ) { } public FieldMapper smartNameFieldMapper ( String name ) { } public SmartNameObjectMapper smartObjectMapper ( String name ) { } public void setAllowUnmappedFields ( boolean allowUnmappedFields ) { } private < T > T failIfFieldMappingNotFound ( String name , T fieldMapping ) { } public Collection < String > queryTypes ( ) { } private SearchLookup lookup = null ; public SearchLookup lookup ( ) { } public long nowInMillis ( ) { } public boolean requireCustomQueryWrappingFilter ( ) { } }
public class ResourceLoadingIndicator { private final Context context ; private final View view ; private final TextView textView ; private final ProgressBar progressBar ; private final int loadingResId ; public ResourceLoadingIndicator ( final Context context , final int loadingResId ) { } public ResourceLoadingIndicator setList ( final ListView listView ) { <START_BUG> listView . addFooterView ( view ) ; <END_BUG> return this ; } public ResourceLoadingIndicator setVisible ( boolean visible ) { } public ResourceLoadingIndicator showLoading ( ) { } }
public class LibgdxToolkit extends Toolkit < Actor , Table , TableLayout > { public static LibgdxToolkit instance = new LibgdxToolkit ( ) ; public static BitmapFont defaultFont ; private static HashMap < String , BitmapFont > fonts = new HashMap ( ) ; public Actor wrap ( Object object ) { } public Actor newWidget ( TableLayout layout , String className ) { } public TableLayout getLayout ( Table table ) { } public Actor newStack ( ) { } public void addChild ( Actor parent , Actor child , String layoutString ) { } public void removeChild ( Actor parent , Actor child ) { } public int getMinWidth ( Actor actor ) { } public int getMinHeight ( Actor actor ) { } public int getPrefWidth ( Actor actor ) { } public int getPrefHeight ( Actor actor ) { } public int getMaxWidth ( Actor actor ) { } public int getMaxHeight ( Actor actor ) { } public void clearDebugRectangles ( TableLayout layout ) { } public void addDebugRectangle ( TableLayout layout , int type , int x , int y , int w , int h ) { if ( ( layout . debugRects ) == null ) layout . debugRects = new Array ( ) ; <START_BUG> layout . debugRects . add ( new LibgdxToolkit . DebugRect ( type , x , y , w , h ) ) ; <END_BUG> } public static void registerFont ( String name , BitmapFont font ) { } public static BitmapFont getFont ( String name ) { } static class DebugRect extends Rectangle { final int type ; public DebugRect ( int type , int x , int y , int width , int height ) { } } }
public class TransportSinglePingAction extends TransportShardSingleOperationAction < SinglePingRequest , SinglePingResponse > { @ Inject public TransportSinglePingAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected ShardIterator shards ( ClusterState clusterState , SinglePingRequest request ) throws ElasticSearchException { <START_BUG> return clusterService . operationRouting ( ) . indexShards ( clusterService . state ( ) , request . index ( ) , request . type , request . id , null ) ; <END_BUG> } @ Override protected SinglePingResponse shardOperation ( SinglePingRequest request , int shardId ) throws ElasticSearchException { } @ Override protected SinglePingRequest newRequest ( ) { } @ Override protected SinglePingResponse newResponse ( ) { } }
public void glBlendFunc ( int sfactor , int dfactor ) { } public void glBlendFuncSeparate ( int srcRGB , int dstRGB , int srcAlpha , int dstAlpha ) { } public void glBufferData ( int target , int size , Buffer data , int usage ) { } public void glBufferSubData ( int target , int offset , int size , Buffer data ) { } public int glCheckFramebufferStatus ( int target ) { } public void glClear ( int mask ) { } public void glClearColor ( float red , float green , float blue , float alpha ) { } public void glClearDepthf ( float depth ) { } public void glClearStencil ( int s ) { } public void glColorMask ( boolean red , boolean green , boolean blue , boolean alpha ) { } public void glCompileShader ( int shader ) { } public void glCompressedTexImage2D ( int target , int level , int internalformat , int width , int height , int border , int imageSize , Buffer data ) { } public void glCompressedTexSubImage2D ( int target , int level , int xoffset , int yoffset , int width , int height , int format , int imageSize , Buffer data ) { } public void glCopyTexImage2D ( int target , int level , int internalformat , int x , int y , int width , int height , int border ) { } public void glCopyTexSubImage2D ( int target , int level , int xoffset , int yoffset , int x , int y , int width , int height ) { } public int glCreateProgram ( ) { } public int glCreateShader ( int type ) { } public void glCullFace ( int mode ) { } public void glDeleteBuffers ( int n , IntBuffer buffers ) { } public void glDeleteFramebuffers ( int n , IntBuffer framebuffers ) { } public void glDeleteProgram ( int program ) { } public void glDeleteRenderbuffers ( int n , IntBuffer renderbuffers ) { } public void glDeleteShader ( int shader ) { } public void glDeleteTextures ( int n , IntBuffer textures ) { } public void glDepthFunc ( int func ) { } public void glDepthMask ( boolean flag ) { } public void glDepthRangef ( float zNear , float zFar ) { } public void glDetachShader ( int program , int shader ) { } public void glDisable ( int cap ) { } public void glDisableVertexAttribArray ( int index ) { } public void glDrawArrays ( int mode , int first , int count ) { } public void glDrawElements ( int mode , int count , int type , Buffer indices ) { } public void glEnable ( int cap ) { } public void glEnableVertexAttribArray ( int index ) { } public void glFinish ( ) { } public void glFlush ( ) { } public void glFramebufferRenderbuffer ( int target , int attachment , int renderbuffertarget , int renderbuffer ) { } public void glFramebufferTexture2D ( int target , int attachment , int textarget , int texture , int level ) { } public void glFrontFace ( int mode ) { } public void glGenBuffers ( int n , IntBuffer buffers ) { } public void glGenFramebuffers ( int n , IntBuffer framebuffers ) { } public void glGenRenderbuffers ( int n , IntBuffer renderbuffers ) { } public void glGenTextures ( int n , IntBuffer textures ) { } public void glGenerateMipmap ( int target ) { } public String glGetActiveAttrib ( int program , int index , IntBuffer size , Buffer type ) { } public String glGetActiveUniform ( int program , int index , IntBuffer size , Buffer type ) { IntBuffer typeTmp = BufferUtils . createIntBuffer ( 2 ) ; String name = org . lwjgl . opengl . GL20 . glGetActiveUniform ( program , index , 256 , typeTmp ) ; size . put ( typeTmp . get ( 0 ) ) ; if ( type instanceof IntBuffer ) <START_BUG> ( ( IntBuffer ) ( type ) ) . put ( typeTmp . get ( 0 ) ) ; <END_BUG> return name ; } public void glGetAttachedShaders ( int program , int maxcount , Buffer count , IntBuffer shaders ) { } public int glGetAttribLocation ( int program , String name ) { } public void glGetBooleanv ( int pname , Buffer params ) { } public void glGetBufferParameteriv ( int target , int pname , IntBuffer params ) { } public int glGetError ( ) { } public void glGetFloatv ( int pname , FloatBuffer params ) { } public void glGetFramebufferAttachmentParameteriv ( int target , int attachment , int pname , IntBuffer params ) { } public void glGetIntegerv ( int pname , IntBuffer params ) { } public String glGetProgramInfoLog ( int program ) { } public void glGetProgramiv ( int program , int pname , IntBuffer params ) { } public void glGetRenderbufferParameteriv ( int target , int pname , IntBuffer params ) { } public String glGetShaderInfoLog ( int shader ) { } public void glGetShaderPrecisionFormat ( int shadertype , int precisiontype , IntBuffer range , IntBuffer precision ) { } public void glGetShaderiv ( int shader , int pname , IntBuffer params ) { } public String glGetString ( int name ) { } public void glGetTexParameterfv ( int target , int pname , FloatBuffer params ) { } public void glGetTexParameteriv ( int target , int pname , IntBuffer params ) { } public int glGetUniformLocation ( int program , String name ) { } public void glGetUniformfv ( int program , int location , FloatBuffer params ) { } public void glGetUniformiv ( int program , int location , IntBuffer params ) { } public void glGetVertexAttribPointerv ( int index , int pname , Buffer pointer ) { } public void glGetVertexAttribfv ( int index , int pname , FloatBuffer params ) { }
public abstract class SearchContext implements Releasable { private static ThreadLocal < SearchContext > current = new ThreadLocal < > ( ) ; public static void setCurrent ( SearchContext value ) { } public static void removeCurrent ( ) { } public static SearchContext current ( ) { } <START_BUG> public abstract boolean clearAndRelease ( ) ; <END_BUG> public abstract void preProcess ( ) { } public abstract Filter searchFilter ( String [ ] types ) { } public abstract long id ( ) { } public abstract String source ( ) { } public abstract ShardSearchRequest request ( ) { } public abstract SearchType searchType ( ) { } public abstract SearchContext searchType ( SearchType searchType ) { } public abstract SearchShardTarget shardTarget ( ) { } public abstract int numberOfShards ( ) { } public abstract boolean hasTypes ( ) { } public abstract String [ ] types ( ) { } public abstract float queryBoost ( ) { } public abstract SearchContext queryBoost ( float queryBoost ) { } public abstract long nowInMillis ( ) { } public abstract Scroll scroll ( ) { } public abstract SearchContext scroll ( Scroll scroll ) { } public abstract SearchContextAggregations aggregations ( ) { } public abstract SearchContext aggregations ( SearchContextAggregations aggregations ) { } public abstract SearchContextFacets facets ( ) { } public abstract SearchContext facets ( SearchContextFacets facets ) { } public abstract SearchContextHighlight highlight ( ) { } public abstract void highlight ( SearchContextHighlight highlight ) { } public abstract SuggestionSearchContext suggest ( ) { } public abstract void suggest ( SuggestionSearchContext suggest ) { } public abstract List < RescoreSearchContext > rescore ( ) { } public abstract void addRescore ( RescoreSearchContext rescore ) { } public abstract boolean hasFieldDataFields ( ) { } public abstract FieldDataFieldsContext fieldDataFields ( ) { } public abstract boolean hasScriptFields ( ) { } public abstract ScriptFieldsContext scriptFields ( ) { } public abstract boolean hasPartialFields ( ) { } public abstract PartialFieldsContext partialFields ( ) { } public abstract boolean sourceRequested ( ) { } public abstract boolean hasFetchSourceContext ( ) { } public abstract FetchSourceContext fetchSourceContext ( ) { } public abstract SearchContext fetchSourceContext ( FetchSourceContext fetchSourceContext ) { } public abstract ContextIndexSearcher searcher ( ) { } public abstract IndexShard indexShard ( ) { } public abstract MapperService mapperService ( ) { } public abstract AnalysisService analysisService ( ) { } public abstract IndexQueryParserService queryParserService ( ) { } public abstract SimilarityService similarityService ( ) { } public abstract ScriptService scriptService ( ) { } public abstract CacheRecycler cacheRecycler ( ) { } public abstract PageCacheRecycler pageCacheRecycler ( ) { } public abstract BigArrays bigArrays ( ) { } public abstract FilterCache filterCache ( ) { } public abstract DocSetCache docSetCache ( ) { } public abstract IndexFieldDataService fieldData ( ) { } public abstract long timeoutInMillis ( ) { } public abstract void timeoutInMillis ( long timeoutInMillis ) { } public abstract SearchContext minimumScore ( float minimumScore ) { } public abstract Float minimumScore ( ) { } public abstract SearchContext sort ( Sort sort ) { } public abstract Sort sort ( ) { } public abstract SearchContext trackScores ( boolean trackScores ) { } public abstract boolean trackScores ( ) { } public abstract SearchContext parsedPostFilter ( ParsedFilter postFilter ) { } public abstract ParsedFilter parsedPostFilter ( ) { } public abstract Filter aliasFilter ( ) { } public abstract SearchContext parsedQuery ( ParsedQuery query ) { } public abstract ParsedQuery parsedQuery ( ) { } public abstract Query query ( ) { } public abstract boolean queryRewritten ( ) { } public abstract SearchContext updateRewriteQuery ( Query rewriteQuery ) { } public abstract int from ( ) { } public abstract SearchContext from ( int from ) { } public abstract int size ( ) { } public abstract SearchContext size ( int size ) { } public abstract boolean hasFieldNames ( ) { } public abstract List < String > fieldNames ( ) { } public abstract void emptyFieldNames ( ) { } public abstract boolean explain ( ) { } public abstract void explain ( boolean explain ) { } @ Nullable public abstract List < String > groupStats ( ) { } public abstract void groupStats ( List < String > groupStats ) { } public abstract boolean version ( ) { } public abstract void version ( boolean version ) { } public abstract int [ ] docIdsToLoad ( ) { } public abstract int docIdsToLoadFrom ( ) { } public abstract int docIdsToLoadSize ( ) { } public abstract SearchContext docIdsToLoad ( int [ ] docIdsToLoad , int docsIdsToLoadFrom , int docsIdsToLoadSize ) { } public abstract void accessed ( long accessTime ) { } public abstract long lastAccessTime ( ) { } public abstract long keepAlive ( ) { } public abstract void keepAlive ( long keepAlive ) { } public abstract void lastEmittedDoc ( ScoreDoc doc ) { } public abstract ScoreDoc lastEmittedDoc ( ) { } public abstract SearchLookup lookup ( ) { } public abstract DfsSearchResult dfsResult ( ) { } public abstract QuerySearchResult queryResult ( ) { } public abstract FetchSearchResult fetchResult ( ) { } public abstract void addReleasable ( Releasable releasable ) { } public abstract void clearReleasables ( ) { } public abstract ScanContext scanContext ( ) { } public abstract SmartNameFieldMappers smartFieldMappers ( String name ) { } public abstract FieldMappers smartNameFieldMappers ( String name ) { } public abstract FieldMapper smartNameFieldMapper ( String name ) { } public abstract SmartNameObjectMapper smartNameObjectMapper ( String name ) { } public abstract boolean useSlowScroll ( ) { } public abstract SearchContext useSlowScroll ( boolean useSlowScroll ) { } }
public class UidFieldVisitor extends BaseFieldVisitor { private String uid ; public UidFieldVisitor ( ) { } @ Override public void stringField ( FieldInfo fieldInfo , String value ) throws IOException { } @ Override public Status needsField ( FieldInfo fieldInfo ) throws IOException { } @ Override public Document createDocument ( ) { Document document = new Document ( ) ; <START_BUG> document . add ( new StoredField ( "_uid" , uid ) ) ; <END_BUG> return document ; } public String uid ( ) { } @ Override public String toString ( ) { } }
public abstract class Screen { private final String [ ] chars = new String [ ] { "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" , ".,!?:;\"\'+-=/\\<<seq2seq4repair_space>" } ; protected static Random random = new Random ( ) ; private Metagun metagun ; public SpriteBatch spriteBatch ; public void removed ( ) { } public final void init ( Metagun metagun ) { } protected void setScreen ( Screen screen ) { } public void draw ( TextureRegion region , int x , int y ) { int width = region . getRegionWidth ( ) ; if ( width < 0 ) width = - width ; <START_BUG> spriteBatch . draw ( region , x , y , width , ( - ( region . getRegionHeight ( ) ) ) ) ; <END_BUG> } public void drawString ( String string , int x , int y ) { } public abstract void render ( ) { } public void tick ( Input input ) { } }
public class NettyHttpRequest implements HttpRequest { private final HttpRequest request ; private QueryStringDecoder queryStringDecoder ; private static ThreadLocal < UnicodeUtil . UTF16Result > utf16Result = new ThreadLocal < UnicodeUtil . UTF16Result > ( ) { @ Override protected UTF16Result initialValue ( ) { } } ; public NettyHttpRequest ( org . jboss . netty . handler . codec . http . HttpRequest request ) { } @ Override public Method method ( ) { } @ Override public String uri ( ) { } @ Override public boolean hasContent ( ) { } @ Override public String contentAsString ( ) { } @ Override public Set < String > headerNames ( ) { } @ Override public String header ( String name ) { } @ Override public List < String > headers ( String name ) { } @ Override public String cookie ( ) { } @ Override public float paramAsFloat ( String key , float defaultValue ) { } @ Override public int paramAsInt ( String key , int defaultValue ) { } @ Override public boolean paramAsBoolean ( String key , boolean defaultValue ) { String sValue = param ( key ) ; if ( sValue == null ) { return defaultValue ; } <START_BUG> return ( sValue . equals ( "true" ) ) || ( sValue . equals ( "1" ) ) ; <END_BUG> } @ Override public TimeValue paramAsTime ( String key , TimeValue defaultValue ) { } @ Override public SizeValue paramAsSize ( String key , SizeValue defaultValue ) { } @ Override public String param ( String key ) { } @ Override public List < String > params ( String key ) { } @ Override public Map < String , List < String > > params ( ) { } public static void UTF8toUTF16 ( ChannelBuffer cb , final int offset , final int length , final UnicodeUtil . UTF16Result result ) { } private static final long UNI_MAX_BMP = 65535 ; private static final int HALF_BASE = 65536 ; private static final long HALF_SHIFT = 10 ; private static final long HALF_MASK = 1023L ; }
public final class ElasticsearchThreadFilter implements ThreadFilter { private final Pattern nodePrefix = Pattern . compile ( ( ( ( ( ( ( ( ( ( ( ( ( "\\[(" + "(" ) + ( Pattern . quote ( TRANSPORT_CLIENT_PREFIX ) ) ) + ")?(" ) + ( Pattern . quote ( GLOBAL_CLUSTER_NODE_PREFIX ) ) ) + "|" ) + ( Pattern . quote ( SUITE_CLUSTER_NODE_PREFIX ) ) ) + "|" ) + ( Pattern . quote ( TEST_CLUSTER_NODE_PREFIX ) ) ) + "|" ) + ( Pattern . quote ( SECOND_CLUSTER_NODE_PREFIX ) ) ) + ")" ) + ")\\d+\\]" ) ) ; @ Override public boolean reject ( Thread t ) { String threadName = t . getName ( ) ; if ( ( ( threadName . contains ( ( ( "[" + ( MulticastChannel . SHARED_CHANNEL_NAME ) ) + "]" ) ) ) || ( threadName . contains ( ( ( "[" + ( ElasticsearchSingleNodeTest . nodeName ( ) ) ) + "]" ) ) ) ) || ( threadName . contains ( "Keep-Alive-Timer" ) ) ) { return true ; } <START_BUG> return nodePrefix . matcher ( t . getName ( ) ) . find ( ) ; <END_BUG> } }
@ Test public class SimpleAttachmentIntegrationTests { private final Logger logger = Loggers . getLogger ( getClass ( ) ) ; private Node node ; @ BeforeClass public void setupServer ( ) { <START_BUG> node = nodeBuilder ( ) . settings ( settingsBuilder ( ) . put ( "node.local" , true ) ) . node ( ) ; <END_BUG> } @ AfterClass public void closeServer ( ) { } @ BeforeMethod public void createIndex ( ) { } @ AfterMethod public void deleteIndex ( ) { } @ Test public void testSimpleAttachment ( ) throws Exception { } }
public class SimpleNettyTransportTests extends AbstractSimpleTransportTests { @ Override protected TransportService build ( Settings settings , Version version ) { } @ Test public void testConnectException ( ) { try { serviceA . connectToNode ( new org . elasticsearch . cluster . node . DiscoveryNode ( "C" , new InetSocketTransportAddress ( "localhost" , 9876 ) , Version . CURRENT ) ) ; <START_BUG> assert false ; <END_BUG> } catch ( ConnectTransportException e ) { } } }
public class DynamicSettings { private ImmutableMap < String , Validator > dynamicSettings = ImmutableMap . of ( ) ; public boolean hasDynamicSetting ( String key ) { } public String validateDynamicSetting ( String dynamicSetting , String value ) { for ( Map . Entry < String , Validator > setting : dynamicSettings . entrySet ( ) ) { <START_BUG> if ( Regex . simpleMatch ( dynamicSetting , setting . getKey ( ) ) ) { <END_BUG> return setting . getValue ( ) . validate ( dynamicSetting , value ) ; } } return null ; } public synchronized void addDynamicSetting ( String setting , Validator validator ) { } public synchronized void addDynamicSetting ( String setting ) { } public synchronized void addDynamicSettings ( String ... settings ) { } }
public abstract class AbstractThreadPool extends AbstractComponent implements ThreadPool { protected volatile boolean started ; protected ExecutorService executorService ; protected ScheduledExecutorService scheduledExecutorService ; protected ExecutorService cached ; protected AbstractThreadPool ( Settings settings ) { } public abstract String getType ( ) { } @ Override public ThreadPoolInfo info ( ) { } @ Override public ThreadPoolStats stats ( ) { } @ Override public boolean isStarted ( ) { } @ Override public Executor cached ( ) { } @ Override public ScheduledFuture < ? > schedule ( Runnable command , long delay , TimeUnit unit ) { } @ Override public < V > ScheduledFuture < V > schedule ( Callable < V > callable , long delay , TimeUnit unit ) { } @ Override public ScheduledFuture < ? > scheduleAtFixedRate ( Runnable command , long initialDelay , long period , TimeUnit unit ) { } @ Override public ScheduledFuture < ? > scheduleWithFixedDelay ( Runnable command , long initialDelay , long delay , TimeUnit unit ) { } @ Override public ScheduledFuture < ? > scheduleWithFixedDelay ( Runnable command , TimeValue interval ) { } @ Override public void shutdown ( ) { } @ Override public void shutdownNow ( ) { started = false ; if ( ! ( executorService . isTerminated ( ) ) ) { executorService . shutdownNow ( ) ; } <START_BUG> if ( ! ( executorService . isTerminated ( ) ) ) { <END_BUG> scheduledExecutorService . shutdownNow ( ) ; } if ( ! ( cached . isTerminated ( ) ) ) { cached . shutdownNow ( ) ; } } @ Override public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { } @ Override public ScheduledFuture < ? > schedule ( Runnable command , TimeValue delay ) { } @ Override public void execute ( Runnable command ) { } protected static class FutureCallable < T > implements Callable < T > { private final Callable < T > callable ; private final FutureListener < T > listener ; public FutureCallable ( Callable < T > callable , FutureListener < T > listener ) { } @ Override public T call ( ) throws Exception { } } protected static class FutureRunnable < T > implements Runnable { private final Runnable runnable ; private final T result ; private final FutureListener < T > listener ; private FutureRunnable ( Runnable runnable , T result , FutureListener < T > listener ) { } @ Override public void run ( ) { } } }
public class Frustum { protected static final Vector3 [ ] clipSpacePlanePoints = new Vector3 [ ] { new Vector3 ( ( - 1 ) , ( - 1 ) , ( - 1 ) ) , new Vector3 ( 1 , ( - 1 ) , ( - 1 ) ) , new Vector3 ( 1 , 1 , ( - 1 ) ) , new Vector3 ( ( - 1 ) , 1 , ( - 1 ) ) , new Vector3 ( ( - 1 ) , ( - 1 ) , 1 ) , new Vector3 ( 1 , ( - 1 ) , 1 ) , new Vector3 ( 1 , 1 , 1 ) , new Vector3 ( ( - 1 ) , 1 , 1 ) } ; protected static final float [ ] clipSpacePlanePointsArray = new float [ 8 * 3 ] ; public final Plane [ ] planes = new Plane [ 6 ] ; public final Vector3 [ ] planePoints = new Vector3 [ ] { new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) } ; protected final float [ ] planePointsArray = new float [ 8 * 3 ] ; public Frustum ( ) { } public void update ( Matrix4 inverseProjectionView ) { } public boolean pointInFrustum ( Vector3 point ) { } public boolean sphereInFrustum ( Vector3 center , float radius ) { } public boolean sphereInFrustumWithoutNearFar ( Vector3 center , float radius ) { <START_BUG> for ( int i = 0 ; i < ( planes . length ) ; i ++ ) <END_BUG> if ( ( planes [ i ] . distance ( center ) ) < ( - radius ) ) return false ; return true ; } public boolean boundsInFrustum ( BoundingBox bounds ) { } }
public String getImagePath ( ) { } public void setImagePath ( String imagePath ) { } public void setFlip ( boolean flipX , boolean flipY ) { } public void save ( Writer output ) throws IOException { } public void load ( BufferedReader reader ) throws IOException { } static String readString ( BufferedReader reader , String name ) throws IOException { } static boolean readBoolean ( BufferedReader reader , String name ) throws IOException { } static int readInt ( BufferedReader reader , String name ) throws IOException { } static float readFloat ( BufferedReader reader , String name ) throws IOException { } static class Particle extends Sprite { int life ; int currentLife ; float scale ; float scaleDiff ; float rotation ; float rotationDiff ; float velocity ; float velocityDiff ; float angle ; float angleDiff ; float angleCos ; float angleSin ; float transparency ; float transparencyDiff ; float wind ; float windDiff ; float gravity ; float gravityDiff ; float [ ] tint ; public Particle ( Sprite sprite ) { } } public static class ParticleValue { boolean active ; boolean alwaysActive ; public void setAlwaysActive ( boolean alwaysActive ) { } public boolean isAlwaysActive ( ) { } public boolean isActive ( ) { } public void setActive ( boolean active ) { } public void save ( Writer output ) throws IOException { } public void load ( BufferedReader reader ) throws IOException { } public void load ( ParticleEmitter . ParticleValue value ) { } } public static class NumericValue extends ParticleEmitter . ParticleValue { private float value ; public float getValue ( ) { } public void setValue ( float value ) { } public void save ( Writer output ) throws IOException { } public void load ( BufferedReader reader ) throws IOException { } public void load ( ParticleEmitter . NumericValue value ) { } } public static class RangedNumericValue extends ParticleEmitter . ParticleValue { private float lowMin ; private float lowMax ; public float newLowValue ( ) { } public void setLow ( float value ) { } public void setLow ( float min , float max ) { } public float getLowMin ( ) { } public void setLowMin ( float lowMin ) { } public float getLowMax ( ) { } public void setLowMax ( float lowMax ) { } public void save ( Writer output ) throws IOException { } public void load ( BufferedReader reader ) throws IOException { } public void load ( ParticleEmitter . RangedNumericValue value ) { } } public static class ScaledNumericValue extends ParticleEmitter . RangedNumericValue { private float [ ] scaling = new float [ ] { 1 } ; float [ ] timeline = new float [ ] { 0 } ; private float highMin ; private float highMax ; private boolean relative ; public float newHighValue ( ) { } public void setHigh ( float value ) { } public void setHigh ( float min , float max ) { } public float getHighMin ( ) { } public void setHighMin ( float highMin ) { } public float getHighMax ( ) { } public void setHighMax ( float highMax ) { } public float [ ] getScaling ( ) { } public void setScaling ( float [ ] values ) { } public float [ ] getTimeline ( ) { } public void setTimeline ( float [ ] timeline ) { } public boolean isRelative ( ) { } public void setRelative ( boolean relative ) { } public float getScale ( float percent ) { } public void save ( Writer output ) throws IOException { } public void load ( BufferedReader reader ) throws IOException { } public void load ( ParticleEmitter . ScaledNumericValue value ) { } } public static class GradientColorValue extends ParticleEmitter . ParticleValue { private static float [ ] temp = new float [ 4 ] ; private float [ ] colors = new float [ ] { 1 , 1 , 1 } ; float [ ] timeline = new float [ ] { 0 } ; public GradientColorValue ( ) { } public float [ ] getTimeline ( ) { } public void setTimeline ( float [ ] timeline ) { } public float [ ] getColors ( ) { } public void setColors ( float [ ] colors ) { } public float [ ] getColor ( float percent ) { } public void save ( Writer output ) throws IOException { } public void load ( BufferedReader reader ) throws IOException { } public void load ( ParticleEmitter . GradientColorValue value ) { super . load ( value ) ; <START_BUG> colors = new float [ 3 ] ; <END_BUG> System . arraycopy ( value . colors , 0 , colors , 0 , colors . length ) ; timeline = new float [ value . timeline . length ] ; System . arraycopy ( value . timeline , 0 , timeline , 0 , timeline . length ) ; } } public static class SpawnShapeValue extends ParticleEmitter . ParticleValue { ParticleEmitter . SpawnShape shape = ParticleEmitter . SpawnShape . point ; boolean edges ; ParticleEmitter . SpawnEllipseSide side = ParticleEmitter . SpawnEllipseSide . both ; public ParticleEmitter . SpawnShape getShape ( ) { } public void setShape ( ParticleEmitter . SpawnShape shape ) { } public boolean isEdges ( ) { } public void setEdges ( boolean edges ) { } public ParticleEmitter . SpawnEllipseSide getSide ( ) { } public void setSide ( ParticleEmitter . SpawnEllipseSide side ) { } public void save ( Writer output ) throws IOException { } public void load ( BufferedReader reader ) throws IOException { } public void load ( ParticleEmitter . SpawnShapeValue value ) { } } public static enum SpawnShape { point , line , square , ellipse ; } public static enum SpawnEllipseSide { both , top , bottom ; } }
public final class EngineSearcherTotalHitsMatcher extends TypeSafeMatcher < Engine . Searcher > { private final Query query ; private final int totalHits ; public EngineSearcherTotalHitsMatcher ( Query query , int totalHits ) { } @ Override public boolean matchesSafely ( Engine . Searcher searcher ) { try { <START_BUG> long count = Lucene . count ( searcher . searcher ( ) , query , ( - 1.0F ) ) ; <END_BUG> return count == ( totalHits ) ; } catch ( IOException e ) { return false ; } } @ Override public void describeTo ( Description description ) { } public static Matcher < Engine . Searcher > engineSearcherTotalHits ( Query query , int totalHits ) { } public static Matcher < Engine . Searcher > engineSearcherTotalHits ( int totalHits ) { } }
public class PublishIndexerClusterStateAction extends AbstractComponent { public static interface NewClusterStateListener { void onNewClusterState ( IndexerClusterState clusterState ) { } } private final TransportService transportService ; private final ClusterService clusterService ; private final PublishIndexerClusterStateAction . NewClusterStateListener listener ; public PublishIndexerClusterStateAction ( Settings settings , TransportService transportService , ClusterService clusterService , PublishIndexerClusterStateAction . NewClusterStateListener listener ) { } public void close ( ) { } public void publish ( IndexerClusterState clusterState ) { } private class PublishClusterStateRequest implements Streamable { private IndexerClusterState clusterState ; private PublishClusterStateRequest ( ) { } private PublishClusterStateRequest ( IndexerClusterState clusterState ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { <START_BUG> clusterState = Builder . readFrom ( in , settings ) ; <END_BUG> } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } private class PublishClusterStateRequestHandler extends BaseTransportRequestHandler < PublishIndexerClusterStateAction . PublishClusterStateRequest > { static final String ACTION = "indexer/state/publish" ; @ Override public PublishIndexerClusterStateAction . PublishClusterStateRequest newInstance ( ) { } @ Override public void messageReceived ( PublishIndexerClusterStateAction . PublishClusterStateRequest request , TransportChannel channel ) throws Exception { } @ Override public boolean spawn ( ) { } } }
public class HashedAggregator { private int missing ; private int total ; private final HashedAggregator . HashCount hash ; private final HashedAggregator . HashCount assertHash = getAssertHash ( ) ; public HashedAggregator ( ) { } public void onDoc ( int docId , BytesValues values ) { final int length = values . setDocument ( docId ) ; int pendingMissing = 1 ; total += length ; for ( int i = 0 ; i < length ; i ++ ) { final BytesRef value = values . nextValue ( ) ; <START_BUG> onValue ( docId , value , values . currentValueHash ( ) , values ) ; <END_BUG> pendingMissing = 0 ; } missing += pendingMissing ; } public void addValue ( BytesRef value , int hashCode , BytesValues values ) { } protected void onValue ( int docId , BytesRef value , int hashCode , BytesValues values ) { } public final int missing ( ) { } public final int total ( ) { } public final boolean isEmpty ( ) { } public HashedAggregator . BytesRefCountIterator getIter ( ) { } public void release ( ) { } public static interface BytesRefCountIterator { public BytesRef next ( ) { } BytesRef makeSafe ( ) { } public int count ( ) { } public boolean shared ( ) { } } public static InternalFacet buildFacet ( String facetName , int size , int shardSize , long missing , long total , TermsFacet . ComparatorType comparatorType , HashedAggregator aggregator ) { } private HashedAggregator . HashCount getAssertHash ( ) { } private static interface HashCount { public boolean add ( BytesRef value , int hashCode , BytesValues values ) { } public boolean addNoCount ( BytesRef value , int hashCode , BytesValues values ) { } public void release ( ) { } public int size ( ) { } public HashedAggregator . BytesRefCountIterator iter ( ) { } } private static final class BytesRefHashHashCount implements HashedAggregator . HashCount { private final BytesRefHash hash ; private int [ ] counts = new int [ 10 ] ; public BytesRefHashHashCount ( BytesRefHash hash ) { } @ Override public boolean add ( BytesRef value , int hashCode , BytesValues values ) { } public boolean addNoCount ( BytesRef value , int hashCode , BytesValues values ) { } @ Override public HashedAggregator . BytesRefCountIterator iter ( ) { } public final class BytesRefCountIteratorImpl implements HashedAggregator . BytesRefCountIterator { final BytesRef spare = new BytesRef ( ) ; private final int size ; private int current = 0 ; private int currentCount = - 1 ; BytesRefCountIteratorImpl ( ) { } public BytesRef next ( ) { } @ Override public BytesRef makeSafe ( ) { } public int count ( ) { } @ Override public boolean shared ( ) { } } @ Override public int size ( ) { } @ Override public void release ( ) { } } private static final class AssertingHashCount implements HashedAggregator . HashCount { private final ObjectIntOpenHashMap < HashedBytesRef > valuesAndCount = new ObjectIntOpenHashMap ( ) ; private HashedBytesRef spare = new HashedBytesRef ( ) ; @ Override public boolean add ( BytesRef value , int hashCode , BytesValues values ) { } @ Override public int size ( ) { } @ Override public HashedAggregator . BytesRefCountIterator iter ( ) { } @ Override public void release ( ) { } @ Override public boolean addNoCount ( BytesRef value , int hashCode , BytesValues values ) { } } }
public class Dialog extends Window { public static float fadeDuration = 0.4F ; Table contentTable ; Table buttonTable ; private Skin skin ; ObjectMap < Actor , Object > values = new ObjectMap ( ) ; boolean cancelHide ; Actor previousKeyboardFocus ; Actor previousScrollFocus ; public Dialog ( String title , Skin skin ) { } public Dialog ( String title , Skin skin , String windowStyleName ) { } public Dialog ( String title , WindowStyle windowStyle ) { } private void initialize ( ) { setModal ( true ) ; defaults ( ) . space ( 6 ) ; add ( ( contentTable = new Table ( skin ) ) ) . expand ( ) . fill ( ) ; row ( ) ; add ( ( buttonTable = new Table ( skin ) ) ) ; contentTable . defaults ( ) . space ( 6 ) ; buttonTable . defaults ( ) . space ( 6 ) ; buttonTable . addListener ( new ChangeListener ( ) { public void changed ( ChangeEvent event , Actor actor ) { while ( ( actor . getParent ( ) ) != ( buttonTable ) ) actor = actor . getParent ( ) ; result ( values . get ( actor ) ) ; if ( ! ( cancelHide ) ) hide ( ) ; cancelHide = false ; } } ) ; addListener ( new FocusListener ( ) { public void keyboardFocusChanged ( FocusEvent event , Actor actor , boolean focused ) { if ( ! focused ) focusChanged ( event ) ; } public void scrollFocusChanged ( FocusEvent event , Actor actor , boolean focused ) { if ( ! focused ) focusChanged ( event ) ; } private void focusChanged ( FocusEvent event ) { Stage stage = getStage ( ) ; <START_BUG> if ( ( isModal ) && ( ( stage . getRoot ( ) . getChildren ( ) . peek ( ) ) == ( Dialog . this ) ) ) { <END_BUG> Actor newFocusedActor = event . getRelatedActor ( ) ; if ( ( newFocusedActor == null ) || ( ! ( newFocusedActor . isDescendantOf ( Dialog . this ) ) ) ) event . cancel ( ) ; } } } ) ; } public Table getContentTable ( ) { } public Table getButtonTable ( ) { } public Dialog text ( String text ) { } public Dialog text ( String text , LabelStyle labelStyle ) { } public Dialog text ( Label label ) { } public Dialog button ( String text ) { } public Dialog button ( String text , Object object ) { } public Dialog button ( String text , Object object , TextButtonStyle buttonStyle ) { } public Dialog button ( Button button ) { } public Dialog button ( Button button , Object object ) { } public Dialog show ( Stage stage ) { } public void hide ( ) { } protected void setParent ( Group parent ) { } public void setObject ( Actor actor , Object object ) { } public Dialog key ( final int keycode , final Object object ) { } protected void result ( Object object ) { } public void cancel ( ) { } }
public abstract class HasChildFilter extends Filter implements ScopePhase . CollectorPhase { final Query childQuery ; final String scope ; final String parentType ; final String childType ; final SearchContext searchContext ; protected HasChildFilter ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext ) { } public Query query ( ) { } public String scope ( ) { } @ Override public String toString ( ) { } public static HasChildFilter create ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext , String executionType ) { } static class Bitset extends HasChildFilter { private Map < Object , FixedBitSet > parentDocs ; public Bitset ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext ) { } public boolean requiresProcessing ( ) { } public Collector collector ( ) { } public void processCollector ( Collector collector ) { } public void clear ( ) { } public DocIdSet getDocIdSet ( IndexReader reader ) throws IOException { if ( ( parentDocs ) == null ) { throw new ElasticSearchIllegalStateException ( "has_child<seq2seq4repair_space>filter/query<seq2seq4repair_space>hasn't<seq2seq4repair_space>executed<seq2seq4repair_space>properly" ) ; } return parentDocs . get ( reader . getCoreCacheKey ( ) ) ; } } static class Uid extends HasChildFilter { THashSet < HashedBytesArray > collectedUids ; Uid ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext ) { } public boolean requiresProcessing ( ) { } public Collector collector ( ) { } public void processCollector ( Collector collector ) { } public DocIdSet getDocIdSet ( IndexReader reader ) throws IOException { if ( ( collectedUids ) == null ) { throw new ElasticSearchIllegalStateException ( "has_child<seq2seq4repair_space>filter/query<seq2seq4repair_space>hasn't<seq2seq4repair_space>executed<seq2seq4repair_space>properly" ) ; } IdReaderTypeCache idReaderTypeCache = searchContext . idCache ( ) . reader ( reader ) . type ( parentType ) ; if ( idReaderTypeCache != null ) { return new HasChildFilter . Uid . ParentDocSet ( reader , collectedUids , idReaderTypeCache ) ; } else { <START_BUG> return DocIdSet . EMPTY_DOCIDSET ; <END_BUG> } } public void clear ( ) { } static class ParentDocSet extends GetDocSet { final IndexReader reader ; final THashSet < HashedBytesArray > parents ; final IdReaderTypeCache typeCache ; ParentDocSet ( IndexReader reader , THashSet < HashedBytesArray > parents , IdReaderTypeCache typeCache ) { } public boolean get ( int doc ) { } } static class UidCollector extends NoopCollector { final String parentType ; final SearchContext context ; final THashSet < HashedBytesArray > collectedUids ; private IdReaderTypeCache typeCache ; UidCollector ( String parentType , SearchContext context , THashSet < HashedBytesArray > collectedUids ) { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void setNextReader ( IndexReader reader , int docBase ) throws IOException { } } } }
public class HttpJsonBuilder { public static JsonBuilder cached ( HttpRequest request ) throws IOException { <START_BUG> JsonBuilder builder = JsonBuilder . cached ( ) ; <END_BUG> String prettyPrint = request . param ( "pretty" ) ; if ( ( prettyPrint != null ) && ( "true" . equals ( prettyPrint ) ) ) { builder . prettyPrint ( ) ; } return builder ; } }
public class SpriteBatch { private Mesh mesh ; private Mesh [ ] buffers ; private Texture lastTexture = null ; private float invTexWidth = 0 ; private float invTexHeight = 0 ; private int idx = 0 ; private int currBufferIdx = 0 ; private final float [ ] vertices ; private final Matrix4 transformMatrix = new Matrix4 ( ) ; private final Matrix4 projectionMatrix = new Matrix4 ( ) ; private final Matrix4 combinedMatrix = new Matrix4 ( ) ; private boolean drawing = false ; private boolean blendingDisabled = false ; private int blendSrcFunc = GL11 . GL_SRC_ALPHA ; private int blendDstFunc = GL11 . GL_ONE_MINUS_SRC_ALPHA ; private ShaderProgram shader ; float color = WHITE . toFloatBits ( ) ; private Color tempColor = new Color ( 1 , 1 , 1 , 1 ) ; public int renderCalls = 0 ; public int maxSpritesInBatch = 0 ; public SpriteBatch ( ) { } public SpriteBatch ( int size ) { } public SpriteBatch ( int size , int buffers ) { } private void createShader ( ) { } public void begin ( ) { } public void end ( ) { } public void setColor ( Color tint ) { } public void setColor ( float r , float g , float b , float a ) { } public void setColor ( float color ) { } public Color getColor ( ) { } public void draw ( Texture texture , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { } public void draw ( Texture texture , float x , float y , float width , float height , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { } public void draw ( Texture texture , float x , float y , int srcX , int srcY , int srcWidth , int srcHeight ) { } public void draw ( Texture texture , float x , float y , float width , float height , float u , float v , float u2 , float v2 ) { } public void draw ( Texture texture , float x , float y ) { } public void draw ( Texture texture , float [ ] spriteVertices , int offset , int length ) { } public void draw ( TextureRegion region , float x , float y ) { <START_BUG> draw ( region , x , y , region . getRegionWidth ( ) , region . getRegionHeight ( ) ) ; <END_BUG> } public void draw ( TextureRegion region , float x , float y , float width , float height ) { } public void draw ( TextureRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation ) { } public void flush ( ) { } private void renderMesh ( ) { } public void disableBlending ( ) { } public void enableBlending ( ) { } public void setBlendFunction ( int srcFunc , int dstFunc ) { } public void dispose ( ) { } public Matrix4 getProjectionMatrix ( ) { } public Matrix4 getTransformMatrix ( ) { } public void setProjectionMatrix ( Matrix4 projection ) { } public void setTransformMatrix ( Matrix4 transform ) { } public boolean isBlendingEnabled ( ) { } }
public class FiltersFunctionScoreQuery extends Query { public static class FilterFunction { public final Filter filter ; public final ScoreFunction function ; public FilterFunction ( Filter filter , ScoreFunction function ) { } @ Override public boolean equals ( Object o ) { if ( ( this ) == o ) return true ; if ( ( o == null ) || ( ( getClass ( ) ) != ( o . getClass ( ) ) ) ) return false ; FiltersFunctionScoreQuery . FilterFunction that = ( ( FiltersFunctionScoreQuery . FilterFunction ) ( o ) ) ; if ( ( filter ) != null ? ! ( filter . equals ( that . filter ) ) : ( that . filter ) != null ) return false ; if ( ( function ) != null ? ! ( function . equals ( that . function ) ) : ( that . function ) != null ) return false ; return true ; } @ Override public int hashCode ( ) { } } public static enum ScoreMode { First , Avg , Max , Sum , Min , Multiply ; } Query subQuery ; final FiltersFunctionScoreQuery . FilterFunction [ ] filterFunctions ; final FiltersFunctionScoreQuery . ScoreMode scoreMode ; final float maxBoost ; protected CombineFunction combineFunction ; public FiltersFunctionScoreQuery ( Query subQuery , FiltersFunctionScoreQuery . ScoreMode scoreMode , FiltersFunctionScoreQuery . FilterFunction [ ] filterFunctions , float maxBoost ) { } public FiltersFunctionScoreQuery setCombineFunction ( CombineFunction combineFunction ) { } public Query getSubQuery ( ) { } public FiltersFunctionScoreQuery . FilterFunction [ ] getFilterFunctions ( ) { } @ Override public Query rewrite ( IndexReader reader ) throws IOException { } @ Override public void extractTerms ( Set < Term > terms ) { } @ Override public Weight createWeight ( IndexSearcher searcher ) throws IOException { } class CustomBoostFactorWeight extends Weight { final Weight subQueryWeight ; final Bits [ ] docSets ; public CustomBoostFactorWeight ( Weight subQueryWeight , int filterFunctionLength ) throws IOException { } public Query getQuery ( ) { } @ Override public float getValueForNormalization ( ) throws IOException { } @ Override public void normalize ( float norm , float topLevelBoost ) { } @ Override public Scorer scorer ( AtomicReaderContext context , boolean scoreDocsInOrder , boolean topScorer , Bits acceptDocs ) throws IOException { } @ Override public Explanation explain ( AtomicReaderContext context , int doc ) throws IOException { } } static class CustomBoostFactorScorer extends Scorer { private final float subQueryBoost ; private final Scorer scorer ; private final FiltersFunctionScoreQuery . FilterFunction [ ] filterFunctions ; private final FiltersFunctionScoreQuery . ScoreMode scoreMode ; private final float maxBoost ; private final Bits [ ] docSets ; private final CombineFunction scoreCombiner ; private CustomBoostFactorScorer ( FiltersFunctionScoreQuery . CustomBoostFactorWeight w , Scorer scorer , FiltersFunctionScoreQuery . ScoreMode scoreMode , FiltersFunctionScoreQuery . FilterFunction [ ] filterFunctions , float maxBoost , Bits [ ] docSets , CombineFunction scoreCombiner ) throws IOException { } @ Override public int docID ( ) { } @ Override public int advance ( int target ) throws IOException { } @ Override public int nextDoc ( ) throws IOException { } @ Override public float score ( ) throws IOException { } @ Override public int freq ( ) throws IOException { } @ Override public long cost ( ) { } } public String toString ( String field ) { } public boolean equals ( Object o ) { <START_BUG> if ( ( getClass ( ) ) != ( o . getClass ( ) ) ) <END_BUG> return false ; FiltersFunctionScoreQuery other = ( ( FiltersFunctionScoreQuery ) ( o ) ) ; if ( ( this . getBoost ( ) ) != ( other . getBoost ( ) ) ) return false ; if ( ! ( this . subQuery . equals ( other . subQuery ) ) ) { return false ; } return Arrays . equals ( this . filterFunctions , other . filterFunctions ) ; } public int hashCode ( ) { } }
public class Sphere implements Serializable { private static final long serialVersionUID = - 6487336868908521596L ; public float radius ; public final Vector3 center ; public Sphere ( Vector3 center , float radius ) { } public boolean overlaps ( Sphere sphere ) { <START_BUG> return ( center . dst2 ( sphere . center ) ) < ( ( ( radius ) * ( radius ) ) + ( ( sphere . radius ) * ( radius ) ) ) ; <END_BUG> } }
public class MD5Mesh { public String shader ; public int numVertices ; public int numWeights ; public int numTriangles ; public float [ ] vertices ; public float [ ] weights ; public short [ ] indices ; public int floatsPerVertex ; public int floatsPerWeight ; public float [ ] createVertexArray ( ) { } public float [ ] createVertexArray ( int stride ) { } public short [ ] getIndices ( ) { } public void calculateVerticesN ( MD5Joints skeleton , float [ ] verts , BoundingBox bbox ) { } public void calculateVertices ( MD5Joints skeleton , float [ ] verts , BoundingBox bbox ) { } static Vector3 bn = new Vector3 ( ) ; public static void calculateVerticesN ( MD5Joints skeleton , float [ ] weights , float [ ] vertices , float [ ] verts , int vstride , int wstride , BoundingBox bbox ) { } public static void calculateVertices ( MD5Joints skeleton , float [ ] weights , float [ ] vertices , float [ ] verts , int vstride , int wstride , BoundingBox bbox ) { } public void calculateVerticesJni ( MD5Joints skeleton , float [ ] verts ) { <START_BUG> MD5Jni . calculateVertices ( skeleton . joints , weights , vertices , verts , numVertices ) ; <END_BUG> } public void calculateNormalsBind ( MD5Joints bindPoseSkeleton , float [ ] verts ) { } static Vector3 _A = new Vector3 ( ) ; static Vector3 _B = new Vector3 ( ) ; static Vector3 _n = new Vector3 ( ) ; private static Vector3 calcNor ( Vector3 v1 , Vector3 v2 , Vector3 v3 ) { } static MD5Quaternion quat = new MD5Quaternion ( ) ; static Vector3 vn = new Vector3 ( ) ; public static void calculateNormalsBind ( MD5Joints skeleton , float [ ] weights , float [ ] vertices , short [ ] indices , float [ ] verts , int vstride , int wstride ) { } public void read ( DataInputStream in ) throws IOException { } public void write ( DataOutputStream out ) throws IOException { } }
public final class LwjglInput implements Input { public static float keyRepeatInitialTime = 0.4F ; public static float keyRepeatTime = 0.1F ; List < LwjglInput . KeyEvent > keyEvents = new ArrayList < LwjglInput . KeyEvent > ( ) ; List < LwjglInput . TouchEvent > touchEvents = new ArrayList < LwjglInput . TouchEvent > ( ) ; boolean mousePressed = false ; int mouseX ; int mouseY ; int deltaX ; int deltaY ; int pressedKeys = 0 ; boolean justTouched = false ; Set < Integer > pressedButtons = new HashSet < Integer > ( ) ; InputProcessor processor ; char lastKeyCharPressed ; float keyRepeatTimer ; long currentEventTimeStamp ; Pool < LwjglInput . KeyEvent > usedKeyEvents = new Pool < LwjglInput . KeyEvent > ( 16 , 1000 ) { protected LwjglInput . KeyEvent newObject ( ) { } } ; Pool < LwjglInput . TouchEvent > usedTouchEvents = new Pool < LwjglInput . TouchEvent > ( 16 , 1000 ) { protected LwjglInput . TouchEvent newObject ( ) { } } ; public LwjglInput ( ) { } public float getAccelerometerX ( ) { } public float getAccelerometerY ( ) { } public float getAccelerometerZ ( ) { } public void getTextInput ( final TextInputListener listener , final String title , final String text ) { } public void getPlaceholderTextInput ( final TextInputListener listener , final String title , final String placeholder ) { } public int getX ( ) { } public int getY ( ) { } public boolean isAccelerometerAvailable ( ) { } public boolean isKeyPressed ( int key ) { } public boolean isTouched ( ) { } public int getX ( int pointer ) { } public int getY ( int pointer ) { } public boolean isTouched ( int pointer ) { } public boolean supportsMultitouch ( ) { } @ Override public void setOnscreenKeyboardVisible ( boolean visible ) { } @ Override public void setCatchBackKey ( boolean catchBack ) { } void processEvents ( ) { } public static int getGdxKeyCode ( int lwjglKeyCode ) { } public static int getLwjglKeyCode ( int gdxKeyCode ) { } public void update ( ) { } private int toGdxButton ( int button ) { } void updateMouse ( ) { } void updateKeyboard ( ) { } @ Override public void setInputProcessor ( InputProcessor processor ) { } @ Override public InputProcessor getInputProcessor ( ) { } @ Override public void vibrate ( int milliseconds ) { } @ Override public boolean justTouched ( ) { } private int toLwjglButton ( int button ) { } @ Override public boolean isButtonPressed ( int button ) { } @ Override public void vibrate ( long [ ] pattern , int repeat ) { } @ Override public void cancelVibrate ( ) { } @ Override public float getAzimuth ( ) { } @ Override public float getPitch ( ) { } @ Override public float getRoll ( ) { } @ Override public boolean isPeripheralAvailable ( Peripheral peripheral ) { } @ Override public int getRotation ( ) { } @ Override public Orientation getNativeOrientation ( ) { } @ Override public void setCursorCatched ( boolean catched ) { } @ Override public boolean isCursorCatched ( ) { } @ Override public int getDeltaX ( ) { } @ Override public int getDeltaX ( int pointer ) { } @ Override public int getDeltaY ( ) { } @ Override public int getDeltaY ( int pointer ) { } @ Override public void setCursorPosition ( int x , int y ) { <START_BUG> Mouse . setCursorPosition ( x , ( ( ( graphics . getHeight ( ) ) - 1 ) - y ) ) ; <END_BUG> } @ Override public void setCursorImage ( Pixmap pixmap , int xHotspot , int yHotspot ) { } @ Override public void setCatchMenuKey ( boolean catchMenu ) { } @ Override public long getCurrentEventTime ( ) { } @ Override public void getRotationMatrix ( float [ ] matrix ) { } class KeyEvent { static final int KEY_DOWN = 0 ; static final int KEY_UP = 1 ; static final int KEY_TYPED = 2 ; long timeStamp ; int type ; int keyCode ; char keyChar ; } class TouchEvent { static final int TOUCH_DOWN = 0 ; static final int TOUCH_UP = 1 ; static final int TOUCH_DRAGGED = 2 ; static final int TOUCH_SCROLLED = 3 ; static final int TOUCH_MOVED = 4 ; long timeStamp ; int type ; int x ; int y ; int scrollAmount ; int button ; int pointer ; } }
public class TopHitsBuilder extends AbstractAggregationBuilder { private SearchSourceBuilder sourceBuilder ; public TopHitsBuilder ( String name ) { } public TopHitsBuilder setFrom ( int from ) { } public TopHitsBuilder setSize ( int size ) { } public TopHitsBuilder setTrackScores ( boolean trackScores ) { } public TopHitsBuilder setExplain ( boolean explain ) { } public TopHitsBuilder setVersion ( boolean version ) { } public TopHitsBuilder setNoFields ( ) { } public TopHitsBuilder setFetchSource ( boolean fetch ) { } public TopHitsBuilder setFetchSource ( @ Nullable String include , @ Nullable String exclude ) { } public TopHitsBuilder setFetchSource ( @ Nullable String [ ] includes , @ Nullable String [ ] excludes ) { } public TopHitsBuilder addFieldDataField ( String name ) { } public TopHitsBuilder addScriptField ( String name , String script ) { } public TopHitsBuilder addScriptField ( String name , String script , Map < String , Object > params ) { } public TopHitsBuilder addScriptField ( String name , String lang , String script , Map < String , Object > params ) { } public TopHitsBuilder addSort ( String field , SortOrder order ) { } public TopHitsBuilder addSort ( SortBuilder sort ) { } public TopHitsBuilder addHighlightedField ( String name ) { } public TopHitsBuilder addHighlightedField ( String name , int fragmentSize ) { } public TopHitsBuilder addHighlightedField ( String name , int fragmentSize , int numberOfFragments ) { } public TopHitsBuilder addHighlightedField ( String name , int fragmentSize , int numberOfFragments , int fragmentOffset ) { } public TopHitsBuilder addHighlightedField ( HighlightBuilder . Field field ) { } public TopHitsBuilder setHighlighterTagsSchema ( String schemaName ) { } public TopHitsBuilder setHighlighterFragmentSize ( Integer fragmentSize ) { } public TopHitsBuilder setHighlighterNumOfFragments ( Integer numOfFragments ) { } public TopHitsBuilder setHighlighterFilter ( Boolean highlightFilter ) { } public TopHitsBuilder setHighlighterEncoder ( String encoder ) { } public TopHitsBuilder setHighlighterPreTags ( String ... preTags ) { } public TopHitsBuilder setHighlighterPostTags ( String ... postTags ) { } public TopHitsBuilder setHighlighterOrder ( String order ) { } public TopHitsBuilder setHighlighterRequireFieldMatch ( boolean requireFieldMatch ) { } public TopHitsBuilder setHighlighterBoundaryMaxScan ( Integer boundaryMaxScan ) { } public TopHitsBuilder setHighlighterBoundaryChars ( char [ ] boundaryChars ) { } public TopHitsBuilder setHighlighterType ( String type ) { } public TopHitsBuilder setHighlighterFragmenter ( String fragmenter ) { } public TopHitsBuilder setHighlighterQuery ( QueryBuilder highlightQuery ) { } public TopHitsBuilder setHighlighterNoMatchSize ( Integer noMatchSize ) { } public TopHitsBuilder setHighlighterPhraseLimit ( Integer phraseLimit ) { } public TopHitsBuilder setHighlighterOptions ( Map < String , Object > options ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { <START_BUG> builder . startObject ( name ) . field ( type ) ; <END_BUG> sourceBuilder ( ) . toXContent ( builder , params ) ; return builder . endObject ( ) ; } private SearchSourceBuilder sourceBuilder ( ) { } public HighlightBuilder highlightBuilder ( ) { } }
public class SimpleNumericTests extends ElasticsearchTestCase { @ Test public void testNumericDetectionEnabled ( ) throws Exception { } @ Test public void testNumericDetectionDefault ( ) throws Exception { } @ Test public void testIgnoreMalformedOption ( ) throws Exception { } @ Test public void testCoerceOption ( ) throws Exception { } public void testDocValues ( ) throws Exception { } public void testDocValuesOnNested ( ) throws Exception { } @ Test public void testPrecisionStepDefaultsDetected ( ) throws Exception { } @ Test public void testPrecisionStepDefaultsMapped ( ) throws Exception { } @ Test public void testPrecisionStepExplicit ( ) throws Exception { } private static void assertPrecisionStepEquals ( int expected , IndexableField field ) throws IOException { assertNotNull ( field ) ; assertThat ( field , instanceOf ( Field . class ) ) ; assertEquals ( expected , ( ( Field ) ( field ) ) . fieldType ( ) . numericPrecisionStep ( ) ) ; <START_BUG> TokenStream ts = field . tokenStream ( null ) ; <END_BUG> assertThat ( ts , instanceOf ( NumericTokenStream . class ) ) ; assertEquals ( expected , ( ( NumericTokenStream ) ( ts ) ) . getPrecisionStep ( ) ) ; } }
public class MetagunAndroid extends AndroidApplication { @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; <START_BUG> initialize ( new Metagun ( ) , false ) ; <END_BUG> } }
public final class LoggerInfoStream extends InfoStream { private final ESLogger logger ; public LoggerInfoStream ( Settings settings , ShardId shardId ) { } public void message ( String component , String message ) { <START_BUG> logger . trace ( "{}:<seq2seq4repair_space>{}" , component , message ) ; <END_BUG> } public boolean isEnabled ( String component ) { } @ Override public void close ( ) { } }
public class Type { String name ; Class clazz ; Class superClass ; Set < Class > assignables = new HashSet < Class > ( ) ; boolean isAbstract ; boolean isInterface ; boolean isPrimitive ; boolean isEnum ; boolean isArray ; boolean isMemberClass ; boolean isStatic ; Field [ ] fields ; Method [ ] methods ; Constructor constructor ; Class componentType ; Object [ ] enumConstants ; public Object newInstance ( ) { } public String getName ( ) { } public Class getClassOfType ( ) { } public Type getSuperclass ( ) { try { <START_BUG> return ( superClass ) == null ? null : ReflectionCache . forName ( superClass . getName ( ) ) ; <END_BUG> } catch ( ClassNotFoundException e ) { return null ; } } public boolean isAssignableFrom ( Type otherType ) { } public Field getField ( String name ) { } public Field [ ] getFields ( ) { } public Field [ ] getDeclaredFields ( ) { } public Method getMethod ( String name , Class ... parameterTypes ) throws NoSuchMethodException { } public Method [ ] getMethods ( ) { } public Method [ ] getDeclaredMethods ( ) { } public Constructor getDeclaredConstructor ( ) throws NoSuchMethodException { } public boolean isAbstract ( ) { } public boolean isInterface ( ) { } public boolean isPrimitive ( ) { } public boolean isEnum ( ) { } public boolean isArray ( ) { } public boolean isMemberClass ( ) { } public boolean isStatic ( ) { } public Class getComponentType ( ) { } public int getArrayLength ( Object obj ) { } public Object getArrayElement ( Object obj , int i ) { } public void setArrayElement ( Object obj , int i , Object value ) { } public Object [ ] getEnumConstants ( ) { } @ Override public String toString ( ) { } }
public class AllocationService extends AbstractComponent { private final AllocationDeciders allocationDeciders ; private final ShardsAllocators shardsAllocators ; public AllocationService ( ) { } public AllocationService ( Settings settings ) { } @ Inject public AllocationService ( Settings settings , AllocationDeciders allocationDeciders , ShardsAllocators shardsAllocators ) { } public Result applyStartedShards ( ClusterState clusterState , List < ? extends ShardRouting > startedShards ) { } public Result applyFailedShard ( ClusterState clusterState , ShardRouting failedShard ) { } public Result reroute ( ClusterState clusterState ) { } public Result rerouteWithNoReassign ( ClusterState clusterState ) { } private boolean reroute ( RoutingAllocation allocation ) { } private boolean moveShards ( RoutingAllocation allocation ) { } private boolean electPrimaries ( RoutingNodes routingNodes ) { } private void applyNewNodes ( RoutingNodes routingNodes , Iterable < DiscoveryNode > liveNodes ) { for ( DiscoveryNode node : liveNodes ) { if ( ! ( routingNodes . nodesToShards ( ) . containsKey ( node . id ( ) ) ) ) { <START_BUG> RoutingNode routingNode = new RoutingNode ( node ) ; <END_BUG> routingNodes . nodesToShards ( ) . put ( node . id ( ) , routingNode ) ; } } } private boolean deassociateDeadNodes ( RoutingNodes routingNodes , Iterable < DiscoveryNode > liveNodes ) { } private boolean applyStartedShards ( RoutingNodes routingNodes , Iterable < ? extends ShardRouting > startedShardEntries ) { } private boolean applyFailedShard ( FailedRerouteAllocation allocation ) { } }
public class NodeIndicesStats implements Serializable , Streamable , ToXContent { private StoreStats storeStats ; private DocsStats docsStats ; private IndexingStats indexingStats ; private GetStats getStats ; private SearchStats searchStats ; private CacheStats cacheStats ; private MergeStats mergeStats ; private RefreshStats refreshStats ; private FlushStats flushStats ; NodeIndicesStats ( ) { } public NodeIndicesStats ( StoreStats storeStats , DocsStats docsStats , IndexingStats indexingStats , GetStats getStats , SearchStats searchStats , CacheStats cacheStats , MergeStats mergeStats , RefreshStats refreshStats , FlushStats flushStats ) { } public StoreStats store ( ) { } public StoreStats getStore ( ) { } public DocsStats docs ( ) { } public DocsStats getDocs ( ) { } public IndexingStats indexing ( ) { } public IndexingStats getIndexing ( ) { } public GetStats get ( ) { } public GetStats getGet ( ) { } public SearchStats search ( ) { } public SearchStats getSearch ( ) { } public CacheStats cache ( ) { } public CacheStats getCache ( ) { } public MergeStats merge ( ) { } public MergeStats getMerge ( ) { } public RefreshStats refresh ( ) { <START_BUG> return this . refreshStats ; <END_BUG> } public RefreshStats getRefresh ( ) { } public FlushStats flush ( ) { } public FlushStats getFlush ( ) { } public static NodeIndicesStats readIndicesStats ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } static final class Fields { static final XContentBuilderString INDICES = new XContentBuilderString ( "indices" ) ; } }
public abstract class TransportAction < Request extends ActionRequest , Response extends ActionResponse > extends AbstractComponent { protected final ThreadPool threadPool ; protected TransportAction ( Settings settings , ThreadPool threadPool ) { } public ActionFuture < Response > execute ( Request request ) throws ElasticsearchException { } public void execute ( Request request , ActionListener < Response > listener ) { if ( request . listenerThreaded ( ) ) { <START_BUG> listener = new TransportAction . ThreadedActionListener < Response > ( threadPool , listener , logger ) ; <END_BUG> } ActionRequestValidationException validationException = request . validate ( ) ; if ( validationException != null ) { listener . onFailure ( validationException ) ; return ; } try { doExecute ( request , listener ) ; } catch ( Throwable e ) { logger . trace ( "Error<seq2seq4repair_space>during<seq2seq4repair_space>transport<seq2seq4repair_space>action<seq2seq4repair_space>execution." , e ) ; listener . onFailure ( e ) ; } } protected abstract void doExecute ( Request request , ActionListener < Response > listener ) { } static final class ThreadedActionListener < Response > implements ActionListener < Response > { private final ThreadPool threadPool ; private final ActionListener < Response > listener ; private final ESLogger logger ; ThreadedActionListener ( ThreadPool threadPool , ActionListener < Response > listener , ESLogger logger ) { } @ Override public void onResponse ( final Response response ) { } @ Override public void onFailure ( final Throwable e ) { } } }
public class RoutingFieldMapper extends AbstractFieldMapper < String > implements org . elasticsearch . index . mapper . RoutingFieldMapper { public static final String CONTENT_TYPE = "_routing" ; public static class Defaults extends AbstractFieldMapper . Defaults { public static final String NAME = "_routing" ; public static final Index INDEX = Index . NOT_ANALYZED ; public static final Store STORE = Store . YES ; public static final boolean OMIT_NORMS = true ; public static final boolean OMIT_TERM_FREQ_AND_POSITIONS = true ; public static final boolean REQUIRED = false ; public static final String PATH = null ; } public static class Builder extends AbstractFieldMapper . Builder < RoutingFieldMapper . Builder , RoutingFieldMapper > { private boolean required = RoutingFieldMapper . Defaults . REQUIRED ; private String path = RoutingFieldMapper . Defaults . PATH ; public Builder ( ) { } public RoutingFieldMapper . Builder required ( boolean required ) { } public RoutingFieldMapper . Builder path ( String path ) { } @ Override public RoutingFieldMapper build ( BuilderContext context ) { } } private boolean required ; private final String path ; protected RoutingFieldMapper ( ) { } protected RoutingFieldMapper ( Field . Store store , Field . Index index , boolean required , String path ) { } public void markAsRequired ( ) { <START_BUG> this . required = required ; <END_BUG> } @ Override public boolean required ( ) { } @ Override public String path ( ) { } @ Override public String value ( Document document ) { } @ Override public String value ( Fieldable field ) { } @ Override public String valueFromString ( String value ) { } @ Override public String valueAsString ( Fieldable field ) { } @ Override public String indexedValue ( String value ) { } public void validate ( ParseContext context , String routing ) throws MapperParsingException { } @ Override protected Field parseCreateField ( ParseContext context ) throws IOException { } @ Override protected String contentType ( ) { } @ Override public void toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( XContentMapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public class TransportSearchScrollScanAction extends AbstractComponent { private final ThreadPool threadPool ; private final ClusterService clusterService ; private final SearchServiceTransportAction searchService ; private final SearchPhaseController searchPhaseController ; @ Inject public TransportSearchScrollScanAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } public void execute ( SearchScrollRequest request , ParsedScrollId scrollId , ActionListener < SearchResponse > listener ) { } private class AsyncAction { private final SearchScrollRequest request ; private final ActionListener < SearchResponse > listener ; private final ParsedScrollId scrollId ; private final DiscoveryNodes nodes ; private volatile AtomicArray < ShardSearchFailure > shardFailures ; private final AtomicArray < QueryFetchSearchResult > queryFetchResults ; private final AtomicInteger successfulOps ; private final AtomicInteger counter ; private final long startTime = System . currentTimeMillis ( ) ; private AsyncAction ( SearchScrollRequest request , ParsedScrollId scrollId , ActionListener < SearchResponse > listener ) { } protected final ShardSearchFailure [ ] buildShardFailures ( ) { } protected final void addShardFailure ( final int shardIndex , ShardSearchFailure failure ) { } public void start ( ) { } private void executePhase ( final int shardIndex , DiscoveryNode node , final long searchId ) { } private void finishHim ( ) { try { innerFinishHim ( ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> ReduceSearchPhaseException failure = new ReduceSearchPhaseException ( "fetch" , "" , e , buildShardFailures ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>reduce<seq2seq4repair_space>search" , failure ) ; } listener . onFailure ( failure ) ; } } private void innerFinishHim ( ) throws IOException { } } }
public class TransportRefreshAction extends TransportBroadcastOperationAction < RefreshRequest , RefreshResponse , ShardRefreshRequest , ShardRefreshResponse > { private final IndicesService indicesService ; @ Inject public TransportRefreshAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected RefreshRequest newRequest ( ) { } @ Override protected RefreshResponse newResponse ( RefreshRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardRefreshRequest newShardRequest ( ) { } @ Override protected ShardRefreshRequest newShardRequest ( int numShards , ShardRouting shard , RefreshRequest request ) { } @ Override protected ShardRefreshResponse newShardResponse ( ) { } @ Override protected ShardRefreshResponse shardOperation ( ShardRefreshRequest request ) throws ElasticsearchException { } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , RefreshRequest request , String [ ] concreteIndices ) { logger . trace ( "resolving<seq2seq4repair_space>shards<seq2seq4repair_space>to<seq2seq4repair_space>refresh<seq2seq4repair_space>based<seq2seq4repair_space>on<seq2seq4repair_space>cluster<seq2seq4repair_space>state<seq2seq4repair_space>version<seq2seq4repair_space>[{}]" , clusterState . version ( ) ) ; <START_BUG> return clusterState . routingTable ( ) . allAssignedShardsGrouped ( concreteIndices , true ) ; <END_BUG> } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , RefreshRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , RefreshRequest countRequest , String [ ] concreteIndices ) { } }
public class TransportNodesStatsAction extends TransportNodesOperationAction < NodesStatsRequest , NodesStatsResponse , TransportNodesStatsAction . NodeStatsRequest , NodeStats > { private final NodeService nodeService ; @ Inject public TransportNodesStatsAction ( Settings settings , ClusterName clusterName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , NodeService nodeService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected NodesStatsResponse newResponse ( NodesStatsRequest nodesInfoRequest , AtomicReferenceArray responses ) { } @ Override protected NodesStatsRequest newRequest ( ) { } @ Override protected TransportNodesStatsAction . NodeStatsRequest newNodeRequest ( ) { } @ Override protected TransportNodesStatsAction . NodeStatsRequest newNodeRequest ( String nodeId , NodesStatsRequest request ) { } @ Override protected NodeStats newNodeResponse ( ) { } @ Override protected NodeStats nodeOperation ( TransportNodesStatsAction . NodeStatsRequest nodeStatsRequest ) throws ElasticSearchException { NodesStatsRequest request = nodeStatsRequest . request ; <START_BUG> return nodeService . stats ( request . indices ( ) , request . os ( ) , request . process ( ) , request . jvm ( ) , request . threadPool ( ) , request . network ( ) , request . transport ( ) , request . http ( ) ) ; <END_BUG> } @ Override protected boolean accumulateExceptions ( ) { } static class NodeStatsRequest extends NodeOperationRequest { NodesStatsRequest request ; NodeStatsRequest ( ) { } NodeStatsRequest ( String nodeId , NodesStatsRequest request ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
public class TransportPercolateAction extends TransportBroadcastOperationAction < PercolateRequest , PercolateResponse , PercolateShardRequest , PercolateShardResponse > { private final PercolatorService percolatorService ; private final TransportGetAction getAction ; @ Inject public TransportPercolateAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , PercolatorService percolatorService , TransportGetAction getAction , ActionFilters actionFilters ) { } @ Override protected void doExecute ( final PercolateRequest request , final ActionListener < PercolateResponse > listener ) { } @ Override protected String executor ( ) { } @ Override protected PercolateRequest newRequest ( ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , PercolateRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , PercolateRequest request , String [ ] concreteIndices ) { } @ Override protected PercolateResponse newResponse ( PercolateRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } public static PercolateResponse reduce ( PercolateRequest request , AtomicReferenceArray shardsResponses , PercolatorService percolatorService ) { } @ Override protected PercolateShardRequest newShardRequest ( ) { } @ Override protected PercolateShardRequest newShardRequest ( int numShards , ShardRouting shard , PercolateRequest request ) { <START_BUG> return new PercolateShardRequest ( shard . index ( ) , shard . id ( ) , numShards , request ) ; <END_BUG> } @ Override protected PercolateShardResponse newShardResponse ( ) { } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , PercolateRequest request , String [ ] concreteIndices ) { } @ Override protected PercolateShardResponse shardOperation ( PercolateShardRequest request ) throws ElasticsearchException { } }
public class IssuesFragment extends ListLoadingFragment < Issue > { private static final int DEFAULT_SIZE = 20 ; private OnItemClickListener clickListener ; private LoaderCallbacks < List < Issue > > loadListener ; @ Inject private IssueService service ; private IRepositoryIdProvider repository ; private IssueFilter filter ; private Issue lastIssue ; private boolean hasMore = true ; private Button moreButton ; private int pages = 1 ; public IssuesFragment setRepository ( IRepositoryIdProvider repository ) { } public IssuesFragment setFilter ( IssueFilter filter ) { } public IssuesFragment setClickListener ( OnItemClickListener clickListener ) { } public IssuesFragment setLoadListener ( LoaderCallbacks < List < Issue > > loadListener ) { } public void onActivityCreated ( Bundle savedInstanceState ) { } public void onLoaderReset ( Loader < List < Issue > > listLoader ) { } public void onLoadFinished ( Loader < List < Issue > > loader , final List < Issue > items ) { } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public Loader < List < Issue > > onCreateLoader ( int i , Bundle bundle ) { } @ Override protected ListAdapter adapterFor ( List < Issue > items ) { <START_BUG> return new com . madgag . android . listviews . ViewHoldingListAdapter < Issue > ( items , viewInflatorFor ( getActivity ( ) , repo_issue_list_item ) , reflectiveFactoryFor ( RepoIssueViewHolder . class ) ) ; <END_BUG> } }
public class TermsStringOrdinalsFacetExecutor extends FacetExecutor { private final WithOrdinals indexFieldData ; final CacheRecycler cacheRecycler ; final BigArrays bigArrays ; private final ComparatorType comparatorType ; private final int size ; private final int shardSize ; private final int minCount ; private final ImmutableSet < BytesRef > excluded ; private final Matcher matcher ; final int ordinalsCacheAbove ; final List < TermsStringOrdinalsFacetExecutor . ReaderAggregator > aggregators ; long missing ; long total ; public TermsStringOrdinalsFacetExecutor ( IndexFieldData . WithOrdinals indexFieldData , int size , int shardSize , TermsFacet . ComparatorType comparatorType , boolean allTerms , SearchContext context , ImmutableSet < BytesRef > excluded , Pattern pattern , int ordinalsCacheAbove ) { } @ Override public TermsStringOrdinalsFacetExecutor . Collector collector ( ) { } @ Override public InternalFacet buildFacet ( String facetName ) { } class Collector extends FacetExecutor . Collector { private long missing ; private long total ; private BytesValues . WithOrdinals values ; private TermsStringOrdinalsFacetExecutor . ReaderAggregator current ; @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void postCollection ( ) { } } public final class ReaderAggregator implements Releasable { private final long maxOrd ; final BytesValues . WithOrdinals values ; final IntArray counts ; int missing = 0 ; long position = ( BytesValues . WithOrdinals . MIN_ORDINAL ) - 1 ; BytesRef current ; int total ; public ReaderAggregator ( BytesValues . WithOrdinals values , int ordinalsCacheLimit , CacheRecycler cacheRecycler ) { } final void onOrdinal ( int docId , long ordinal ) { } final void incrementMissing ( int numMissing ) { } public boolean nextPosition ( ) { } public BytesRef copyCurrent ( ) { <START_BUG> return values . copyShared ( ) ; <END_BUG> } @ Override public void close ( ) { } } public static class AggregatorPriorityQueue extends PriorityQueue < TermsStringOrdinalsFacetExecutor . ReaderAggregator > { public AggregatorPriorityQueue ( int size ) { } @ Override protected boolean lessThan ( TermsStringOrdinalsFacetExecutor . ReaderAggregator a , TermsStringOrdinalsFacetExecutor . ReaderAggregator b ) { } } }
public class RepositoryUtils { public static boolean isComplete ( Repository repository ) { <START_BUG> return ( repository . isFork ( ) ) || ( ( repository . getForks ( ) ) != 0 ) ; <END_BUG> } }
public class MetaDataMappingService extends AbstractComponent { private final ClusterService clusterService ; private final IndicesService indicesService ; private final NodeMappingCreatedAction mappingCreatedAction ; private final BlockingQueue < MetaDataMappingService . MappingTask > refreshOrUpdateQueue = ConcurrentCollections . newBlockingQueue ( ) ; @ Inject public MetaDataMappingService ( Settings settings , ClusterService clusterService , IndicesService indicesService , NodeMappingCreatedAction mappingCreatedAction ) { } static class MappingTask { final String index ; final String indexUUID ; MappingTask ( String index , final String indexUUID ) { } } static class RefreshTask extends MetaDataMappingService . MappingTask { final String [ ] types ; RefreshTask ( String index , final String indexUUID , String [ ] types ) { } } static class UpdateTask extends MetaDataMappingService . MappingTask { final String type ; final CompressedString mappingSource ; final MetaDataMappingService . Listener listener ; UpdateTask ( String index , String indexUUID , String type , CompressedString mappingSource , MetaDataMappingService . Listener listener ) { } } ClusterState executeRefreshOrUpdate ( final ClusterState currentState ) throws Exception { } public void refreshMapping ( final String index , final String indexUUID , final String ... types ) { } public void updateMapping ( final String index , final String indexUUID , final String type , final CompressedString mappingSource , final MetaDataMappingService . Listener listener ) { } public void removeMapping ( final DeleteMappingClusterStateUpdateRequest request , final ClusterStateUpdateListener listener ) { clusterService . submitStateUpdateTask ( ( ( "remove-mapping<seq2seq4repair_space>[" + ( request . type ( ) ) ) + "]" ) , HIGH , new AckedClusterStateUpdateTask ( ) { @ Override public boolean mustAck ( DiscoveryNode discoveryNode ) { return true ; } @ Override public void onAllNodesAcked ( @ Nullable Throwable t ) { listener . onResponse ( new ClusterStateUpdateResponse ( true ) ) ; } @ Override public void onAckTimeout ( ) { <START_BUG> listener . onResponse ( new ClusterStateUpdateResponse ( true ) ) ; <END_BUG> } @ Override public TimeValue ackTimeout ( ) { return request . ackTimeout ( ) ; } @ Override public TimeValue timeout ( ) { return request . masterNodeTimeout ( ) ; } @ Override public void onFailure ( String source , Throwable t ) { listener . onFailure ( t ) ; } @ Override public ClusterState execute ( ClusterState currentState ) { if ( ( request . indices ( ) . length ) == 0 ) { throw new org . elasticsearch . indices . IndexMissingException ( new Index ( "_all" ) ) ; } MetaData . Builder builder = MetaData . newMetaDataBuilder ( ) . metaData ( currentState . metaData ( ) ) ; boolean changed = false ; String latestIndexWithout = null ; for ( String indexName : request . indices ( ) ) { IndexMetaData indexMetaData = currentState . metaData ( ) . index ( indexName ) ; if ( indexMetaData != null ) { if ( indexMetaData . mappings ( ) . containsKey ( request . type ( ) ) ) { builder . put ( IndexMetaData . newIndexMetaDataBuilder ( indexMetaData ) . removeMapping ( request . type ( ) ) ) ; changed = true ; } else { latestIndexWithout = indexMetaData . index ( ) ; } } } if ( ! changed ) { throw new org . elasticsearch . indices . TypeMissingException ( new Index ( latestIndexWithout ) , request . type ( ) ) ; } logger . info ( "[{}]<seq2seq4repair_space>remove_mapping<seq2seq4repair_space>[{}]" , request . indices ( ) , request . type ( ) ) ; return ClusterState . builder ( ) . state ( currentState ) . metaData ( builder ) . build ( ) ; } @ Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { } } ) ; } public void putMapping ( final MetaDataMappingService . PutRequest request , final MetaDataMappingService . Listener listener ) { } public static interface Listener { void onResponse ( MetaDataMappingService . Response response ) { } void onFailure ( Throwable t ) { } } public static class PutRequest { final String [ ] indices ; final String mappingType ; final String mappingSource ; boolean ignoreConflicts = false ; TimeValue timeout = TimeValue . timeValueSeconds ( 10 ) ; TimeValue masterTimeout = MasterNodeOperationRequest . DEFAULT_MASTER_NODE_TIMEOUT ; public PutRequest ( String [ ] indices , String mappingType , String mappingSource ) { } public MetaDataMappingService . PutRequest ignoreConflicts ( boolean ignoreConflicts ) { } public MetaDataMappingService . PutRequest timeout ( TimeValue timeout ) { } public MetaDataMappingService . PutRequest masterTimeout ( TimeValue masterTimeout ) { } } public static class Response { private final boolean acknowledged ; public Response ( boolean acknowledged ) { } public boolean acknowledged ( ) { } } private class CountDownListener implements NodeMappingCreatedAction . Listener { private final CountDown countDown ; private final MetaDataMappingService . Listener listener ; private final long minClusterStateVersion ; public CountDownListener ( int countDown , long minClusterStateVersion , MetaDataMappingService . Listener listener ) { } @ Override public void onNodeMappingCreated ( NodeMappingCreatedAction . NodeMappingCreatedResponse response ) { } public void decrementCounter ( ) { } @ Override public void onTimeout ( ) { } } }
public class GLES10Shader implements Shader { private Camera camera ; private RenderContext context ; private Matrix4 currentTransform ; private Material currentMaterial ; private Texture currentTexture0 ; private Mesh currentMesh ; public static int defaultCullFace = GL10 . GL_BACK ; public GLES10Shader ( ) { } @ Override public void init ( ) { } @ Override public boolean canRender ( final Renderable renderable ) { } @ Override public int compareTo ( Shader other ) { } @ Override public boolean equals ( Object obj ) { } public boolean equals ( GLES10Shader obj ) { } @ Override public void begin ( final Camera camera , final RenderContext context ) { this . context = context ; this . camera = camera ; <START_BUG> context . setDepthTest ( true , GL_LEQUAL ) ; <END_BUG> gl10 . glMatrixMode ( GL_PROJECTION ) ; gl10 . glLoadMatrixf ( camera . combined . val , 0 ) ; gl10 . glMatrixMode ( GL_MODELVIEW ) ; } private final float [ ] lightVal = new float [ ] { 0 , 0 , 0 , 0 } ; private final float [ ] zeroVal4 = new float [ ] { 0 , 0 , 0 , 0 } ; private final float [ ] oneVal4 = new float [ ] { 1 , 1 , 1 , 1 } ; private void bindLights ( Lights lights ) { } private static final float [ ] getValues ( final float [ ] out , final float v0 , final float v1 , final float v2 , final float v3 ) { } private static final float [ ] getValues ( final float [ ] out , final Color color ) { } @ Override public void render ( final Renderable renderable ) { } @ Override public void end ( ) { } @ Override public void dispose ( ) { } }
public class TransportClusterRerouteAction extends TransportMasterNodeOperationAction < ClusterRerouteRequest , ClusterRerouteResponse > { private final AllocationService allocationService ; @ Inject public TransportClusterRerouteAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , AllocationService allocationService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected ClusterRerouteRequest newRequest ( ) { } @ Override protected ClusterRerouteResponse newResponse ( ) { } @ Override protected void masterOperation ( final ClusterRerouteRequest request , final ClusterState state , final ActionListener < ClusterRerouteResponse > listener ) throws ElasticsearchException { clusterService . submitStateUpdateTask ( "cluster_reroute<seq2seq4repair_space>(api)" , URGENT , new AckedClusterStateUpdateTask ( ) { private volatile ClusterState clusterStateToSend ; @ Override public boolean mustAck ( DiscoveryNode discoveryNode ) { return true ; } @ Override public void onAllNodesAcked ( @ Nullable Throwable t ) { listener . onResponse ( new ClusterRerouteResponse ( true , clusterStateToSend ) ) ; } @ Override public void onAckTimeout ( ) { listener . onResponse ( new ClusterRerouteResponse ( false , clusterStateToSend ) ) ; } @ Override public TimeValue ackTimeout ( ) { return request . timeout ( ) ; } @ Override public TimeValue timeout ( ) { return request . masterNodeTimeout ( ) ; } @ Override public void onFailure ( String source , Throwable t ) { logger . debug ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>perform<seq2seq4repair_space>[{}]" , t , source ) ; listener . onFailure ( t ) ; } @ Override public ClusterState execute ( ClusterState currentState ) { <START_BUG> RoutingAllocation . Result routingResult = allocationService . reroute ( currentState , request . commands ) ; <END_BUG> ClusterState newState = ClusterState . builder ( currentState ) . routingResult ( routingResult ) . build ( ) ; clusterStateToSend = newState ; if ( request . dryRun ) { return currentState ; } return newState ; } @ Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { } } ) ; } }
public class Label extends Widget { private static final Color tempColor = new Color ( ) ; private Label . LabelStyle style ; private final TextBounds bounds = new TextBounds ( ) ; private final StringBuilder text = new StringBuilder ( ) ; private StringBuilder tempText ; private BitmapFontCache cache ; private int labelAlign = Align . left ; private HAlignment lineAlign = HAlignment . LEFT ; private boolean wrap ; private float lastPrefHeight ; private boolean sizeInvalid = true ; private float fontScaleX = 1 ; private float fontScaleY = 1 ; private boolean ellipse ; public Label ( CharSequence text , Skin skin ) { } public Label ( CharSequence text , Skin skin , String styleName ) { } public Label ( CharSequence text , Skin skin , String fontName , Color color ) { } public Label ( CharSequence text , Skin skin , String fontName , String colorName ) { } public Label ( CharSequence text , Label . LabelStyle style ) { } public void setStyle ( Label . LabelStyle style ) { } public Label . LabelStyle getStyle ( ) { } public void setText ( CharSequence newText ) { } public boolean textEquals ( CharSequence other ) { } <START_BUG> public CharSequence getText ( ) { <END_BUG> return text ; } public void invalidate ( ) { } private void scaleAndComputeSize ( ) { } private void computeSize ( ) { } public void layout ( ) { } public void draw ( Batch batch , float parentAlpha ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public TextBounds getTextBounds ( ) { } public void setWrap ( boolean wrap ) { } public void setAlignment ( int alignment ) { } public void setAlignment ( int labelAlign , int lineAlign ) { } public void setFontScale ( float fontScale ) { } public void setFontScale ( float fontScaleX , float fontScaleY ) { } public float getFontScaleX ( ) { } public void setFontScaleX ( float fontScaleX ) { } public float getFontScaleY ( ) { } public void setFontScaleY ( float fontScaleY ) { } public void setEllipse ( boolean ellipse ) { } protected BitmapFontCache getBitmapFontCache ( ) { } public static class LabelStyle { public BitmapFont font ; public Color fontColor ; public Drawable background ; public LabelStyle ( ) { } public LabelStyle ( BitmapFont font , Color fontColor ) { } public LabelStyle ( Label . LabelStyle style ) { } } }
public abstract class BucketsAggregator extends Aggregator { private IntArray docCounts ; public BucketsAggregator ( String name , BucketAggregationMode bucketAggregationMode , AggregatorFactories factories , long estimatedBucketsCount , AggregationContext context , Aggregator parent ) { } protected final long maxBucketOrd ( ) { } protected final void collectBucket ( int doc , long bucketOrd ) throws IOException { } protected final void collectExistingBucket ( int doc , long bucketOrd ) throws IOException { } public IntArray getDocCounts ( ) { } protected final void collectBucketNoCounts ( int doc , long bucketOrd ) throws IOException { } <START_BUG> protected final void incrementBucketDocCount ( int inc , long bucketOrd ) throws IOException { <END_BUG> docCounts = bigArrays . grow ( docCounts , ( bucketOrd + 1 ) ) ; docCounts . increment ( bucketOrd , inc ) ; } public final int bucketDocCount ( long bucketOrd ) { } protected final InternalAggregations bucketAggregations ( long bucketOrd ) { } protected final InternalAggregations bucketEmptyAggregations ( ) { } @ Override public final void close ( ) { } }
public class Button extends Actor { public interface ClickListener { public void clicked ( Button button ) { } } public final TextureRegion pressedRegion ; public final TextureRegion unpressedRegion ; public Button . ClickListener clickListener ; protected boolean pressed = false ; public Button ( String name ) { } public Button ( String name , Texture texture ) { } public Button ( String name , TextureRegion region ) { } public Button ( String name , TextureRegion unpressedRegion , TextureRegion pressedRegion ) { } @ Override protected void render ( SpriteBatch batch ) { } @ Override protected boolean touchDown ( float x , float y , int pointer ) { } @ Override protected boolean touchUp ( float x , float y , int pointer ) { } @ Override protected boolean touchDragged ( float x , float y , int pointer ) { <START_BUG> return true ; <END_BUG> } public Actor hit ( float x , float y ) { } }
public final class EngineSearcherTotalHitsMatcher extends TypeSafeMatcher < Engine . Searcher > { private final Query query ; private final int totalHits ; public EngineSearcherTotalHitsMatcher ( Query query , int totalHits ) { } @ Override public boolean matchesSafely ( Engine . Searcher searcher ) { } @ Override public void describeTo ( Description description ) { } public static Matcher < Engine . Searcher > engineSearcherTotalHits ( Query query , int totalHits ) { } public static Matcher < Engine . Searcher > engineSearcherTotalHits ( int totalHits ) { <START_BUG> return new EngineSearcherTotalHitsMatcher ( Queries . MATCH_ALL_QUERY , totalHits ) ; <END_BUG> } }
public class SizeFieldMapper extends IntegerFieldMapper implements RootMapper { public static final String NAME = "_size" ; public static final String CONTENT_TYPE = "_size" ; public static class Defaults extends IntegerFieldMapper . Defaults { public static final String NAME = SizeFieldMapper . CONTENT_TYPE ; public static final boolean ENABLED = false ; } public static class Builder extends Mapper . Builder < SizeFieldMapper . Builder , IntegerFieldMapper > { protected boolean enabled = SizeFieldMapper . Defaults . ENABLED ; protected Store store = STORE ; public Builder ( ) { } public SizeFieldMapper . Builder enabled ( boolean enabled ) { } public SizeFieldMapper . Builder store ( Field . Store store ) { } @ Override public SizeFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private final boolean enabled ; public SizeFieldMapper ( ) { } public SizeFieldMapper ( boolean enabled , Field . Store store ) { } @ Override protected String contentType ( ) { } public boolean enabled ( ) { } @ Override public void validate ( ParseContext context ) throws MapperParsingException { } @ Override public void preParse ( ParseContext context ) throws IOException { } @ Override public void postParse ( ParseContext context ) throws IOException { } @ Override public void parse ( ParseContext context ) throws IOException { } @ Override public boolean includeInObject ( ) { } @ Override protected Fieldable parseCreateField ( ParseContext context ) throws IOException { if ( ! ( enabled ) ) { return null ; } <START_BUG> return new CustomIntegerNumericField ( this , context . source ( ) . length ) ; <END_BUG> } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } }
public static final native int btSparseSdf3_nprobes_get ( long jarg1 , btSparseSdf3 jarg1_ ) { } public static final native void btSparseSdf3_nqueries_set ( long jarg1 , btSparseSdf3 jarg1_ , int jarg2 ) { } public static final native int btSparseSdf3_nqueries_get ( long jarg1 , btSparseSdf3 jarg1_ ) { } public static final native void btSparseSdf3_Initialize__SWIG_0 ( long jarg1 , btSparseSdf3 jarg1_ , int jarg2 , int jarg3 ) { } public static final native void btSparseSdf3_Initialize__SWIG_1 ( long jarg1 , btSparseSdf3 jarg1_ , int jarg2 ) { } public static final native void btSparseSdf3_Initialize__SWIG_2 ( long jarg1 , btSparseSdf3 jarg1_ ) { } public static final native void btSparseSdf3_Reset ( long jarg1 , btSparseSdf3 jarg1_ ) { } public static final native void btSparseSdf3_GarbageCollect__SWIG_0 ( long jarg1 , btSparseSdf3 jarg1_ , int jarg2 ) { } public static final native void btSparseSdf3_GarbageCollect__SWIG_1 ( long jarg1 , btSparseSdf3 jarg1_ ) { } public static final native int btSparseSdf3_RemoveReferences ( long jarg1 , btSparseSdf3 jarg1_ , long jarg2 , btCollisionShape jarg2_ ) { } public static final native float btSparseSdf3_Evaluate ( long jarg1 , btSparseSdf3 jarg1_ , Vector3 jarg2 , long jarg3 , btCollisionShape jarg3_ , Vector3 jarg4 , float jarg5 ) { } public static final native void btSparseSdf3_BuildCell ( long jarg1 , btSparseSdf3 jarg1_ , long jarg2 ) { } public static final native float btSparseSdf3_DistanceToShape ( Vector3 jarg1 , long jarg2 , btCollisionShape jarg2_ ) { } public static final native long btSparseSdf3_Decompose ( float jarg1 ) { } public static final native float btSparseSdf3_Lerp ( float jarg1 , float jarg2 , float jarg3 ) { } public static final native long btSparseSdf3_Hash ( int jarg1 , int jarg2 , int jarg3 , long jarg4 , btCollisionShape jarg4_ ) { } public static final native long new_btSparseSdf3 ( ) { } public static final native void delete_btSparseSdf3 ( long jarg1 ) { } public static final native void btSoftBodyWorldInfo_air_density_set ( long jarg1 , btSoftBodyWorldInfo jarg1_ , float jarg2 ) { } public static final native float btSoftBodyWorldInfo_air_density_get ( long jarg1 , btSoftBodyWorldInfo jarg1_ ) { } public static final native void btSoftBodyWorldInfo_water_density_set ( long jarg1 , btSoftBodyWorldInfo jarg1_ , float jarg2 ) { } public static final native float btSoftBodyWorldInfo_water_density_get ( long jarg1 , btSoftBodyWorldInfo jarg1_ ) { } public static final native void btSoftBodyWorldInfo_water_offset_set ( long jarg1 , btSoftBodyWorldInfo jarg1_ , float jarg2 ) { } public static final native float btSoftBodyWorldInfo_water_offset_get ( long jarg1 , btSoftBodyWorldInfo jarg1_ ) { } public static final native void btSoftBodyWorldInfo_maxDisplacement_set ( long jarg1 , btSoftBodyWorldInfo jarg1_ , float jarg2 ) { } public static final native float btSoftBodyWorldInfo_maxDisplacement_get ( long jarg1 , btSoftBodyWorldInfo jarg1_ ) { } public static final native void btSoftBodyWorldInfo_water_normal_set ( long jarg1 , btSoftBodyWorldInfo jarg1_ , long jarg2 , btVector3 jarg2_ ) { } public static final native long btSoftBodyWorldInfo_water_normal_get ( long jarg1 , btSoftBodyWorldInfo jarg1_ ) { } public static final native void btSoftBodyWorldInfo_broadphase_set ( long jarg1 , btSoftBodyWorldInfo jarg1_ , long jarg2 , btBroadphaseInterface jarg2_ ) { } public static final native long btSoftBodyWorldInfo_broadphase_get ( long jarg1 , btSoftBodyWorldInfo jarg1_ ) { } public static final native void btSoftBodyWorldInfo_dispatcher_set ( long jarg1 , btSoftBodyWorldInfo jarg1_ , long jarg2 , btDispatcher jarg2_ ) { } public static final native long btSoftBodyWorldInfo_dispatcher_get ( long jarg1 , btSoftBodyWorldInfo jarg1_ ) { } public static final native void btSoftBodyWorldInfo_gravity_set ( long jarg1 , btSoftBodyWorldInfo jarg1_ , long jarg2 , btVector3 jarg2_ ) { } public static final native long btSoftBodyWorldInfo_gravity_get ( long jarg1 , btSoftBodyWorldInfo jarg1_ ) { } public static final native void btSoftBodyWorldInfo_sparsesdf_set ( long jarg1 , btSoftBodyWorldInfo jarg1_ , long jarg2 , btSparseSdf3 jarg2_ ) { } public static final native long btSoftBodyWorldInfo_sparsesdf_get ( long jarg1 , btSoftBodyWorldInfo jarg1_ ) { } public static final native long new_btSoftBodyWorldInfo ( ) { } public static final native void delete_btSoftBodyWorldInfo ( long jarg1 ) { } <START_BUG> public static final native void btSoftBody_collisionDisabledObjects_set ( long jarg1 , btSoftBody jarg1_ , long jarg2 , btCollisionObjectConstArray jarg2_ ) ; <END_BUG> public static final native long btSoftBody_collisionDisabledObjects_get ( long jarg1 , btSoftBody jarg1_ ) { } public static final native void btSoftBody_softBodySolver_set ( long jarg1 , btSoftBody jarg1_ , long jarg2 , btSoftBodySolver jarg2_ ) { } public static final native long btSoftBody_softBodySolver_get ( long jarg1 , btSoftBody jarg1_ ) { } public static final native void btSoftBody_cfg_set ( long jarg1 , btSoftBody jarg1_ , long jarg2 ) { } public static final native long btSoftBody_cfg_get ( long jarg1 , btSoftBody jarg1_ ) { } public static final native void btSoftBody_sst_set ( long jarg1 , btSoftBody jarg1_ , long jarg2 ) { } public static final native long btSoftBody_sst_get ( long jarg1 , btSoftBody jarg1_ ) { } public static final native void btSoftBody_pose_set ( long jarg1 , btSoftBody jarg1_ , long jarg2 ) { } public static final native long btSoftBody_pose_get ( long jarg1 , btSoftBody jarg1_ ) { } public static final native void btSoftBody_tag_set ( long jarg1 , btSoftBody jarg1_ , long jarg2 ) { } public static final native long btSoftBody_tag_get ( long jarg1 , btSoftBody jarg1_ ) { } public static final native void btSoftBody_worldInfo_set ( long jarg1 , btSoftBody jarg1_ , long jarg2 , btSoftBodyWorldInfo jarg2_ ) { } public static final native long btSoftBody_worldInfo_get ( long jarg1 , btSoftBody jarg1_ ) { } public static final native void btSoftBody_notes_set ( long jarg1 , btSoftBody jarg1_ , long jarg2 ) { } public static final native long btSoftBody_notes_get ( long jarg1 , btSoftBody jarg1_ ) { } public static final native void btSoftBody_nodes_set ( long jarg1 , btSoftBody jarg1_ , long jarg2 ) { } public static final native long btSoftBody_nodes_get ( long jarg1 , btSoftBody jarg1_ ) { } public static final native void btSoftBody_links_set ( long jarg1 , btSoftBody jarg1_ , long jarg2 ) { } public static final native long btSoftBody_links_get ( long jarg1 , btSoftBody jarg1_ ) { }
public class TermsStatsStringFacetExecutor extends FacetExecutor { private final ComparatorType comparatorType ; final IndexFieldData keyIndexFieldData ; final IndexNumericFieldData valueIndexFieldData ; final SearchScript script ; private final int size ; private final int shardSize ; final V < ObjectObjectOpenHashMap < HashedBytesRef , InternalTermsStatsStringFacet . StringEntry > > entries ; long missing ; public TermsStatsStringFacetExecutor ( IndexFieldData keyIndexFieldData , IndexNumericFieldData valueIndexFieldData , SearchScript valueScript , int size , int shardSize , TermsStatsFacet . ComparatorType comparatorType , SearchContext context ) { } @ Override public TermsStatsStringFacetExecutor . Collector collector ( ) { } @ Override public InternalFacet buildFacet ( String facetName ) { } class Collector extends FacetExecutor . Collector { private final TermsStatsStringFacetExecutor . Aggregator aggregator ; private BytesValues keyValues ; public Collector ( ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext context ) throws IOException { <START_BUG> keyValues = keyIndexFieldData . load ( context ) . getBytesValues ( ) ; <END_BUG> if ( ( script ) != null ) { script . setNextReader ( context ) ; } else { aggregator . valueValues = valueIndexFieldData . load ( context ) . getDoubleValues ( ) ; } } @ Override public void collect ( int doc ) throws IOException { } @ Override public void postCollection ( ) { } } public static class Aggregator extends HashedAggregator { final ObjectObjectOpenHashMap < HashedBytesRef , InternalTermsStatsStringFacet . StringEntry > entries ; final HashedBytesRef spare = new HashedBytesRef ( ) ; int missing = 0 ; DoubleValues valueValues ; TermsStatsStringFacetExecutor . Aggregator . ValueAggregator valueAggregator = new TermsStatsStringFacetExecutor . Aggregator . ValueAggregator ( ) ; public Aggregator ( ObjectObjectOpenHashMap < HashedBytesRef , InternalTermsStatsStringFacet . StringEntry > entries ) { } @ Override public void onValue ( int docId , BytesRef value , int hashCode , BytesValues values ) { } public static class ValueAggregator extends DoubleFacetAggregatorBase { StringEntry stringEntry ; @ Override public void onValue ( int docId , double value ) { } } } public static class ScriptAggregator extends TermsStatsStringFacetExecutor . Aggregator { private final SearchScript script ; public ScriptAggregator ( ObjectObjectOpenHashMap < HashedBytesRef , InternalTermsStatsStringFacet . StringEntry > entries , SearchScript script ) { } @ Override public void onValue ( int docId , BytesRef value , int hashCode , BytesValues values ) { } } }
public class GwtTestStarter extends GwtApplication { @ Override public GwtApplicationConfiguration getConfig ( ) { <START_BUG> return new GwtApplicationConfiguration ( 480 , 320 ) ; <END_BUG> } @ Override public ApplicationListener getApplicationListener ( ) { } }
public class Container < T extends Actor > extends WidgetGroup { private T actor ; private Value minWidth = Value . minWidth ; private Value minHeight = Value . minHeight ; private Value prefWidth = Value . prefWidth ; private Value prefHeight = Value . prefHeight ; private Value maxWidth = Value . zero ; private Value maxHeight = Value . zero ; private Value padTop = Value . zero ; private Value padLeft = Value . zero ; private Value padBottom = Value . zero ; private Value padRight = Value . zero ; private float fillX ; private float fillY ; private int align ; private Drawable background ; private boolean clip ; private boolean round = true ; public Container ( ) { } public Container ( T actor ) { } public void draw ( Batch batch , float parentAlpha ) { } protected void drawBackground ( Batch batch , float parentAlpha , float x , float y ) { } public void setBackground ( Drawable background ) { } public void setBackground ( Drawable background , boolean adjustPadding ) { if ( ( this . background ) == background ) return ; this . background = background ; if ( adjustPadding ) { if ( background == null ) <START_BUG> pad ( null ) ; <END_BUG> else pad ( background . getTopHeight ( ) , background . getLeftWidth ( ) , background . getBottomHeight ( ) , background . getRightWidth ( ) ) ; Container . invalidate ( ) ; } } public Container < T > background ( Drawable background ) { } public Drawable getBackground ( ) { } public void layout ( ) { } public void setActor ( T actor ) { } public T getActor ( ) { } public void addActor ( Actor actor ) { } public void addActorAt ( int index , Actor actor ) { } public void addActorBefore ( Actor actorBefore , Actor actor ) { } public void addActorAfter ( Actor actorAfter , Actor actor ) { } public boolean removeActor ( Actor actor ) { } public Container < T > size ( Value size ) { } public Container < T > size ( Value width , Value height ) { } public Container < T > size ( float size ) { } public Container < T > size ( float width , float height ) { } public Container < T > width ( Value width ) { } public Container < T > width ( float width ) { } public Container < T > height ( Value height ) { } public Container < T > height ( float height ) { } public Container < T > minSize ( Value size ) { } public Container < T > minSize ( Value width , Value height ) { } public Container < T > minWidth ( Value minWidth ) { } public Container < T > minHeight ( Value minHeight ) { } public Container < T > minSize ( float size ) { } public Container < T > minSize ( float width , float height ) { } public Container < T > minWidth ( float minWidth ) { } public Container < T > minHeight ( float minHeight ) { } public Container < T > prefSize ( Value size ) { } public Container < T > prefSize ( Value width , Value height ) { } public Container < T > prefWidth ( Value prefWidth ) { } public Container < T > prefHeight ( Value prefHeight ) { } public Container < T > prefSize ( float width , float height ) { } public Container < T > prefSize ( float size ) { } public Container < T > prefWidth ( float prefWidth ) { } public Container < T > prefHeight ( float prefHeight ) { } public Container < T > maxSize ( Value size ) { } public Container < T > maxSize ( Value width , Value height ) { } public Container < T > maxWidth ( Value maxWidth ) { } public Container < T > maxHeight ( Value maxHeight ) { } public Container < T > maxSize ( float size ) { } public Container < T > maxSize ( float width , float height ) { } public Container < T > maxWidth ( float maxWidth ) { } public Container < T > maxHeight ( float maxHeight ) { } public Container < T > pad ( Value pad ) { } public Container < T > pad ( Value top , Value left , Value bottom , Value right ) { } public Container < T > padTop ( Value padTop ) { } public Container < T > padLeft ( Value padLeft ) { } public Container < T > padBottom ( Value padBottom ) { } public Container < T > padRight ( Value padRight ) { } public Container < T > pad ( float pad ) { } public Container < T > pad ( float top , float left , float bottom , float right ) { } public Container < T > padTop ( float padTop ) { } public Container < T > padLeft ( float padLeft ) { } public Container < T > padBottom ( float padBottom ) { } public Container < T > padRight ( float padRight ) { } public Container < T > fill ( ) { } public Container < T > fillX ( ) { } public Container < T > fillY ( ) { } public Container < T > fill ( float x , float y ) { } public Container < T > fill ( boolean x , boolean y ) { } public Container < T > fill ( boolean fill ) { }
public class AnimationController extends BaseAnimationController { public interface AnimationListener { void onEnd ( final AnimationController . AnimationDesc animation ) { } void onLoop ( final AnimationController . AnimationDesc animation ) { } } public static class AnimationDesc { public AnimationController . AnimationListener listener ; public Animation animation ; public float speed ; public float time ; public float offset ; public float duration ; public int loopCount ; protected AnimationDesc ( ) { } protected float update ( float delta ) { } } protected final Pool < AnimationController . AnimationDesc > animationPool = new Pool < AnimationController . AnimationDesc > ( ) { @ Override protected AnimationController . AnimationDesc newObject ( ) { } } ; public AnimationController . AnimationDesc current ; public AnimationController . AnimationDesc queued ; public float queuedTransitionTime ; public AnimationController . AnimationDesc previous ; public float transitionCurrentTime ; public float transitionTargetTime ; public boolean inAction ; public boolean paused ; public boolean allowSameAnimation ; private boolean justChangedAnimation = false ; public AnimationController ( final ModelInstance target ) { } private AnimationController . AnimationDesc obtain ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener ) { } private AnimationController . AnimationDesc obtain ( final String id , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener ) { } private AnimationController . AnimationDesc obtain ( final AnimationController . AnimationDesc anim ) { } private boolean updating ; public void update ( float delta ) { } public AnimationController . AnimationDesc setAnimation ( final String id ) { } public AnimationController . AnimationDesc setAnimation ( final String id , int loopCount ) { } public AnimationController . AnimationDesc setAnimation ( final String id , final AnimationController . AnimationListener listener ) { } public AnimationController . AnimationDesc setAnimation ( final String id , int loopCount , final AnimationController . AnimationListener listener ) { } public AnimationController . AnimationDesc setAnimation ( final String id , int loopCount , float speed , final AnimationController . AnimationListener listener ) { } public AnimationController . AnimationDesc setAnimation ( final String id , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener ) { } protected AnimationController . AnimationDesc setAnimation ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener ) { } protected AnimationController . AnimationDesc setAnimation ( final AnimationController . AnimationDesc anim ) { if ( updating ) throw new GdxRuntimeException ( "Cannot<seq2seq4repair_space>change<seq2seq4repair_space>animation<seq2seq4repair_space>during<seq2seq4repair_space>update" ) ; if ( ( current ) == null ) current = anim ; else { <START_BUG> if ( ( anim != null ) && ( ( current . animation ) == ( anim . animation ) ) ) <END_BUG> anim . time = current . time ; else removeAnimation ( current . animation ) ; animationPool . free ( current ) ; current = anim ; } justChangedAnimation = true ; return anim ; } public AnimationController . AnimationDesc animate ( final String id , float transitionTime ) { } public AnimationController . AnimationDesc animate ( final String id , final AnimationController . AnimationListener listener , float transitionTime ) { } public AnimationController . AnimationDesc animate ( final String id , int loopCount , final AnimationController . AnimationListener listener , float transitionTime ) { } public AnimationController . AnimationDesc animate ( final String id , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } public AnimationController . AnimationDesc animate ( final String id , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc animate ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc animate ( final AnimationController . AnimationDesc anim , float transitionTime ) { } public AnimationController . AnimationDesc queue ( final String id , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } public AnimationController . AnimationDesc queue ( final String id , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc queue ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc queue ( final AnimationController . AnimationDesc anim , float transitionTime ) { } public AnimationController . AnimationDesc action ( final String id , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } public AnimationController . AnimationDesc action ( final String id , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc action ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationController . AnimationListener listener , float transitionTime ) { } protected AnimationController . AnimationDesc action ( final AnimationController . AnimationDesc anim , float transitionTime ) { } }
public interface ZenPing extends LifecycleComponent < ZenPing > { void setNodesProvider ( DiscoveryNodesProvider nodesProvider ) { } void ping ( ZenPing . PingListener listener , TimeValue timeout ) throws ElasticSearchException { } public interface PingListener { void onPing ( ZenPing . PingResponse [ ] pings ) { } } public class PingResponse implements Streamable { private ClusterName clusterName ; private DiscoveryNode target ; private DiscoveryNode master ; private PingResponse ( ) { } public PingResponse ( DiscoveryNode target , DiscoveryNode master , ClusterName clusterName ) { } public ClusterName clusterName ( ) { } public DiscoveryNode target ( ) { } public DiscoveryNode master ( ) { } public static ZenPing . PingResponse readPingResponse ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } @ Override public String toString ( ) { <START_BUG> return ( ( ( "ping_response<seq2seq4repair_space>target<seq2seq4repair_space>[" + ( target ) ) + "],<seq2seq4repair_space>master<seq2seq4repair_space>[" ) + ( master ) ) + "]" ; <END_BUG> } } }
public class NettyMemcachedServerTransport extends AbstractLifecycleComponent < MemcachedServerTransport > implements MemcachedServerTransport { private final RestController restController ; private final NetworkService networkService ; private final int workerCount ; private final boolean blockingServer ; private final String port ; private final String bindHost ; private final String publishHost ; private final Boolean tcpNoDelay ; private final Boolean tcpKeepAlive ; private final Boolean reuseAddress ; private final ByteSizeValue tcpSendBufferSize ; private final ByteSizeValue tcpReceiveBufferSize ; private volatile ServerBootstrap serverBootstrap ; private volatile BoundTransportAddress boundAddress ; private volatile Channel serverChannel ; private volatile OpenChannelsHandler serverOpenChannels ; @ Inject public NettyMemcachedServerTransport ( Settings settings , RestController restController , NetworkService networkService ) { } @ Override public BoundTransportAddress boundAddress ( ) { } @ Override protected void doStart ( ) throws ElasticSearchException { this . serverOpenChannels = new OpenChannelsHandler ( ) ; if ( blockingServer ) { serverBootstrap = new ServerBootstrap ( new org . elasticsearch . common . netty . channel . socket . oio . OioServerSocketChannelFactory ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , "memcached_server_boss" ) ) , Executors . newCachedThreadPool ( daemonThreadFactory ( settings , "memcached_server_worker" ) ) ) ) ; } else { serverBootstrap = new ServerBootstrap ( new org . elasticsearch . common . netty . channel . socket . nio . NioServerSocketChannelFactory ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , "memcached_server_boss" ) ) , Executors . newCachedThreadPool ( daemonThreadFactory ( settings , "memcached_server_worker" ) ) , workerCount ) ) ; } ChannelPipelineFactory pipelineFactory = new ChannelPipelineFactory ( ) { @ Override public ChannelPipeline getPipeline ( ) throws Exception { ChannelPipeline pipeline = Channels . pipeline ( ) ; pipeline . addLast ( "openChannels" , serverOpenChannels ) ; <START_BUG> pipeline . addLast ( "decoder" , new MemcachedDecoder ( ) ) ; <END_BUG> pipeline . addLast ( "dispatcher" , new MemcachedDispatcher ( restController ) ) ; return pipeline ; } } ; serverBootstrap . setPipelineFactory ( pipelineFactory ) ; if ( ( tcpNoDelay ) != null ) { serverBootstrap . setOption ( "child.tcpNoDelay" , tcpNoDelay ) ; } if ( ( tcpKeepAlive ) != null ) { serverBootstrap . setOption ( "child.keepAlive" , tcpKeepAlive ) ; } if ( ( tcpSendBufferSize ) != null ) { serverBootstrap . setOption ( "child.sendBufferSize" , tcpSendBufferSize . bytes ( ) ) ; } if ( ( tcpReceiveBufferSize ) != null ) { serverBootstrap . setOption ( "child.receiveBufferSize" , tcpReceiveBufferSize . bytes ( ) ) ; } if ( ( reuseAddress ) != null ) { serverBootstrap . setOption ( "reuseAddress" , reuseAddress ) ; serverBootstrap . setOption ( "child.reuseAddress" , reuseAddress ) ; } InetAddress hostAddressX ; try { hostAddressX = networkService . resolveBindHostAddress ( bindHost ) ; } catch ( IOException e ) { throw new BindHttpException ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>resolve<seq2seq4repair_space>host<seq2seq4repair_space>[" + ( bindHost ) ) + "]" ) , e ) ; } final InetAddress hostAddress = hostAddressX ; PortsRange portsRange = new PortsRange ( port ) ; final AtomicReference < Exception > lastException = new AtomicReference < Exception > ( ) ; boolean success = portsRange . iterate ( new PortsRange . PortCallback ( ) { @ Override public boolean onPortNumber ( int portNumber ) { try { serverChannel = serverBootstrap . bind ( new InetSocketAddress ( hostAddress , portNumber ) ) ; } catch ( Exception e ) { lastException . set ( e ) ; return false ; } return true ; } } ) ; if ( ! success ) { throw new BindHttpException ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>bind<seq2seq4repair_space>to<seq2seq4repair_space>[" + ( port ) ) + "]" ) , lastException . get ( ) ) ; } InetSocketAddress boundAddress = ( ( InetSocketAddress ) ( serverChannel . getLocalAddress ( ) ) ) ; InetSocketAddress publishAddress ; try { publishAddress = new InetSocketAddress ( networkService . resolvePublishHostAddress ( publishHost ) , boundAddress . getPort ( ) ) ; } catch ( Exception e ) { throw new BindTransportException ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>resolve<seq2seq4repair_space>publish<seq2seq4repair_space>address" , e ) ; } this . boundAddress = new BoundTransportAddress ( new InetSocketTransportAddress ( boundAddress ) , new InetSocketTransportAddress ( publishAddress ) ) ; } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } }
public class IOSApplication implements Application { public static abstract class Delegate extends UIApplicationDelegate . Adapter { private IOSApplication app ; protected abstract IOSApplication createApplication ( ) { } @ Override public boolean didFinishLaunching ( UIApplication application , NSDictionary launchOptions ) { } @ Override public void didBecomeActive ( UIApplication application ) { } @ Override public void willResignActive ( UIApplication application ) { } @ Override public void willTerminate ( UIApplication application ) { } } UIApplication uiApp ; UIWindow uiWindow ; ApplicationListener listener ; IOSApplicationConfiguration config ; IOSGraphics graphics ; IOSAudio audio ; IOSFiles files ; IOSInput input ; IOSNet net ; int logLevel = Application . LOG_DEBUG ; float displayScaleFactor ; Array < Runnable > runnables = new Array < Runnable > ( ) ; Array < Runnable > executedRunnables = new Array < Runnable > ( ) ; Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; public IOSApplication ( ApplicationListener listener , IOSApplicationConfiguration config ) { } final boolean didFinishLaunching ( UIApplication uiApp , NSDictionary options ) { } public UIViewController getUIViewController ( ) { } CGSize getBounds ( UIViewController viewController ) { } final void didBecomeActive ( UIApplication uiApp ) { } final void willResignActive ( UIApplication uiApp ) { } final void willTerminate ( UIApplication uiApp ) { } @ Override public ApplicationListener getApplicationListener ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Input getInput ( ) { } @ Override public Files getFiles ( ) { } @ Override public Net getNet ( ) { } @ Override public void log ( String tag , String message ) { } @ Override <START_BUG> public void log ( String tag , String message , Exception exception ) { <END_BUG> if ( ( logLevel ) > ( LOG_NONE ) ) { System . out . println ( ( ( ( "[info]<seq2seq4repair_space>" + tag ) + ":<seq2seq4repair_space>" ) + message ) ) ; exception . printStackTrace ( ) ; } } @ Override public void error ( String tag , String message ) { } @ Override public void error ( String tag , String message , Throwable exception ) { } @ Override public void debug ( String tag , String message ) { } @ Override public void debug ( String tag , String message , Throwable exception ) { } @ Override public void setLogLevel ( int logLevel ) { } @ Override public int getLogLevel ( ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } @ Override public Preferences getPreferences ( String name ) { } @ Override public void postRunnable ( Runnable runnable ) { } public void processRunnables ( ) { } @ Override public void exit ( ) { } @ Override public Clipboard getClipboard ( ) { } @ Override public void addLifecycleListener ( LifecycleListener listener ) { } @ Override public void removeLifecycleListener ( LifecycleListener listener ) { } }
public class DynamicTemplate { public static enum MatchType { SIMPLE , REGEX ; public static DynamicTemplate . MatchType fromString ( String value ) { } } public static DynamicTemplate parse ( String name , Map < String , Object > conf ) throws MapperParsingException { } private final String name ; private final Map < String , Object > conf ; private final String pathMatch ; private final String pathUnmatch ; private final String match ; private final String unmatch ; private final DynamicTemplate . MatchType matchType ; private final String matchMappingType ; private final Map < String , Object > mapping ; public DynamicTemplate ( String name , Map < String , Object > conf , String pathMatch , String pathUnmatch , String match , String unmatch , String matchMappingType , DynamicTemplate . MatchType matchType , Map < String , Object > mapping ) { } public String name ( ) { } public Map < String , Object > conf ( ) { } public boolean match ( ContentPath path , String name , String dynamicType ) { } public boolean hasType ( ) { } public String mappingType ( String dynamicType ) { <START_BUG> return mapping . containsKey ( "type" ) ? mapping . get ( "type" ) . toString ( ) : dynamicType ; <END_BUG> } private boolean patternMatch ( String pattern , String str ) { } public Map < String , Object > mappingForName ( String name , String dynamicType ) { } private Map < String , Object > processMap ( Map < String , Object > map , String name , String dynamicType ) { } private List processList ( List list , String name , String dynamicType ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } }
public class Rectangle implements Serializable { public static final Rectangle tmp = new Rectangle ( ) ; public static final Rectangle tmp2 = new Rectangle ( ) ; private static final long serialVersionUID = 5733252015138115702L ; public float x ; public float y ; public float width ; public float height ; public Rectangle ( ) { } public Rectangle ( float x , float y , float width , float height ) { } public Rectangle ( Rectangle rect ) { } public void set ( float x , float y , float width , float height ) { } public float getX ( ) { } public void setX ( float x ) { } public float getY ( ) { } public void setY ( float y ) { } public float getWidth ( ) { } public void setWidth ( float width ) { } public float getHeight ( ) { } public void setHeight ( float height ) { } public boolean contains ( float x , float y ) { <START_BUG> return ( ( ( ( this . x ) < x ) && ( ( ( this . x ) + ( this . width ) ) > x ) ) && ( ( this . y ) < y ) ) && ( ( ( this . y ) + ( this . height ) ) > y ) ; <END_BUG> } public boolean contains ( Rectangle rectangle ) { } public boolean overlaps ( Rectangle r ) { } public void set ( Rectangle rect ) { } public void merge ( Rectangle rect ) { } public String toString ( ) { } }
public class Material implements Iterable < Material . Attribute > , Comparator < Material . Attribute > { public static abstract class Attribute { protected static long register ( final String type ) { } public final long type ; protected Attribute ( final long type ) { } public abstract Material . Attribute copy ( ) { } protected abstract boolean equals ( Material . Attribute other ) { } @ Override public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( obj == ( this ) ) return true ; if ( ! ( obj instanceof Material . Attribute ) ) return false ; final Material . Attribute other = ( ( Material . Attribute ) ( obj ) ) ; <START_BUG> if ( ( this . type ) != ( other . type ) ) <END_BUG> return false ; return equals ( other ) ; } @ Override public String toString ( ) { } } private static final Array < String > types = new Array < String > ( ) ; private static int counter = 0 ; protected static final long getAttributeType ( final String alias ) { } protected static final String getAttributeAlias ( final long type ) { } protected static final long register ( final String alias ) { } public String id ; protected long mask ; protected final Array < Material . Attribute > attributes = new Array < Material . Attribute > ( ) ; protected boolean sorted = true ; public Material ( ) { } public Material ( final String id ) { } public Material ( final Material . Attribute ... attributes ) { } public Material ( final String id , final Material . Attribute ... attributes ) { } public Material ( final Array < Material . Attribute > attributes ) { } public Material ( final String id , final Array < Material . Attribute > attributes ) { } public Material ( final Material copyFrom ) { } public Material ( final String id , final Material copyFrom ) { } private final void enable ( final long mask ) { } private final void disable ( final long mask ) { } public final long getMask ( ) { } public final boolean has ( final long type ) { } protected int indexOf ( final long type ) { } public final void set ( final Material . Attribute attribute ) { } public final void set ( final Material . Attribute ... attributes ) { } public final void set ( final Iterable < Material . Attribute > attributes ) { } public final void remove ( final long mask ) { } public final Material . Attribute get ( final long type ) { } public final Array < Material . Attribute > get ( final Array < Material . Attribute > out , final long type ) { } public final void clear ( ) { } public int size ( ) { } public final Material copy ( ) { } @ Override public final int compare ( final Material . Attribute arg0 , final Material . Attribute arg1 ) { } public final void sort ( ) { } public final boolean same ( final Material other , boolean compareValues ) { } public final boolean same ( final Material other ) { } public final boolean equals ( final Material other ) { } @ Override public final boolean equals ( final Object obj ) { return obj instanceof Material ? equals ( ( ( Material ) ( obj ) ) ) : false ; } @ Override public final Iterator < Material . Attribute > iterator ( ) { } }
public class EsAbortPolicy implements RejectedExecutionHandler { public static final EsAbortPolicy INSTANCE = new EsAbortPolicy ( ) ; @ Override public void rejectedExecution ( Runnable r , ThreadPoolExecutor executor ) { <START_BUG> throw new EsRejectedExecutionException ( ) ; <END_BUG> } }
public class FilterFacetParser extends AbstractComponent implements FacetParser { @ Inject public FilterFacetParser ( Settings settings ) { } @ Override public String [ ] types ( ) { } @ Override public Mode defaultMainMode ( ) { } @ Override public Mode defaultGlobalMode ( ) { } @ Override public FacetExecutor parse ( String facetName , XContentParser parser , SearchContext context ) throws IOException { <START_BUG> Filter facetFilter = context . queryParserService ( ) . parseInnerFilter ( parser ) ; <END_BUG> return new FilterFacetExecutor ( facetFilter ) ; } }
public class RestFilterChainTests extends ElasticsearchTestCase { @ Test public void testRestFilters ( ) throws InterruptedException { RestController restController = new RestController ( ImmutableSettings . EMPTY ) ; int numFilters = randomInt ( 10 ) ; Set < Integer > orders = new HashSet < > ( numFilters ) ; while ( ( orders . size ( ) ) < numFilters ) { orders . add ( randomInt ( 10 ) ) ; } List < RestFilter > filters = new ArrayList < > ( ) ; for ( Integer order : orders ) { RestFilterChainTests . TestFilter testFilter = new RestFilterChainTests . TestFilter ( order , randomFrom ( RestFilterChainTests . Operation . values ( ) ) ) ; filters . add ( testFilter ) ; restController . registerFilter ( testFilter ) ; } ArrayList < RestFilter > restFiltersByOrder = Lists . newArrayList ( filters ) ; Collections . sort ( restFiltersByOrder , new Comparator < RestFilter > ( ) { @ Override public int compare ( RestFilter o1 , RestFilter o2 ) { <START_BUG> return Integer . compare ( o2 . order ( ) , o1 . order ( ) ) ; <END_BUG> } } ) ; List < RestFilter > expectedRestFilters = Lists . newArrayList ( ) ; for ( RestFilter filter : restFiltersByOrder ) { RestFilterChainTests . TestFilter testFilter = ( ( RestFilterChainTests . TestFilter ) ( filter ) ) ; expectedRestFilters . add ( testFilter ) ; if ( ! ( ( testFilter . callback ) == ( RestFilterChainTests . Operation . CONTINUE_PROCESSING ) ) ) { break ; } } restController . registerHandler ( GET , "/" , new RestHandler ( ) { @ Override public void handleRequest ( RestRequest request , RestChannel channel ) throws Exception { channel . sendResponse ( new RestFilterChainTests . TestResponse ( ) ) ; } } ) ; FakeRestRequest fakeRestRequest = new FakeRestRequest ( ) ; RestFilterChainTests . FakeRestChannel fakeRestChannel = new RestFilterChainTests . FakeRestChannel ( fakeRestRequest , 1 ) ; restController . dispatchRequest ( fakeRestRequest , fakeRestChannel ) ; assertThat ( fakeRestChannel . await ( ) , equalTo ( true ) ) ; List < RestFilterChainTests . TestFilter > testFiltersByLastExecution = Lists . newArrayList ( ) ; for ( RestFilter restFilter : filters ) { testFiltersByLastExecution . add ( ( ( RestFilterChainTests . TestFilter ) ( restFilter ) ) ) ; } Collections . sort ( testFiltersByLastExecution , new Comparator < RestFilterChainTests . TestFilter > ( ) { @ Override public int compare ( RestFilterChainTests . TestFilter o1 , RestFilterChainTests . TestFilter o2 ) { return Long . compare ( o1 . executionToken , o2 . executionToken ) ; } } ) ; ArrayList < RestFilterChainTests . TestFilter > finalTestFilters = Lists . newArrayList ( ) ; for ( RestFilter filter : testFiltersByLastExecution ) { RestFilterChainTests . TestFilter testFilter = ( ( RestFilterChainTests . TestFilter ) ( filter ) ) ; finalTestFilters . add ( testFilter ) ; if ( ! ( ( testFilter . callback ) == ( RestFilterChainTests . Operation . CONTINUE_PROCESSING ) ) ) { break ; } } assertThat ( finalTestFilters . size ( ) , equalTo ( expectedRestFilters . size ( ) ) ) ; for ( int i = 0 ; i < ( finalTestFilters . size ( ) ) ; i ++ ) { RestFilterChainTests . TestFilter testFilter = finalTestFilters . get ( i ) ; assertThat ( testFilter , equalTo ( expectedRestFilters . get ( i ) ) ) ; assertThat ( testFilter . runs . get ( ) , equalTo ( 1 ) ) ; } } @ Test public void testTooManyContinueProcessing ( ) throws InterruptedException { } private static class FakeRestChannel extends RestChannel { private final CountDownLatch latch ; AtomicInteger responses = new AtomicInteger ( ) ; AtomicInteger errors = new AtomicInteger ( ) ; protected FakeRestChannel ( RestRequest request , int responseCount ) { } @ Override public XContentBuilder newBuilder ( ) throws IOException { } @ Override public XContentBuilder newBuilder ( @ Nullable BytesReference autoDetectSource ) throws IOException { } @ Override protected BytesStreamOutput newBytesOutput ( ) { } @ Override public RestRequest request ( ) { } @ Override public void sendResponse ( RestResponse response ) { } public boolean await ( ) throws InterruptedException { } } private static enum Operation implements RestFilterChainTests . Callback { CONTINUE_PROCESSING ( ) { @ Override public void execute ( RestRequest request , RestChannel channel , RestFilterChain filterChain ) throws Exception { } } , CHANNEL_RESPONSE ( ) { @ Override public void execute ( RestRequest request , RestChannel channel , RestFilterChain filterChain ) throws Exception { } } ; } private static interface Callback { void execute ( RestRequest request , RestChannel channel , RestFilterChain filterChain ) throws Exception { } } private final AtomicInteger counter = new AtomicInteger ( ) ; private class TestFilter extends RestFilter { private final int order ; private final RestFilterChainTests . Callback callback ; AtomicInteger runs = new AtomicInteger ( ) ; volatile int executionToken = Integer . MAX_VALUE ; TestFilter ( int order , RestFilterChainTests . Callback callback ) { } @ Override public void process ( RestRequest request , RestChannel channel , RestFilterChain filterChain ) throws Exception { } @ Override public int order ( ) { } @ Override public String toString ( ) { } } private static class TestResponse extends RestResponse { @ Override public String contentType ( ) { } @ Override public boolean contentThreadSafe ( ) { } @ Override public BytesReference content ( ) { } @ Override public RestStatus status ( ) { } } }
public class DepthTestAttribute extends Attribute { public static final String Alias = "depthStencil" ; public static final long Type = register ( DepthTestAttribute . Alias ) ; protected static long Mask = DepthTestAttribute . Type ; public static final boolean is ( final long mask ) { } public int depthFunc ; public float depthRangeNear ; public float depthRangeFar ; public boolean depthMask ; public DepthTestAttribute ( ) { } public DepthTestAttribute ( boolean depthMask ) { } public DepthTestAttribute ( final int depthFunc ) { } public DepthTestAttribute ( int depthFunc , boolean depthMask ) { } public DepthTestAttribute ( int depthFunc , float depthRangeNear , float depthRangeFar ) { } public DepthTestAttribute ( int depthFunc , float depthRangeNear , float depthRangeFar , boolean depthMask ) { } public DepthTestAttribute ( final long type , int depthFunc , float depthRangeNear , float depthRangeFar , boolean depthMask ) { } public DepthTestAttribute ( final DepthTestAttribute rhs ) { } @ Override public Attribute copy ( ) { } @ Override public int hashCode ( ) { <START_BUG> int result = ( ( int ) ( type ) ) ; <END_BUG> result = ( 971 * result ) + ( depthFunc ) ; result = ( 971 * result ) + ( NumberUtils . floatToRawIntBits ( depthRangeNear ) ) ; result = ( 971 * result ) + ( NumberUtils . floatToRawIntBits ( depthRangeFar ) ) ; result = ( 971 * result ) + ( depthMask ? 1 : 0 ) ; return result ; } }
public class IntSet { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; private static final int EMPTY = 0 ; public int size ; int [ ] keyTable ; int capacity ; int stashSize ; boolean hasZeroValue ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private IntSet . IntSetIterator iterator1 ; private IntSet . IntSetIterator iterator2 ; public IntSet ( ) { } public IntSet ( int initialCapacity ) { } public IntSet ( int initialCapacity , float loadFactor ) { } public IntSet ( IntSet map ) { } public boolean add ( int key ) { } public void addAll ( IntArray array ) { } public void addAll ( IntArray array , int offset , int length ) { } public void addAll ( int ... array ) { } public void addAll ( int [ ] array , int offset , int length ) { } public void addAll ( IntSet set ) { } private void addResize ( int key ) { } private void push ( int insertKey , int index1 , int key1 , int index2 , int key2 , int index3 , int key3 ) { } private void addStash ( int key ) { } public boolean remove ( int key ) { } boolean removeStash ( int key ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean contains ( int key ) { } private boolean containsKeyStash ( int key ) { } public int first ( ) { if ( hasZeroValue ) return 0 ; int [ ] keyTable = this . keyTable ; <START_BUG> for ( int i = 0 , n = ( capacity ) + ( stashSize ) ; i < n ; ) <END_BUG> if ( ( keyTable [ i ] ) != ( IntSet . EMPTY ) ) return keyTable [ i ] ; throw new IllegalStateException ( "IntSet<seq2seq4repair_space>is<seq2seq4repair_space>empty." ) ; } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public IntSet . IntSetIterator iterator ( ) { } public static IntSet with ( int ... array ) { } public static class Entry < V > { public int key ; public V value ; public String toString ( ) { } } public static class IntSetIterator { static final int INDEX_ILLEGAL = - 2 ; static final int INDEX_ZERO = - 1 ; public boolean hasNext ; final IntSet set ; int nextIndex ; int currentIndex ; boolean valid = true ; public IntSetIterator ( IntSet set ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { } public int next ( ) { } public IntArray toArray ( ) { } } }
public class JoglGraphics extends JoglGraphicsBase implements GLEventListener { ApplicationListener listener = null ; boolean useGL2 ; boolean created = false ; public JoglGraphics ( ApplicationListener listener , String title , int width , int height , boolean useGL2 ) { } public void create ( ) { } public void pause ( ) { } public void resume ( ) { } @ Override public void init ( GLAutoDrawable drawable ) { } @ Override public void reshape ( GLAutoDrawable drawable , int x , int y , int width , int height ) { } @ Override public void display ( GLAutoDrawable arg0 ) { } @ Override public void displayChanged ( GLAutoDrawable arg0 , boolean arg1 , boolean arg2 ) { } public void destroy ( ) { canvas . getContext ( ) . makeCurrent ( ) ; <START_BUG> listener . destroy ( ) ; <END_BUG> } }
public class BumperElement extends FieldElement { Body pegBody ; Collection pegBodySet ; float radius ; float cx ; float cy ; float kick ; public void finishCreate ( Map params , World world ) { } @ Override public Collection getBodies ( ) { } @ Override public boolean shouldCallTick ( ) { } Vector2 impulseForBall ( Body ball ) { } @ Override public void handleCollision ( Body ball , Body bodyHit , Field field ) { Vector2 impulse = this . impulseForBall ( ball ) ; if ( impulse != null ) { <START_BUG> ball . applyLinearImpulse ( impulse , ball . getWorldCenter ( ) , true ) ; <END_BUG> flashForFrames ( 3 ) ; } } @ Override public void draw ( IFieldRenderer renderer ) { } }
public class JsonValue { private String name ; private JsonValue . ValueType type ; private String stringValue ; private Boolean booleanValue ; private Double doubleValue ; private long longValue ; private JsonValue child ; private JsonValue next ; private JsonValue prev ; public JsonValue ( JsonValue . ValueType type ) { } public JsonValue ( String value ) { } public JsonValue ( double value ) { } public JsonValue ( long value ) { } public JsonValue ( boolean value ) { } public JsonValue get ( int index ) { } public JsonValue get ( String name ) { } public JsonValue require ( int index ) { } public JsonValue require ( String name ) { } public JsonValue remove ( int index ) { } public JsonValue remove ( String name ) { } public int size ( ) { } public String asString ( ) { if ( ( stringValue ) != null ) return stringValue ; if ( ( doubleValue ) != null ) { <START_BUG> if ( ( doubleValue ) == ( longValue ) ) <END_BUG> return Long . toString ( longValue ) ; return Double . toString ( doubleValue ) ; } if ( ( booleanValue ) != null ) return Boolean . toString ( booleanValue ) ; if ( ( type ) == ( JsonValue . ValueType . nullValue ) ) return null ; throw new IllegalStateException ( ( "Value<seq2seq4repair_space>cannot<seq2seq4repair_space>be<seq2seq4repair_space>converted<seq2seq4repair_space>to<seq2seq4repair_space>string:<seq2seq4repair_space>" + ( type ) ) ) ; } public float asFloat ( ) { } public double asDouble ( ) { } public long asLong ( ) { } public int asInt ( ) { } public boolean asBoolean ( ) { } public JsonValue getChild ( String name ) { } public String getString ( String name , String defaultValue ) { } public float getFloat ( String name , float defaultValue ) { } public double getDouble ( String name , double defaultValue ) { } public long getLong ( String name , long defaultValue ) { } public int getInt ( String name , int defaultValue ) { } public boolean getBoolean ( String name , boolean defaultValue ) { } public String getString ( String name ) { } public float getFloat ( String name ) { } public double getDouble ( String name ) { } public long getLong ( String name ) { } public int getInt ( String name ) { } public boolean getBoolean ( String name ) { } public String getString ( int index ) { } public float getFloat ( int index ) { } public double getDouble ( int index ) { } public long getLong ( int index ) { } public int getInt ( int index ) { } public boolean getBoolean ( int index ) { } public JsonValue . ValueType type ( ) { } public void setType ( JsonValue . ValueType type ) { } public boolean isArray ( ) { } public boolean isObject ( ) { } public boolean isString ( ) { } public boolean isNumber ( ) { } public boolean isDouble ( ) { } public boolean isLong ( ) { } public boolean isBoolean ( ) { } public boolean isNull ( ) { } public boolean isValue ( ) { } public String name ( ) { } public void setName ( String name ) { } public JsonValue child ( ) { } public void addChild ( JsonValue newChild ) { } public JsonValue next ( ) { } public void setNext ( JsonValue next ) { } public JsonValue prev ( ) { } public void setPrev ( JsonValue prev ) { } public void set ( String value ) { } public void set ( double value ) { } public void set ( long value ) { } public void set ( boolean value ) { } public String toString ( ) { } public String prettyPrint ( OutputType outputType , int singleLineColumns ) { } private void prettyPrint ( JsonValue object , StringBuilder buffer , OutputType outputType , int indent , int singleLineColumns ) { } private static boolean isFlat ( JsonValue object ) { } private static boolean isFlat ( Array array ) { } private static void indent ( int count , StringBuilder buffer ) { } public enum ValueType { object , array , stringValue , doubleValue , longValue , booleanValue , nullValue ; } }
public class DefaultShaderProvider extends BaseShaderProvider { @ Override protected Shader createShader ( final Renderable renderable ) { app . log ( "DefaultShaderProvider" , "Creating<seq2seq4repair_space>new<seq2seq4repair_space>shader" ) ; if ( graphics . isGL20Available ( ) ) <START_BUG> return new com . badlogic . gdx . graphics . g3d . shaders . DefaultShader ( renderable . material , renderable . mesh . getVertexAttributes ( ) , ( ( renderable . lights ) != null ) , 2 , 5 , 3 , ( ( renderable . bones ) == null ? 0 : 12 ) ) ; <END_BUG> return new GLES10Shader ( ) ; } }
@ ThreadSafe public class MemoryTranslog extends AbstractIndexShardComponent implements Translog { private final Object mutex = new Object ( ) ; private final AtomicLong estimatedMemorySize = new AtomicLong ( ) ; private volatile long id ; private volatile Queue < Operation > operations ; private final AtomicInteger operationCounter = new AtomicInteger ( ) ; @ Inject public MemoryTranslog ( ShardId shardId , @ IndexSettings Settings indexSettings ) { } @ Override public long currentId ( ) { } @ Override public int size ( ) { <START_BUG> return operations . size ( ) ; <END_BUG> } @ Override public ByteSizeValue estimateMemorySize ( ) { } @ Override public void newTranslog ( long id ) { } @ Override public void add ( Operation operation ) throws TranslogException { } @ Override public Snapshot snapshot ( ) { } @ Override public Snapshot snapshot ( Snapshot snapshot ) { } @ Override public void close ( ) { } }
public class PluginManager { public static final class ACTION { public static final int NONE = 0 ; public static final int INSTALL = 1 ; public static final int REMOVE = 2 ; public static final int LIST = 3 ; } public enum OutputMode { DEFAULT , SILENT , VERBOSE ; } public static final TimeValue DEFAULT_TIMEOUT = TimeValue . timeValueMillis ( 0 ) ; private static final ImmutableSet < Object > BLACKLIST = ImmutableSet . builder ( ) . add ( "elasticsearch" , "elasticsearch.bat" , "elasticsearch.in.sh" , "plugin" , "plugin.bat" , "service.bat" ) . build ( ) ; private static final ImmutableSet < Object > VALID_TOP_LEVEL_PLUGIN_DIRS = ImmutableSet . builder ( ) . add ( "_site" , "bin" , "config" , "_dict" ) . build ( ) ; private final Environment environment ; private String url ; private PluginManager . OutputMode outputMode ; private TimeValue timeout ; public PluginManager ( Environment environment , String url , PluginManager . OutputMode outputMode , TimeValue timeout ) { } public void downloadAndExtract ( String name ) throws IOException { } public void removePlugin ( String name ) throws IOException { } private static void checkForForbiddenName ( String name ) { } public File [ ] getListInstalledPlugins ( ) { } public void listInstalledPlugins ( ) { } private boolean topLevelDirInExcess ( ZipFile zipFile ) { } private static final int EXIT_CODE_OK = 0 ; private static final int EXIT_CODE_CMD_USAGE = 64 ; private static final int EXIT_CODE_IO_ERROR = 74 ; private static final int EXIT_CODE_ERROR = 70 ; public static void main ( String [ ] args ) { } private static String getCommandValue ( String [ ] args , int arg , String flag ) { } private static void displayHelp ( String message ) { } private void debug ( String line ) { } private void log ( String line ) { } static class PluginHandle { final String name ; final String version ; final String user ; final String repo ; PluginHandle ( String name , String version , String user , String repo ) { } List < URL > urls ( ) { } private static void addUrl ( List < URL > urls , String url ) { } File distroFile ( Environment env ) { } File extractedDir ( Environment env ) { } File binDir ( Environment env ) { } File configDir ( Environment env ) { <START_BUG> return new File ( new File ( env . homeFile ( ) , "config" ) , name ) ; <END_BUG> } static PluginManager . PluginHandle parse ( String name ) { } } }
public class RestCountAction extends BaseRestHandler { @ Inject public RestCountAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { CountRequest countRequest = new CountRequest ( RestActions . splitIndices ( request . param ( "index" ) ) ) ; if ( request . hasParam ( "ignore_indices" ) ) { countRequest . ignoreIndices ( IgnoreIndices . fromString ( request . param ( "ignore_indices" ) ) ) ; } countRequest . listenerThreaded ( false ) ; try { BroadcastOperationThreading operationThreading = BroadcastOperationThreading . fromString ( request . param ( "operation_threading" ) , SINGLE_THREAD ) ; if ( operationThreading == ( BroadcastOperationThreading . NO_THREADS ) ) { operationThreading = BroadcastOperationThreading . SINGLE_THREAD ; } countRequest . operationThreading ( operationThreading ) ; if ( request . hasContent ( ) ) { countRequest . query ( request . content ( ) , request . contentUnsafe ( ) ) ; } else { String source = request . param ( "source" ) ; if ( source != null ) { countRequest . query ( source ) ; } else { BytesReference querySource = RestActions . parseQuerySource ( request ) ; if ( querySource != null ) { countRequest . query ( querySource , false ) ; } } } countRequest . routing ( request . param ( "routing" ) ) ; countRequest . minScore ( request . paramAsFloat ( "min_score" , DEFAULT_MIN_SCORE ) ) ; countRequest . types ( splitTypes ( request . param ( "type" ) ) ) ; countRequest . preference ( request . param ( "preference" ) ) ; } catch ( Exception e ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . BAD_REQUEST , builder . startObject ( ) . field ( "error" , e . getMessage ( ) ) . endObject ( ) ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } return ; } client . count ( countRequest , new org . elasticsearch . action . ActionListener < CountResponse > ( ) { @ Override public void onResponse ( CountResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) ; builder . field ( "count" , response . getCount ( ) ) ; buildBroadcastShardsHeader ( builder , response ) ; builder . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class PublishClusterStateAction extends AbstractComponent { public static interface NewClusterStateListener { void onNewClusterState ( ClusterState clusterState ) { } } private final TransportService transportService ; private final DiscoveryNodesProvider nodesProvider ; private final PublishClusterStateAction . NewClusterStateListener listener ; public PublishClusterStateAction ( Settings settings , TransportService transportService , DiscoveryNodesProvider nodesProvider , PublishClusterStateAction . NewClusterStateListener listener ) { } public void close ( ) { } public void publish ( ClusterState clusterState ) { } class PublishClusterStateRequest implements Streamable { BytesReference clusterStateInBytes ; private PublishClusterStateRequest ( ) { } private PublishClusterStateRequest ( byte [ ] clusterStateInBytes ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { <START_BUG> out . writeBytesReference ( clusterStateInBytes , true ) ; <END_BUG> } } private class PublishClusterStateRequestHandler extends BaseTransportRequestHandler < PublishClusterStateAction . PublishClusterStateRequest > { static final String ACTION = "discovery/zen/publish" ; @ Override public PublishClusterStateAction . PublishClusterStateRequest newInstance ( ) { } @ Override public void messageReceived ( PublishClusterStateAction . PublishClusterStateRequest request , TransportChannel channel ) throws Exception { } @ Override public String executor ( ) { } } }
public abstract class BlobStoreIndexGateway extends AbstractIndexComponent implements IndexGateway { private final BlobStoreGateway gateway ; private final BlobStore blobStore ; private final BlobPath indexPath ; protected ByteSizeValue chunkSize ; protected BlobStoreIndexGateway ( Index index , @ IndexSettings Settings indexSettings , Gateway gateway ) { } public ImmutableMap < String , BlobMetaData > listIndexBlobs ( int shardId ) throws IOException { ImmutableBlobContainer indexContainer = blobStore . immutableBlobContainer ( shardIndexPath ( shardId ) ) ; <START_BUG> return BlobStoreIndexShardGateway . aggregateParts ( indexContainer . listBlobs ( ) ) ; <END_BUG> } @ Override public String toString ( ) { } public BlobStore blobStore ( ) { } public BlobPath indexPath ( ) { } public ByteSizeValue chunkSize ( ) { } public BlobPath shardPath ( int shardId ) { } public BlobPath shardIndexPath ( int shardId ) { } public BlobPath shardTranslogPath ( int shardId ) { } @ Override public void close ( boolean delete ) throws ElasticSearchException { } }
public class IOSFileHandle extends FileHandle { public IOSFileHandle ( String fileName , FileType type ) { } public IOSFileHandle ( File file , FileType type ) { } public FileHandle child ( String name ) { } public FileHandle parent ( ) { } @ Override public boolean exists ( ) { <START_BUG> return file . exists ( ) ; <END_BUG> } public File file ( ) { } }
public class IndexingMemoryController extends AbstractLifecycleComponent < IndexingMemoryController > { private final ThreadPool threadPool ; private final IndicesService indicesService ; private final ByteSizeValue indexingBuffer ; private final ByteSizeValue minShardIndexBufferSize ; private final ByteSizeValue maxShardIndexBufferSize ; private final TimeValue inactiveTime ; private final TimeValue interval ; private final IndexingMemoryController . Listener listener = new IndexingMemoryController . Listener ( ) ; private final Map < ShardId , IndexingMemoryController . ShardIndexingStatus > shardsIndicesStatus = Maps . newHashMap ( ) ; private volatile ScheduledFuture scheduler ; private final Object mutex = new Object ( ) ; @ Inject public IndexingMemoryController ( Settings settings , ThreadPool threadPool , IndicesService indicesService ) { } @ Override protected void doStart ( ) throws ElasticSearchException { } @ Override protected void doStop ( ) throws ElasticSearchException { } @ Override protected void doClose ( ) throws ElasticSearchException { } class ShardsIndicesStatusChecker implements Runnable { @ Override public void run ( ) { } } class Listener extends IndicesLifecycle . Listener { @ Override public void afterIndexShardCreated ( IndexShard indexShard ) { } @ Override <START_BUG> public void afterIndexShardClosed ( ShardId shardId , boolean delete ) { <END_BUG> synchronized ( mutex ) { calcAndSetShardIndexingBuffer ( ( ( ( ( "removed_shard[" + ( shardId . index ( ) . name ( ) ) ) + "][" ) + ( shardId . id ( ) ) ) + "]" ) ) ; shardsIndicesStatus . remove ( shardId ) ; } } } private void calcAndSetShardIndexingBuffer ( String reason ) { } private ByteSizeValue calcShardIndexingBuffer ( int shardsCount ) { } private int countShards ( ) { } static class ShardIndexingStatus { long translogId = - 1 ; int translogNumberOfOperations = - 1 ; boolean inactiveIndexing = false ; long time = - 1 ; } }
public abstract class AbstractSharedClusterTest extends ElasticsearchTestCase { private static TestCluster cluster ; @ BeforeClass protected static void beforeClass ( ) throws Exception { } @ BeforeMethod public final void before ( ) { } @ AfterMethod public void after ( ) { } public static TestCluster cluster ( ) { } public ClusterService clusterService ( ) { } @ AfterClass protected static void afterClass ( ) { } public static Client client ( ) { } public Builder randomSettingsBuilder ( ) { } public Settings getSettings ( ) { } public static void wipeIndices ( String ... names ) { } public static void wipeIndex ( String name ) { } public static void wipeTemplates ( String ... templates ) { } public void createIndex ( String ... names ) { } public void createIndexMapped ( String name , String type , String ... simpleMapping ) throws IOException { } public CreateIndexRequestBuilder prepareCreate ( String index , int numNodes ) { } public CreateIndexRequestBuilder prepareCreate ( String index , int numNodes , ImmutableSettings . Builder builder ) { } public CreateIndexRequestBuilder addMapping ( CreateIndexRequestBuilder builder , String type , Object [ ] ... mapping ) throws IOException { } private Builder getExcludeSettings ( String index , int num , ImmutableSettings . Builder builder ) { } public Set < String > getExcludeNodes ( String index , int num ) { } public void allowNodes ( String index , int numNodes ) { } public CreateIndexRequestBuilder prepareCreate ( String index ) { } public void updateClusterSettings ( Settings settings ) { } public ClusterHealthStatus ensureGreen ( ) { } public ClusterHealthStatus waitForRelocation ( ) { } public ClusterHealthStatus waitForRelocation ( ClusterHealthStatus status ) { } public ClusterHealthStatus ensureYellow ( ) { <START_BUG> ClusterHealthResponse actionGet = AbstractSharedClusterTest . client ( ) . admin ( ) . cluster ( ) . health ( org . elasticsearch . client . Requests . clusterHealthRequest ( ) . waitForYellowStatus ( ) . waitForEvents ( Priority . LANGUID ) ) . actionGet ( ) ; <END_BUG> assertThat ( actionGet . isTimedOut ( ) , equalTo ( false ) ) ; return actionGet . getStatus ( ) ; } public static String commaString ( Iterable < String > strings ) { } protected int numberOfNodes ( ) { } protected IndexResponse index ( String index , String type , XContentBuilder source ) { } protected IndexResponse index ( String index , String type , String id , String field , Object value ) { } protected RefreshResponse refresh ( ) { } protected FlushResponse flush ( ) { } protected OptimizeResponse optimize ( ) { } protected Set < String > nodeIdsWithIndex ( String ... indices ) { } protected int numAssignedShards ( String ... indices ) { } protected boolean indexExists ( String index ) { } protected AdminClient admin ( ) { } protected < Res extends ActionResponse > Res run ( ActionRequestBuilder < ? , Res , ? > builder ) { } protected < Res extends BroadcastOperationResponse > Res run ( BroadcastOperationRequestBuilder < ? , Res , ? > builder ) { } }
public class TransportAliasesExistAction extends TransportMasterNodeReadOperationAction < GetAliasesRequest , AliasesExistResponse > { @ Inject public TransportAliasesExistAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { } @ Override protected String transportAction ( ) { } @ Override protected String executor ( ) { } @ Override protected GetAliasesRequest newRequest ( ) { } @ Override protected AliasesExistResponse newResponse ( ) { } @ Override protected void masterOperation ( GetAliasesRequest request , ClusterState state , ActionListener < AliasesExistResponse > listener ) throws ElasticsearchException { <START_BUG> String [ ] concreteIndices = state . metaData ( ) . concreteIndices ( request . indices ( ) , request . indicesOptions ( ) ) ; <END_BUG> request . indices ( concreteIndices ) ; boolean result = state . metaData ( ) . hasAliases ( request . aliases ( ) , request . indices ( ) ) ; listener . onResponse ( new AliasesExistResponse ( result ) ) ; } }
public class ValidateQueryRequest extends BroadcastOperationRequest { private static final XContentType contentType = Requests . CONTENT_TYPE ; private BytesReference querySource ; private boolean querySourceUnsafe ; private boolean explain ; private String [ ] types = Strings . EMPTY_ARRAY ; ValidateQueryRequest ( ) { } public ValidateQueryRequest ( String ... indices ) { } @ Override public ActionRequestValidationException validate ( ) { } @ Override public ValidateQueryRequest operationThreading ( BroadcastOperationThreading operationThreading ) { } @ Override protected void beforeStart ( ) { } @ Override public ValidateQueryRequest listenerThreaded ( boolean threadedListener ) { } public ValidateQueryRequest indices ( String ... indices ) { } BytesReference querySource ( ) { } @ Required public ValidateQueryRequest query ( QueryBuilder queryBuilder ) { } @ Required public ValidateQueryRequest query ( Map querySource ) { } @ Required public ValidateQueryRequest query ( XContentBuilder builder ) { } @ Required public ValidateQueryRequest query ( String querySource ) { } @ Required public ValidateQueryRequest query ( byte [ ] querySource ) { } @ Required public ValidateQueryRequest query ( byte [ ] querySource , int offset , int length , boolean unsafe ) { } @ Required public ValidateQueryRequest query ( BytesReference querySource , boolean unsafe ) { } String [ ] types ( ) { } public ValidateQueryRequest types ( String ... types ) { } public void explain ( boolean explain ) { } public boolean explain ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; <START_BUG> out . writeBytesReference ( querySource , true ) ; <END_BUG> out . writeVInt ( types . length ) ; for ( String type : types ) { out . writeUTF ( type ) ; } out . writeBoolean ( explain ) ; } @ Override public String toString ( ) { } }
public class ParticleEffectLoader extends SynchronousAssetLoader < ParticleEffect , ParticleEffectLoader . ParticleEffectParameter > { public ParticleEffectLoader ( FileHandleResolver resolver ) { } @ Override public ParticleEffect load ( AssetManager am , String fileName , FileHandle file , ParticleEffectLoader . ParticleEffectParameter param ) { } @ Override public Array < AssetDescriptor > getDependencies ( String fileName , FileHandle file , ParticleEffectLoader . ParticleEffectParameter param ) { Array < AssetDescriptor > deps = null ; if ( ( param != null ) && ( ( param . atlasFile ) != null ) ) { <START_BUG> deps = new Array < AssetDescriptor > ( ) ; <END_BUG> deps . add ( new AssetDescriptor < TextureAtlas > ( param . atlasFile , TextureAtlas . class ) ) ; } return deps ; } public static class ParticleEffectParameter extends AssetLoaderParameters < ParticleEffect > { public String atlasFile ; public FileHandle imagesDir ; } }
public class PercentilesBuilder extends ValuesSourceMetricsAggregationBuilder < PercentilesBuilder > { private double [ ] percentiles ; private Double compression ; public PercentilesBuilder ( String name ) { } public PercentilesBuilder percentiles ( double ... percentiles ) { for ( int i = 0 ; i < ( percentiles . length ) ; i ++ ) { if ( ( ( percentiles [ i ] ) < 0 ) || ( ( percentiles [ i ] ) > 100 ) ) { <START_BUG> throw new IllegalArgumentException ( ( ( "the<seq2seq4repair_space>percents<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>percentiles<seq2seq4repair_space>aggregation<seq2seq4repair_space>[" + ( getName ( ) ) ) + "]<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>[0,<seq2seq4repair_space>100]<seq2seq4repair_space>range" ) ) ; <END_BUG> } } this . percentiles = percentiles ; return this ; } public PercentilesBuilder compression ( double compression ) { } @ Override protected void internalXContent ( XContentBuilder builder , Params params ) throws IOException { } }
public class Environment { private final Settings settings ; private final File homeFile ; private final File workFile ; private final File workWithClusterFile ; private final File [ ] dataFiles ; private final File [ ] dataWithClusterFiles ; private final File configFile ; private final File pluginsFile ; private final File logsFile ; public Environment ( ) { } public Environment ( Settings settings ) { } public Settings settings ( ) { } public File homeFile ( ) { } public File workFile ( ) { } public File workWithClusterFile ( ) { } public File [ ] dataFiles ( ) { } public File [ ] dataWithClusterFiles ( ) { } public File configFile ( ) { } public File pluginsFile ( ) { } public File logsFile ( ) { } public String resolveConfigAndLoadToString ( String path ) throws IOException , FailedToResolveConfigException { <START_BUG> return Streams . copyToString ( new InputStreamReader ( resolveConfig ( path ) . openStream ( ) , "UTF-8" ) ) ; <END_BUG> } public URL resolveConfig ( String path ) throws FailedToResolveConfigException { } }
public final class AndroidGraphics implements Renderer , Graphics { final View view ; int width ; int height ; AndroidApplication app ; GLCommon gl ; GL10 gl10 ; GL11 gl11 ; GL20 gl20 ; GLU glu ; private long lastFrameTime = System . nanoTime ( ) ; private float deltaTime = 0 ; private long frameStart = System . nanoTime ( ) ; private int frames = 0 ; private int fps ; private WindowedMean mean = new WindowedMean ( 5 ) ; volatile boolean created = false ; volatile boolean running = false ; volatile boolean pause = false ; volatile boolean resume = false ; volatile boolean destroy = false ; private float ppiX = 0 ; private float ppiY = 0 ; private float ppcX = 0 ; private float ppcY = 0 ; private BufferFormat bufferFormat = new BufferFormat ( 5 , 6 , 5 , 0 , 16 , 0 , 0 ) ; public AndroidGraphics ( AndroidApplication activity , boolean useGL2IfAvailable , ResolutionStrategy resolutionStrategy ) { } private View createGLSurfaceView ( Activity activity , boolean useGL2 , ResolutionStrategy resolutionStrategy ) { } private EGLConfigChooser getEglConfigChooser ( ) { } private void updatePpi ( ) { } private boolean checkGL20 ( ) { } @ Override public GL10 getGL10 ( ) { } @ Override public GL11 getGL11 ( ) { } @ Override public GL20 getGL20 ( ) { } @ Override public int getHeight ( ) { } @ Override public int getWidth ( ) { } @ Override public boolean isGL11Available ( ) { } @ Override public boolean isGL20Available ( ) { } private static boolean isPowerOfTwo ( int value ) { } private void setupGL ( javax . microedition . khronos . opengles . GL10 gl ) { } @ Override public void onSurfaceChanged ( javax . microedition . khronos . opengles . GL10 gl , int width , int height ) { } @ Override public void onSurfaceCreated ( javax . microedition . khronos . opengles . GL10 gl , EGLConfig config ) { } private void logConfig ( EGLConfig config ) { } int [ ] value = new int [ 1 ] ; private int getAttrib ( EGL10 egl , EGLDisplay display , EGLConfig config , int attrib , int defValue ) { } Object synch = new Object ( ) ; void resume ( ) { } void pause ( ) { } void destroy ( ) { } @ Override public void onDrawFrame ( javax . microedition . khronos . opengles . GL10 gl ) { } @ Override public float getDeltaTime ( ) { } @ Override public GraphicsType getType ( ) { } @ Override public int getFramesPerSecond ( ) { } public void clearManagedCaches ( ) { } public View getView ( ) { } @ Override public GLCommon getGLCommon ( ) { } @ Override public float getPpiX ( ) { } @ Override public float getPpiY ( ) { } @ Override public float getPpcX ( ) { } @ Override public float getPpcY ( ) { } @ Override public GLU getGLU ( ) { } @ Override public boolean supportsDisplayModeChange ( ) { } @ Override public boolean setDisplayMode ( DisplayMode displayMode ) { } @ Override public DisplayMode [ ] getDisplayModes ( ) { <START_BUG> return new DisplayMode [ 0 ] ; <END_BUG> } @ Override public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { } @ Override public void setTitle ( String title ) { } @ Override public void setIcon ( Pixmap pixmap ) { } private class AndroidDisplayMode extends DisplayMode { protected AndroidDisplayMode ( int width , int height , int refreshRate , int bitsPerPixel ) { } } @ Override public DisplayMode getDesktopDisplayMode ( ) { } @ Override public BufferFormat getBufferFormat ( ) { } @ Override public void setVSync ( boolean vsync ) { } }
public class Pixmap implements Disposable { public enum Format { Alpha , LuminanceAlpha , RGB565 , RGBA4444 , RGB888 , RGBA8888 ; static int toGdx2DPixmapFormat ( Pixmap . Format format ) { } static Pixmap . Format fromGdx2DPixmapFormat ( int format ) { } } public enum Blending { None , SourceOver ; } public enum Filter { NearestNeighbour , BiLinear ; } final Gdx2DPixmap pixmap ; int color = 0 ; public static void setBlending ( Pixmap . Blending blending ) { } public static void setFilter ( Pixmap . Filter filter ) { } public Pixmap ( int width , int height , Pixmap . Format format ) { } public Pixmap ( FileHandle file ) { } public void setColor ( float r , float g , float b , float a ) { } public void fill ( ) { } public void drawLine ( int x , int y , int x2 , int y2 ) { } public void drawRectangle ( int x , int y , int width , int height ) { } public void drawPixmap ( Pixmap pixmap , int x , int y , int srcx , int srcy , int srcWidth , int srcHeight ) { } public void drawPixmap ( Pixmap pixmap , int srcx , int srcy , int srcWidth , int srcHeight , int dstx , int dsty , int dstWidth , int dstHeight ) { } public void fillRectangle ( int x , int y , int width , int height ) { } public void drawCircle ( int x , int y , int radius ) { } public void fillCircle ( int x , int y , int radius ) { <START_BUG> pixmap . drawCircle ( x , y , radius , color ) ; <END_BUG> } public int getPixel ( int x , int y ) { } public int getWidth ( ) { } public int getHeight ( ) { } public void dispose ( ) { } public void drawPixel ( int x , int y ) { } public int getGLFormat ( ) { } public int getGLInternalFormat ( ) { } public int getGLType ( ) { } public ByteBuffer getPixels ( ) { } public Pixmap . Format getFormat ( ) { } }
public class TransportCountAction extends TransportBroadcastOperationAction < CountRequest , CountResponse , ShardCountRequest , ShardCountResponse > { private final IndicesService indicesService ; private final ScriptService scriptService ; private final CacheRecycler cacheRecycler ; private final PageCacheRecycler pageCacheRecycler ; private final BigArrays bigArrays ; @ Inject public TransportCountAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService , ScriptService scriptService , CacheRecycler cacheRecycler , PageCacheRecycler pageCacheRecycler , BigArrays bigArrays , ActionFilters actionFilters ) { } @ Override protected void doExecute ( CountRequest request , ActionListener < CountResponse > listener ) { } @ Override protected String executor ( ) { } @ Override protected CountRequest newRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( ) { } @ Override protected ShardCountRequest newShardRequest ( int numShards , ShardRouting shard , CountRequest request ) { String [ ] filteringAliases = clusterService . state ( ) . metaData ( ) . filteringAliases ( shard . index ( ) , request . indices ( ) ) ; <START_BUG> return new ShardCountRequest ( shard . index ( ) , shard . id ( ) , filteringAliases , request ) ; <END_BUG> } @ Override protected ShardCountResponse newShardResponse ( ) { } @ Override protected GroupShardsIterator shards ( ClusterState clusterState , CountRequest request , String [ ] concreteIndices ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , CountRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , CountRequest countRequest , String [ ] concreteIndices ) { } @ Override protected CountResponse newResponse ( CountRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected ShardCountResponse shardOperation ( ShardCountRequest request ) throws ElasticsearchException { } }
@ Test public class SimpleIndexQueryParserTests { private Injector injector ; private IndexQueryParserService queryParser ; @ BeforeClass public void setupQueryParser ( ) throws IOException { } @ AfterClass public void close ( ) { } private IndexQueryParserService queryParser ( ) throws IOException { } private BytesRef longToPrefixCoded ( long val ) { BytesRef bytesRef = new BytesRef ( ) ; <START_BUG> NumericUtils . longToPrefixCoded ( val , 0 , bytesRef ) ; <END_BUG> return bytesRef ; } @ Test public void testQueryStringBuilder ( ) throws Exception { } @ Test public void testQueryString ( ) throws Exception { } @ Test public void testQueryStringFields1Builder ( ) throws Exception { } @ Test public void testQueryStringFields1 ( ) throws Exception { } @ Test public void testQueryStringFieldsMatch ( ) throws Exception { } @ Test public void testQueryStringFields2Builder ( ) throws Exception { } @ Test public void testQueryStringFields2 ( ) throws Exception { } @ Test public void testQueryStringFields3Builder ( ) throws Exception { } @ Test public void testQueryStringFields3 ( ) throws Exception { } @ Test public void testMatchAllBuilder ( ) throws Exception { } @ Test public void testMatchAll ( ) throws Exception { } @ Test public void testDisMaxBuilder ( ) throws Exception { } @ Test public void testDisMax ( ) throws Exception { } @ Test public void testDisMax2 ( ) throws Exception { } @ Test public void testTermQueryBuilder ( ) throws IOException { } @ Test public void testTermQuery ( ) throws IOException { } @ Test public void testFuzzyQueryBuilder ( ) throws IOException { } @ Test public void testFuzzyQuery ( ) throws IOException { } @ Test public void testFuzzyQueryWithFieldsBuilder ( ) throws IOException { } @ Test public void testFuzzyQueryWithFields ( ) throws IOException { } @ Test public void testFuzzyQueryWithFields2 ( ) throws IOException { } @ Test public void testFieldQueryBuilder1 ( ) throws IOException { } @ Test public void testFieldQuery1 ( ) throws IOException { } @ Test public void testFieldQuery2 ( ) throws IOException { } @ Test public void testFieldQuery3 ( ) throws IOException { } @ Test public void testTextQuery1 ( ) throws IOException { } @ Test public void testTextQuery2 ( ) throws IOException { } @ Test public void testTextQuery3 ( ) throws IOException { } @ Test public void testTextQuery4 ( ) throws IOException { } @ Test public void testTextQuery4_2 ( ) throws IOException { } @ Test public void testTermWithBoostQueryBuilder ( ) throws IOException { } @ Test public void testTermWithBoostQuery ( ) throws IOException { } @ Test public void testPrefixQueryBuilder ( ) throws IOException { } @ Test public void testPrefixQuery ( ) throws IOException { } @ Test public void testPrefixBoostQuery ( ) throws IOException { } @ Test public void testPrefixFilteredQueryBuilder ( ) throws IOException { } @ Test public void testPrefixFilteredQuery ( ) throws IOException { } @ Test public void testPrefixNamedFilteredQuery ( ) throws IOException { } @ Test public void testPrefixQueryBoostQueryBuilder ( ) throws IOException { } @ Test public void testPrefixQueryBoostQuery ( ) throws IOException { } @ Test public void testWildcardQueryBuilder ( ) throws IOException { } @ Test public void testWildcardQuery ( ) throws IOException { } @ Test public void testWildcardBoostQuery ( ) throws IOException { } @ Test public void testRangeQueryBuilder ( ) throws IOException { } @ Test public void testRangeQuery ( ) throws IOException { } @ Test public void testRange2Query ( ) throws IOException { } @ Test public void testRangeFilteredQueryBuilder ( ) throws IOException { } @ Test public void testRangeFilteredQuery ( ) throws IOException { } @ Test public void testRangeNamedFilteredQuery ( ) throws IOException { } @ Test public void testNumericRangeFilteredQueryBuilder ( ) throws IOException { } @ Test public void testNumericRangeFilteredQuery ( ) throws IOException { } @ Test public void testBoolFilteredQuery ( ) throws IOException { } @ Test public void testAndFilteredQueryBuilder ( ) throws IOException { } @ Test public void testAndFilteredQuery ( ) throws IOException { } @ Test public void testAndNamedFilteredQuery ( ) throws IOException { } @ Test public void testAndFilteredQuery2 ( ) throws IOException { } @ Test public void testOrFilteredQueryBuilder ( ) throws IOException { } @ Test public void testOrFilteredQuery ( ) throws IOException { } @ Test public void testOrFilteredQuery2 ( ) throws IOException { } @ Test public void testNotFilteredQueryBuilder ( ) throws IOException { } @ Test public void testNotFilteredQuery ( ) throws IOException { } @ Test public void testNotFilteredQuery2 ( ) throws IOException { } @ Test public void testNotFilteredQuery3 ( ) throws IOException { } @ Test public void testBoostingQueryBuilder ( ) throws IOException { } @ Test public void testBoostingQuery ( ) throws IOException { } @ Test public void testQueryStringFuzzyNumeric ( ) throws IOException { } @ Test public void testBoolQueryBuilder ( ) throws IOException { } @ Test public void testBoolQuery ( ) throws IOException { } @ Test public void testTermsQuery ( ) throws IOException { } @ Test public void testFilteredQueryBuilder ( ) throws IOException { } @ Test public void testFilteredQuery ( ) throws IOException { } @ Test public void testFilteredQuery2 ( ) throws IOException { } @ Test public void testFilteredQuery3 ( ) throws IOException { } @ Test public void testFilteredQuery4 ( ) throws IOException { } @ Test public void testLimitFilter ( ) throws Exception { } @ Test public void testTermFilterQuery ( ) throws Exception { } @ Test public void testTermNamedFilterQuery ( ) throws Exception { } @ Test public void testTermsFilterQueryBuilder ( ) throws Exception { } @ Test public void testTermsFilterQuery ( ) throws Exception { } @ Test public void testTermsWithNameFilterQuery ( ) throws Exception { } @ Test public void testConstantScoreQueryBuilder ( ) throws IOException { } @ Test public void testConstantScoreQuery ( ) throws IOException { } @ Test public void testCustomBoostFactorQueryBuilder ( ) throws IOException { } @ Test public void testCustomBoostFactorQuery ( ) throws IOException { }
public class TransportBroadcastPingAction extends TransportBroadcastOperationAction < BroadcastPingRequest , BroadcastPingResponse , BroadcastShardPingRequest , BroadcastShardPingResponse > { @ Inject public TransportBroadcastPingAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected String transportShardAction ( ) { } @ Override protected BroadcastPingRequest newRequest ( ) { } @ Override protected GroupShardsIterator shards ( BroadcastPingRequest request , ClusterState clusterState ) { <START_BUG> return clusterService . operationRouting ( ) . searchShards ( clusterState , request . indices ( ) , request . queryHint ( ) , null ) ; <END_BUG> } @ Override protected BroadcastPingResponse newResponse ( BroadcastPingRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { } @ Override protected BroadcastShardPingRequest newShardRequest ( ) { } @ Override protected BroadcastShardPingRequest newShardRequest ( ShardRouting shard , BroadcastPingRequest request ) { } @ Override protected BroadcastShardPingResponse newShardResponse ( ) { } @ Override protected BroadcastShardPingResponse shardOperation ( BroadcastShardPingRequest broadcastShardPingRequest ) throws ElasticSearchException { } }
public final class BytesRefValComparator extends NestedWrappableComparator < BytesRef > { private final IndexFieldData < ? > indexFieldData ; private final MultiValueMode sortMode ; private final BytesRef missingValue ; private final BytesRef [ ] values ; private BytesRef bottom ; private BytesRef top ; private BytesValues docTerms ; BytesRefValComparator ( IndexFieldData < ? > indexFieldData , int numHits , MultiValueMode sortMode , BytesRef missingValue ) { } @ Override public int compare ( int slot1 , int slot2 ) { } @ Override public int compareBottom ( int doc ) throws IOException { } @ Override public int compareTop ( int doc ) throws IOException { } @ Override public void copy ( int slot , int doc ) throws IOException { } @ Override public FieldComparator < BytesRef > setNextReader ( AtomicReaderContext context ) throws IOException { <START_BUG> docTerms = indexFieldData . load ( context ) . getBytesValues ( false ) ; <END_BUG> return this ; } @ Override public void setBottom ( final int bottom ) { } @ Override public void setTopValue ( BytesRef top ) { } @ Override public BytesRef value ( int slot ) { } @ Override public int compareValues ( BytesRef val1 , BytesRef val2 ) { } @ Override public void missing ( int slot ) { } @ Override public int compareBottomMissing ( ) { } @ Override public int compareTopMissing ( ) { } }
public class Stage extends InputAdapter implements Disposable { private float width ; private float height ; private float gutterWidth ; private float gutterHeight ; private float centerX ; private float centerY ; private Camera camera ; private final SpriteBatch batch ; private final boolean ownsBatch ; private final Group root ; private final Vector2 stageCoords = new Vector2 ( ) ; private Actor [ ] pointerOverActors = new Actor [ 20 ] ; private Actor mouseOverActor ; private Actor keyboardFocus ; private Actor scrollFocus ; private SnapshotArray < Stage . TouchFocus > touchFocuses = new SnapshotArray ( true , 4 , Stage . TouchFocus . class ) ; public Stage ( ) { } public Stage ( float width , float height , boolean stretch ) { } public Stage ( float width , float height , boolean stretch , SpriteBatch batch ) { } public void setViewport ( float width , float height , boolean keepAspectRatio ) { } public void draw ( ) { } public void act ( ) { <START_BUG> act ( graphics . getDeltaTime ( ) ) ; <END_BUG> } public void act ( float delta ) { } private Actor fireEnterAndExit ( Actor overLast , int screenX , int screenY , int pointer ) { } public boolean touchDown ( int screenX , int screenY , int pointer , int button ) { } public boolean touchDragged ( int screenX , int screenY , int pointer ) { } public boolean touchUp ( int screenX , int screenY , int pointer , int button ) { } public boolean mouseMoved ( int screenX , int screenY ) { } public boolean scrolled ( int amount ) { } public boolean keyDown ( int keyCode ) { } public boolean keyUp ( int keyCode ) { } public boolean keyTyped ( char character ) { } public void addTouchFocus ( EventListener listener , Actor listenerActor , Actor target , int pointer , int button ) { } public void removeTouchFocus ( EventListener listener , Actor listenerActor , Actor target , int pointer , int button ) { } public void cancelTouchFocus ( ) { } public void cancelTouchFocus ( EventListener listener , Actor actor ) { } public void addActor ( Actor actor ) { } public Array < Actor > getActors ( ) { } public boolean addListener ( EventListener listener ) { } public boolean removeListener ( EventListener listener ) { } public boolean addCaptureListener ( EventListener listener ) { } public boolean removeCaptureListener ( EventListener listener ) { } public void clear ( ) { } public void unfocusAll ( ) { } public void unfocus ( Actor actor ) { } public void setKeyboardFocus ( Actor actor ) { } public Actor getKeyboardFocus ( ) { } public void setScrollFocus ( Actor actor ) { } public Actor getScrollFocus ( ) { } public float getWidth ( ) { } public float getHeight ( ) { } public float getGutterWidth ( ) { } public float getGutterHeight ( ) { } public SpriteBatch getSpriteBatch ( ) { } public Camera getCamera ( ) { } public void setCamera ( Camera camera ) { } public Group getRoot ( ) { } public Actor hit ( float stageX , float stageY ) { } public Vector2 screenToStageCoordinates ( Vector2 screenCoords ) { } public Vector2 stageToScreenCoordinates ( Vector2 stageCoords ) { } public Vector2 toScreenCoordinates ( Vector2 coords , Matrix4 transformMatrix ) { } public void dispose ( ) { } public static final class TouchFocus implements Poolable { EventListener listener ; Actor listenerActor ; Actor target ; int pointer ; int button ; public void reset ( ) { } } }
public abstract class EventPager extends ResourcePager < Event > { @ Override <START_BUG> protected String getId ( Event resource ) { <END_BUG> return resource . getId ( ) ; } }
public class DateFieldMapper extends NumberFieldMapper < Long > { public static final String CONTENT_TYPE = "date" ; public static class Defaults extends NumberFieldMapper . Defaults { public static final FormatDateTimeFormatter DATE_TIME_FORMATTER = Joda . forPattern ( "dateOptionalTime" ) ; public static final FieldType FIELD_TYPE = new FieldType ( NumberFieldMapper . Defaults . FIELD_TYPE ) ; public static final String NULL_VALUE = null ; public static final TimeUnit TIME_UNIT = TimeUnit . MILLISECONDS ; public static final boolean PARSE_UPPER_INCLUSIVE = true ; } public static class Builder extends NumberFieldMapper . Builder < DateFieldMapper . Builder , DateFieldMapper > { protected TimeUnit timeUnit = DateFieldMapper . Defaults . TIME_UNIT ; protected String nullValue = DateFieldMapper . Defaults . NULL_VALUE ; protected FormatDateTimeFormatter dateTimeFormatter = DateFieldMapper . Defaults . DATE_TIME_FORMATTER ; public Builder ( String name ) { } public DateFieldMapper . Builder timeUnit ( TimeUnit timeUnit ) { } public DateFieldMapper . Builder nullValue ( String nullValue ) { } public DateFieldMapper . Builder dateTimeFormatter ( FormatDateTimeFormatter dateTimeFormatter ) { } @ Override public DateFieldMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } protected final FormatDateTimeFormatter dateTimeFormatter ; private final boolean parseUpperInclusive ; private final DateMathParser dateMathParser ; private String nullValue ; protected final TimeUnit timeUnit ; protected DateFieldMapper ( Names names , FormatDateTimeFormatter dateTimeFormatter , int precisionStep , float boost , FieldType fieldType , String nullValue , TimeUnit timeUnit , boolean parseUpperInclusive , Explicit < Boolean > ignoreMalformed , PostingsFormatProvider provider , SimilarityProvider similarity , @ Nullable Settings fieldDataSettings ) { } @ Override public FieldType defaultFieldType ( ) { } @ Override public FieldDataType defaultFieldDataType ( ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Long value ( Object value ) { } @ Override public Object valueForSearch ( Object value ) { } @ Override public BytesRef indexedValueForSearch ( Object value ) { BytesRef bytesRef = new BytesRef ( ) ; <START_BUG> NumericUtils . longToPrefixCoded ( parseValue ( value ) , precisionStep ( ) , bytesRef ) ; <END_BUG> return bytesRef ; } private long parseValue ( Object value ) { } private String convertToString ( Object value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query termQuery ( Object value , @ Nullable QueryParseContext context ) { } @ Override public Filter termFilter ( Object value , @ Nullable QueryParseContext context ) { } @ Override public Query rangeQuery ( Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( IndexFieldDataService fieldData , Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected boolean customBoost ( ) { } @ Override protected Field innerParseCreateField ( ParseContext context ) throws IOException { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } private long parseStringValue ( String value ) { } }
public static final int V_0_19_10_ID = 191099 ; public static final Version V_0_19_10 = new < org . apache . lucene . util . Version > Version ( Version . V_0_19_10_ID , false ) ; public static final int V_0_19_11_ID = 191199 ; public static final Version V_0_19_11 = new < org . apache . lucene . util . Version > Version ( Version . V_0_19_11_ID , false ) ; public static final int V_0_19_12_ID = 191299 ; public static final Version V_0_19_12 = new < org . apache . lucene . util . Version > Version ( Version . V_0_19_12_ID , false ) ; public static final int V_0_19_13_ID = 191399 ; public static final Version V_0_19_13 = new < org . apache . lucene . util . Version > Version ( Version . V_0_19_13_ID , false ) ; public static final int V_0_20_0_RC1_ID = 200051 ; public static final Version V_0_20_0_RC1 = new < org . apache . lucene . util . Version > Version ( Version . V_0_20_0_RC1_ID , false ) ; public static final int V_0_20_0_ID = 200099 ; public static final Version V_0_20_0 = new < org . apache . lucene . util . Version > Version ( Version . V_0_20_0_ID , false ) ; public static final int V_0_20_1_ID = 200199 ; public static final Version V_0_20_1 = new < org . apache . lucene . util . Version > Version ( Version . V_0_20_1_ID , false ) ; public static final int V_0_20_2_ID = 200299 ; public static final Version V_0_20_2 = new < org . apache . lucene . util . Version > Version ( Version . V_0_20_2_ID , false ) ; public static final int V_0_20_3_ID = 200399 ; public static final Version V_0_20_3 = new < org . apache . lucene . util . Version > Version ( Version . V_0_20_3_ID , false ) ; public static final int V_0_20_4_ID = 200499 ; public static final Version V_0_20_4 = new < org . apache . lucene . util . Version > Version ( Version . V_0_20_4_ID , false ) ; public static final int V_0_20_5_ID = 200599 ; public static final Version V_0_20_5 = new < org . apache . lucene . util . Version > Version ( Version . V_0_20_5_ID , false ) ; public static final int V_0_20_6_ID = 200699 ; public static final Version V_0_20_6 = new < org . apache . lucene . util . Version > Version ( Version . V_0_20_6_ID , false ) ; public static final int V_0_20_7_ID = 200799 ; public static final Version V_0_20_7 = new < org . apache . lucene . util . Version > Version ( Version . V_0_20_7_ID , false ) ; public static final int V_0_90_0_Beta1_ID = 900001 ; public static final Version V_0_90_0_Beta1 = new < org . apache . lucene . util . Version > Version ( Version . V_0_90_0_Beta1_ID , false ) ; public static final int V_0_90_0_RC1_ID = 900051 ; public static final Version V_0_90_0_RC1 = new < org . apache . lucene . util . Version > Version ( Version . V_0_90_0_RC1_ID , false ) ; public static final int V_0_90_0_RC2_ID = 900052 ; public static final Version V_0_90_0_RC2 = new < org . apache . lucene . util . Version > Version ( Version . V_0_90_0_RC2_ID , false ) ; public static final int V_0_90_0_ID = 900099 ; public static final Version V_0_90_0 = new < org . apache . lucene . util . Version > Version ( Version . V_0_90_0_ID , false ) ; public static final int V_0_90_1_ID = 900199 ; public static final Version V_0_90_1 = new < org . apache . lucene . util . Version > Version ( Version . V_0_90_1_ID , false ) ; public static final int V_0_90_2_ID = 900299 ; public static final Version V_0_90_2 = new < org . apache . lucene . util . Version > Version ( Version . V_0_90_2_ID , false ) ; public static final int V_0_90_3_ID = 900399 ; public static final Version V_0_90_3 = new < org . apache . lucene . util . Version > Version ( Version . V_0_90_3_ID , false ) ; public static final int V_1_0_0_Beta1_ID = 1000001 ; public static final Version V_1_0_0_Beta1 = new < org . apache . lucene . util . Version > Version ( Version . V_1_0_0_Beta1_ID , true ) ; public static final Version CURRENT = Version . V_1_0_0_Beta1 ; public static Version readVersion ( StreamInput in ) throws IOException { } public static Version fromId ( int id ) { } public static void writeVersion ( Version version , StreamOutput out ) throws IOException { } public final int id ; public final byte major ; public final byte minor ; public final byte revision ; public final byte build ; public final Boolean snapshot ; public final org . apache . lucene . util . Version luceneVersion ; Version ( int id , @ Nullable Boolean snapshot , org . apache . lucene . util . Version luceneVersion ) { } public boolean snapshot ( ) { } public boolean after ( Version version ) { } public boolean onOrAfter ( Version version ) { } public boolean before ( Version version ) { } public boolean onOrBefore ( Version version ) { } public String number ( ) { } public static void main ( String [ ] args ) { <START_BUG> System . out . println ( ( ( ( ( ( ( "ElasticSearch<seq2seq4repair_space>Version:<seq2seq4repair_space>" + ( Version . CURRENT ) ) + ",<seq2seq4repair_space>JVM:<seq2seq4repair_space>" ) + ( JvmInfo . jvmInfo ( ) . version ( ) ) ) + "(" ) + ( JvmInfo . jvmInfo ( ) . vmVersion ( ) ) ) + ")" ) ) ; <END_BUG> } @ Override public String toString ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } }
public class SourceLookup implements Map { private IndexReader reader ; private int docId = - 1 ; private byte [ ] sourceAsBytes ; private int sourceAsBytesOffset ; private int sourceAsBytesLength ; private Map < String , Object > source ; public Map < String , Object > source ( ) { } private Map < String , Object > loadSourceIfNeeded ( ) { } public static Map < String , Object > sourceAsMap ( byte [ ] bytes , int offset , int length ) throws ElasticSearchParseException { <START_BUG> return XContentHelper . convertToMap ( bytes , offset , length ) . v2 ( ) ; <END_BUG> } public void setNextReader ( IndexReader reader ) { } public void setNextDocId ( int docId ) { } public void setNextSource ( byte [ ] source , int offset , int length ) { } public void setNextSource ( Map < String , Object > source ) { } public List < Object > extractRawValues ( String path ) { } public Object filter ( String [ ] includes , String [ ] excludes ) { } public Object extractValue ( String path ) { } @ Override public Object get ( Object key ) { } @ Override public int size ( ) { } @ Override public boolean isEmpty ( ) { } @ Override public boolean containsKey ( Object key ) { } @ Override public boolean containsValue ( Object value ) { } @ Override public Set keySet ( ) { } @ Override public Collection values ( ) { } @ Override public Set entrySet ( ) { } @ Override public Object put ( Object key , Object value ) { } @ Override public Object remove ( Object key ) { } @ Override public void putAll ( Map m ) { } @ Override public void clear ( ) { } }
public class TermsFilterParser extends AbstractIndexComponent implements XContentFilterParser { public static final String NAME = "terms" ; @ Inject public TermsFilterParser ( Index index , @ IndexSettings Settings settings ) { } @ Override public String [ ] names ( ) { <START_BUG> return new String [ ] { TermsFilterParser . NAME } ; <END_BUG> } @ Override public Filter parse ( QueryParseContext parseContext ) throws IOException , QueryParsingException { } }
public class LwjglDebugStarter { public static void main ( String [ ] argv ) { LwjglApplicationConfiguration config = new LwjglApplicationConfiguration ( ) ; <START_BUG> config . useGL20 = false ; <END_BUG> config . vSyncEnabled = true ; new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new ShapeRendererTest ( ) , config ) ; } }
public final class TestCluster implements Iterable < Client > { private final ESLogger logger = Loggers . getLogger ( getClass ( ) ) ; private final TreeMap < String , TestCluster . NodeAndClient > nodes = Maps . newTreeMap ( ) ; private final Set < File > dataDirToClean = new HashSet < File > ( ) ; private final String clusterName ; private final AtomicBoolean open = new AtomicBoolean ( true ) ; private final Settings defaultSettings ; private Random random ; private AtomicInteger nextNodeId = new AtomicInteger ( 0 ) ; private final int numSharedNodes ; private final long [ ] sharedNodesSeeds ; private double transportClientRatio = 0.0 ; private final NodeSettingsSource nodeSettingsSource ; TestCluster ( long clusterSeed , String clusterName ) { } TestCluster ( long clusterSeed , int numNodes , String clusterName , NodeSettingsSource nodeSettingsSource ) { } private static boolean isLocalTransportConfigured ( ) { } private Settings getSettings ( int nodeOrdinal , Settings others ) { } static String clusterName ( String prefix , String childVMId , long clusterSeed ) { } private void ensureOpen ( ) { } private synchronized TestCluster . NodeAndClient getOrBuildRandomNode ( ) { } private synchronized TestCluster . NodeAndClient getRandomNodeAndClient ( ) { } private synchronized TestCluster . NodeAndClient getRandomNodeAndClient ( Predicate < TestCluster . NodeAndClient > predicate ) { } public synchronized void ensureAtLeastNumNodes ( int n ) { } public synchronized void ensureAtMostNumNodes ( int n ) { } private TestCluster . NodeAndClient buildNode ( Settings settings ) { } private TestCluster . NodeAndClient buildNode ( ) { } private TestCluster . NodeAndClient buildNode ( int nodeId , long seed , Settings settings ) { } private String buildNodeName ( int id ) { } synchronized Client client ( ) { } public synchronized Client masterClient ( ) { } public synchronized Client nonMasterClient ( ) { } public synchronized Client clientNodeClient ( ) { } public synchronized Client client ( String nodeName ) { } public synchronized Client smartClient ( ) { } public synchronized Client client ( final Predicate < Settings > filterPredicate ) { } void close ( ) { } private final class NodeAndClient implements Closeable { private InternalNode node ; private Client client ; private Client nodeClient ; private final AtomicBoolean closed = new AtomicBoolean ( false ) ; private final TestCluster . ClientFactory clientFactory ; private final String name ; NodeAndClient ( String name , Node node , TestCluster . ClientFactory factory ) { } Node node ( ) { } Client client ( Random random ) { } Client nodeClient ( ) { } void resetClient ( ) { } void restart ( TestCluster . RestartCallback callback ) throws Exception { } @ Override public void close ( ) { } } static class ClientFactory { public Client client ( Node node , String clusterName , Random random ) { } } static class TransportClientFactory extends TestCluster . ClientFactory { private boolean sniff ; public static TestCluster . TransportClientFactory NO_SNIFF_CLIENT_FACTORY = new TestCluster . TransportClientFactory ( false ) ; public static TestCluster . TransportClientFactory SNIFF_CLIENT_FACTORY = new TestCluster . TransportClientFactory ( true ) ; public TransportClientFactory ( boolean sniff ) { } @ Override public Client client ( Node node , String clusterName , Random random ) { } } class RandomClientFactory extends TestCluster . ClientFactory { @ Override public Client client ( Node node , String clusterName , Random random ) { } } synchronized void beforeTest ( Random random , double transportClientRatio ) { } private synchronized void reset ( Random random , boolean wipeData , double transportClientRatio ) { } synchronized void afterTest ( ) { } private void resetClients ( ) { } private void wipeDataDirectories ( ) { if ( ! ( dataDirToClean . isEmpty ( ) ) ) { logger . info ( "Wipe<seq2seq4repair_space>data<seq2seq4repair_space>directory<seq2seq4repair_space>for<seq2seq4repair_space>all<seq2seq4repair_space>nodes<seq2seq4repair_space>locations:<seq2seq4repair_space>{}" , this . dataDirToClean ) ; try { <START_BUG> FileSystemUtils . deleteRecursively ( dataDirToClean . toArray ( new File [ dataDirToClean . size ( ) ] ) ) ; <END_BUG> } finally { this . dataDirToClean . clear ( ) ; } } } public synchronized ClusterService clusterService ( ) { } public synchronized < T > Iterable < T > getInstances ( Class < T > clazz ) { } public synchronized < T > T getInstance ( Class < T > clazz , final String node ) { } public synchronized < T > T getInstance ( Class < T > clazz ) { } private synchronized < T > T getInstanceFromNode ( Class < T > clazz , InternalNode node ) { } public synchronized int size ( ) { } public synchronized void stopRandomNode ( ) { } public synchronized void stopRandomNode ( final Predicate < Settings > filter ) { } public synchronized void stopCurrentMasterNode ( ) { } public void stopRandomNonMasterNode ( ) { } public void restartRandomNode ( ) throws Exception { } public void restartRandomNode ( TestCluster . RestartCallback callback ) throws Exception { } private void restartAllNodes ( boolean rollingRestart , TestCluster . RestartCallback callback ) throws Exception { } private static final TestCluster . RestartCallback EMPTY_CALLBACK = new TestCluster . RestartCallback ( ) { public Settings onNodeStopped ( String node ) { } } ; public void fullRestart ( ) throws Exception { } public void rollingRestart ( ) throws Exception { } public void rollingRestart ( TestCluster . RestartCallback function ) throws Exception { } public void fullRestart ( TestCluster . RestartCallback function ) throws Exception { } private String getMasterName ( ) { } synchronized Set < String > allButN ( int numNodes ) { } private synchronized Set < String > nRandomNodes ( int numNodes ) { } public synchronized void startNodeClient ( Settings settings ) { } public synchronized Set < String > nodesInclude ( String index ) { } public String startNode ( ) { } public String startNode ( Settings . Builder settings ) { } public String startNode ( Settings settings ) { }
@ Override public ParentChildAtomicFieldData loadDirect ( AtomicReaderContext context ) throws Exception { AtomicReader reader = context . reader ( ) ; final float acceptableTransientOverheadRatio = fieldDataType . getSettings ( ) . getAsFloat ( "acceptable_transient_overhead_ratio" , DEFAULT_ACCEPTABLE_OVERHEAD_RATIO ) ; synchronized ( lock ) { boolean success = false ; ParentChildAtomicFieldData data = null ; ParentChildFilteredTermsEnum termsEnum = new ParentChildFilteredTermsEnum ( new ParentChildIntersectTermsEnum ( reader , UidFieldMapper . NAME , ParentFieldMapper . NAME ) , parentTypes ) ; ParentChildIndexFieldData . ParentChildEstimator estimator = new ParentChildIndexFieldData . ParentChildEstimator ( breakerService . getBreaker ( ) , termsEnum ) ; TermsEnum estimatedTermsEnum = estimator . beforeLoad ( null ) ; ObjectObjectOpenHashMap < String , ParentChildIndexFieldData . TypeBuilder > typeBuilders = ObjectObjectOpenHashMap . newInstance ( ) ; try { try { DocsEnum docsEnum = null ; for ( BytesRef term = estimatedTermsEnum . next ( ) ; term != null ; term = estimatedTermsEnum . next ( ) ) { String type = termsEnum . type ( ) ; ParentChildIndexFieldData . TypeBuilder typeBuilder = typeBuilders . get ( type ) ; if ( typeBuilder == null ) { typeBuilders . put ( type , ( typeBuilder = new ParentChildIndexFieldData . TypeBuilder ( acceptableTransientOverheadRatio , reader ) ) ) ; } BytesRef id = termsEnum . id ( ) ; final long termOrd = typeBuilder . builder . nextOrdinal ( ) ; assert termOrd == ( typeBuilder . termOrdToBytesOffset . size ( ) ) ; typeBuilder . termOrdToBytesOffset . add ( typeBuilder . bytes . copyUsingLengthPrefix ( id ) ) ; docsEnum = estimatedTermsEnum . docs ( null , docsEnum , FLAG_NONE ) ; for ( int docId = docsEnum . nextDoc ( ) ; docId != ( DocsEnum . NO_MORE_DOCS ) ; docId = docsEnum . nextDoc ( ) ) { typeBuilder . builder . addDoc ( docId ) ; } } ImmutableOpenMap . Builder < String , PagedBytesAtomicFieldData > typeToAtomicFieldData = ImmutableOpenMap . builder ( typeBuilders . size ( ) ) ; for ( ObjectObjectCursor < String , ParentChildIndexFieldData . TypeBuilder > cursor : typeBuilders ) { final long sizePointer = cursor . value . bytes . getPointer ( ) ; PagedBytes . Reader bytesReader = cursor . value . bytes . freeze ( true ) ; final Ordinals ordinals = cursor . value . builder . build ( fieldDataType . getSettings ( ) ) ; typeToAtomicFieldData . put ( cursor . key , new PagedBytesAtomicFieldData ( bytesReader , sizePointer , cursor . value . termOrdToBytesOffset , ordinals ) ) ; } data = new ParentChildAtomicFieldData ( typeToAtomicFieldData . build ( ) ) ; } finally { for ( ObjectObjectCursor < String , ParentChildIndexFieldData . TypeBuilder > cursor : typeBuilders ) { cursor . value . builder . close ( ) ; } } success = true ; return data ; } finally { if ( success ) { estimator . afterLoad ( estimatedTermsEnum , data . getMemorySizeInBytes ( ) ) ; } else { estimator . afterLoad ( estimatedTermsEnum , 0 ) ; } } } } public WithOrdinals getGlobalParentChild ( String type , IndexReader indexReader ) { } @ Override public void beforeCreate ( DocumentMapper mapper ) { } @ Override public void afterRemove ( DocumentMapper mapper ) { } class TypeBuilder { final PagedBytes bytes ; final MonotonicAppendingLongBuffer termOrdToBytesOffset ; final OrdinalsBuilder builder ; TypeBuilder ( float acceptableTransientOverheadRatio , AtomicReader reader ) throws IOException { } } public static class Builder implements IndexFieldData . Builder { @ Override public IndexFieldData < ? > build ( Index index , @ IndexSettings Settings indexSettings , FieldMapper < ? > mapper , IndexFieldDataCache cache , CircuitBreakerService breakerService , MapperService mapperService , GlobalOrdinalsBuilder globalOrdinalBuilder ) { } } public class ParentChildEstimator implements PerValueEstimator { private final MemoryCircuitBreaker breaker ; private final TermsEnum filteredEnum ; public ParentChildEstimator ( MemoryCircuitBreaker breaker , TermsEnum filteredEnum ) { } @ Override public long bytesPerValue ( BytesRef term ) { } @ Override public TermsEnum beforeLoad ( Terms terms ) throws IOException { } @ Override public void afterLoad ( TermsEnum termsEnum , long actualUsed ) { } } private class ParentTypesGlobalOrdinalsLoading implements WithOrdinals { public ParentTypesGlobalOrdinalsLoading ( ) { } @ Override public AtomicFieldData . WithOrdinals load ( AtomicReaderContext context ) { } @ Override public AtomicFieldData . WithOrdinals loadDirect ( AtomicReaderContext context ) { throw new ElasticsearchIllegalStateException ( "Shouldn't<seq2seq4repair_space>be<seq2seq4repair_space>invoked" ) ; } @ Override public WithOrdinals loadGlobal ( IndexReader indexReader ) { } @ Override public WithOrdinals localGlobalDirect ( IndexReader indexReader ) throws Exception { } @ Override public Names getFieldNames ( ) { } @ Override public FieldDataType getFieldDataType ( ) { } @ Override public boolean valuesOrdered ( ) { } @ Override public XFieldComparatorSource comparatorSource ( @ Nullable Object missingValue , MultiValueMode sortMode ) { } @ Override public void clear ( ) { } @ Override public void clear ( IndexReader reader ) { } @ Override public Index index ( ) { } private final class PerType extends ParentChildIndexFieldData . ParentTypesGlobalOrdinalsLoading { private final String type ; public PerType ( String type ) { } @ Override public AtomicFieldData . WithOrdinals load ( AtomicReaderContext context ) { } @ Override public AtomicFieldData . WithOrdinals loadDirect ( AtomicReaderContext context ) { ParentChildAtomicFieldData parentChildAtomicFieldData = ParentChildIndexFieldData . this . load ( context ) ; AtomicFieldData . WithOrdinals typeAfd = parentChildAtomicFieldData . getAtomicFieldData ( type ) ; if ( typeAfd != null ) { return typeAfd ; } else { <START_BUG> return PagedBytesAtomicFieldData . empty ( ) ; <END_BUG> } } @ Override public WithOrdinals loadGlobal ( IndexReader indexReader ) { } @ Override public WithOrdinals localGlobalDirect ( IndexReader indexReader ) throws Exception { } } } private final class ParentChildGlobalOrdinalsIndexFieldData extends GlobalOrdinalsIndexFieldData { private final ImmutableOpenMap < String , WithOrdinals > typeGlobalOrdinals ; private ParentChildGlobalOrdinalsIndexFieldData ( ImmutableOpenMap < String , WithOrdinals > typeGlobalOrdinals , long memorySizeInBytes ) { } @ Override public AtomicFieldData . WithOrdinals load ( AtomicReaderContext context ) { } public WithOrdinals type ( String type ) { } } }
public class FastImage extends Actor { public final TextureRegion region ; private float sX ; private float sY ; private float sOriginX ; private float sOriginY ; private float sRotation ; private float sScaleX ; private float sScaleY ; private float sWidth ; private float sHeight ; private Sprite sprite = new Sprite ( ) ; boolean updated = false ; public FastImage ( String name ) { } public FastImage ( String name , Texture texture ) { } public FastImage ( String name , TextureRegion region ) { } @ Override protected void draw ( SpriteBatch batch , float parentAlpha ) { updateSprite ( ) ; if ( ( region . getTexture ( ) ) != null ) { <START_BUG> sprite . draw ( batch ) ; <END_BUG> } } private void updateSprite ( ) { } @ Override protected boolean touchDown ( float x , float y , int pointer ) { } @ Override protected boolean touchUp ( float x , float y , int pointer ) { } @ Override protected boolean touchDragged ( float x , float y , int pointer ) { } public Actor hit ( float x , float y ) { } }
public abstract class HasChildFilter extends Filter implements ScopePhase . CollectorPhase { final Query childQuery ; final String scope ; final String parentType ; final String childType ; final SearchContext searchContext ; protected HasChildFilter ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext ) { } public Query query ( ) { } public String scope ( ) { } @ Override public String toString ( ) { } public static HasChildFilter create ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext , String executionType ) { } static class Bitset extends HasChildFilter { private Map < Object , FixedBitSet > parentDocs ; public Bitset ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext ) { } public boolean requiresProcessing ( ) { } public Collector collector ( ) { } public void processCollector ( Collector collector ) { } public void clear ( ) { } public DocIdSet getDocIdSet ( AtomicReaderContext context , Bits acceptDocs ) throws IOException { } } static class Uid extends HasChildFilter { THashSet < HashedBytesArray > collectedUids ; Uid ( Query childQuery , String scope , String parentType , String childType , SearchContext searchContext ) { } public boolean requiresProcessing ( ) { } public Collector collector ( ) { } public void processCollector ( Collector collector ) { } public DocIdSet getDocIdSet ( AtomicReaderContext context , Bits acceptDocs ) throws IOException { } public void clear ( ) { } static class ParentDocSet extends GetDocSet { final IndexReader reader ; final THashSet < HashedBytesArray > parents ; final IdReaderTypeCache typeCache ; final Bits acceptDocs ; ParentDocSet ( IndexReader reader , THashSet < HashedBytesArray > parents , IdReaderTypeCache typeCache , Bits acceptDocs ) { } public boolean get ( int doc ) { <START_BUG> return ( acceptDocs . get ( doc ) ) && ( parents . contains ( typeCache . idByDoc ( doc ) ) ) ; <END_BUG> } } static class UidCollector extends NoopCollector { final String parentType ; final SearchContext context ; final THashSet < HashedBytesArray > collectedUids ; private IdReaderTypeCache typeCache ; UidCollector ( String parentType , SearchContext context , THashSet < HashedBytesArray > collectedUids ) { } @ Override public void collect ( int doc ) throws IOException { } @ Override public void setNextReader ( AtomicReaderContext readerContext ) throws IOException { } } } }
public class IOSFileHandle extends FileHandle { public IOSFileHandle ( String fileName , FileType type ) { } public IOSFileHandle ( File file , FileType type ) { } public FileHandle child ( String name ) { } public FileHandle parent ( ) { } @ Override public boolean exists ( ) { <START_BUG> return file ( ) . exists ( ) ; <END_BUG> } public File file ( ) { } }
public class ScrollPane extends WidgetGroup { private ScrollPane . ScrollPaneStyle style ; private Actor widget ; final Rectangle hScrollBounds = new Rectangle ( ) ; final Rectangle vScrollBounds = new Rectangle ( ) ; final Rectangle hKnobBounds = new Rectangle ( ) ; final Rectangle vKnobBounds = new Rectangle ( ) ; private final Rectangle widgetAreaBounds = new Rectangle ( ) ; private final Rectangle widgetCullingArea = new Rectangle ( ) ; private final Rectangle scissorBounds = new Rectangle ( ) ; private ActorGestureListener gestureListener ; boolean scrollX ; boolean scrollY ; float amountX ; float amountY ; float visualAmountX ; float visualAmountY ; float maxX ; float maxY ; boolean touchScrollH ; boolean touchScrollV ; final Vector2 lastPoint = new Vector2 ( ) ; float areaWidth ; float areaHeight ; private boolean fadeScrollBars = true ; private boolean smoothScrolling = true ; float fadeAlpha ; float fadeAlphaSeconds = 1 ; float fadeDelay ; float fadeDelaySeconds = 1 ; private boolean flickScroll = true ; float velocityX ; float velocityY ; float flingTimer ; private boolean overscrollX = true ; private boolean overscrollY = true ; float flingTime = 1.0F ; private float overscrollDistance = 50 ; private float overscrollSpeedMin = 30 ; private float overscrollSpeedMax = 200 ; private boolean forceOverscrollX ; private boolean forceOverscrollY ; private boolean disableX ; private boolean disableY ; private boolean clamp = true ; public ScrollPane ( Actor widget ) { } public ScrollPane ( Actor widget , Skin skin ) { } public ScrollPane ( Actor widget , Skin skin , String styleName ) { } public ScrollPane ( Actor widget , ScrollPane . ScrollPaneStyle style ) { } void resetFade ( ) { } void cancelTouchFocusedChild ( InputEvent event ) { } void clamp ( ) { } public void setStyle ( ScrollPane . ScrollPaneStyle style ) { } public ScrollPane . ScrollPaneStyle getStyle ( ) { } public void act ( float delta ) { } public void layout ( ) { } @ Override public void draw ( SpriteBatch batch , float parentAlpha ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMinWidth ( ) { } public float getMinHeight ( ) { } public void setWidget ( Actor widget ) { } public void addActor ( Actor actor ) { } public void addActorAt ( int index , Actor actor ) { } public void addActorBefore ( Actor actorBefore , Actor actor ) { } public boolean removeActor ( Actor actor ) { } public Actor hit ( float x , float y ) { } public void setScrollX ( float pixels ) { } public float getScrollX ( ) { } public void setScrollY ( float pixels ) { } public float getScrollY ( ) { } public float getVisualScrollX ( ) { } public float getVisualScrollY ( ) { } public float getScrollPercentX ( ) { } public void setScrollPercentX ( float percentX ) { } public float getScrollPercentY ( ) { } public void setScrollPercentY ( float percentY ) { } public void setFlickScroll ( boolean flickScroll ) { } public void scrollTo ( float x , float y , float width , float height ) { } public float getMaxX ( ) { } public float getMaxY ( ) { } public float getScrollBarHeight ( ) { } public float getScrollBarWidth ( ) { <START_BUG> return ( ( style . vScrollKnob ) == null ) || ( ! ( scrollY ) ) ? 0 : style . hScrollKnob . getMinWidth ( ) ; <END_BUG> } public void setScrollingDisabled ( boolean x , boolean y ) { } public boolean isPanning ( ) { } public boolean isFlinging ( ) { } public void setVelocityX ( float velocityX ) { } public float getVelocityX ( ) { } public void setVelocityY ( float velocityY ) { } public float getVelocityY ( ) { } public void setOverscroll ( boolean overscrollX , boolean overscrollY ) { } public void setupOverscroll ( float distance , float speedMin , float speedMax ) { } public void setForceOverscroll ( boolean x , boolean y ) { } public void setFlingTime ( float flingTime ) { } public void setClamp ( boolean clamp ) { } public void setFadeScrollBars ( boolean fadeScrollBars ) { } public void setupFadeScrollBars ( float fadeAlphaSeconds , float fadeDelaySeconds ) { } public void setSmoothScrolling ( boolean smoothScrolling ) { } public static class ScrollPaneStyle { public Drawable background ; public Drawable hScroll ; public Drawable hScrollKnob ; public Drawable vScroll ; public Drawable vScrollKnob ; public ScrollPaneStyle ( ) { } public ScrollPaneStyle ( Drawable background , Drawable hScroll , Drawable hScrollKnob , Drawable vScroll , Drawable vScrollKnob ) { } public ScrollPaneStyle ( ScrollPane . ScrollPaneStyle style ) { } } }
public final class DefaultTextureBinder implements TextureBinder { public static final int ROUNDROBIN = 0 ; public static final int WEIGHTED = 1 ; public static final int MAX_GLES_UNITS = 32 ; private final int offset ; private final int count ; private final int reuseWeight ; private final TextureDescriptor [ ] textures ; private final int [ ] weights ; private final int method ; private boolean reused ; private int reuseCount = 0 ; private int bindCount = 0 ; public DefaultTextureBinder ( final int method ) { } public DefaultTextureBinder ( final int method , final int offset ) { } public DefaultTextureBinder ( final int method , final int offset , final int count ) { } public DefaultTextureBinder ( final int method , final int offset , final int count , final int reuseWeight ) { } private static int getMaxTextureUnits ( ) { } @ Override public void begin ( ) { for ( int i = 0 ; i < ( count ) ; i ++ ) { <START_BUG> textures [ i ] . reset ( ) ; <END_BUG> if ( ( weights ) != null ) weights [ i ] = 0 ; } } @ Override public void end ( ) { } @ Override public final int bind ( final TextureDescriptor textureDesc ) { } private final int bindTexture ( final TextureDescriptor textureDesc , final boolean rebind ) { } private int currentTexture = 0 ; private final int bindTextureRoundRobin ( final Texture texture ) { } private final int bindTextureWeighted ( final Texture texture ) { } @ Override public final int getBindCount ( ) { } @ Override public final int getReuseCount ( ) { } @ Override public final void resetCounts ( ) { } }
public abstract class DialogFragmentHelper extends RoboDialogFragment implements OnClickListener { private static final String ARG_TITLE = "title" ; private static final String ARG_MESSAGE = "message" ; private static final String ARG_REQUEST_CODE = "requestCode" ; protected static void show ( DialogFragmentActivity activity , DialogFragmentHelper fragment , Bundle arguments , String tag ) { } protected static Bundle createArguments ( final String title , final String message , final int requestCode ) { } protected void onResult ( int resultCode ) { } protected String getTitle ( ) { } protected String getMessage ( ) { } @ Override public void onCancel ( DialogInterface dialog ) { } protected AlertDialog createDialog ( ) { <START_BUG> final AlertDialog dialog = new LightAlertDialog ( getActivity ( ) ) ; <END_BUG> dialog . setTitle ( getTitle ( ) ) ; dialog . setMessage ( getMessage ( ) ) ; dialog . setCancelable ( true ) ; dialog . setOnCancelListener ( this ) ; return dialog ; } @ Override public void onClick ( DialogInterface dialog , int which ) { } }
public class ThreadLocalRecyclerTests extends AbstractRecyclerTests { @ Override protected Recycler < byte [ ] > newRecycler ( ) { <START_BUG> return new ThreadLocalRecycler < byte [ ] > ( RECYCLER_C , randomIntBetween ( 5 , 10 ) ) ; <END_BUG> } }
public class StringBuilder implements Appendable , CharSequence { static final int INITIAL_CAPACITY = 16 ; public char [ ] chars ; public int length ; final char [ ] getValue ( ) { } public StringBuilder ( ) { } public StringBuilder ( int capacity ) { } public StringBuilder ( CharSequence seq ) { } public StringBuilder ( StringBuilder builder ) { } public StringBuilder ( String string ) { } private void enlargeBuffer ( int min ) { } final void appendNull ( ) { } final void append0 ( char [ ] value ) { int newSize = ( length ) + ( value . length ) ; if ( newSize > ( chars . length ) ) { enlargeBuffer ( newSize ) ; } <START_BUG> System . arraycopy ( value , 0 , value , length , value . length ) ; <END_BUG> length = newSize ; } final void append0 ( char [ ] value , int offset , int length ) { } final void append0 ( char ch ) { } final void append0 ( String string ) { } final void append0 ( CharSequence s , int start , int end ) { } public int capacity ( ) { } public char charAt ( int index ) { } final void delete0 ( int start , int end ) { } final void deleteCharAt0 ( int location ) { } public void ensureCapacity ( int min ) { } public void getChars ( int start , int end , char [ ] dest , int destStart ) { } final void insert0 ( int index , char [ ] value ) { } final void insert0 ( int index , char [ ] value , int start , int length ) { } final void insert0 ( int index , char ch ) { } final void insert0 ( int index , String string ) { } final void insert0 ( int index , CharSequence s , int start , int end ) { } public int length ( ) { } private void move ( int size , int index ) { } final void replace0 ( int start , int end , String string ) { } final void reverse0 ( ) { } public void setCharAt ( int index , char ch ) { } public void setLength ( int newLength ) { } public String substring ( int start ) { } public String substring ( int start , int end ) { } @ Override public String toString ( ) { } public CharSequence subSequence ( int start , int end ) { } public int indexOf ( String string ) { } public int indexOf ( String subString , int start ) { } public int lastIndexOf ( String string ) { } public int lastIndexOf ( String subString , int start ) { } public void trimToSize ( ) { } public int codePointAt ( int index ) { } public int codePointBefore ( int index ) { } public int codePointCount ( int beginIndex , int endIndex ) { } public int offsetByCodePoints ( int index , int codePointOffset ) { } public StringBuilder append ( boolean b ) { } public StringBuilder append ( char c ) { } public StringBuilder append ( int i ) { } public StringBuilder append ( long lng ) { } public StringBuilder append ( float f ) { } public StringBuilder append ( double d ) { } public StringBuilder append ( Object obj ) { } public StringBuilder append ( String str ) { } public StringBuilder append ( char [ ] ch ) { } public StringBuilder append ( char [ ] str , int offset , int len ) { } public StringBuilder append ( CharSequence csq ) { } public StringBuilder append ( StringBuilder builder ) { } public StringBuilder append ( CharSequence csq , int start , int end ) { } public StringBuilder append ( StringBuilder builder , int start , int end ) { } public StringBuilder appendCodePoint ( int codePoint ) { } public StringBuilder delete ( int start , int end ) { } public StringBuilder deleteCharAt ( int index ) { } public StringBuilder insert ( int offset , boolean b ) { } public StringBuilder insert ( int offset , char c ) { } public StringBuilder insert ( int offset , int i ) { } public StringBuilder insert ( int offset , long l ) { } public StringBuilder insert ( int offset , float f ) { } public StringBuilder insert ( int offset , double d ) { } public StringBuilder insert ( int offset , Object obj ) { } public StringBuilder insert ( int offset , String str ) { } public StringBuilder insert ( int offset , char [ ] ch ) { } public StringBuilder insert ( int offset , char [ ] str , int strOffset , int strLen ) { } public StringBuilder insert ( int offset , CharSequence s ) { } public StringBuilder insert ( int offset , CharSequence s , int start , int end ) { } public StringBuilder replace ( int start , int end , String str ) { } public StringBuilder reverse ( ) { } public int hashCode ( ) { } public boolean equals ( Object obj ) { } }
public class IntFloatMap { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; private static final int EMPTY = 0 ; public int size ; int [ ] keyTable ; float [ ] valueTable ; int capacity ; int stashSize ; float zeroValue ; boolean hasZeroValue ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private IntFloatMap . Entries entries1 ; private IntFloatMap . Entries entries2 ; private IntFloatMap . Values values1 ; private IntFloatMap . Values values2 ; private IntFloatMap . Keys keys1 ; private IntFloatMap . Keys keys2 ; public IntFloatMap ( ) { } public IntFloatMap ( int initialCapacity ) { } public IntFloatMap ( int initialCapacity , float loadFactor ) { } public IntFloatMap ( IntFloatMap map ) { } public void put ( int key , float value ) { } public void putAll ( IntFloatMap map ) { } private void putResize ( int key , float value ) { } private void push ( int insertKey , float insertValue , int index1 , int key1 , int index2 , int key2 , int index3 , int key3 ) { } private void putStash ( int key , float value ) { } public float get ( int key , float defaultValue ) { } private float getStash ( int key , float defaultValue ) { } public float getAndIncrement ( int key , float defaultValue , float increment ) { } private float getAndIncrementStash ( int key , float defaultValue , float increment ) { } public float remove ( int key , float defaultValue ) { } float removeStash ( int key , float defaultValue ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean containsValue ( float value ) { } public boolean containsValue ( float value , float epsilon ) { } public boolean containsKey ( int key ) { } private boolean containsKeyStash ( int key ) { } public int findKey ( float value , int notFound ) { } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public IntFloatMap . Entries entries ( ) { } public IntFloatMap . Values values ( ) { } public IntFloatMap . Keys keys ( ) { } public static class Entry < K > { public int key ; public float value ; public String toString ( ) { } } private static class MapIterator < K > { static final int INDEX_ILLEGAL = - 2 ; static final int INDEX_ZERO = - 1 ; public boolean hasNext ; final IntFloatMap map ; int nextIndex ; int currentIndex ; boolean valid = true ; public MapIterator ( IntFloatMap map ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { if ( ( ( currentIndex ) == ( IntFloatMap . MapIterator . INDEX_ZERO ) ) && ( map . hasZeroValue ) ) { map . hasZeroValue = false ; } else if ( ( currentIndex ) < 0 ) { throw new IllegalStateException ( "next<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>called<seq2seq4repair_space>before<seq2seq4repair_space>remove." ) ; } else if ( ( currentIndex ) >= ( map . capacity ) ) { map . removeStashIndex ( currentIndex ) ; <START_BUG> nextIndex = currentIndex ; <END_BUG> findNextIndex ( ) ; } else { map . keyTable [ currentIndex ] = IntFloatMap . EMPTY ; } currentIndex = IntFloatMap . MapIterator . INDEX_ILLEGAL ; ( map . size ) -- ; } } public static class Entries extends IntFloatMap . MapIterator implements Iterable < IntFloatMap . Entry > , Iterator < IntFloatMap . Entry > { private IntFloatMap . Entry entry = new IntFloatMap . Entry ( ) ; public Entries ( IntFloatMap map ) { } public IntFloatMap . Entry next ( ) { } public boolean hasNext ( ) { } public Iterator < IntFloatMap . Entry > iterator ( ) { } } public static class Values extends IntFloatMap . MapIterator < Object > { public Values ( IntFloatMap map ) { } public boolean hasNext ( ) { } public float next ( ) { } public FloatArray toArray ( ) { } } public static class Keys extends IntFloatMap . MapIterator { public Keys ( IntFloatMap map ) { } public boolean hasNext ( ) { } public int next ( ) { } public IntArray toArray ( ) { } } }
public class WidgetGroup extends Group implements Layout { private boolean needsLayout = true ; private boolean fillParent ; private boolean layoutEnabled = true ; public float getMinWidth ( ) { } public float getMinHeight ( ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMaxWidth ( ) { } public float getMaxHeight ( ) { } public void setLayoutEnabled ( boolean enabled ) { } private void setLayoutEnabled ( Group parent , boolean enabled ) { <START_BUG> SnapshotArray < Actor > children = getChildren ( ) ; <END_BUG> for ( int i = 0 , n = children . size ; i < n ; i ++ ) { Actor actor = children . get ( i ) ; if ( actor instanceof Layout ) ( ( Layout ) ( actor ) ) . setLayoutEnabled ( enabled ) ; else if ( actor instanceof Group ) setLayoutEnabled ( ( ( Group ) ( actor ) ) , enabled ) ; } } public void validate ( ) { } public boolean needsLayout ( ) { } public void invalidate ( ) { } public void invalidateHierarchy ( ) { } protected void childrenChanged ( ) { } protected void sizeChanged ( ) { } public void pack ( ) { } public void setFillParent ( boolean fillParent ) { } public void layout ( ) { } public void draw ( Batch batch , float parentAlpha ) { } }
public class EmptyOrdinals implements Ordinals { private final int numDocs ; public EmptyOrdinals ( int numDocs ) { } @ Override public long getMemorySizeInBytes ( ) { } @ Override public Object getBackingStorage ( ) { } @ Override public boolean isMultiValued ( ) { } @ Override public int getNumDocs ( ) { } @ Override public int getNumOrds ( ) { <START_BUG> return ( numDocs ) + 1 ; <END_BUG> } @ Override public EmptyOrdinals . Docs ordinals ( ) { } public static class Docs implements Ordinals . Docs { private final EmptyOrdinals parent ; public Docs ( EmptyOrdinals parent ) { } @ Override public Ordinals ordinals ( ) { } @ Override public int getNumDocs ( ) { } @ Override public int getNumOrds ( ) { return parent . getNumOrds ( ) ; } @ Override public boolean isMultiValued ( ) { } @ Override public int getOrd ( int docId ) { } @ Override public IntArrayRef getOrds ( int docId ) { } @ Override public Iter getIter ( int docId ) { } @ Override public void forEachOrdinalInDoc ( int docId , OrdinalInDocProc proc ) { } } }
public class FieldLookup { private final FieldMapper mapper ; private Document doc ; private Object value ; private boolean valueLoaded = false ; private List < Object > values = new ArrayList < Object > ( ) ; private boolean valuesLoaded = false ; FieldLookup ( FieldMapper mapper ) { } public FieldMapper mapper ( ) { } public Document doc ( ) { } public void doc ( Document doc ) { } public void clear ( ) { value = null ; valueLoaded = false ; values . clear ( ) ; <START_BUG> valuesLoaded = true ; <END_BUG> doc = null ; } public boolean isEmpty ( ) { } public Object getValue ( ) { } public List < Object > getValues ( ) { } }
public class TransportShardDeleteByQueryAction extends TransportShardReplicationOperationAction < ShardDeleteByQueryRequest , ShardDeleteByQueryResponse > { @ Inject public TransportShardDeleteByQueryAction ( Settings settings , TransportService transportService , ClusterService clusterService , IndicesService indicesService , ThreadPool threadPool , ShardStateAction shardStateAction ) { } @ Override protected ShardDeleteByQueryRequest newRequestInstance ( ) { } @ Override protected ShardDeleteByQueryResponse newResponseInstance ( ) { } @ Override protected String transportAction ( ) { } @ Override protected void checkBlock ( ShardDeleteByQueryRequest request , ClusterState state ) { } @ Override protected ShardDeleteByQueryResponse shardOperationOnPrimary ( ShardOperationRequest shardRequest ) { } @ Override protected void shardOperationOnReplica ( ShardOperationRequest shardRequest ) { } @ Override protected ShardsIterator shards ( ClusterState clusterState , ShardDeleteByQueryRequest request ) { <START_BUG> GroupShardsIterator group = indicesService . indexServiceSafe ( request . index ( ) ) . operationRouting ( ) . deleteByQueryShards ( clusterService . state ( ) ) ; <END_BUG> for ( ShardsIterator shards : group ) { if ( ( shards . shardId ( ) . id ( ) ) == ( request . shardId ( ) ) ) { return shards ; } } throw new org . elasticsearch . ElasticSearchIllegalStateException ( ( ( "No<seq2seq4repair_space>shards<seq2seq4repair_space>iterator<seq2seq4repair_space>found<seq2seq4repair_space>for<seq2seq4repair_space>shard<seq2seq4repair_space>[" + ( request . shardId ( ) ) ) + "]" ) ) ; } }
public class RestGetAction extends BaseRestHandler { @ Inject public RestGetAction ( Settings settings , Client client , RestController controller ) { } @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { final GetRequest getRequest = new GetRequest ( request . param ( "index" ) , request . param ( "type" ) , request . param ( "id" ) ) ; getRequest . listenerThreaded ( false ) ; getRequest . operationThreaded ( true ) ; getRequest . refresh ( request . paramAsBoolean ( "refresh" , getRequest . refresh ( ) ) ) ; getRequest . routing ( request . param ( "routing" ) ) ; getRequest . parent ( request . param ( "parent" ) ) ; getRequest . preference ( request . param ( "preference" ) ) ; getRequest . realtime ( request . paramAsBooleanOptional ( "realtime" , null ) ) ; String sField = request . param ( "fields" ) ; if ( sField != null ) { String [ ] sFields = Strings . splitStringByCommaToArray ( sField ) ; if ( sFields != null ) { getRequest . fields ( sFields ) ; } } client . get ( getRequest , new org . elasticsearch . action . ActionListener < GetResponse > ( ) { @ Override public void onResponse ( GetResponse response ) { try { XContentBuilder builder = restContentBuilder ( request ) ; response . toXContent ( builder , request ) ; if ( ! ( response . isExists ( ) ) ) { channel . sendResponse ( new XContentRestResponse ( request , RestStatus . NOT_FOUND , builder ) ) ; } else { channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; } <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
public class SearchSourceBuilder { public static SearchSourceBuilder searchSource ( ) { } public static SearchSourceFacetsBuilder facets ( ) { } public static SearchSourceHighlightBuilder highlight ( ) { } private JsonQueryBuilder queryBuilder ; private int from = - 1 ; private int size = - 1 ; private String queryParserName ; private Boolean explain ; private List < SearchSourceBuilder . SortTuple > sortFields ; private List < String > fieldNames ; private SearchSourceFacetsBuilder facetsBuilder ; private SearchSourceHighlightBuilder highlightBuilder ; private TObjectFloatHashMap < String > indexBoost = null ; public SearchSourceBuilder ( ) { } public SearchSourceBuilder query ( JsonQueryBuilder query ) { } public SearchSourceBuilder from ( int from ) { } public SearchSourceBuilder size ( int size ) { } public SearchSourceBuilder queryParserName ( String queryParserName ) { } <START_BUG> public SearchSourceBuilder explain ( boolean explain ) { <END_BUG> this . explain = explain ; return this ; } public SearchSourceBuilder sort ( String name , boolean reverse ) { } public SearchSourceBuilder sort ( String name ) { } public SearchSourceBuilder sort ( String name , String type ) { } public SearchSourceBuilder sort ( String name , String type , boolean reverse ) { } public SearchSourceBuilder facets ( SearchSourceFacetsBuilder facetsBuilder ) { } public SearchSourceBuilder highlight ( SearchSourceHighlightBuilder highlightBuilder ) { } public SearchSourceBuilder fields ( List < String > fields ) { } public SearchSourceBuilder field ( String name ) { } public SearchSourceBuilder indexBoost ( String index , float indexBoost ) { } public byte [ ] build ( ) throws SearchException { } private static class SortTuple { private final String fieldName ; private final boolean reverse ; private final String type ; private SortTuple ( String fieldName , boolean reverse , String type ) { } public String fieldName ( ) { } public boolean reverse ( ) { } public String type ( ) { } } }
